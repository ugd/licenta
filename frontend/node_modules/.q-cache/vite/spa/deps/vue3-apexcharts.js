import {
  __commonJS
} from "./chunk-RSJERJUL.js";

// node_modules/@vue/shared/dist/shared.cjs.js
var require_shared_cjs = __commonJS({
  "node_modules/@vue/shared/dist/shared.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeMap(str, expectsLowerCase) {
      const set = new Set(str.split(","));
      return expectsLowerCase ? (val) => set.has(val.toLowerCase()) : (val) => set.has(val);
    }
    var EMPTY_OBJ = Object.freeze({});
    var EMPTY_ARR = Object.freeze([]);
    var NOOP = () => {
    };
    var NO = () => false;
    var isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
    var isModelListener = (key) => key.startsWith("onUpdate:");
    var extend = Object.assign;
    var remove = (arr, el) => {
      const i = arr.indexOf(el);
      if (i > -1) {
        arr.splice(i, 1);
      }
    };
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var hasOwn = (val, key) => hasOwnProperty2.call(val, key);
    var isArray = Array.isArray;
    var isMap = (val) => toTypeString(val) === "[object Map]";
    var isSet = (val) => toTypeString(val) === "[object Set]";
    var isDate = (val) => toTypeString(val) === "[object Date]";
    var isRegExp = (val) => toTypeString(val) === "[object RegExp]";
    var isFunction = (val) => typeof val === "function";
    var isString = (val) => typeof val === "string";
    var isSymbol = (val) => typeof val === "symbol";
    var isObject = (val) => val !== null && typeof val === "object";
    var isPromise = (val) => {
      return (isObject(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);
    };
    var objectToString = Object.prototype.toString;
    var toTypeString = (value) => objectToString.call(value);
    var toRawType = (value) => {
      return toTypeString(value).slice(8, -1);
    };
    var isPlainObject = (val) => toTypeString(val) === "[object Object]";
    var isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
    var isReservedProp = makeMap(
      ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
    );
    var isBuiltInDirective = makeMap(
      "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
    );
    var cacheStringFunction = (fn) => {
      const cache = /* @__PURE__ */ Object.create(null);
      return (str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
      };
    };
    var camelizeRE = /-(\w)/g;
    var camelize = cacheStringFunction((str) => {
      return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
    });
    var hyphenateRE = /\B([A-Z])/g;
    var hyphenate = cacheStringFunction(
      (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
    );
    var capitalize = cacheStringFunction((str) => {
      return str.charAt(0).toUpperCase() + str.slice(1);
    });
    var toHandlerKey = cacheStringFunction((str) => {
      const s = str ? `on${capitalize(str)}` : ``;
      return s;
    });
    var hasChanged = (value, oldValue) => !Object.is(value, oldValue);
    var invokeArrayFns = (fns, ...arg) => {
      for (let i = 0; i < fns.length; i++) {
        fns[i](...arg);
      }
    };
    var def = (obj, key, value, writable = false) => {
      Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        writable,
        value
      });
    };
    var looseToNumber = (val) => {
      const n = parseFloat(val);
      return isNaN(n) ? val : n;
    };
    var toNumber = (val) => {
      const n = isString(val) ? Number(val) : NaN;
      return isNaN(n) ? val : n;
    };
    var _globalThis;
    var getGlobalThis = () => {
      return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    };
    var identRE = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
    function genPropsAccessExp(name) {
      return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;
    }
    var PatchFlags = {
      "TEXT": 1,
      "1": "TEXT",
      "CLASS": 2,
      "2": "CLASS",
      "STYLE": 4,
      "4": "STYLE",
      "PROPS": 8,
      "8": "PROPS",
      "FULL_PROPS": 16,
      "16": "FULL_PROPS",
      "NEED_HYDRATION": 32,
      "32": "NEED_HYDRATION",
      "STABLE_FRAGMENT": 64,
      "64": "STABLE_FRAGMENT",
      "KEYED_FRAGMENT": 128,
      "128": "KEYED_FRAGMENT",
      "UNKEYED_FRAGMENT": 256,
      "256": "UNKEYED_FRAGMENT",
      "NEED_PATCH": 512,
      "512": "NEED_PATCH",
      "DYNAMIC_SLOTS": 1024,
      "1024": "DYNAMIC_SLOTS",
      "DEV_ROOT_FRAGMENT": 2048,
      "2048": "DEV_ROOT_FRAGMENT",
      "HOISTED": -1,
      "-1": "HOISTED",
      "BAIL": -2,
      "-2": "BAIL"
    };
    var PatchFlagNames = {
      [1]: `TEXT`,
      [2]: `CLASS`,
      [4]: `STYLE`,
      [8]: `PROPS`,
      [16]: `FULL_PROPS`,
      [32]: `NEED_HYDRATION`,
      [64]: `STABLE_FRAGMENT`,
      [128]: `KEYED_FRAGMENT`,
      [256]: `UNKEYED_FRAGMENT`,
      [512]: `NEED_PATCH`,
      [1024]: `DYNAMIC_SLOTS`,
      [2048]: `DEV_ROOT_FRAGMENT`,
      [-1]: `HOISTED`,
      [-2]: `BAIL`
    };
    var ShapeFlags = {
      "ELEMENT": 1,
      "1": "ELEMENT",
      "FUNCTIONAL_COMPONENT": 2,
      "2": "FUNCTIONAL_COMPONENT",
      "STATEFUL_COMPONENT": 4,
      "4": "STATEFUL_COMPONENT",
      "TEXT_CHILDREN": 8,
      "8": "TEXT_CHILDREN",
      "ARRAY_CHILDREN": 16,
      "16": "ARRAY_CHILDREN",
      "SLOTS_CHILDREN": 32,
      "32": "SLOTS_CHILDREN",
      "TELEPORT": 64,
      "64": "TELEPORT",
      "SUSPENSE": 128,
      "128": "SUSPENSE",
      "COMPONENT_SHOULD_KEEP_ALIVE": 256,
      "256": "COMPONENT_SHOULD_KEEP_ALIVE",
      "COMPONENT_KEPT_ALIVE": 512,
      "512": "COMPONENT_KEPT_ALIVE",
      "COMPONENT": 6,
      "6": "COMPONENT"
    };
    var SlotFlags = {
      "STABLE": 1,
      "1": "STABLE",
      "DYNAMIC": 2,
      "2": "DYNAMIC",
      "FORWARDED": 3,
      "3": "FORWARDED"
    };
    var slotFlagsText = {
      [1]: "STABLE",
      [2]: "DYNAMIC",
      [3]: "FORWARDED"
    };
    var GLOBALS_ALLOWED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error";
    var isGloballyAllowed = makeMap(GLOBALS_ALLOWED);
    var isGloballyWhitelisted = isGloballyAllowed;
    var range = 2;
    function generateCodeFrame(source, start = 0, end = source.length) {
      start = Math.max(0, Math.min(start, source.length));
      end = Math.max(0, Math.min(end, source.length));
      if (start > end)
        return "";
      let lines = source.split(/(\r?\n)/);
      const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);
      lines = lines.filter((_, idx) => idx % 2 === 0);
      let count = 0;
      const res = [];
      for (let i = 0; i < lines.length; i++) {
        count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);
        if (count >= start) {
          for (let j = i - range; j <= i + range || end > count; j++) {
            if (j < 0 || j >= lines.length)
              continue;
            const line = j + 1;
            res.push(
              `${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`
            );
            const lineLength = lines[j].length;
            const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;
            if (j === i) {
              const pad = start - (count - (lineLength + newLineSeqLength));
              const length = Math.max(
                1,
                end > count ? lineLength - pad : end - start
              );
              res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
            } else if (j > i) {
              if (end > count) {
                const length = Math.max(Math.min(end - count, lineLength), 1);
                res.push(`   |  ` + "^".repeat(length));
              }
              count += lineLength + newLineSeqLength;
            }
          }
          break;
        }
      }
      return res.join("\n");
    }
    function normalizeStyle(value) {
      if (isArray(value)) {
        const res = {};
        for (let i = 0; i < value.length; i++) {
          const item = value[i];
          const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
          if (normalized) {
            for (const key in normalized) {
              res[key] = normalized[key];
            }
          }
        }
        return res;
      } else if (isString(value) || isObject(value)) {
        return value;
      }
    }
    var listDelimiterRE = /;(?![^(]*\))/g;
    var propertyDelimiterRE = /:([^]+)/;
    var styleCommentRE = /\/\*[^]*?\*\//g;
    function parseStringStyle(cssText) {
      const ret = {};
      cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
        if (item) {
          const tmp = item.split(propertyDelimiterRE);
          tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
      });
      return ret;
    }
    function stringifyStyle(styles) {
      let ret = "";
      if (!styles || isString(styles)) {
        return ret;
      }
      for (const key in styles) {
        const value = styles[key];
        if (isString(value) || typeof value === "number") {
          const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
          ret += `${normalizedKey}:${value};`;
        }
      }
      return ret;
    }
    function normalizeClass(value) {
      let res = "";
      if (isString(value)) {
        res = value;
      } else if (isArray(value)) {
        for (let i = 0; i < value.length; i++) {
          const normalized = normalizeClass(value[i]);
          if (normalized) {
            res += normalized + " ";
          }
        }
      } else if (isObject(value)) {
        for (const name in value) {
          if (value[name]) {
            res += name + " ";
          }
        }
      }
      return res.trim();
    }
    function normalizeProps(props) {
      if (!props)
        return null;
      let { class: klass, style } = props;
      if (klass && !isString(klass)) {
        props.class = normalizeClass(klass);
      }
      if (style) {
        props.style = normalizeStyle(style);
      }
      return props;
    }
    var HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
    var SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
    var MATH_TAGS = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics";
    var VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
    var isHTMLTag = makeMap(HTML_TAGS);
    var isSVGTag = makeMap(SVG_TAGS);
    var isMathMLTag = makeMap(MATH_TAGS);
    var isVoidTag = makeMap(VOID_TAGS);
    var specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
    var isSpecialBooleanAttr = makeMap(specialBooleanAttrs);
    var isBooleanAttr = makeMap(
      specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`
    );
    function includeBooleanAttr(value) {
      return !!value || value === "";
    }
    var unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
    var attrValidationCache = {};
    function isSSRSafeAttrName(name) {
      if (attrValidationCache.hasOwnProperty(name)) {
        return attrValidationCache[name];
      }
      const isUnsafe = unsafeAttrCharRE.test(name);
      if (isUnsafe) {
        console.error(`unsafe attribute name: ${name}`);
      }
      return attrValidationCache[name] = !isUnsafe;
    }
    var propsToAttrMap = {
      acceptCharset: "accept-charset",
      className: "class",
      htmlFor: "for",
      httpEquiv: "http-equiv"
    };
    var isKnownHtmlAttr = makeMap(
      `accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`
    );
    var isKnownSvgAttr = makeMap(
      `xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`
    );
    function isRenderableAttrValue(value) {
      if (value == null) {
        return false;
      }
      const type = typeof value;
      return type === "string" || type === "number" || type === "boolean";
    }
    var escapeRE = /["'&<>]/;
    function escapeHtml(string) {
      const str = "" + string;
      const match = escapeRE.exec(str);
      if (!match) {
        return str;
      }
      let html = "";
      let escaped;
      let index;
      let lastIndex = 0;
      for (index = match.index; index < str.length; index++) {
        switch (str.charCodeAt(index)) {
          case 34:
            escaped = "&quot;";
            break;
          case 38:
            escaped = "&amp;";
            break;
          case 39:
            escaped = "&#39;";
            break;
          case 60:
            escaped = "&lt;";
            break;
          case 62:
            escaped = "&gt;";
            break;
          default:
            continue;
        }
        if (lastIndex !== index) {
          html += str.slice(lastIndex, index);
        }
        lastIndex = index + 1;
        html += escaped;
      }
      return lastIndex !== index ? html + str.slice(lastIndex, index) : html;
    }
    var commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
    function escapeHtmlComment(src) {
      return src.replace(commentStripRE, "");
    }
    function looseCompareArrays(a, b) {
      if (a.length !== b.length)
        return false;
      let equal = true;
      for (let i = 0; equal && i < a.length; i++) {
        equal = looseEqual(a[i], b[i]);
      }
      return equal;
    }
    function looseEqual(a, b) {
      if (a === b)
        return true;
      let aValidType = isDate(a);
      let bValidType = isDate(b);
      if (aValidType || bValidType) {
        return aValidType && bValidType ? a.getTime() === b.getTime() : false;
      }
      aValidType = isSymbol(a);
      bValidType = isSymbol(b);
      if (aValidType || bValidType) {
        return a === b;
      }
      aValidType = isArray(a);
      bValidType = isArray(b);
      if (aValidType || bValidType) {
        return aValidType && bValidType ? looseCompareArrays(a, b) : false;
      }
      aValidType = isObject(a);
      bValidType = isObject(b);
      if (aValidType || bValidType) {
        if (!aValidType || !bValidType) {
          return false;
        }
        const aKeysCount = Object.keys(a).length;
        const bKeysCount = Object.keys(b).length;
        if (aKeysCount !== bKeysCount) {
          return false;
        }
        for (const key in a) {
          const aHasKey = a.hasOwnProperty(key);
          const bHasKey = b.hasOwnProperty(key);
          if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
            return false;
          }
        }
      }
      return String(a) === String(b);
    }
    function looseIndexOf(arr, val) {
      return arr.findIndex((item) => looseEqual(item, val));
    }
    var toDisplayString = (val) => {
      return isString(val) ? val : val == null ? "" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
    };
    var replacer = (_key, val) => {
      if (val && val.__v_isRef) {
        return replacer(_key, val.value);
      } else if (isMap(val)) {
        return {
          [`Map(${val.size})`]: [...val.entries()].reduce(
            (entries, [key, val2], i) => {
              entries[stringifySymbol(key, i) + " =>"] = val2;
              return entries;
            },
            {}
          )
        };
      } else if (isSet(val)) {
        return {
          [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
        };
      } else if (isSymbol(val)) {
        return stringifySymbol(val);
      } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
        return String(val);
      }
      return val;
    };
    var stringifySymbol = (v, i = "") => {
      var _a;
      return isSymbol(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v;
    };
    exports.EMPTY_ARR = EMPTY_ARR;
    exports.EMPTY_OBJ = EMPTY_OBJ;
    exports.NO = NO;
    exports.NOOP = NOOP;
    exports.PatchFlagNames = PatchFlagNames;
    exports.PatchFlags = PatchFlags;
    exports.ShapeFlags = ShapeFlags;
    exports.SlotFlags = SlotFlags;
    exports.camelize = camelize;
    exports.capitalize = capitalize;
    exports.def = def;
    exports.escapeHtml = escapeHtml;
    exports.escapeHtmlComment = escapeHtmlComment;
    exports.extend = extend;
    exports.genPropsAccessExp = genPropsAccessExp;
    exports.generateCodeFrame = generateCodeFrame;
    exports.getGlobalThis = getGlobalThis;
    exports.hasChanged = hasChanged;
    exports.hasOwn = hasOwn;
    exports.hyphenate = hyphenate;
    exports.includeBooleanAttr = includeBooleanAttr;
    exports.invokeArrayFns = invokeArrayFns;
    exports.isArray = isArray;
    exports.isBooleanAttr = isBooleanAttr;
    exports.isBuiltInDirective = isBuiltInDirective;
    exports.isDate = isDate;
    exports.isFunction = isFunction;
    exports.isGloballyAllowed = isGloballyAllowed;
    exports.isGloballyWhitelisted = isGloballyWhitelisted;
    exports.isHTMLTag = isHTMLTag;
    exports.isIntegerKey = isIntegerKey;
    exports.isKnownHtmlAttr = isKnownHtmlAttr;
    exports.isKnownSvgAttr = isKnownSvgAttr;
    exports.isMap = isMap;
    exports.isMathMLTag = isMathMLTag;
    exports.isModelListener = isModelListener;
    exports.isObject = isObject;
    exports.isOn = isOn;
    exports.isPlainObject = isPlainObject;
    exports.isPromise = isPromise;
    exports.isRegExp = isRegExp;
    exports.isRenderableAttrValue = isRenderableAttrValue;
    exports.isReservedProp = isReservedProp;
    exports.isSSRSafeAttrName = isSSRSafeAttrName;
    exports.isSVGTag = isSVGTag;
    exports.isSet = isSet;
    exports.isSpecialBooleanAttr = isSpecialBooleanAttr;
    exports.isString = isString;
    exports.isSymbol = isSymbol;
    exports.isVoidTag = isVoidTag;
    exports.looseEqual = looseEqual;
    exports.looseIndexOf = looseIndexOf;
    exports.looseToNumber = looseToNumber;
    exports.makeMap = makeMap;
    exports.normalizeClass = normalizeClass;
    exports.normalizeProps = normalizeProps;
    exports.normalizeStyle = normalizeStyle;
    exports.objectToString = objectToString;
    exports.parseStringStyle = parseStringStyle;
    exports.propsToAttrMap = propsToAttrMap;
    exports.remove = remove;
    exports.slotFlagsText = slotFlagsText;
    exports.stringifyStyle = stringifyStyle;
    exports.toDisplayString = toDisplayString;
    exports.toHandlerKey = toHandlerKey;
    exports.toNumber = toNumber;
    exports.toRawType = toRawType;
    exports.toTypeString = toTypeString;
  }
});

// node_modules/@vue/shared/index.js
var require_shared = __commonJS({
  "node_modules/@vue/shared/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_shared_cjs();
    }
  }
});

// node_modules/@vue/compiler-core/node_modules/entities/lib/generated/decode-data-html.js
var require_decode_data_html = __commonJS({
  "node_modules/@vue/compiler-core/node_modules/entities/lib/generated/decode-data-html.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = new Uint16Array(
      '\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map(function(c) {
        return c.charCodeAt(0);
      })
    );
  }
});

// node_modules/@vue/compiler-core/node_modules/entities/lib/generated/decode-data-xml.js
var require_decode_data_xml = __commonJS({
  "node_modules/@vue/compiler-core/node_modules/entities/lib/generated/decode-data-xml.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = new Uint16Array(
      "\u0200aglq	\x1B\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map(function(c) {
        return c.charCodeAt(0);
      })
    );
  }
});

// node_modules/@vue/compiler-core/node_modules/entities/lib/decode_codepoint.js
var require_decode_codepoint = __commonJS({
  "node_modules/@vue/compiler-core/node_modules/entities/lib/decode_codepoint.js"(exports) {
    "use strict";
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.replaceCodePoint = exports.fromCodePoint = void 0;
    var decodeMap = /* @__PURE__ */ new Map([
      [0, 65533],
      [128, 8364],
      [130, 8218],
      [131, 402],
      [132, 8222],
      [133, 8230],
      [134, 8224],
      [135, 8225],
      [136, 710],
      [137, 8240],
      [138, 352],
      [139, 8249],
      [140, 338],
      [142, 381],
      [145, 8216],
      [146, 8217],
      [147, 8220],
      [148, 8221],
      [149, 8226],
      [150, 8211],
      [151, 8212],
      [152, 732],
      [153, 8482],
      [154, 353],
      [155, 8250],
      [156, 339],
      [158, 382],
      [159, 376]
    ]);
    exports.fromCodePoint = (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
      var output = "";
      if (codePoint > 65535) {
        codePoint -= 65536;
        output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      output += String.fromCharCode(codePoint);
      return output;
    };
    function replaceCodePoint(codePoint) {
      var _a2;
      if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
        return 65533;
      }
      return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
    }
    exports.replaceCodePoint = replaceCodePoint;
    function decodeCodePoint(codePoint) {
      return (0, exports.fromCodePoint)(replaceCodePoint(codePoint));
    }
    exports.default = decodeCodePoint;
  }
});

// node_modules/@vue/compiler-core/node_modules/entities/lib/decode.js
var require_decode = __commonJS({
  "node_modules/@vue/compiler-core/node_modules/entities/lib/decode.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeXML = exports.decodeHTMLStrict = exports.decodeHTMLAttribute = exports.decodeHTML = exports.determineBranch = exports.EntityDecoder = exports.DecodingMode = exports.BinTrieFlags = exports.fromCodePoint = exports.replaceCodePoint = exports.decodeCodePoint = exports.xmlDecodeTree = exports.htmlDecodeTree = void 0;
    var decode_data_html_js_1 = __importDefault(require_decode_data_html());
    exports.htmlDecodeTree = decode_data_html_js_1.default;
    var decode_data_xml_js_1 = __importDefault(require_decode_data_xml());
    exports.xmlDecodeTree = decode_data_xml_js_1.default;
    var decode_codepoint_js_1 = __importStar(require_decode_codepoint());
    exports.decodeCodePoint = decode_codepoint_js_1.default;
    var decode_codepoint_js_2 = require_decode_codepoint();
    Object.defineProperty(exports, "replaceCodePoint", { enumerable: true, get: function() {
      return decode_codepoint_js_2.replaceCodePoint;
    } });
    Object.defineProperty(exports, "fromCodePoint", { enumerable: true, get: function() {
      return decode_codepoint_js_2.fromCodePoint;
    } });
    var CharCodes;
    (function(CharCodes2) {
      CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
      CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
      CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
      CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
      CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
      CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
      CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
      CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
      CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
      CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
      CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
      CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
    })(CharCodes || (CharCodes = {}));
    var TO_LOWER_BIT = 32;
    var BinTrieFlags;
    (function(BinTrieFlags2) {
      BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
      BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
      BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
    })(BinTrieFlags = exports.BinTrieFlags || (exports.BinTrieFlags = {}));
    function isNumber(code) {
      return code >= CharCodes.ZERO && code <= CharCodes.NINE;
    }
    function isHexadecimalCharacter(code) {
      return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F;
    }
    function isAsciiAlphaNumeric(code) {
      return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z || isNumber(code);
    }
    function isEntityInAttributeInvalidEnd(code) {
      return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
    }
    var EntityDecoderState;
    (function(EntityDecoderState2) {
      EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
      EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
      EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
      EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
      EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
    })(EntityDecoderState || (EntityDecoderState = {}));
    var DecodingMode;
    (function(DecodingMode2) {
      DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
      DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
      DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
    })(DecodingMode = exports.DecodingMode || (exports.DecodingMode = {}));
    var EntityDecoder = function() {
      function EntityDecoder2(decodeTree, emitCodePoint, errors) {
        this.decodeTree = decodeTree;
        this.emitCodePoint = emitCodePoint;
        this.errors = errors;
        this.state = EntityDecoderState.EntityStart;
        this.consumed = 1;
        this.result = 0;
        this.treeIndex = 0;
        this.excess = 1;
        this.decodeMode = DecodingMode.Strict;
      }
      EntityDecoder2.prototype.startEntity = function(decodeMode) {
        this.decodeMode = decodeMode;
        this.state = EntityDecoderState.EntityStart;
        this.result = 0;
        this.treeIndex = 0;
        this.excess = 1;
        this.consumed = 1;
      };
      EntityDecoder2.prototype.write = function(str, offset) {
        switch (this.state) {
          case EntityDecoderState.EntityStart: {
            if (str.charCodeAt(offset) === CharCodes.NUM) {
              this.state = EntityDecoderState.NumericStart;
              this.consumed += 1;
              return this.stateNumericStart(str, offset + 1);
            }
            this.state = EntityDecoderState.NamedEntity;
            return this.stateNamedEntity(str, offset);
          }
          case EntityDecoderState.NumericStart: {
            return this.stateNumericStart(str, offset);
          }
          case EntityDecoderState.NumericDecimal: {
            return this.stateNumericDecimal(str, offset);
          }
          case EntityDecoderState.NumericHex: {
            return this.stateNumericHex(str, offset);
          }
          case EntityDecoderState.NamedEntity: {
            return this.stateNamedEntity(str, offset);
          }
        }
      };
      EntityDecoder2.prototype.stateNumericStart = function(str, offset) {
        if (offset >= str.length) {
          return -1;
        }
        if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
          this.state = EntityDecoderState.NumericHex;
          this.consumed += 1;
          return this.stateNumericHex(str, offset + 1);
        }
        this.state = EntityDecoderState.NumericDecimal;
        return this.stateNumericDecimal(str, offset);
      };
      EntityDecoder2.prototype.addToNumericResult = function(str, start, end, base) {
        if (start !== end) {
          var digitCount = end - start;
          this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);
          this.consumed += digitCount;
        }
      };
      EntityDecoder2.prototype.stateNumericHex = function(str, offset) {
        var startIdx = offset;
        while (offset < str.length) {
          var char = str.charCodeAt(offset);
          if (isNumber(char) || isHexadecimalCharacter(char)) {
            offset += 1;
          } else {
            this.addToNumericResult(str, startIdx, offset, 16);
            return this.emitNumericEntity(char, 3);
          }
        }
        this.addToNumericResult(str, startIdx, offset, 16);
        return -1;
      };
      EntityDecoder2.prototype.stateNumericDecimal = function(str, offset) {
        var startIdx = offset;
        while (offset < str.length) {
          var char = str.charCodeAt(offset);
          if (isNumber(char)) {
            offset += 1;
          } else {
            this.addToNumericResult(str, startIdx, offset, 10);
            return this.emitNumericEntity(char, 2);
          }
        }
        this.addToNumericResult(str, startIdx, offset, 10);
        return -1;
      };
      EntityDecoder2.prototype.emitNumericEntity = function(lastCp, expectedLength) {
        var _a;
        if (this.consumed <= expectedLength) {
          (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
          return 0;
        }
        if (lastCp === CharCodes.SEMI) {
          this.consumed += 1;
        } else if (this.decodeMode === DecodingMode.Strict) {
          return 0;
        }
        this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);
        if (this.errors) {
          if (lastCp !== CharCodes.SEMI) {
            this.errors.missingSemicolonAfterCharacterReference();
          }
          this.errors.validateNumericCharacterReference(this.result);
        }
        return this.consumed;
      };
      EntityDecoder2.prototype.stateNamedEntity = function(str, offset) {
        var decodeTree = this.decodeTree;
        var current = decodeTree[this.treeIndex];
        var valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
        for (; offset < str.length; offset++, this.excess++) {
          var char = str.charCodeAt(offset);
          this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
          if (this.treeIndex < 0) {
            return this.result === 0 || this.decodeMode === DecodingMode.Attribute && (valueLength === 0 || isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
          }
          current = decodeTree[this.treeIndex];
          valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
          if (valueLength !== 0) {
            if (char === CharCodes.SEMI) {
              return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
            }
            if (this.decodeMode !== DecodingMode.Strict) {
              this.result = this.treeIndex;
              this.consumed += this.excess;
              this.excess = 0;
            }
          }
        }
        return -1;
      };
      EntityDecoder2.prototype.emitNotTerminatedNamedEntity = function() {
        var _a;
        var _b = this, result = _b.result, decodeTree = _b.decodeTree;
        var valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
        this.emitNamedEntityData(result, valueLength, this.consumed);
        (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
        return this.consumed;
      };
      EntityDecoder2.prototype.emitNamedEntityData = function(result, valueLength, consumed) {
        var decodeTree = this.decodeTree;
        this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
        if (valueLength === 3) {
          this.emitCodePoint(decodeTree[result + 2], consumed);
        }
        return consumed;
      };
      EntityDecoder2.prototype.end = function() {
        var _a;
        switch (this.state) {
          case EntityDecoderState.NamedEntity: {
            return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
          }
          case EntityDecoderState.NumericDecimal: {
            return this.emitNumericEntity(0, 2);
          }
          case EntityDecoderState.NumericHex: {
            return this.emitNumericEntity(0, 3);
          }
          case EntityDecoderState.NumericStart: {
            (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
            return 0;
          }
          case EntityDecoderState.EntityStart: {
            return 0;
          }
        }
      };
      return EntityDecoder2;
    }();
    exports.EntityDecoder = EntityDecoder;
    function getDecoder(decodeTree) {
      var ret = "";
      var decoder = new EntityDecoder(decodeTree, function(str) {
        return ret += (0, decode_codepoint_js_1.fromCodePoint)(str);
      });
      return function decodeWithTrie(str, decodeMode) {
        var lastIndex = 0;
        var offset = 0;
        while ((offset = str.indexOf("&", offset)) >= 0) {
          ret += str.slice(lastIndex, offset);
          decoder.startEntity(decodeMode);
          var len = decoder.write(
            str,
            offset + 1
          );
          if (len < 0) {
            lastIndex = offset + decoder.end();
            break;
          }
          lastIndex = offset + len;
          offset = len === 0 ? lastIndex + 1 : lastIndex;
        }
        var result = ret + str.slice(lastIndex);
        ret = "";
        return result;
      };
    }
    function determineBranch(decodeTree, current, nodeIdx, char) {
      var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
      var jumpOffset = current & BinTrieFlags.JUMP_TABLE;
      if (branchCount === 0) {
        return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
      }
      if (jumpOffset) {
        var value = char - jumpOffset;
        return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
      }
      var lo = nodeIdx;
      var hi = lo + branchCount - 1;
      while (lo <= hi) {
        var mid = lo + hi >>> 1;
        var midVal = decodeTree[mid];
        if (midVal < char) {
          lo = mid + 1;
        } else if (midVal > char) {
          hi = mid - 1;
        } else {
          return decodeTree[mid + branchCount];
        }
      }
      return -1;
    }
    exports.determineBranch = determineBranch;
    var htmlDecoder = getDecoder(decode_data_html_js_1.default);
    var xmlDecoder = getDecoder(decode_data_xml_js_1.default);
    function decodeHTML(str, mode) {
      if (mode === void 0) {
        mode = DecodingMode.Legacy;
      }
      return htmlDecoder(str, mode);
    }
    exports.decodeHTML = decodeHTML;
    function decodeHTMLAttribute(str) {
      return htmlDecoder(str, DecodingMode.Attribute);
    }
    exports.decodeHTMLAttribute = decodeHTMLAttribute;
    function decodeHTMLStrict(str) {
      return htmlDecoder(str, DecodingMode.Strict);
    }
    exports.decodeHTMLStrict = decodeHTMLStrict;
    function decodeXML(str) {
      return xmlDecoder(str, DecodingMode.Strict);
    }
    exports.decodeXML = decodeXML;
  }
});

// node_modules/@babel/parser/lib/index.js
var require_lib = __commonJS({
  "node_modules/@babel/parser/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    var Position = class {
      constructor(line, col, index) {
        this.line = void 0;
        this.column = void 0;
        this.index = void 0;
        this.line = line;
        this.column = col;
        this.index = index;
      }
    };
    var SourceLocation = class {
      constructor(start, end) {
        this.start = void 0;
        this.end = void 0;
        this.filename = void 0;
        this.identifierName = void 0;
        this.start = start;
        this.end = end;
      }
    };
    function createPositionWithColumnOffset(position, columnOffset) {
      const {
        line,
        column,
        index
      } = position;
      return new Position(line, column + columnOffset, index + columnOffset);
    }
    var code = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";
    var ModuleErrors = {
      ImportMetaOutsideModule: {
        message: `import.meta may appear only with 'sourceType: "module"'`,
        code
      },
      ImportOutsideModule: {
        message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
        code
      }
    };
    var NodeDescriptions = {
      ArrayPattern: "array destructuring pattern",
      AssignmentExpression: "assignment expression",
      AssignmentPattern: "assignment expression",
      ArrowFunctionExpression: "arrow function expression",
      ConditionalExpression: "conditional expression",
      CatchClause: "catch clause",
      ForOfStatement: "for-of statement",
      ForInStatement: "for-in statement",
      ForStatement: "for-loop",
      FormalParameters: "function parameter list",
      Identifier: "identifier",
      ImportSpecifier: "import specifier",
      ImportDefaultSpecifier: "import default specifier",
      ImportNamespaceSpecifier: "import namespace specifier",
      ObjectPattern: "object destructuring pattern",
      ParenthesizedExpression: "parenthesized expression",
      RestElement: "rest element",
      UpdateExpression: {
        true: "prefix operation",
        false: "postfix operation"
      },
      VariableDeclarator: "variable declaration",
      YieldExpression: "yield expression"
    };
    var toNodeDescription = (node) => node.type === "UpdateExpression" ? NodeDescriptions.UpdateExpression[`${node.prefix}`] : NodeDescriptions[node.type];
    var StandardErrors = {
      AccessorIsGenerator: ({
        kind
      }) => `A ${kind}ter cannot be a generator.`,
      ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
      AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
      AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
      AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
      AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
      AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
      AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
      AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
      BadGetterArity: "A 'get' accessor must not have any formal parameters.",
      BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
      BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
      ConstructorClassField: "Classes may not have a field named 'constructor'.",
      ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
      ConstructorIsAccessor: "Class constructor may not be an accessor.",
      ConstructorIsAsync: "Constructor can't be an async function.",
      ConstructorIsGenerator: "Constructor can't be a generator.",
      DeclarationMissingInitializer: ({
        kind
      }) => `Missing initializer in ${kind} declaration.`,
      DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
      DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
      DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
      DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
      DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
      DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
      DecoratorStaticBlock: "Decorators can't be used with a static block.",
      DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
      DeletePrivateField: "Deleting a private field is not allowed.",
      DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
      DuplicateConstructor: "Duplicate constructor in the same class.",
      DuplicateDefaultExport: "Only one default export allowed per module.",
      DuplicateExport: ({
        exportName
      }) => `\`${exportName}\` has already been exported. Exported identifiers must be unique.`,
      DuplicateProto: "Redefinition of __proto__ property.",
      DuplicateRegExpFlags: "Duplicate regular expression flag.",
      DynamicImportPhaseRequiresImportExpressions: ({
        phase
      }) => `'import.${phase}(...)' can only be parsed when using the 'createImportExpressions' option.`,
      ElementAfterRest: "Rest element must be last element.",
      EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
      ExportBindingIsString: ({
        localName,
        exportName
      }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${localName}' as '${exportName}' } from 'some-module'\`?`,
      ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
      ForInOfLoopInitializer: ({
        type
      }) => `'${type === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`,
      ForInUsing: "For-in loop may not start with 'using' declaration.",
      ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
      ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
      GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
      IllegalBreakContinue: ({
        type
      }) => `Unsyntactic ${type === "BreakStatement" ? "break" : "continue"}.`,
      IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
      IllegalReturn: "'return' outside of function.",
      ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.",
      ImportBindingIsString: ({
        importName
      }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${importName}" as foo }\`?`,
      ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
      ImportCallArity: ({
        maxArgumentCount
      }) => `\`import()\` requires exactly ${maxArgumentCount === 1 ? "one argument" : "one or two arguments"}.`,
      ImportCallNotNewExpression: "Cannot use new with import(...).",
      ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
      ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
      ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
      ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
      IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
      InvalidBigIntLiteral: "Invalid BigIntLiteral.",
      InvalidCodePoint: "Code point out of bounds.",
      InvalidCoverInitializedName: "Invalid shorthand property initializer.",
      InvalidDecimal: "Invalid decimal.",
      InvalidDigit: ({
        radix
      }) => `Expected number in radix ${radix}.`,
      InvalidEscapeSequence: "Bad character escape sequence.",
      InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
      InvalidEscapedReservedWord: ({
        reservedWord
      }) => `Escape sequence in keyword ${reservedWord}.`,
      InvalidIdentifier: ({
        identifierName
      }) => `Invalid identifier ${identifierName}.`,
      InvalidLhs: ({
        ancestor
      }) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`,
      InvalidLhsBinding: ({
        ancestor
      }) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,
      InvalidLhsOptionalChaining: ({
        ancestor
      }) => `Invalid optional chaining in the left-hand side of ${toNodeDescription(ancestor)}.`,
      InvalidNumber: "Invalid number.",
      InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
      InvalidOrUnexpectedToken: ({
        unexpected
      }) => `Unexpected character '${unexpected}'.`,
      InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
      InvalidPrivateFieldResolution: ({
        identifierName
      }) => `Private name #${identifierName} is not defined.`,
      InvalidPropertyBindingPattern: "Binding member expression.",
      InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
      InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
      LabelRedeclaration: ({
        labelName
      }) => `Label '${labelName}' is already declared.`,
      LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
      LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
      MalformedRegExpFlags: "Invalid regular expression flag.",
      MissingClassName: "A class name is required.",
      MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
      MissingSemicolon: "Missing semicolon.",
      MissingPlugin: ({
        missingPlugin
      }) => `This experimental syntax requires enabling the parser plugin: ${missingPlugin.map((name) => JSON.stringify(name)).join(", ")}.`,
      MissingOneOfPlugins: ({
        missingPlugin
      }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map((name) => JSON.stringify(name)).join(", ")}.`,
      MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
      MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
      ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
      ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
      ModuleAttributesWithDuplicateKeys: ({
        key
      }) => `Duplicate key "${key}" is not allowed in module attributes.`,
      ModuleExportNameHasLoneSurrogate: ({
        surrogateCharCode
      }) => `An export name cannot include a lone surrogate, found '\\u${surrogateCharCode.toString(16)}'.`,
      ModuleExportUndefined: ({
        localName
      }) => `Export '${localName}' is not defined.`,
      MultipleDefaultsInSwitch: "Multiple default clauses.",
      NewlineAfterThrow: "Illegal newline after throw.",
      NoCatchOrFinally: "Missing catch or finally clause.",
      NumberIdentifier: "Identifier directly after number.",
      NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
      ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
      OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
      OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
      OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
      ParamDupe: "Argument name clash.",
      PatternHasAccessor: "Object pattern can't contain getter or setter.",
      PatternHasMethod: "Object pattern can't contain methods.",
      PrivateInExpectedIn: ({
        identifierName
      }) => `Private names are only allowed in property accesses (\`obj.#${identifierName}\`) or in \`in\` expressions (\`#${identifierName} in obj\`).`,
      PrivateNameRedeclaration: ({
        identifierName
      }) => `Duplicate private name #${identifierName}.`,
      RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
      RecordNoProto: "'__proto__' is not allowed in Record expressions.",
      RestTrailingComma: "Unexpected trailing comma after rest element.",
      SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
      SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
      SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
      StaticPrototype: "Classes may not have static property named prototype.",
      SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
      SuperPrivateField: "Private fields can't be accessed on super.",
      TrailingDecorator: "Decorators must be attached to a class element.",
      TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
      UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
      UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
      UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
      UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
      UnexpectedKeyword: ({
        keyword
      }) => `Unexpected keyword '${keyword}'.`,
      UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
      UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
      UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
      UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
      UnexpectedPrivateField: "Unexpected private name.",
      UnexpectedReservedWord: ({
        reservedWord
      }) => `Unexpected reserved word '${reservedWord}'.`,
      UnexpectedSuper: "'super' is only allowed in object methods and classes.",
      UnexpectedToken: ({
        expected,
        unexpected
      }) => `Unexpected token${unexpected ? ` '${unexpected}'.` : ""}${expected ? `, expected "${expected}"` : ""}`,
      UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
      UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
      UnsupportedBind: "Binding should be performed on object property.",
      UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
      UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
      UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
      UnsupportedMetaProperty: ({
        target,
        onlyValidPropertyName
      }) => `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,
      UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
      UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
      UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
      UnterminatedComment: "Unterminated comment.",
      UnterminatedRegExp: "Unterminated regular expression.",
      UnterminatedString: "Unterminated string constant.",
      UnterminatedTemplate: "Unterminated template.",
      UsingDeclarationExport: "Using declaration cannot be exported.",
      UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
      VarRedeclaration: ({
        identifierName
      }) => `Identifier '${identifierName}' has already been declared.`,
      YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
      YieldInParameter: "Yield expression is not allowed in formal parameters.",
      ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
    };
    var StrictModeErrors = {
      StrictDelete: "Deleting local variable in strict mode.",
      StrictEvalArguments: ({
        referenceName
      }) => `Assigning to '${referenceName}' in strict mode.`,
      StrictEvalArgumentsBinding: ({
        bindingName
      }) => `Binding '${bindingName}' in strict mode.`,
      StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
      StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
      StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
      StrictWith: "'with' in strict mode."
    };
    var UnparenthesizedPipeBodyDescriptions = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
    var PipelineOperatorErrors = {
      PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
      PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
      PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
      PipeTopicUnconfiguredToken: ({
        token
      }) => `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${token}" }.`,
      PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
      PipeUnparenthesizedBody: ({
        type
      }) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({
        type
      })}; please wrap it in parentheses.`,
      PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
      PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
      PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
      PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
      PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
      PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
    };
    var _excluded = ["toMessage"];
    var _excluded2 = ["message"];
    function defineHidden(obj, key, value) {
      Object.defineProperty(obj, key, {
        enumerable: false,
        configurable: true,
        value
      });
    }
    function toParseErrorConstructor(_ref) {
      let {
        toMessage
      } = _ref, properties = _objectWithoutPropertiesLoose(_ref, _excluded);
      return function constructor(loc, details) {
        const error = new SyntaxError();
        Object.assign(error, properties, {
          loc,
          pos: loc.index
        });
        if ("missingPlugin" in details) {
          Object.assign(error, {
            missingPlugin: details.missingPlugin
          });
        }
        defineHidden(error, "clone", function clone(overrides = {}) {
          var _overrides$loc;
          const {
            line,
            column,
            index
          } = (_overrides$loc = overrides.loc) != null ? _overrides$loc : loc;
          return constructor(new Position(line, column, index), Object.assign({}, details, overrides.details));
        });
        defineHidden(error, "details", details);
        Object.defineProperty(error, "message", {
          configurable: true,
          get() {
            const message = `${toMessage(details)} (${loc.line}:${loc.column})`;
            this.message = message;
            return message;
          },
          set(value) {
            Object.defineProperty(this, "message", {
              value,
              writable: true
            });
          }
        });
        return error;
      };
    }
    function ParseErrorEnum(argument, syntaxPlugin) {
      if (Array.isArray(argument)) {
        return (parseErrorTemplates) => ParseErrorEnum(parseErrorTemplates, argument[0]);
      }
      const ParseErrorConstructors = {};
      for (const reasonCode of Object.keys(argument)) {
        const template = argument[reasonCode];
        const _ref2 = typeof template === "string" ? {
          message: () => template
        } : typeof template === "function" ? {
          message: template
        } : template, {
          message
        } = _ref2, rest = _objectWithoutPropertiesLoose(_ref2, _excluded2);
        const toMessage = typeof message === "string" ? () => message : message;
        ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({
          code: "BABEL_PARSER_SYNTAX_ERROR",
          reasonCode,
          toMessage
        }, syntaxPlugin ? {
          syntaxPlugin
        } : {}, rest));
      }
      return ParseErrorConstructors;
    }
    var Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors));
    var {
      defineProperty
    } = Object;
    var toUnenumerable = (object, key) => defineProperty(object, key, {
      enumerable: false,
      value: object[key]
    });
    function toESTreeLocation(node) {
      node.loc.start && toUnenumerable(node.loc.start, "index");
      node.loc.end && toUnenumerable(node.loc.end, "index");
      return node;
    }
    var estree = (superClass) => class ESTreeParserMixin extends superClass {
      parse() {
        const file = toESTreeLocation(super.parse());
        if (this.options.tokens) {
          file.tokens = file.tokens.map(toESTreeLocation);
        }
        return file;
      }
      parseRegExpLiteral({
        pattern,
        flags
      }) {
        let regex = null;
        try {
          regex = new RegExp(pattern, flags);
        } catch (e) {
        }
        const node = this.estreeParseLiteral(regex);
        node.regex = {
          pattern,
          flags
        };
        return node;
      }
      parseBigIntLiteral(value) {
        let bigInt;
        try {
          bigInt = BigInt(value);
        } catch (_unused) {
          bigInt = null;
        }
        const node = this.estreeParseLiteral(bigInt);
        node.bigint = String(node.value || value);
        return node;
      }
      parseDecimalLiteral(value) {
        const decimal = null;
        const node = this.estreeParseLiteral(decimal);
        node.decimal = String(node.value || value);
        return node;
      }
      estreeParseLiteral(value) {
        return this.parseLiteral(value, "Literal");
      }
      parseStringLiteral(value) {
        return this.estreeParseLiteral(value);
      }
      parseNumericLiteral(value) {
        return this.estreeParseLiteral(value);
      }
      parseNullLiteral() {
        return this.estreeParseLiteral(null);
      }
      parseBooleanLiteral(value) {
        return this.estreeParseLiteral(value);
      }
      directiveToStmt(directive) {
        const expression = directive.value;
        delete directive.value;
        expression.type = "Literal";
        expression.raw = expression.extra.raw;
        expression.value = expression.extra.expressionValue;
        const stmt = directive;
        stmt.type = "ExpressionStatement";
        stmt.expression = expression;
        stmt.directive = expression.extra.rawValue;
        delete expression.extra;
        return stmt;
      }
      initFunction(node, isAsync) {
        super.initFunction(node, isAsync);
        node.expression = false;
      }
      checkDeclaration(node) {
        if (node != null && this.isObjectProperty(node)) {
          this.checkDeclaration(node.value);
        } else {
          super.checkDeclaration(node);
        }
      }
      getObjectOrClassMethodParams(method) {
        return method.value.params;
      }
      isValidDirective(stmt) {
        var _stmt$expression$extr;
        return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);
      }
      parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
        super.parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse);
        const directiveStatements = node.directives.map((d) => this.directiveToStmt(d));
        node.body = directiveStatements.concat(node.body);
        delete node.directives;
      }
      pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true);
        if (method.typeParameters) {
          method.value.typeParameters = method.typeParameters;
          delete method.typeParameters;
        }
        classBody.body.push(method);
      }
      parsePrivateName() {
        const node = super.parsePrivateName();
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return node;
          }
        }
        return this.convertPrivateNameToPrivateIdentifier(node);
      }
      convertPrivateNameToPrivateIdentifier(node) {
        const name = super.getPrivateNameSV(node);
        node = node;
        delete node.id;
        node.name = name;
        node.type = "PrivateIdentifier";
        return node;
      }
      isPrivateName(node) {
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return super.isPrivateName(node);
          }
        }
        return node.type === "PrivateIdentifier";
      }
      getPrivateNameSV(node) {
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return super.getPrivateNameSV(node);
          }
        }
        return node.name;
      }
      parseLiteral(value, type) {
        const node = super.parseLiteral(value, type);
        node.raw = node.extra.raw;
        delete node.extra;
        return node;
      }
      parseFunctionBody(node, allowExpression, isMethod = false) {
        super.parseFunctionBody(node, allowExpression, isMethod);
        node.expression = node.body.type !== "BlockStatement";
      }
      parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
        let funcNode = this.startNode();
        funcNode.kind = node.kind;
        funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
        funcNode.type = "FunctionExpression";
        delete funcNode.kind;
        node.value = funcNode;
        if (type === "ClassPrivateMethod") {
          node.computed = false;
        }
        return this.finishNode(node, "MethodDefinition");
      }
      nameIsConstructor(key) {
        if (key.type === "Literal")
          return key.value === "constructor";
        return super.nameIsConstructor(key);
      }
      parseClassProperty(...args) {
        const propertyNode = super.parseClassProperty(...args);
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return propertyNode;
          }
        }
        propertyNode.type = "PropertyDefinition";
        return propertyNode;
      }
      parseClassPrivateProperty(...args) {
        const propertyNode = super.parseClassPrivateProperty(...args);
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return propertyNode;
          }
        }
        propertyNode.type = "PropertyDefinition";
        propertyNode.computed = false;
        return propertyNode;
      }
      parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
        const node = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor);
        if (node) {
          node.type = "Property";
          if (node.kind === "method") {
            node.kind = "init";
          }
          node.shorthand = false;
        }
        return node;
      }
      parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
        const node = super.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
        if (node) {
          node.kind = "init";
          node.type = "Property";
        }
        return node;
      }
      isValidLVal(type, isUnparenthesizedInAssign, binding) {
        return type === "Property" ? "value" : super.isValidLVal(type, isUnparenthesizedInAssign, binding);
      }
      isAssignable(node, isBinding) {
        if (node != null && this.isObjectProperty(node)) {
          return this.isAssignable(node.value, isBinding);
        }
        return super.isAssignable(node, isBinding);
      }
      toAssignable(node, isLHS = false) {
        if (node != null && this.isObjectProperty(node)) {
          const {
            key,
            value
          } = node;
          if (this.isPrivateName(key)) {
            this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
          }
          this.toAssignable(value, isLHS);
        } else {
          super.toAssignable(node, isLHS);
        }
      }
      toAssignableObjectExpressionProp(prop, isLast, isLHS) {
        if (prop.type === "Property" && (prop.kind === "get" || prop.kind === "set")) {
          this.raise(Errors.PatternHasAccessor, prop.key);
        } else if (prop.type === "Property" && prop.method) {
          this.raise(Errors.PatternHasMethod, prop.key);
        } else {
          super.toAssignableObjectExpressionProp(prop, isLast, isLHS);
        }
      }
      finishCallExpression(unfinished, optional) {
        const node = super.finishCallExpression(unfinished, optional);
        if (node.callee.type === "Import") {
          node.type = "ImportExpression";
          node.source = node.arguments[0];
          if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
            var _ref, _ref2;
            node.options = (_ref = node.arguments[1]) != null ? _ref : null;
            node.attributes = (_ref2 = node.arguments[1]) != null ? _ref2 : null;
          }
          delete node.arguments;
          delete node.callee;
        }
        return node;
      }
      toReferencedArguments(node) {
        if (node.type === "ImportExpression") {
          return;
        }
        super.toReferencedArguments(node);
      }
      parseExport(unfinished, decorators) {
        const exportStartLoc = this.state.lastTokStartLoc;
        const node = super.parseExport(unfinished, decorators);
        switch (node.type) {
          case "ExportAllDeclaration":
            node.exported = null;
            break;
          case "ExportNamedDeclaration":
            if (node.specifiers.length === 1 && node.specifiers[0].type === "ExportNamespaceSpecifier") {
              node.type = "ExportAllDeclaration";
              node.exported = node.specifiers[0].exported;
              delete node.specifiers;
            }
          case "ExportDefaultDeclaration":
            {
              var _declaration$decorato;
              const {
                declaration
              } = node;
              if ((declaration == null ? void 0 : declaration.type) === "ClassDeclaration" && ((_declaration$decorato = declaration.decorators) == null ? void 0 : _declaration$decorato.length) > 0 && declaration.start === node.start) {
                this.resetStartLocation(node, exportStartLoc);
              }
            }
            break;
        }
        return node;
      }
      parseSubscript(base, startLoc, noCalls, state) {
        const node = super.parseSubscript(base, startLoc, noCalls, state);
        if (state.optionalChainMember) {
          if (node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression") {
            node.type = node.type.substring(8);
          }
          if (state.stop) {
            const chain = this.startNodeAtNode(node);
            chain.expression = node;
            return this.finishNode(chain, "ChainExpression");
          }
        } else if (node.type === "MemberExpression" || node.type === "CallExpression") {
          node.optional = false;
        }
        return node;
      }
      isOptionalMemberExpression(node) {
        if (node.type === "ChainExpression") {
          return node.expression.type === "MemberExpression";
        }
        return super.isOptionalMemberExpression(node);
      }
      hasPropertyAsPrivateName(node) {
        if (node.type === "ChainExpression") {
          node = node.expression;
        }
        return super.hasPropertyAsPrivateName(node);
      }
      isObjectProperty(node) {
        return node.type === "Property" && node.kind === "init" && !node.method;
      }
      isObjectMethod(node) {
        return node.type === "Property" && (node.method || node.kind === "get" || node.kind === "set");
      }
      finishNodeAt(node, type, endLoc) {
        return toESTreeLocation(super.finishNodeAt(node, type, endLoc));
      }
      resetStartLocation(node, startLoc) {
        super.resetStartLocation(node, startLoc);
        toESTreeLocation(node);
      }
      resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
        super.resetEndLocation(node, endLoc);
        toESTreeLocation(node);
      }
    };
    var TokContext = class {
      constructor(token, preserveSpace) {
        this.token = void 0;
        this.preserveSpace = void 0;
        this.token = token;
        this.preserveSpace = !!preserveSpace;
      }
    };
    var types = {
      brace: new TokContext("{"),
      j_oTag: new TokContext("<tag"),
      j_cTag: new TokContext("</tag"),
      j_expr: new TokContext("<tag>...</tag>", true)
    };
    {
      types.template = new TokContext("`", true);
    }
    var beforeExpr = true;
    var startsExpr = true;
    var isLoop = true;
    var isAssign = true;
    var prefix = true;
    var postfix = true;
    var ExportedTokenType = class {
      constructor(label, conf = {}) {
        this.label = void 0;
        this.keyword = void 0;
        this.beforeExpr = void 0;
        this.startsExpr = void 0;
        this.rightAssociative = void 0;
        this.isLoop = void 0;
        this.isAssign = void 0;
        this.prefix = void 0;
        this.postfix = void 0;
        this.binop = void 0;
        this.label = label;
        this.keyword = conf.keyword;
        this.beforeExpr = !!conf.beforeExpr;
        this.startsExpr = !!conf.startsExpr;
        this.rightAssociative = !!conf.rightAssociative;
        this.isLoop = !!conf.isLoop;
        this.isAssign = !!conf.isAssign;
        this.prefix = !!conf.prefix;
        this.postfix = !!conf.postfix;
        this.binop = conf.binop != null ? conf.binop : null;
        {
          this.updateContext = null;
        }
      }
    };
    var keywords$1 = /* @__PURE__ */ new Map();
    function createKeyword(name, options = {}) {
      options.keyword = name;
      const token = createToken(name, options);
      keywords$1.set(name, token);
      return token;
    }
    function createBinop(name, binop) {
      return createToken(name, {
        beforeExpr,
        binop
      });
    }
    var tokenTypeCounter = -1;
    var tokenTypes = [];
    var tokenLabels = [];
    var tokenBinops = [];
    var tokenBeforeExprs = [];
    var tokenStartsExprs = [];
    var tokenPrefixes = [];
    function createToken(name, options = {}) {
      var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;
      ++tokenTypeCounter;
      tokenLabels.push(name);
      tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1);
      tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null ? _options$beforeExpr : false);
      tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null ? _options$startsExpr : false);
      tokenPrefixes.push((_options$prefix = options.prefix) != null ? _options$prefix : false);
      tokenTypes.push(new ExportedTokenType(name, options));
      return tokenTypeCounter;
    }
    function createKeywordLike(name, options = {}) {
      var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;
      ++tokenTypeCounter;
      keywords$1.set(name, tokenTypeCounter);
      tokenLabels.push(name);
      tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1);
      tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null ? _options$beforeExpr2 : false);
      tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null ? _options$startsExpr2 : false);
      tokenPrefixes.push((_options$prefix2 = options.prefix) != null ? _options$prefix2 : false);
      tokenTypes.push(new ExportedTokenType("name", options));
      return tokenTypeCounter;
    }
    var tt = {
      bracketL: createToken("[", {
        beforeExpr,
        startsExpr
      }),
      bracketHashL: createToken("#[", {
        beforeExpr,
        startsExpr
      }),
      bracketBarL: createToken("[|", {
        beforeExpr,
        startsExpr
      }),
      bracketR: createToken("]"),
      bracketBarR: createToken("|]"),
      braceL: createToken("{", {
        beforeExpr,
        startsExpr
      }),
      braceBarL: createToken("{|", {
        beforeExpr,
        startsExpr
      }),
      braceHashL: createToken("#{", {
        beforeExpr,
        startsExpr
      }),
      braceR: createToken("}"),
      braceBarR: createToken("|}"),
      parenL: createToken("(", {
        beforeExpr,
        startsExpr
      }),
      parenR: createToken(")"),
      comma: createToken(",", {
        beforeExpr
      }),
      semi: createToken(";", {
        beforeExpr
      }),
      colon: createToken(":", {
        beforeExpr
      }),
      doubleColon: createToken("::", {
        beforeExpr
      }),
      dot: createToken("."),
      question: createToken("?", {
        beforeExpr
      }),
      questionDot: createToken("?."),
      arrow: createToken("=>", {
        beforeExpr
      }),
      template: createToken("template"),
      ellipsis: createToken("...", {
        beforeExpr
      }),
      backQuote: createToken("`", {
        startsExpr
      }),
      dollarBraceL: createToken("${", {
        beforeExpr,
        startsExpr
      }),
      templateTail: createToken("...`", {
        startsExpr
      }),
      templateNonTail: createToken("...${", {
        beforeExpr,
        startsExpr
      }),
      at: createToken("@"),
      hash: createToken("#", {
        startsExpr
      }),
      interpreterDirective: createToken("#!..."),
      eq: createToken("=", {
        beforeExpr,
        isAssign
      }),
      assign: createToken("_=", {
        beforeExpr,
        isAssign
      }),
      slashAssign: createToken("_=", {
        beforeExpr,
        isAssign
      }),
      xorAssign: createToken("_=", {
        beforeExpr,
        isAssign
      }),
      moduloAssign: createToken("_=", {
        beforeExpr,
        isAssign
      }),
      incDec: createToken("++/--", {
        prefix,
        postfix,
        startsExpr
      }),
      bang: createToken("!", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      tilde: createToken("~", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      doubleCaret: createToken("^^", {
        startsExpr
      }),
      doubleAt: createToken("@@", {
        startsExpr
      }),
      pipeline: createBinop("|>", 0),
      nullishCoalescing: createBinop("??", 1),
      logicalOR: createBinop("||", 1),
      logicalAND: createBinop("&&", 2),
      bitwiseOR: createBinop("|", 3),
      bitwiseXOR: createBinop("^", 4),
      bitwiseAND: createBinop("&", 5),
      equality: createBinop("==/!=/===/!==", 6),
      lt: createBinop("</>/<=/>=", 7),
      gt: createBinop("</>/<=/>=", 7),
      relational: createBinop("</>/<=/>=", 7),
      bitShift: createBinop("<</>>/>>>", 8),
      bitShiftL: createBinop("<</>>/>>>", 8),
      bitShiftR: createBinop("<</>>/>>>", 8),
      plusMin: createToken("+/-", {
        beforeExpr,
        binop: 9,
        prefix,
        startsExpr
      }),
      modulo: createToken("%", {
        binop: 10,
        startsExpr
      }),
      star: createToken("*", {
        binop: 10
      }),
      slash: createBinop("/", 10),
      exponent: createToken("**", {
        beforeExpr,
        binop: 11,
        rightAssociative: true
      }),
      _in: createKeyword("in", {
        beforeExpr,
        binop: 7
      }),
      _instanceof: createKeyword("instanceof", {
        beforeExpr,
        binop: 7
      }),
      _break: createKeyword("break"),
      _case: createKeyword("case", {
        beforeExpr
      }),
      _catch: createKeyword("catch"),
      _continue: createKeyword("continue"),
      _debugger: createKeyword("debugger"),
      _default: createKeyword("default", {
        beforeExpr
      }),
      _else: createKeyword("else", {
        beforeExpr
      }),
      _finally: createKeyword("finally"),
      _function: createKeyword("function", {
        startsExpr
      }),
      _if: createKeyword("if"),
      _return: createKeyword("return", {
        beforeExpr
      }),
      _switch: createKeyword("switch"),
      _throw: createKeyword("throw", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _try: createKeyword("try"),
      _var: createKeyword("var"),
      _const: createKeyword("const"),
      _with: createKeyword("with"),
      _new: createKeyword("new", {
        beforeExpr,
        startsExpr
      }),
      _this: createKeyword("this", {
        startsExpr
      }),
      _super: createKeyword("super", {
        startsExpr
      }),
      _class: createKeyword("class", {
        startsExpr
      }),
      _extends: createKeyword("extends", {
        beforeExpr
      }),
      _export: createKeyword("export"),
      _import: createKeyword("import", {
        startsExpr
      }),
      _null: createKeyword("null", {
        startsExpr
      }),
      _true: createKeyword("true", {
        startsExpr
      }),
      _false: createKeyword("false", {
        startsExpr
      }),
      _typeof: createKeyword("typeof", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _void: createKeyword("void", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _delete: createKeyword("delete", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _do: createKeyword("do", {
        isLoop,
        beforeExpr
      }),
      _for: createKeyword("for", {
        isLoop
      }),
      _while: createKeyword("while", {
        isLoop
      }),
      _as: createKeywordLike("as", {
        startsExpr
      }),
      _assert: createKeywordLike("assert", {
        startsExpr
      }),
      _async: createKeywordLike("async", {
        startsExpr
      }),
      _await: createKeywordLike("await", {
        startsExpr
      }),
      _defer: createKeywordLike("defer", {
        startsExpr
      }),
      _from: createKeywordLike("from", {
        startsExpr
      }),
      _get: createKeywordLike("get", {
        startsExpr
      }),
      _let: createKeywordLike("let", {
        startsExpr
      }),
      _meta: createKeywordLike("meta", {
        startsExpr
      }),
      _of: createKeywordLike("of", {
        startsExpr
      }),
      _sent: createKeywordLike("sent", {
        startsExpr
      }),
      _set: createKeywordLike("set", {
        startsExpr
      }),
      _source: createKeywordLike("source", {
        startsExpr
      }),
      _static: createKeywordLike("static", {
        startsExpr
      }),
      _using: createKeywordLike("using", {
        startsExpr
      }),
      _yield: createKeywordLike("yield", {
        startsExpr
      }),
      _asserts: createKeywordLike("asserts", {
        startsExpr
      }),
      _checks: createKeywordLike("checks", {
        startsExpr
      }),
      _exports: createKeywordLike("exports", {
        startsExpr
      }),
      _global: createKeywordLike("global", {
        startsExpr
      }),
      _implements: createKeywordLike("implements", {
        startsExpr
      }),
      _intrinsic: createKeywordLike("intrinsic", {
        startsExpr
      }),
      _infer: createKeywordLike("infer", {
        startsExpr
      }),
      _is: createKeywordLike("is", {
        startsExpr
      }),
      _mixins: createKeywordLike("mixins", {
        startsExpr
      }),
      _proto: createKeywordLike("proto", {
        startsExpr
      }),
      _require: createKeywordLike("require", {
        startsExpr
      }),
      _satisfies: createKeywordLike("satisfies", {
        startsExpr
      }),
      _keyof: createKeywordLike("keyof", {
        startsExpr
      }),
      _readonly: createKeywordLike("readonly", {
        startsExpr
      }),
      _unique: createKeywordLike("unique", {
        startsExpr
      }),
      _abstract: createKeywordLike("abstract", {
        startsExpr
      }),
      _declare: createKeywordLike("declare", {
        startsExpr
      }),
      _enum: createKeywordLike("enum", {
        startsExpr
      }),
      _module: createKeywordLike("module", {
        startsExpr
      }),
      _namespace: createKeywordLike("namespace", {
        startsExpr
      }),
      _interface: createKeywordLike("interface", {
        startsExpr
      }),
      _type: createKeywordLike("type", {
        startsExpr
      }),
      _opaque: createKeywordLike("opaque", {
        startsExpr
      }),
      name: createToken("name", {
        startsExpr
      }),
      string: createToken("string", {
        startsExpr
      }),
      num: createToken("num", {
        startsExpr
      }),
      bigint: createToken("bigint", {
        startsExpr
      }),
      decimal: createToken("decimal", {
        startsExpr
      }),
      regexp: createToken("regexp", {
        startsExpr
      }),
      privateName: createToken("#name", {
        startsExpr
      }),
      eof: createToken("eof"),
      jsxName: createToken("jsxName"),
      jsxText: createToken("jsxText", {
        beforeExpr: true
      }),
      jsxTagStart: createToken("jsxTagStart", {
        startsExpr: true
      }),
      jsxTagEnd: createToken("jsxTagEnd"),
      placeholder: createToken("%%", {
        startsExpr: true
      })
    };
    function tokenIsIdentifier(token) {
      return token >= 93 && token <= 132;
    }
    function tokenKeywordOrIdentifierIsKeyword(token) {
      return token <= 92;
    }
    function tokenIsKeywordOrIdentifier(token) {
      return token >= 58 && token <= 132;
    }
    function tokenIsLiteralPropertyName(token) {
      return token >= 58 && token <= 136;
    }
    function tokenComesBeforeExpression(token) {
      return tokenBeforeExprs[token];
    }
    function tokenCanStartExpression(token) {
      return tokenStartsExprs[token];
    }
    function tokenIsAssignment(token) {
      return token >= 29 && token <= 33;
    }
    function tokenIsFlowInterfaceOrTypeOrOpaque(token) {
      return token >= 129 && token <= 131;
    }
    function tokenIsLoop(token) {
      return token >= 90 && token <= 92;
    }
    function tokenIsKeyword(token) {
      return token >= 58 && token <= 92;
    }
    function tokenIsOperator(token) {
      return token >= 39 && token <= 59;
    }
    function tokenIsPostfix(token) {
      return token === 34;
    }
    function tokenIsPrefix(token) {
      return tokenPrefixes[token];
    }
    function tokenIsTSTypeOperator(token) {
      return token >= 121 && token <= 123;
    }
    function tokenIsTSDeclarationStart(token) {
      return token >= 124 && token <= 130;
    }
    function tokenLabelName(token) {
      return tokenLabels[token];
    }
    function tokenOperatorPrecedence(token) {
      return tokenBinops[token];
    }
    function tokenIsRightAssociative(token) {
      return token === 57;
    }
    function tokenIsTemplate(token) {
      return token >= 24 && token <= 25;
    }
    function getExportedToken(token) {
      return tokenTypes[token];
    }
    {
      tokenTypes[8].updateContext = (context) => {
        context.pop();
      };
      tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = (context) => {
        context.push(types.brace);
      };
      tokenTypes[22].updateContext = (context) => {
        if (context[context.length - 1] === types.template) {
          context.pop();
        } else {
          context.push(types.template);
        }
      };
      tokenTypes[142].updateContext = (context) => {
        context.push(types.j_expr, types.j_oTag);
      };
    }
    var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
    var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
    var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    function isInAstralSet(code2, set) {
      let pos = 65536;
      for (let i = 0, length = set.length; i < length; i += 2) {
        pos += set[i];
        if (pos > code2)
          return false;
        pos += set[i + 1];
        if (pos >= code2)
          return true;
      }
      return false;
    }
    function isIdentifierStart(code2) {
      if (code2 < 65)
        return code2 === 36;
      if (code2 <= 90)
        return true;
      if (code2 < 97)
        return code2 === 95;
      if (code2 <= 122)
        return true;
      if (code2 <= 65535) {
        return code2 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code2));
      }
      return isInAstralSet(code2, astralIdentifierStartCodes);
    }
    function isIdentifierChar(code2) {
      if (code2 < 48)
        return code2 === 36;
      if (code2 < 58)
        return true;
      if (code2 < 65)
        return false;
      if (code2 <= 90)
        return true;
      if (code2 < 97)
        return code2 === 95;
      if (code2 <= 122)
        return true;
      if (code2 <= 65535) {
        return code2 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code2));
      }
      return isInAstralSet(code2, astralIdentifierStartCodes) || isInAstralSet(code2, astralIdentifierCodes);
    }
    var reservedWords = {
      keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
      strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
      strictBind: ["eval", "arguments"]
    };
    var keywords = new Set(reservedWords.keyword);
    var reservedWordsStrictSet = new Set(reservedWords.strict);
    var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
    function isReservedWord(word, inModule) {
      return inModule && word === "await" || word === "enum";
    }
    function isStrictReservedWord(word, inModule) {
      return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
    }
    function isStrictBindOnlyReservedWord(word) {
      return reservedWordsStrictBindSet.has(word);
    }
    function isStrictBindReservedWord(word, inModule) {
      return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
    }
    function isKeyword(word) {
      return keywords.has(word);
    }
    function isIteratorStart(current, next, next2) {
      return current === 64 && next === 64 && isIdentifierStart(next2);
    }
    var reservedWordLikeSet = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
    function canBeReservedWord(word) {
      return reservedWordLikeSet.has(word);
    }
    var Scope = class {
      constructor(flags) {
        this.flags = 0;
        this.names = /* @__PURE__ */ new Map();
        this.firstLexicalName = "";
        this.flags = flags;
      }
    };
    var ScopeHandler = class {
      constructor(parser, inModule) {
        this.parser = void 0;
        this.scopeStack = [];
        this.inModule = void 0;
        this.undefinedExports = /* @__PURE__ */ new Map();
        this.parser = parser;
        this.inModule = inModule;
      }
      get inTopLevel() {
        return (this.currentScope().flags & 1) > 0;
      }
      get inFunction() {
        return (this.currentVarScopeFlags() & 2) > 0;
      }
      get allowSuper() {
        return (this.currentThisScopeFlags() & 16) > 0;
      }
      get allowDirectSuper() {
        return (this.currentThisScopeFlags() & 32) > 0;
      }
      get inClass() {
        return (this.currentThisScopeFlags() & 64) > 0;
      }
      get inClassAndNotInNonArrowFunction() {
        const flags = this.currentThisScopeFlags();
        return (flags & 64) > 0 && (flags & 2) === 0;
      }
      get inStaticBlock() {
        for (let i = this.scopeStack.length - 1; ; i--) {
          const {
            flags
          } = this.scopeStack[i];
          if (flags & 128) {
            return true;
          }
          if (flags & (387 | 64)) {
            return false;
          }
        }
      }
      get inNonArrowFunction() {
        return (this.currentThisScopeFlags() & 2) > 0;
      }
      get treatFunctionsAsVar() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      }
      createScope(flags) {
        return new Scope(flags);
      }
      enter(flags) {
        this.scopeStack.push(this.createScope(flags));
      }
      exit() {
        const scope = this.scopeStack.pop();
        return scope.flags;
      }
      treatFunctionsAsVarInScope(scope) {
        return !!(scope.flags & (2 | 128) || !this.parser.inModule && scope.flags & 1);
      }
      declareName(name, bindingType, loc) {
        let scope = this.currentScope();
        if (bindingType & 8 || bindingType & 16) {
          this.checkRedeclarationInScope(scope, name, bindingType, loc);
          let type = scope.names.get(name) || 0;
          if (bindingType & 16) {
            type = type | 4;
          } else {
            if (!scope.firstLexicalName) {
              scope.firstLexicalName = name;
            }
            type = type | 2;
          }
          scope.names.set(name, type);
          if (bindingType & 8) {
            this.maybeExportDefined(scope, name);
          }
        } else if (bindingType & 4) {
          for (let i = this.scopeStack.length - 1; i >= 0; --i) {
            scope = this.scopeStack[i];
            this.checkRedeclarationInScope(scope, name, bindingType, loc);
            scope.names.set(name, (scope.names.get(name) || 0) | 1);
            this.maybeExportDefined(scope, name);
            if (scope.flags & 387)
              break;
          }
        }
        if (this.parser.inModule && scope.flags & 1) {
          this.undefinedExports.delete(name);
        }
      }
      maybeExportDefined(scope, name) {
        if (this.parser.inModule && scope.flags & 1) {
          this.undefinedExports.delete(name);
        }
      }
      checkRedeclarationInScope(scope, name, bindingType, loc) {
        if (this.isRedeclaredInScope(scope, name, bindingType)) {
          this.parser.raise(Errors.VarRedeclaration, loc, {
            identifierName: name
          });
        }
      }
      isRedeclaredInScope(scope, name, bindingType) {
        if (!(bindingType & 1))
          return false;
        if (bindingType & 8) {
          return scope.names.has(name);
        }
        const type = scope.names.get(name);
        if (bindingType & 16) {
          return (type & 2) > 0 || !this.treatFunctionsAsVarInScope(scope) && (type & 1) > 0;
        }
        return (type & 2) > 0 && !(scope.flags & 8 && scope.firstLexicalName === name) || !this.treatFunctionsAsVarInScope(scope) && (type & 4) > 0;
      }
      checkLocalExport(id) {
        const {
          name
        } = id;
        const topLevelScope = this.scopeStack[0];
        if (!topLevelScope.names.has(name)) {
          this.undefinedExports.set(name, id.loc.start);
        }
      }
      currentScope() {
        return this.scopeStack[this.scopeStack.length - 1];
      }
      currentVarScopeFlags() {
        for (let i = this.scopeStack.length - 1; ; i--) {
          const {
            flags
          } = this.scopeStack[i];
          if (flags & 387) {
            return flags;
          }
        }
      }
      currentThisScopeFlags() {
        for (let i = this.scopeStack.length - 1; ; i--) {
          const {
            flags
          } = this.scopeStack[i];
          if (flags & (387 | 64) && !(flags & 4)) {
            return flags;
          }
        }
      }
    };
    var FlowScope = class extends Scope {
      constructor(...args) {
        super(...args);
        this.declareFunctions = /* @__PURE__ */ new Set();
      }
    };
    var FlowScopeHandler = class extends ScopeHandler {
      createScope(flags) {
        return new FlowScope(flags);
      }
      declareName(name, bindingType, loc) {
        const scope = this.currentScope();
        if (bindingType & 2048) {
          this.checkRedeclarationInScope(scope, name, bindingType, loc);
          this.maybeExportDefined(scope, name);
          scope.declareFunctions.add(name);
          return;
        }
        super.declareName(name, bindingType, loc);
      }
      isRedeclaredInScope(scope, name, bindingType) {
        if (super.isRedeclaredInScope(scope, name, bindingType))
          return true;
        if (bindingType & 2048 && !scope.declareFunctions.has(name)) {
          const type = scope.names.get(name);
          return (type & 4) > 0 || (type & 2) > 0;
        }
        return false;
      }
      checkLocalExport(id) {
        if (!this.scopeStack[0].declareFunctions.has(id.name)) {
          super.checkLocalExport(id);
        }
      }
    };
    var BaseParser = class {
      constructor() {
        this.sawUnambiguousESM = false;
        this.ambiguousScriptDifferentAst = false;
      }
      hasPlugin(pluginConfig) {
        if (typeof pluginConfig === "string") {
          return this.plugins.has(pluginConfig);
        } else {
          const [pluginName, pluginOptions] = pluginConfig;
          if (!this.hasPlugin(pluginName)) {
            return false;
          }
          const actualOptions = this.plugins.get(pluginName);
          for (const key of Object.keys(pluginOptions)) {
            if ((actualOptions == null ? void 0 : actualOptions[key]) !== pluginOptions[key]) {
              return false;
            }
          }
          return true;
        }
      }
      getPluginOption(plugin, name) {
        var _this$plugins$get;
        return (_this$plugins$get = this.plugins.get(plugin)) == null ? void 0 : _this$plugins$get[name];
      }
    };
    function setTrailingComments(node, comments) {
      if (node.trailingComments === void 0) {
        node.trailingComments = comments;
      } else {
        node.trailingComments.unshift(...comments);
      }
    }
    function setLeadingComments(node, comments) {
      if (node.leadingComments === void 0) {
        node.leadingComments = comments;
      } else {
        node.leadingComments.unshift(...comments);
      }
    }
    function setInnerComments(node, comments) {
      if (node.innerComments === void 0) {
        node.innerComments = comments;
      } else {
        node.innerComments.unshift(...comments);
      }
    }
    function adjustInnerComments(node, elements, commentWS) {
      let lastElement = null;
      let i = elements.length;
      while (lastElement === null && i > 0) {
        lastElement = elements[--i];
      }
      if (lastElement === null || lastElement.start > commentWS.start) {
        setInnerComments(node, commentWS.comments);
      } else {
        setTrailingComments(lastElement, commentWS.comments);
      }
    }
    var CommentsParser = class extends BaseParser {
      addComment(comment) {
        if (this.filename)
          comment.loc.filename = this.filename;
        const {
          commentsLen
        } = this.state;
        if (this.comments.length !== commentsLen) {
          this.comments.length = commentsLen;
        }
        this.comments.push(comment);
        this.state.commentsLen++;
      }
      processComment(node) {
        const {
          commentStack
        } = this.state;
        const commentStackLength = commentStack.length;
        if (commentStackLength === 0)
          return;
        let i = commentStackLength - 1;
        const lastCommentWS = commentStack[i];
        if (lastCommentWS.start === node.end) {
          lastCommentWS.leadingNode = node;
          i--;
        }
        const {
          start: nodeStart
        } = node;
        for (; i >= 0; i--) {
          const commentWS = commentStack[i];
          const commentEnd = commentWS.end;
          if (commentEnd > nodeStart) {
            commentWS.containingNode = node;
            this.finalizeComment(commentWS);
            commentStack.splice(i, 1);
          } else {
            if (commentEnd === nodeStart) {
              commentWS.trailingNode = node;
            }
            break;
          }
        }
      }
      finalizeComment(commentWS) {
        const {
          comments
        } = commentWS;
        if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {
          if (commentWS.leadingNode !== null) {
            setTrailingComments(commentWS.leadingNode, comments);
          }
          if (commentWS.trailingNode !== null) {
            setLeadingComments(commentWS.trailingNode, comments);
          }
        } else {
          const {
            containingNode: node,
            start: commentStart
          } = commentWS;
          if (this.input.charCodeAt(commentStart - 1) === 44) {
            switch (node.type) {
              case "ObjectExpression":
              case "ObjectPattern":
              case "RecordExpression":
                adjustInnerComments(node, node.properties, commentWS);
                break;
              case "CallExpression":
              case "OptionalCallExpression":
                adjustInnerComments(node, node.arguments, commentWS);
                break;
              case "FunctionDeclaration":
              case "FunctionExpression":
              case "ArrowFunctionExpression":
              case "ObjectMethod":
              case "ClassMethod":
              case "ClassPrivateMethod":
                adjustInnerComments(node, node.params, commentWS);
                break;
              case "ArrayExpression":
              case "ArrayPattern":
              case "TupleExpression":
                adjustInnerComments(node, node.elements, commentWS);
                break;
              case "ExportNamedDeclaration":
              case "ImportDeclaration":
                adjustInnerComments(node, node.specifiers, commentWS);
                break;
              default: {
                setInnerComments(node, comments);
              }
            }
          } else {
            setInnerComments(node, comments);
          }
        }
      }
      finalizeRemainingComments() {
        const {
          commentStack
        } = this.state;
        for (let i = commentStack.length - 1; i >= 0; i--) {
          this.finalizeComment(commentStack[i]);
        }
        this.state.commentStack = [];
      }
      resetPreviousNodeTrailingComments(node) {
        const {
          commentStack
        } = this.state;
        const {
          length
        } = commentStack;
        if (length === 0)
          return;
        const commentWS = commentStack[length - 1];
        if (commentWS.leadingNode === node) {
          commentWS.leadingNode = null;
        }
      }
      resetPreviousIdentifierLeadingComments(node) {
        const {
          commentStack
        } = this.state;
        const {
          length
        } = commentStack;
        if (length === 0)
          return;
        if (commentStack[length - 1].trailingNode === node) {
          commentStack[length - 1].trailingNode = null;
        } else if (length >= 2 && commentStack[length - 2].trailingNode === node) {
          commentStack[length - 2].trailingNode = null;
        }
      }
      takeSurroundingComments(node, start, end) {
        const {
          commentStack
        } = this.state;
        const commentStackLength = commentStack.length;
        if (commentStackLength === 0)
          return;
        let i = commentStackLength - 1;
        for (; i >= 0; i--) {
          const commentWS = commentStack[i];
          const commentEnd = commentWS.end;
          const commentStart = commentWS.start;
          if (commentStart === end) {
            commentWS.leadingNode = node;
          } else if (commentEnd === start) {
            commentWS.trailingNode = node;
          } else if (commentEnd < start) {
            break;
          }
        }
      }
    };
    var lineBreak = /\r\n?|[\n\u2028\u2029]/;
    var lineBreakG = new RegExp(lineBreak.source, "g");
    function isNewLine(code2) {
      switch (code2) {
        case 10:
        case 13:
        case 8232:
        case 8233:
          return true;
        default:
          return false;
      }
    }
    var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
    var skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
    var skipWhiteSpaceToLineBreak = new RegExp("(?=(" + skipWhiteSpaceInLine.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
    function isWhitespace(code2) {
      switch (code2) {
        case 9:
        case 11:
        case 12:
        case 32:
        case 160:
        case 5760:
        case 8192:
        case 8193:
        case 8194:
        case 8195:
        case 8196:
        case 8197:
        case 8198:
        case 8199:
        case 8200:
        case 8201:
        case 8202:
        case 8239:
        case 8287:
        case 12288:
        case 65279:
          return true;
        default:
          return false;
      }
    }
    var State = class {
      constructor() {
        this.flags = 1024;
        this.curLine = void 0;
        this.lineStart = void 0;
        this.startLoc = void 0;
        this.endLoc = void 0;
        this.errors = [];
        this.potentialArrowAt = -1;
        this.noArrowAt = [];
        this.noArrowParamsConversionAt = [];
        this.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        this.labels = [];
        this.commentsLen = 0;
        this.commentStack = [];
        this.pos = 0;
        this.type = 139;
        this.value = null;
        this.start = 0;
        this.end = 0;
        this.lastTokEndLoc = null;
        this.lastTokStartLoc = null;
        this.context = [types.brace];
        this.firstInvalidTemplateEscapePos = null;
        this.strictErrors = /* @__PURE__ */ new Map();
        this.tokensLength = 0;
      }
      get strict() {
        return (this.flags & 1) > 0;
      }
      set strict(v) {
        if (v)
          this.flags |= 1;
        else
          this.flags &= -2;
      }
      init({
        strictMode,
        sourceType,
        startLine,
        startColumn
      }) {
        this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === "module";
        this.curLine = startLine;
        this.lineStart = -startColumn;
        this.startLoc = this.endLoc = new Position(startLine, startColumn, 0);
      }
      get maybeInArrowParameters() {
        return (this.flags & 2) > 0;
      }
      set maybeInArrowParameters(v) {
        if (v)
          this.flags |= 2;
        else
          this.flags &= -3;
      }
      get inType() {
        return (this.flags & 4) > 0;
      }
      set inType(v) {
        if (v)
          this.flags |= 4;
        else
          this.flags &= -5;
      }
      get noAnonFunctionType() {
        return (this.flags & 8) > 0;
      }
      set noAnonFunctionType(v) {
        if (v)
          this.flags |= 8;
        else
          this.flags &= -9;
      }
      get hasFlowComment() {
        return (this.flags & 16) > 0;
      }
      set hasFlowComment(v) {
        if (v)
          this.flags |= 16;
        else
          this.flags &= -17;
      }
      get isAmbientContext() {
        return (this.flags & 32) > 0;
      }
      set isAmbientContext(v) {
        if (v)
          this.flags |= 32;
        else
          this.flags &= -33;
      }
      get inAbstractClass() {
        return (this.flags & 64) > 0;
      }
      set inAbstractClass(v) {
        if (v)
          this.flags |= 64;
        else
          this.flags &= -65;
      }
      get inDisallowConditionalTypesContext() {
        return (this.flags & 128) > 0;
      }
      set inDisallowConditionalTypesContext(v) {
        if (v)
          this.flags |= 128;
        else
          this.flags &= -129;
      }
      get soloAwait() {
        return (this.flags & 256) > 0;
      }
      set soloAwait(v) {
        if (v)
          this.flags |= 256;
        else
          this.flags &= -257;
      }
      get inFSharpPipelineDirectBody() {
        return (this.flags & 512) > 0;
      }
      set inFSharpPipelineDirectBody(v) {
        if (v)
          this.flags |= 512;
        else
          this.flags &= -513;
      }
      get canStartJSXElement() {
        return (this.flags & 1024) > 0;
      }
      set canStartJSXElement(v) {
        if (v)
          this.flags |= 1024;
        else
          this.flags &= -1025;
      }
      get containsEsc() {
        return (this.flags & 2048) > 0;
      }
      set containsEsc(v) {
        if (v)
          this.flags |= 2048;
        else
          this.flags &= -2049;
      }
      curPosition() {
        return new Position(this.curLine, this.pos - this.lineStart, this.pos);
      }
      clone() {
        const state = new State();
        state.flags = this.flags;
        state.curLine = this.curLine;
        state.lineStart = this.lineStart;
        state.startLoc = this.startLoc;
        state.endLoc = this.endLoc;
        state.errors = this.errors.slice();
        state.potentialArrowAt = this.potentialArrowAt;
        state.noArrowAt = this.noArrowAt.slice();
        state.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice();
        state.topicContext = this.topicContext;
        state.labels = this.labels.slice();
        state.commentsLen = this.commentsLen;
        state.commentStack = this.commentStack.slice();
        state.pos = this.pos;
        state.type = this.type;
        state.value = this.value;
        state.start = this.start;
        state.end = this.end;
        state.lastTokEndLoc = this.lastTokEndLoc;
        state.lastTokStartLoc = this.lastTokStartLoc;
        state.context = this.context.slice();
        state.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos;
        state.strictErrors = this.strictErrors;
        state.tokensLength = this.tokensLength;
        return state;
      }
    };
    var _isDigit = function isDigit(code2) {
      return code2 >= 48 && code2 <= 57;
    };
    var forbiddenNumericSeparatorSiblings = {
      decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
      hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
    };
    var isAllowedNumericSeparatorSibling = {
      bin: (ch) => ch === 48 || ch === 49,
      oct: (ch) => ch >= 48 && ch <= 55,
      dec: (ch) => ch >= 48 && ch <= 57,
      hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
    };
    function readStringContents(type, input, pos, lineStart, curLine, errors) {
      const initialPos = pos;
      const initialLineStart = lineStart;
      const initialCurLine = curLine;
      let out = "";
      let firstInvalidLoc = null;
      let chunkStart = pos;
      const {
        length
      } = input;
      for (; ; ) {
        if (pos >= length) {
          errors.unterminated(initialPos, initialLineStart, initialCurLine);
          out += input.slice(chunkStart, pos);
          break;
        }
        const ch = input.charCodeAt(pos);
        if (isStringEnd(type, ch, input, pos)) {
          out += input.slice(chunkStart, pos);
          break;
        }
        if (ch === 92) {
          out += input.slice(chunkStart, pos);
          const res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors);
          if (res.ch === null && !firstInvalidLoc) {
            firstInvalidLoc = {
              pos,
              lineStart,
              curLine
            };
          } else {
            out += res.ch;
          }
          ({
            pos,
            lineStart,
            curLine
          } = res);
          chunkStart = pos;
        } else if (ch === 8232 || ch === 8233) {
          ++pos;
          ++curLine;
          lineStart = pos;
        } else if (ch === 10 || ch === 13) {
          if (type === "template") {
            out += input.slice(chunkStart, pos) + "\n";
            ++pos;
            if (ch === 13 && input.charCodeAt(pos) === 10) {
              ++pos;
            }
            ++curLine;
            chunkStart = lineStart = pos;
          } else {
            errors.unterminated(initialPos, initialLineStart, initialCurLine);
          }
        } else {
          ++pos;
        }
      }
      return {
        pos,
        str: out,
        firstInvalidLoc,
        lineStart,
        curLine,
        containsInvalid: !!firstInvalidLoc
      };
    }
    function isStringEnd(type, ch, input, pos) {
      if (type === "template") {
        return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
      }
      return ch === (type === "double" ? 34 : 39);
    }
    function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
      const throwOnInvalid = !inTemplate;
      pos++;
      const res = (ch2) => ({
        pos,
        ch: ch2,
        lineStart,
        curLine
      });
      const ch = input.charCodeAt(pos++);
      switch (ch) {
        case 110:
          return res("\n");
        case 114:
          return res("\r");
        case 120: {
          let code2;
          ({
            code: code2,
            pos
          } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));
          return res(code2 === null ? null : String.fromCharCode(code2));
        }
        case 117: {
          let code2;
          ({
            code: code2,
            pos
          } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));
          return res(code2 === null ? null : String.fromCodePoint(code2));
        }
        case 116:
          return res("	");
        case 98:
          return res("\b");
        case 118:
          return res("\v");
        case 102:
          return res("\f");
        case 13:
          if (input.charCodeAt(pos) === 10) {
            ++pos;
          }
        case 10:
          lineStart = pos;
          ++curLine;
        case 8232:
        case 8233:
          return res("");
        case 56:
        case 57:
          if (inTemplate) {
            return res(null);
          } else {
            errors.strictNumericEscape(pos - 1, lineStart, curLine);
          }
        default:
          if (ch >= 48 && ch <= 55) {
            const startPos = pos - 1;
            const match = input.slice(startPos, pos + 2).match(/^[0-7]+/);
            let octalStr = match[0];
            let octal = parseInt(octalStr, 8);
            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }
            pos += octalStr.length - 1;
            const next = input.charCodeAt(pos);
            if (octalStr !== "0" || next === 56 || next === 57) {
              if (inTemplate) {
                return res(null);
              } else {
                errors.strictNumericEscape(startPos, lineStart, curLine);
              }
            }
            return res(String.fromCharCode(octal));
          }
          return res(String.fromCharCode(ch));
      }
    }
    function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
      const initialPos = pos;
      let n;
      ({
        n,
        pos
      } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));
      if (n === null) {
        if (throwOnInvalid) {
          errors.invalidEscapeSequence(initialPos, lineStart, curLine);
        } else {
          pos = initialPos - 1;
        }
      }
      return {
        code: n,
        pos
      };
    }
    function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
      const start = pos;
      const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
      const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
      let invalid = false;
      let total = 0;
      for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
        const code2 = input.charCodeAt(pos);
        let val;
        if (code2 === 95 && allowNumSeparator !== "bail") {
          const prev = input.charCodeAt(pos - 1);
          const next = input.charCodeAt(pos + 1);
          if (!allowNumSeparator) {
            if (bailOnError)
              return {
                n: null,
                pos
              };
            errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
          } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
            if (bailOnError)
              return {
                n: null,
                pos
              };
            errors.unexpectedNumericSeparator(pos, lineStart, curLine);
          }
          ++pos;
          continue;
        }
        if (code2 >= 97) {
          val = code2 - 97 + 10;
        } else if (code2 >= 65) {
          val = code2 - 65 + 10;
        } else if (_isDigit(code2)) {
          val = code2 - 48;
        } else {
          val = Infinity;
        }
        if (val >= radix) {
          if (val <= 9 && bailOnError) {
            return {
              n: null,
              pos
            };
          } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
            val = 0;
          } else if (forceLen) {
            val = 0;
            invalid = true;
          } else {
            break;
          }
        }
        ++pos;
        total = total * radix + val;
      }
      if (pos === start || len != null && pos - start !== len || invalid) {
        return {
          n: null,
          pos
        };
      }
      return {
        n: total,
        pos
      };
    }
    function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
      const ch = input.charCodeAt(pos);
      let code2;
      if (ch === 123) {
        ++pos;
        ({
          code: code2,
          pos
        } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors));
        ++pos;
        if (code2 !== null && code2 > 1114111) {
          if (throwOnInvalid) {
            errors.invalidCodePoint(pos, lineStart, curLine);
          } else {
            return {
              code: null,
              pos
            };
          }
        }
      } else {
        ({
          code: code2,
          pos
        } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
      }
      return {
        code: code2,
        pos
      };
    }
    function buildPosition(pos, lineStart, curLine) {
      return new Position(curLine, pos - lineStart, pos);
    }
    var VALID_REGEX_FLAGS = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]);
    var Token = class {
      constructor(state) {
        this.type = state.type;
        this.value = state.value;
        this.start = state.start;
        this.end = state.end;
        this.loc = new SourceLocation(state.startLoc, state.endLoc);
      }
    };
    var Tokenizer = class extends CommentsParser {
      constructor(options, input) {
        super();
        this.isLookahead = void 0;
        this.tokens = [];
        this.errorHandlers_readInt = {
          invalidDigit: (pos, lineStart, curLine, radix) => {
            if (!this.options.errorRecovery)
              return false;
            this.raise(Errors.InvalidDigit, buildPosition(pos, lineStart, curLine), {
              radix
            });
            return true;
          },
          numericSeparatorInEscapeSequence: this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),
          unexpectedNumericSeparator: this.errorBuilder(Errors.UnexpectedNumericSeparator)
        };
        this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
          invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),
          invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint)
        });
        this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
          strictNumericEscape: (pos, lineStart, curLine) => {
            this.recordStrictModeErrors(Errors.StrictNumericEscape, buildPosition(pos, lineStart, curLine));
          },
          unterminated: (pos, lineStart, curLine) => {
            throw this.raise(Errors.UnterminatedString, buildPosition(pos - 1, lineStart, curLine));
          }
        });
        this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
          strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),
          unterminated: (pos, lineStart, curLine) => {
            throw this.raise(Errors.UnterminatedTemplate, buildPosition(pos, lineStart, curLine));
          }
        });
        this.state = new State();
        this.state.init(options);
        this.input = input;
        this.length = input.length;
        this.comments = [];
        this.isLookahead = false;
      }
      pushToken(token) {
        this.tokens.length = this.state.tokensLength;
        this.tokens.push(token);
        ++this.state.tokensLength;
      }
      next() {
        this.checkKeywordEscapes();
        if (this.options.tokens) {
          this.pushToken(new Token(this.state));
        }
        this.state.lastTokEndLoc = this.state.endLoc;
        this.state.lastTokStartLoc = this.state.startLoc;
        this.nextToken();
      }
      eat(type) {
        if (this.match(type)) {
          this.next();
          return true;
        } else {
          return false;
        }
      }
      match(type) {
        return this.state.type === type;
      }
      createLookaheadState(state) {
        return {
          pos: state.pos,
          value: null,
          type: state.type,
          start: state.start,
          end: state.end,
          context: [this.curContext()],
          inType: state.inType,
          startLoc: state.startLoc,
          lastTokEndLoc: state.lastTokEndLoc,
          curLine: state.curLine,
          lineStart: state.lineStart,
          curPosition: state.curPosition
        };
      }
      lookahead() {
        const old = this.state;
        this.state = this.createLookaheadState(old);
        this.isLookahead = true;
        this.nextToken();
        this.isLookahead = false;
        const curr = this.state;
        this.state = old;
        return curr;
      }
      nextTokenStart() {
        return this.nextTokenStartSince(this.state.pos);
      }
      nextTokenStartSince(pos) {
        skipWhiteSpace.lastIndex = pos;
        return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;
      }
      lookaheadCharCode() {
        return this.input.charCodeAt(this.nextTokenStart());
      }
      nextTokenInLineStart() {
        return this.nextTokenInLineStartSince(this.state.pos);
      }
      nextTokenInLineStartSince(pos) {
        skipWhiteSpaceInLine.lastIndex = pos;
        return skipWhiteSpaceInLine.test(this.input) ? skipWhiteSpaceInLine.lastIndex : pos;
      }
      lookaheadInLineCharCode() {
        return this.input.charCodeAt(this.nextTokenInLineStart());
      }
      codePointAtPos(pos) {
        let cp = this.input.charCodeAt(pos);
        if ((cp & 64512) === 55296 && ++pos < this.input.length) {
          const trail = this.input.charCodeAt(pos);
          if ((trail & 64512) === 56320) {
            cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
          }
        }
        return cp;
      }
      setStrict(strict) {
        this.state.strict = strict;
        if (strict) {
          this.state.strictErrors.forEach(([toParseError, at]) => this.raise(toParseError, at));
          this.state.strictErrors.clear();
        }
      }
      curContext() {
        return this.state.context[this.state.context.length - 1];
      }
      nextToken() {
        this.skipSpace();
        this.state.start = this.state.pos;
        if (!this.isLookahead)
          this.state.startLoc = this.state.curPosition();
        if (this.state.pos >= this.length) {
          this.finishToken(139);
          return;
        }
        this.getTokenFromCode(this.codePointAtPos(this.state.pos));
      }
      skipBlockComment(commentEnd) {
        let startLoc;
        if (!this.isLookahead)
          startLoc = this.state.curPosition();
        const start = this.state.pos;
        const end = this.input.indexOf(commentEnd, start + 2);
        if (end === -1) {
          throw this.raise(Errors.UnterminatedComment, this.state.curPosition());
        }
        this.state.pos = end + commentEnd.length;
        lineBreakG.lastIndex = start + 2;
        while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {
          ++this.state.curLine;
          this.state.lineStart = lineBreakG.lastIndex;
        }
        if (this.isLookahead)
          return;
        const comment = {
          type: "CommentBlock",
          value: this.input.slice(start + 2, end),
          start,
          end: end + commentEnd.length,
          loc: new SourceLocation(startLoc, this.state.curPosition())
        };
        if (this.options.tokens)
          this.pushToken(comment);
        return comment;
      }
      skipLineComment(startSkip) {
        const start = this.state.pos;
        let startLoc;
        if (!this.isLookahead)
          startLoc = this.state.curPosition();
        let ch = this.input.charCodeAt(this.state.pos += startSkip);
        if (this.state.pos < this.length) {
          while (!isNewLine(ch) && ++this.state.pos < this.length) {
            ch = this.input.charCodeAt(this.state.pos);
          }
        }
        if (this.isLookahead)
          return;
        const end = this.state.pos;
        const value = this.input.slice(start + startSkip, end);
        const comment = {
          type: "CommentLine",
          value,
          start,
          end,
          loc: new SourceLocation(startLoc, this.state.curPosition())
        };
        if (this.options.tokens)
          this.pushToken(comment);
        return comment;
      }
      skipSpace() {
        const spaceStart = this.state.pos;
        const comments = [];
        loop:
          while (this.state.pos < this.length) {
            const ch = this.input.charCodeAt(this.state.pos);
            switch (ch) {
              case 32:
              case 160:
              case 9:
                ++this.state.pos;
                break;
              case 13:
                if (this.input.charCodeAt(this.state.pos + 1) === 10) {
                  ++this.state.pos;
                }
              case 10:
              case 8232:
              case 8233:
                ++this.state.pos;
                ++this.state.curLine;
                this.state.lineStart = this.state.pos;
                break;
              case 47:
                switch (this.input.charCodeAt(this.state.pos + 1)) {
                  case 42: {
                    const comment = this.skipBlockComment("*/");
                    if (comment !== void 0) {
                      this.addComment(comment);
                      if (this.options.attachComment)
                        comments.push(comment);
                    }
                    break;
                  }
                  case 47: {
                    const comment = this.skipLineComment(2);
                    if (comment !== void 0) {
                      this.addComment(comment);
                      if (this.options.attachComment)
                        comments.push(comment);
                    }
                    break;
                  }
                  default:
                    break loop;
                }
                break;
              default:
                if (isWhitespace(ch)) {
                  ++this.state.pos;
                } else if (ch === 45 && !this.inModule && this.options.annexB) {
                  const pos = this.state.pos;
                  if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {
                    const comment = this.skipLineComment(3);
                    if (comment !== void 0) {
                      this.addComment(comment);
                      if (this.options.attachComment)
                        comments.push(comment);
                    }
                  } else {
                    break loop;
                  }
                } else if (ch === 60 && !this.inModule && this.options.annexB) {
                  const pos = this.state.pos;
                  if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {
                    const comment = this.skipLineComment(4);
                    if (comment !== void 0) {
                      this.addComment(comment);
                      if (this.options.attachComment)
                        comments.push(comment);
                    }
                  } else {
                    break loop;
                  }
                } else {
                  break loop;
                }
            }
          }
        if (comments.length > 0) {
          const end = this.state.pos;
          const commentWhitespace = {
            start: spaceStart,
            end,
            comments,
            leadingNode: null,
            trailingNode: null,
            containingNode: null
          };
          this.state.commentStack.push(commentWhitespace);
        }
      }
      finishToken(type, val) {
        this.state.end = this.state.pos;
        this.state.endLoc = this.state.curPosition();
        const prevType = this.state.type;
        this.state.type = type;
        this.state.value = val;
        if (!this.isLookahead) {
          this.updateContext(prevType);
        }
      }
      replaceToken(type) {
        this.state.type = type;
        this.updateContext();
      }
      readToken_numberSign() {
        if (this.state.pos === 0 && this.readToken_interpreter()) {
          return;
        }
        const nextPos = this.state.pos + 1;
        const next = this.codePointAtPos(nextPos);
        if (next >= 48 && next <= 57) {
          throw this.raise(Errors.UnexpectedDigitAfterHash, this.state.curPosition());
        }
        if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
          this.expectPlugin("recordAndTuple");
          if (this.getPluginOption("recordAndTuple", "syntaxType") === "bar") {
            throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
          }
          this.state.pos += 2;
          if (next === 123) {
            this.finishToken(7);
          } else {
            this.finishToken(1);
          }
        } else if (isIdentifierStart(next)) {
          ++this.state.pos;
          this.finishToken(138, this.readWord1(next));
        } else if (next === 92) {
          ++this.state.pos;
          this.finishToken(138, this.readWord1());
        } else {
          this.finishOp(27, 1);
        }
      }
      readToken_dot() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next >= 48 && next <= 57) {
          this.readNumber(true);
          return;
        }
        if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
          this.state.pos += 3;
          this.finishToken(21);
        } else {
          ++this.state.pos;
          this.finishToken(16);
        }
      }
      readToken_slash() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61) {
          this.finishOp(31, 2);
        } else {
          this.finishOp(56, 1);
        }
      }
      readToken_interpreter() {
        if (this.state.pos !== 0 || this.length < 2)
          return false;
        let ch = this.input.charCodeAt(this.state.pos + 1);
        if (ch !== 33)
          return false;
        const start = this.state.pos;
        this.state.pos += 1;
        while (!isNewLine(ch) && ++this.state.pos < this.length) {
          ch = this.input.charCodeAt(this.state.pos);
        }
        const value = this.input.slice(start + 2, this.state.pos);
        this.finishToken(28, value);
        return true;
      }
      readToken_mult_modulo(code2) {
        let type = code2 === 42 ? 55 : 54;
        let width = 1;
        let next = this.input.charCodeAt(this.state.pos + 1);
        if (code2 === 42 && next === 42) {
          width++;
          next = this.input.charCodeAt(this.state.pos + 2);
          type = 57;
        }
        if (next === 61 && !this.state.inType) {
          width++;
          type = code2 === 37 ? 33 : 30;
        }
        this.finishOp(type, width);
      }
      readToken_pipe_amp(code2) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === code2) {
          if (this.input.charCodeAt(this.state.pos + 2) === 61) {
            this.finishOp(30, 3);
          } else {
            this.finishOp(code2 === 124 ? 41 : 42, 2);
          }
          return;
        }
        if (code2 === 124) {
          if (next === 62) {
            this.finishOp(39, 2);
            return;
          }
          if (this.hasPlugin("recordAndTuple") && next === 125) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
            }
            this.state.pos += 2;
            this.finishToken(9);
            return;
          }
          if (this.hasPlugin("recordAndTuple") && next === 93) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
            }
            this.state.pos += 2;
            this.finishToken(4);
            return;
          }
        }
        if (next === 61) {
          this.finishOp(30, 2);
          return;
        }
        this.finishOp(code2 === 124 ? 43 : 45, 1);
      }
      readToken_caret() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61 && !this.state.inType) {
          this.finishOp(32, 2);
        } else if (next === 94 && this.hasPlugin(["pipelineOperator", {
          proposal: "hack",
          topicToken: "^^"
        }])) {
          this.finishOp(37, 2);
          const lookaheadCh = this.input.codePointAt(this.state.pos);
          if (lookaheadCh === 94) {
            this.unexpected();
          }
        } else {
          this.finishOp(44, 1);
        }
      }
      readToken_atSign() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 64 && this.hasPlugin(["pipelineOperator", {
          proposal: "hack",
          topicToken: "@@"
        }])) {
          this.finishOp(38, 2);
        } else {
          this.finishOp(26, 1);
        }
      }
      readToken_plus_min(code2) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === code2) {
          this.finishOp(34, 2);
          return;
        }
        if (next === 61) {
          this.finishOp(30, 2);
        } else {
          this.finishOp(53, 1);
        }
      }
      readToken_lt() {
        const {
          pos
        } = this.state;
        const next = this.input.charCodeAt(pos + 1);
        if (next === 60) {
          if (this.input.charCodeAt(pos + 2) === 61) {
            this.finishOp(30, 3);
            return;
          }
          this.finishOp(51, 2);
          return;
        }
        if (next === 61) {
          this.finishOp(49, 2);
          return;
        }
        this.finishOp(47, 1);
      }
      readToken_gt() {
        const {
          pos
        } = this.state;
        const next = this.input.charCodeAt(pos + 1);
        if (next === 62) {
          const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;
          if (this.input.charCodeAt(pos + size) === 61) {
            this.finishOp(30, size + 1);
            return;
          }
          this.finishOp(52, size);
          return;
        }
        if (next === 61) {
          this.finishOp(49, 2);
          return;
        }
        this.finishOp(48, 1);
      }
      readToken_eq_excl(code2) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61) {
          this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
          return;
        }
        if (code2 === 61 && next === 62) {
          this.state.pos += 2;
          this.finishToken(19);
          return;
        }
        this.finishOp(code2 === 61 ? 29 : 35, 1);
      }
      readToken_question() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        const next2 = this.input.charCodeAt(this.state.pos + 2);
        if (next === 63) {
          if (next2 === 61) {
            this.finishOp(30, 3);
          } else {
            this.finishOp(40, 2);
          }
        } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
          this.state.pos += 2;
          this.finishToken(18);
        } else {
          ++this.state.pos;
          this.finishToken(17);
        }
      }
      getTokenFromCode(code2) {
        switch (code2) {
          case 46:
            this.readToken_dot();
            return;
          case 40:
            ++this.state.pos;
            this.finishToken(10);
            return;
          case 41:
            ++this.state.pos;
            this.finishToken(11);
            return;
          case 59:
            ++this.state.pos;
            this.finishToken(13);
            return;
          case 44:
            ++this.state.pos;
            this.finishToken(12);
            return;
          case 91:
            if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
              if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
              }
              this.state.pos += 2;
              this.finishToken(2);
            } else {
              ++this.state.pos;
              this.finishToken(0);
            }
            return;
          case 93:
            ++this.state.pos;
            this.finishToken(3);
            return;
          case 123:
            if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
              if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
              }
              this.state.pos += 2;
              this.finishToken(6);
            } else {
              ++this.state.pos;
              this.finishToken(5);
            }
            return;
          case 125:
            ++this.state.pos;
            this.finishToken(8);
            return;
          case 58:
            if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
              this.finishOp(15, 2);
            } else {
              ++this.state.pos;
              this.finishToken(14);
            }
            return;
          case 63:
            this.readToken_question();
            return;
          case 96:
            this.readTemplateToken();
            return;
          case 48: {
            const next = this.input.charCodeAt(this.state.pos + 1);
            if (next === 120 || next === 88) {
              this.readRadixNumber(16);
              return;
            }
            if (next === 111 || next === 79) {
              this.readRadixNumber(8);
              return;
            }
            if (next === 98 || next === 66) {
              this.readRadixNumber(2);
              return;
            }
          }
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            this.readNumber(false);
            return;
          case 34:
          case 39:
            this.readString(code2);
            return;
          case 47:
            this.readToken_slash();
            return;
          case 37:
          case 42:
            this.readToken_mult_modulo(code2);
            return;
          case 124:
          case 38:
            this.readToken_pipe_amp(code2);
            return;
          case 94:
            this.readToken_caret();
            return;
          case 43:
          case 45:
            this.readToken_plus_min(code2);
            return;
          case 60:
            this.readToken_lt();
            return;
          case 62:
            this.readToken_gt();
            return;
          case 61:
          case 33:
            this.readToken_eq_excl(code2);
            return;
          case 126:
            this.finishOp(36, 1);
            return;
          case 64:
            this.readToken_atSign();
            return;
          case 35:
            this.readToken_numberSign();
            return;
          case 92:
            this.readWord();
            return;
          default:
            if (isIdentifierStart(code2)) {
              this.readWord(code2);
              return;
            }
        }
        throw this.raise(Errors.InvalidOrUnexpectedToken, this.state.curPosition(), {
          unexpected: String.fromCodePoint(code2)
        });
      }
      finishOp(type, size) {
        const str = this.input.slice(this.state.pos, this.state.pos + size);
        this.state.pos += size;
        this.finishToken(type, str);
      }
      readRegexp() {
        const startLoc = this.state.startLoc;
        const start = this.state.start + 1;
        let escaped, inClass;
        let {
          pos
        } = this.state;
        for (; ; ++pos) {
          if (pos >= this.length) {
            throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));
          }
          const ch = this.input.charCodeAt(pos);
          if (isNewLine(ch)) {
            throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));
          }
          if (escaped) {
            escaped = false;
          } else {
            if (ch === 91) {
              inClass = true;
            } else if (ch === 93 && inClass) {
              inClass = false;
            } else if (ch === 47 && !inClass) {
              break;
            }
            escaped = ch === 92;
          }
        }
        const content = this.input.slice(start, pos);
        ++pos;
        let mods = "";
        const nextPos = () => createPositionWithColumnOffset(startLoc, pos + 2 - start);
        while (pos < this.length) {
          const cp = this.codePointAtPos(pos);
          const char = String.fromCharCode(cp);
          if (VALID_REGEX_FLAGS.has(cp)) {
            if (cp === 118) {
              if (mods.includes("u")) {
                this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());
              }
            } else if (cp === 117) {
              if (mods.includes("v")) {
                this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());
              }
            }
            if (mods.includes(char)) {
              this.raise(Errors.DuplicateRegExpFlags, nextPos());
            }
          } else if (isIdentifierChar(cp) || cp === 92) {
            this.raise(Errors.MalformedRegExpFlags, nextPos());
          } else {
            break;
          }
          ++pos;
          mods += char;
        }
        this.state.pos = pos;
        this.finishToken(137, {
          pattern: content,
          flags: mods
        });
      }
      readInt(radix, len, forceLen = false, allowNumSeparator = true) {
        const {
          n,
          pos
        } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt, false);
        this.state.pos = pos;
        return n;
      }
      readRadixNumber(radix) {
        const startLoc = this.state.curPosition();
        let isBigInt = false;
        this.state.pos += 2;
        const val = this.readInt(radix);
        if (val == null) {
          this.raise(Errors.InvalidDigit, createPositionWithColumnOffset(startLoc, 2), {
            radix
          });
        }
        const next = this.input.charCodeAt(this.state.pos);
        if (next === 110) {
          ++this.state.pos;
          isBigInt = true;
        } else if (next === 109) {
          throw this.raise(Errors.InvalidDecimal, startLoc);
        }
        if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
          throw this.raise(Errors.NumberIdentifier, this.state.curPosition());
        }
        if (isBigInt) {
          const str = this.input.slice(startLoc.index, this.state.pos).replace(/[_n]/g, "");
          this.finishToken(135, str);
          return;
        }
        this.finishToken(134, val);
      }
      readNumber(startsWithDot) {
        const start = this.state.pos;
        const startLoc = this.state.curPosition();
        let isFloat = false;
        let isBigInt = false;
        let isDecimal = false;
        let hasExponent = false;
        let isOctal = false;
        if (!startsWithDot && this.readInt(10) === null) {
          this.raise(Errors.InvalidNumber, this.state.curPosition());
        }
        const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;
        if (hasLeadingZero) {
          const integer = this.input.slice(start, this.state.pos);
          this.recordStrictModeErrors(Errors.StrictOctalLiteral, startLoc);
          if (!this.state.strict) {
            const underscorePos = integer.indexOf("_");
            if (underscorePos > 0) {
              this.raise(Errors.ZeroDigitNumericSeparator, createPositionWithColumnOffset(startLoc, underscorePos));
            }
          }
          isOctal = hasLeadingZero && !/[89]/.test(integer);
        }
        let next = this.input.charCodeAt(this.state.pos);
        if (next === 46 && !isOctal) {
          ++this.state.pos;
          this.readInt(10);
          isFloat = true;
          next = this.input.charCodeAt(this.state.pos);
        }
        if ((next === 69 || next === 101) && !isOctal) {
          next = this.input.charCodeAt(++this.state.pos);
          if (next === 43 || next === 45) {
            ++this.state.pos;
          }
          if (this.readInt(10) === null) {
            this.raise(Errors.InvalidOrMissingExponent, startLoc);
          }
          isFloat = true;
          hasExponent = true;
          next = this.input.charCodeAt(this.state.pos);
        }
        if (next === 110) {
          if (isFloat || hasLeadingZero) {
            this.raise(Errors.InvalidBigIntLiteral, startLoc);
          }
          ++this.state.pos;
          isBigInt = true;
        }
        if (next === 109) {
          this.expectPlugin("decimal", this.state.curPosition());
          if (hasExponent || hasLeadingZero) {
            this.raise(Errors.InvalidDecimal, startLoc);
          }
          ++this.state.pos;
          isDecimal = true;
        }
        if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
          throw this.raise(Errors.NumberIdentifier, this.state.curPosition());
        }
        const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");
        if (isBigInt) {
          this.finishToken(135, str);
          return;
        }
        if (isDecimal) {
          this.finishToken(136, str);
          return;
        }
        const val = isOctal ? parseInt(str, 8) : parseFloat(str);
        this.finishToken(134, val);
      }
      readCodePoint(throwOnInvalid) {
        const {
          code: code2,
          pos
        } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint);
        this.state.pos = pos;
        return code2;
      }
      readString(quote) {
        const {
          str,
          pos,
          curLine,
          lineStart
        } = readStringContents(quote === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
        this.state.pos = pos + 1;
        this.state.lineStart = lineStart;
        this.state.curLine = curLine;
        this.finishToken(133, str);
      }
      readTemplateContinuation() {
        if (!this.match(8)) {
          this.unexpected(null, 8);
        }
        this.state.pos--;
        this.readTemplateToken();
      }
      readTemplateToken() {
        const opening = this.input[this.state.pos];
        const {
          str,
          firstInvalidLoc,
          pos,
          curLine,
          lineStart
        } = readStringContents("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
        this.state.pos = pos + 1;
        this.state.lineStart = lineStart;
        this.state.curLine = curLine;
        if (firstInvalidLoc) {
          this.state.firstInvalidTemplateEscapePos = new Position(firstInvalidLoc.curLine, firstInvalidLoc.pos - firstInvalidLoc.lineStart, firstInvalidLoc.pos);
        }
        if (this.input.codePointAt(pos) === 96) {
          this.finishToken(24, firstInvalidLoc ? null : opening + str + "`");
        } else {
          this.state.pos++;
          this.finishToken(25, firstInvalidLoc ? null : opening + str + "${");
        }
      }
      recordStrictModeErrors(toParseError, at) {
        const index = at.index;
        if (this.state.strict && !this.state.strictErrors.has(index)) {
          this.raise(toParseError, at);
        } else {
          this.state.strictErrors.set(index, [toParseError, at]);
        }
      }
      readWord1(firstCode) {
        this.state.containsEsc = false;
        let word = "";
        const start = this.state.pos;
        let chunkStart = this.state.pos;
        if (firstCode !== void 0) {
          this.state.pos += firstCode <= 65535 ? 1 : 2;
        }
        while (this.state.pos < this.length) {
          const ch = this.codePointAtPos(this.state.pos);
          if (isIdentifierChar(ch)) {
            this.state.pos += ch <= 65535 ? 1 : 2;
          } else if (ch === 92) {
            this.state.containsEsc = true;
            word += this.input.slice(chunkStart, this.state.pos);
            const escStart = this.state.curPosition();
            const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;
            if (this.input.charCodeAt(++this.state.pos) !== 117) {
              this.raise(Errors.MissingUnicodeEscape, this.state.curPosition());
              chunkStart = this.state.pos - 1;
              continue;
            }
            ++this.state.pos;
            const esc = this.readCodePoint(true);
            if (esc !== null) {
              if (!identifierCheck(esc)) {
                this.raise(Errors.EscapedCharNotAnIdentifier, escStart);
              }
              word += String.fromCodePoint(esc);
            }
            chunkStart = this.state.pos;
          } else {
            break;
          }
        }
        return word + this.input.slice(chunkStart, this.state.pos);
      }
      readWord(firstCode) {
        const word = this.readWord1(firstCode);
        const type = keywords$1.get(word);
        if (type !== void 0) {
          this.finishToken(type, tokenLabelName(type));
        } else {
          this.finishToken(132, word);
        }
      }
      checkKeywordEscapes() {
        const {
          type
        } = this.state;
        if (tokenIsKeyword(type) && this.state.containsEsc) {
          this.raise(Errors.InvalidEscapedReservedWord, this.state.startLoc, {
            reservedWord: tokenLabelName(type)
          });
        }
      }
      raise(toParseError, at, details = {}) {
        const loc = at instanceof Position ? at : at.loc.start;
        const error = toParseError(loc, details);
        if (!this.options.errorRecovery)
          throw error;
        if (!this.isLookahead)
          this.state.errors.push(error);
        return error;
      }
      raiseOverwrite(toParseError, at, details = {}) {
        const loc = at instanceof Position ? at : at.loc.start;
        const pos = loc.index;
        const errors = this.state.errors;
        for (let i = errors.length - 1; i >= 0; i--) {
          const error = errors[i];
          if (error.loc.index === pos) {
            return errors[i] = toParseError(loc, details);
          }
          if (error.loc.index < pos)
            break;
        }
        return this.raise(toParseError, at, details);
      }
      updateContext(prevType) {
      }
      unexpected(loc, type) {
        throw this.raise(Errors.UnexpectedToken, loc != null ? loc : this.state.startLoc, {
          expected: type ? tokenLabelName(type) : null
        });
      }
      expectPlugin(pluginName, loc) {
        if (this.hasPlugin(pluginName)) {
          return true;
        }
        throw this.raise(Errors.MissingPlugin, loc != null ? loc : this.state.startLoc, {
          missingPlugin: [pluginName]
        });
      }
      expectOnePlugin(pluginNames) {
        if (!pluginNames.some((name) => this.hasPlugin(name))) {
          throw this.raise(Errors.MissingOneOfPlugins, this.state.startLoc, {
            missingPlugin: pluginNames
          });
        }
      }
      errorBuilder(error) {
        return (pos, lineStart, curLine) => {
          this.raise(error, buildPosition(pos, lineStart, curLine));
        };
      }
    };
    var ClassScope = class {
      constructor() {
        this.privateNames = /* @__PURE__ */ new Set();
        this.loneAccessors = /* @__PURE__ */ new Map();
        this.undefinedPrivateNames = /* @__PURE__ */ new Map();
      }
    };
    var ClassScopeHandler = class {
      constructor(parser) {
        this.parser = void 0;
        this.stack = [];
        this.undefinedPrivateNames = /* @__PURE__ */ new Map();
        this.parser = parser;
      }
      current() {
        return this.stack[this.stack.length - 1];
      }
      enter() {
        this.stack.push(new ClassScope());
      }
      exit() {
        const oldClassScope = this.stack.pop();
        const current = this.current();
        for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {
          if (current) {
            if (!current.undefinedPrivateNames.has(name)) {
              current.undefinedPrivateNames.set(name, loc);
            }
          } else {
            this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {
              identifierName: name
            });
          }
        }
      }
      declarePrivateName(name, elementType, loc) {
        const {
          privateNames,
          loneAccessors,
          undefinedPrivateNames
        } = this.current();
        let redefined = privateNames.has(name);
        if (elementType & 3) {
          const accessor = redefined && loneAccessors.get(name);
          if (accessor) {
            const oldStatic = accessor & 4;
            const newStatic = elementType & 4;
            const oldKind = accessor & 3;
            const newKind = elementType & 3;
            redefined = oldKind === newKind || oldStatic !== newStatic;
            if (!redefined)
              loneAccessors.delete(name);
          } else if (!redefined) {
            loneAccessors.set(name, elementType);
          }
        }
        if (redefined) {
          this.parser.raise(Errors.PrivateNameRedeclaration, loc, {
            identifierName: name
          });
        }
        privateNames.add(name);
        undefinedPrivateNames.delete(name);
      }
      usePrivateName(name, loc) {
        let classScope;
        for (classScope of this.stack) {
          if (classScope.privateNames.has(name))
            return;
        }
        if (classScope) {
          classScope.undefinedPrivateNames.set(name, loc);
        } else {
          this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {
            identifierName: name
          });
        }
      }
    };
    var ExpressionScope = class {
      constructor(type = 0) {
        this.type = type;
      }
      canBeArrowParameterDeclaration() {
        return this.type === 2 || this.type === 1;
      }
      isCertainlyParameterDeclaration() {
        return this.type === 3;
      }
    };
    var ArrowHeadParsingScope = class extends ExpressionScope {
      constructor(type) {
        super(type);
        this.declarationErrors = /* @__PURE__ */ new Map();
      }
      recordDeclarationError(ParsingErrorClass, at) {
        const index = at.index;
        this.declarationErrors.set(index, [ParsingErrorClass, at]);
      }
      clearDeclarationError(index) {
        this.declarationErrors.delete(index);
      }
      iterateErrors(iterator) {
        this.declarationErrors.forEach(iterator);
      }
    };
    var ExpressionScopeHandler = class {
      constructor(parser) {
        this.parser = void 0;
        this.stack = [new ExpressionScope()];
        this.parser = parser;
      }
      enter(scope) {
        this.stack.push(scope);
      }
      exit() {
        this.stack.pop();
      }
      recordParameterInitializerError(toParseError, node) {
        const origin = node.loc.start;
        const {
          stack
        } = this;
        let i = stack.length - 1;
        let scope = stack[i];
        while (!scope.isCertainlyParameterDeclaration()) {
          if (scope.canBeArrowParameterDeclaration()) {
            scope.recordDeclarationError(toParseError, origin);
          } else {
            return;
          }
          scope = stack[--i];
        }
        this.parser.raise(toParseError, origin);
      }
      recordArrowParameterBindingError(error, node) {
        const {
          stack
        } = this;
        const scope = stack[stack.length - 1];
        const origin = node.loc.start;
        if (scope.isCertainlyParameterDeclaration()) {
          this.parser.raise(error, origin);
        } else if (scope.canBeArrowParameterDeclaration()) {
          scope.recordDeclarationError(error, origin);
        } else {
          return;
        }
      }
      recordAsyncArrowParametersError(at) {
        const {
          stack
        } = this;
        let i = stack.length - 1;
        let scope = stack[i];
        while (scope.canBeArrowParameterDeclaration()) {
          if (scope.type === 2) {
            scope.recordDeclarationError(Errors.AwaitBindingIdentifier, at);
          }
          scope = stack[--i];
        }
      }
      validateAsPattern() {
        const {
          stack
        } = this;
        const currentScope = stack[stack.length - 1];
        if (!currentScope.canBeArrowParameterDeclaration())
          return;
        currentScope.iterateErrors(([toParseError, loc]) => {
          this.parser.raise(toParseError, loc);
          let i = stack.length - 2;
          let scope = stack[i];
          while (scope.canBeArrowParameterDeclaration()) {
            scope.clearDeclarationError(loc.index);
            scope = stack[--i];
          }
        });
      }
    };
    function newParameterDeclarationScope() {
      return new ExpressionScope(3);
    }
    function newArrowHeadScope() {
      return new ArrowHeadParsingScope(1);
    }
    function newAsyncArrowScope() {
      return new ArrowHeadParsingScope(2);
    }
    function newExpressionScope() {
      return new ExpressionScope();
    }
    var ProductionParameterHandler = class {
      constructor() {
        this.stacks = [];
      }
      enter(flags) {
        this.stacks.push(flags);
      }
      exit() {
        this.stacks.pop();
      }
      currentFlags() {
        return this.stacks[this.stacks.length - 1];
      }
      get hasAwait() {
        return (this.currentFlags() & 2) > 0;
      }
      get hasYield() {
        return (this.currentFlags() & 1) > 0;
      }
      get hasReturn() {
        return (this.currentFlags() & 4) > 0;
      }
      get hasIn() {
        return (this.currentFlags() & 8) > 0;
      }
    };
    function functionFlags(isAsync, isGenerator) {
      return (isAsync ? 2 : 0) | (isGenerator ? 1 : 0);
    }
    var UtilParser = class extends Tokenizer {
      addExtra(node, key, value, enumerable = true) {
        if (!node)
          return;
        const extra = node.extra = node.extra || {};
        if (enumerable) {
          extra[key] = value;
        } else {
          Object.defineProperty(extra, key, {
            enumerable,
            value
          });
        }
      }
      isContextual(token) {
        return this.state.type === token && !this.state.containsEsc;
      }
      isUnparsedContextual(nameStart, name) {
        const nameEnd = nameStart + name.length;
        if (this.input.slice(nameStart, nameEnd) === name) {
          const nextCh = this.input.charCodeAt(nameEnd);
          return !(isIdentifierChar(nextCh) || (nextCh & 64512) === 55296);
        }
        return false;
      }
      isLookaheadContextual(name) {
        const next = this.nextTokenStart();
        return this.isUnparsedContextual(next, name);
      }
      eatContextual(token) {
        if (this.isContextual(token)) {
          this.next();
          return true;
        }
        return false;
      }
      expectContextual(token, toParseError) {
        if (!this.eatContextual(token)) {
          if (toParseError != null) {
            throw this.raise(toParseError, this.state.startLoc);
          }
          this.unexpected(null, token);
        }
      }
      canInsertSemicolon() {
        return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();
      }
      hasPrecedingLineBreak() {
        return lineBreak.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
      }
      hasFollowingLineBreak() {
        skipWhiteSpaceToLineBreak.lastIndex = this.state.end;
        return skipWhiteSpaceToLineBreak.test(this.input);
      }
      isLineTerminator() {
        return this.eat(13) || this.canInsertSemicolon();
      }
      semicolon(allowAsi = true) {
        if (allowAsi ? this.isLineTerminator() : this.eat(13))
          return;
        this.raise(Errors.MissingSemicolon, this.state.lastTokEndLoc);
      }
      expect(type, loc) {
        this.eat(type) || this.unexpected(loc, type);
      }
      tryParse(fn, oldState = this.state.clone()) {
        const abortSignal = {
          node: null
        };
        try {
          const node = fn((node2 = null) => {
            abortSignal.node = node2;
            throw abortSignal;
          });
          if (this.state.errors.length > oldState.errors.length) {
            const failState = this.state;
            this.state = oldState;
            this.state.tokensLength = failState.tokensLength;
            return {
              node,
              error: failState.errors[oldState.errors.length],
              thrown: false,
              aborted: false,
              failState
            };
          }
          return {
            node,
            error: null,
            thrown: false,
            aborted: false,
            failState: null
          };
        } catch (error) {
          const failState = this.state;
          this.state = oldState;
          if (error instanceof SyntaxError) {
            return {
              node: null,
              error,
              thrown: true,
              aborted: false,
              failState
            };
          }
          if (error === abortSignal) {
            return {
              node: abortSignal.node,
              error: null,
              thrown: false,
              aborted: true,
              failState
            };
          }
          throw error;
        }
      }
      checkExpressionErrors(refExpressionErrors, andThrow) {
        if (!refExpressionErrors)
          return false;
        const {
          shorthandAssignLoc,
          doubleProtoLoc,
          privateKeyLoc,
          optionalParametersLoc
        } = refExpressionErrors;
        const hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc;
        if (!andThrow) {
          return hasErrors;
        }
        if (shorthandAssignLoc != null) {
          this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);
        }
        if (doubleProtoLoc != null) {
          this.raise(Errors.DuplicateProto, doubleProtoLoc);
        }
        if (privateKeyLoc != null) {
          this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);
        }
        if (optionalParametersLoc != null) {
          this.unexpected(optionalParametersLoc);
        }
      }
      isLiteralPropertyName() {
        return tokenIsLiteralPropertyName(this.state.type);
      }
      isPrivateName(node) {
        return node.type === "PrivateName";
      }
      getPrivateNameSV(node) {
        return node.id.name;
      }
      hasPropertyAsPrivateName(node) {
        return (node.type === "MemberExpression" || node.type === "OptionalMemberExpression") && this.isPrivateName(node.property);
      }
      isObjectProperty(node) {
        return node.type === "ObjectProperty";
      }
      isObjectMethod(node) {
        return node.type === "ObjectMethod";
      }
      initializeScopes(inModule = this.options.sourceType === "module") {
        const oldLabels = this.state.labels;
        this.state.labels = [];
        const oldExportedIdentifiers = this.exportedIdentifiers;
        this.exportedIdentifiers = /* @__PURE__ */ new Set();
        const oldInModule = this.inModule;
        this.inModule = inModule;
        const oldScope = this.scope;
        const ScopeHandler2 = this.getScopeHandler();
        this.scope = new ScopeHandler2(this, inModule);
        const oldProdParam = this.prodParam;
        this.prodParam = new ProductionParameterHandler();
        const oldClassScope = this.classScope;
        this.classScope = new ClassScopeHandler(this);
        const oldExpressionScope = this.expressionScope;
        this.expressionScope = new ExpressionScopeHandler(this);
        return () => {
          this.state.labels = oldLabels;
          this.exportedIdentifiers = oldExportedIdentifiers;
          this.inModule = oldInModule;
          this.scope = oldScope;
          this.prodParam = oldProdParam;
          this.classScope = oldClassScope;
          this.expressionScope = oldExpressionScope;
        };
      }
      enterInitialScopes() {
        let paramFlags = 0;
        if (this.inModule) {
          paramFlags |= 2;
        }
        this.scope.enter(1);
        this.prodParam.enter(paramFlags);
      }
      checkDestructuringPrivate(refExpressionErrors) {
        const {
          privateKeyLoc
        } = refExpressionErrors;
        if (privateKeyLoc !== null) {
          this.expectPlugin("destructuringPrivate", privateKeyLoc);
        }
      }
    };
    var ExpressionErrors = class {
      constructor() {
        this.shorthandAssignLoc = null;
        this.doubleProtoLoc = null;
        this.privateKeyLoc = null;
        this.optionalParametersLoc = null;
      }
    };
    var Node2 = class {
      constructor(parser, pos, loc) {
        this.type = "";
        this.start = pos;
        this.end = 0;
        this.loc = new SourceLocation(loc);
        if (parser != null && parser.options.ranges)
          this.range = [pos, 0];
        if (parser != null && parser.filename)
          this.loc.filename = parser.filename;
      }
    };
    var NodePrototype = Node2.prototype;
    {
      NodePrototype.__clone = function() {
        const newNode = new Node2(void 0, this.start, this.loc.start);
        const keys = Object.keys(this);
        for (let i = 0, length = keys.length; i < length; i++) {
          const key = keys[i];
          if (key !== "leadingComments" && key !== "trailingComments" && key !== "innerComments") {
            newNode[key] = this[key];
          }
        }
        return newNode;
      };
    }
    function clonePlaceholder(node) {
      return cloneIdentifier(node);
    }
    function cloneIdentifier(node) {
      const {
        type,
        start,
        end,
        loc,
        range,
        extra,
        name
      } = node;
      const cloned = Object.create(NodePrototype);
      cloned.type = type;
      cloned.start = start;
      cloned.end = end;
      cloned.loc = loc;
      cloned.range = range;
      cloned.extra = extra;
      cloned.name = name;
      if (type === "Placeholder") {
        cloned.expectedNode = node.expectedNode;
      }
      return cloned;
    }
    function cloneStringLiteral(node) {
      const {
        type,
        start,
        end,
        loc,
        range,
        extra
      } = node;
      if (type === "Placeholder") {
        return clonePlaceholder(node);
      }
      const cloned = Object.create(NodePrototype);
      cloned.type = type;
      cloned.start = start;
      cloned.end = end;
      cloned.loc = loc;
      cloned.range = range;
      if (node.raw !== void 0) {
        cloned.raw = node.raw;
      } else {
        cloned.extra = extra;
      }
      cloned.value = node.value;
      return cloned;
    }
    var NodeUtils = class extends UtilParser {
      startNode() {
        const loc = this.state.startLoc;
        return new Node2(this, loc.index, loc);
      }
      startNodeAt(loc) {
        return new Node2(this, loc.index, loc);
      }
      startNodeAtNode(type) {
        return this.startNodeAt(type.loc.start);
      }
      finishNode(node, type) {
        return this.finishNodeAt(node, type, this.state.lastTokEndLoc);
      }
      finishNodeAt(node, type, endLoc) {
        node.type = type;
        node.end = endLoc.index;
        node.loc.end = endLoc;
        if (this.options.ranges)
          node.range[1] = endLoc.index;
        if (this.options.attachComment)
          this.processComment(node);
        return node;
      }
      resetStartLocation(node, startLoc) {
        node.start = startLoc.index;
        node.loc.start = startLoc;
        if (this.options.ranges)
          node.range[0] = startLoc.index;
      }
      resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
        node.end = endLoc.index;
        node.loc.end = endLoc;
        if (this.options.ranges)
          node.range[1] = endLoc.index;
      }
      resetStartLocationFromNode(node, locationNode) {
        this.resetStartLocation(node, locationNode.loc.start);
      }
    };
    var reservedTypes = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);
    var FlowErrors = ParseErrorEnum`flow`({
      AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
      AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
      AssignReservedType: ({
        reservedType
      }) => `Cannot overwrite reserved type ${reservedType}.`,
      DeclareClassElement: "The `declare` modifier can only appear on class fields.",
      DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
      DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
      EnumBooleanMemberNotInitialized: ({
        memberName,
        enumName
      }) => `Boolean enum members need to be initialized. Use either \`${memberName} = true,\` or \`${memberName} = false,\` in enum \`${enumName}\`.`,
      EnumDuplicateMemberName: ({
        memberName,
        enumName
      }) => `Enum member names need to be unique, but the name \`${memberName}\` has already been used before in enum \`${enumName}\`.`,
      EnumInconsistentMemberValues: ({
        enumName
      }) => `Enum \`${enumName}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
      EnumInvalidExplicitType: ({
        invalidEnumType,
        enumName
      }) => `Enum type \`${invalidEnumType}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
      EnumInvalidExplicitTypeUnknownSupplied: ({
        enumName
      }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
      EnumInvalidMemberInitializerPrimaryType: ({
        enumName,
        memberName,
        explicitType
      }) => `Enum \`${enumName}\` has type \`${explicitType}\`, so the initializer of \`${memberName}\` needs to be a ${explicitType} literal.`,
      EnumInvalidMemberInitializerSymbolType: ({
        enumName,
        memberName
      }) => `Symbol enum members cannot be initialized. Use \`${memberName},\` in enum \`${enumName}\`.`,
      EnumInvalidMemberInitializerUnknownType: ({
        enumName,
        memberName
      }) => `The enum member initializer for \`${memberName}\` needs to be a literal (either a boolean, number, or string) in enum \`${enumName}\`.`,
      EnumInvalidMemberName: ({
        enumName,
        memberName,
        suggestion
      }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${memberName}\`, consider using \`${suggestion}\`, in enum \`${enumName}\`.`,
      EnumNumberMemberNotInitialized: ({
        enumName,
        memberName
      }) => `Number enum members need to be initialized, e.g. \`${memberName} = 1\` in enum \`${enumName}\`.`,
      EnumStringMemberInconsistentlyInitialized: ({
        enumName
      }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${enumName}\`.`,
      GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
      ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
      ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
      InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
      InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
      InexactVariance: "Explicit inexact syntax cannot have variance.",
      InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
      MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
      NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
      NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
      PatternIsOptional: Object.assign({
        message: "A binding pattern parameter cannot be optional in an implementation signature."
      }, {
        reasonCode: "OptionalBindingPattern"
      }),
      SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
      SpreadVariance: "Spread properties cannot have variance.",
      ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
      ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
      ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
      ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
      ThisParamNoDefault: "The `this` parameter may not have a default value.",
      TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
      TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
      UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
      UnexpectedReservedType: ({
        reservedType
      }) => `Unexpected reserved type ${reservedType}.`,
      UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
      UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
      UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
      UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
      UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
      UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
      UnsupportedDeclareExportKind: ({
        unsupportedExportKind,
        suggestion
      }) => `\`declare export ${unsupportedExportKind}\` is not supported. Use \`${suggestion}\` instead.`,
      UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
      UnterminatedFlowComment: "Unterminated flow-comment."
    });
    function isEsModuleType(bodyElement) {
      return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
    }
    function hasTypeImportKind(node) {
      return node.importKind === "type" || node.importKind === "typeof";
    }
    var exportSuggestions = {
      const: "declare export var",
      let: "declare export var",
      type: "export type",
      interface: "export interface"
    };
    function partition(list, test) {
      const list1 = [];
      const list2 = [];
      for (let i = 0; i < list.length; i++) {
        (test(list[i], i, list) ? list1 : list2).push(list[i]);
      }
      return [list1, list2];
    }
    var FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
    var flow = (superClass) => class FlowParserMixin extends superClass {
      constructor(...args) {
        super(...args);
        this.flowPragma = void 0;
      }
      getScopeHandler() {
        return FlowScopeHandler;
      }
      shouldParseTypes() {
        return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
      }
      shouldParseEnums() {
        return !!this.getPluginOption("flow", "enums");
      }
      finishToken(type, val) {
        if (type !== 133 && type !== 13 && type !== 28) {
          if (this.flowPragma === void 0) {
            this.flowPragma = null;
          }
        }
        super.finishToken(type, val);
      }
      addComment(comment) {
        if (this.flowPragma === void 0) {
          const matches = FLOW_PRAGMA_REGEX.exec(comment.value);
          if (!matches)
            ;
          else if (matches[1] === "flow") {
            this.flowPragma = "flow";
          } else if (matches[1] === "noflow") {
            this.flowPragma = "noflow";
          } else {
            throw new Error("Unexpected flow pragma");
          }
        }
        super.addComment(comment);
      }
      flowParseTypeInitialiser(tok) {
        const oldInType = this.state.inType;
        this.state.inType = true;
        this.expect(tok || 14);
        const type = this.flowParseType();
        this.state.inType = oldInType;
        return type;
      }
      flowParsePredicate() {
        const node = this.startNode();
        const moduloLoc = this.state.startLoc;
        this.next();
        this.expectContextual(110);
        if (this.state.lastTokStartLoc.index > moduloLoc.index + 1) {
          this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, moduloLoc);
        }
        if (this.eat(10)) {
          node.value = super.parseExpression();
          this.expect(11);
          return this.finishNode(node, "DeclaredPredicate");
        } else {
          return this.finishNode(node, "InferredPredicate");
        }
      }
      flowParseTypeAndPredicateInitialiser() {
        const oldInType = this.state.inType;
        this.state.inType = true;
        this.expect(14);
        let type = null;
        let predicate = null;
        if (this.match(54)) {
          this.state.inType = oldInType;
          predicate = this.flowParsePredicate();
        } else {
          type = this.flowParseType();
          this.state.inType = oldInType;
          if (this.match(54)) {
            predicate = this.flowParsePredicate();
          }
        }
        return [type, predicate];
      }
      flowParseDeclareClass(node) {
        this.next();
        this.flowParseInterfaceish(node, true);
        return this.finishNode(node, "DeclareClass");
      }
      flowParseDeclareFunction(node) {
        this.next();
        const id = node.id = this.parseIdentifier();
        const typeNode = this.startNode();
        const typeContainer = this.startNode();
        if (this.match(47)) {
          typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          typeNode.typeParameters = null;
        }
        this.expect(10);
        const tmp = this.flowParseFunctionTypeParams();
        typeNode.params = tmp.params;
        typeNode.rest = tmp.rest;
        typeNode.this = tmp._this;
        this.expect(11);
        [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
        typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
        id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
        this.resetEndLocation(id);
        this.semicolon();
        this.scope.declareName(node.id.name, 2048, node.id.loc.start);
        return this.finishNode(node, "DeclareFunction");
      }
      flowParseDeclare(node, insideModule) {
        if (this.match(80)) {
          return this.flowParseDeclareClass(node);
        } else if (this.match(68)) {
          return this.flowParseDeclareFunction(node);
        } else if (this.match(74)) {
          return this.flowParseDeclareVariable(node);
        } else if (this.eatContextual(127)) {
          if (this.match(16)) {
            return this.flowParseDeclareModuleExports(node);
          } else {
            if (insideModule) {
              this.raise(FlowErrors.NestedDeclareModule, this.state.lastTokStartLoc);
            }
            return this.flowParseDeclareModule(node);
          }
        } else if (this.isContextual(130)) {
          return this.flowParseDeclareTypeAlias(node);
        } else if (this.isContextual(131)) {
          return this.flowParseDeclareOpaqueType(node);
        } else if (this.isContextual(129)) {
          return this.flowParseDeclareInterface(node);
        } else if (this.match(82)) {
          return this.flowParseDeclareExportDeclaration(node, insideModule);
        } else {
          this.unexpected();
        }
      }
      flowParseDeclareVariable(node) {
        this.next();
        node.id = this.flowParseTypeAnnotatableIdentifier(true);
        this.scope.declareName(node.id.name, 5, node.id.loc.start);
        this.semicolon();
        return this.finishNode(node, "DeclareVariable");
      }
      flowParseDeclareModule(node) {
        this.scope.enter(0);
        if (this.match(133)) {
          node.id = super.parseExprAtom();
        } else {
          node.id = this.parseIdentifier();
        }
        const bodyNode = node.body = this.startNode();
        const body = bodyNode.body = [];
        this.expect(5);
        while (!this.match(8)) {
          let bodyNode2 = this.startNode();
          if (this.match(83)) {
            this.next();
            if (!this.isContextual(130) && !this.match(87)) {
              this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc);
            }
            super.parseImport(bodyNode2);
          } else {
            this.expectContextual(125, FlowErrors.UnsupportedStatementInDeclareModule);
            bodyNode2 = this.flowParseDeclare(bodyNode2, true);
          }
          body.push(bodyNode2);
        }
        this.scope.exit();
        this.expect(8);
        this.finishNode(bodyNode, "BlockStatement");
        let kind = null;
        let hasModuleExport = false;
        body.forEach((bodyElement) => {
          if (isEsModuleType(bodyElement)) {
            if (kind === "CommonJS") {
              this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);
            }
            kind = "ES";
          } else if (bodyElement.type === "DeclareModuleExports") {
            if (hasModuleExport) {
              this.raise(FlowErrors.DuplicateDeclareModuleExports, bodyElement);
            }
            if (kind === "ES") {
              this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);
            }
            kind = "CommonJS";
            hasModuleExport = true;
          }
        });
        node.kind = kind || "CommonJS";
        return this.finishNode(node, "DeclareModule");
      }
      flowParseDeclareExportDeclaration(node, insideModule) {
        this.expect(82);
        if (this.eat(65)) {
          if (this.match(68) || this.match(80)) {
            node.declaration = this.flowParseDeclare(this.startNode());
          } else {
            node.declaration = this.flowParseType();
            this.semicolon();
          }
          node.default = true;
          return this.finishNode(node, "DeclareExportDeclaration");
        } else {
          if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !insideModule) {
            const label = this.state.value;
            throw this.raise(FlowErrors.UnsupportedDeclareExportKind, this.state.startLoc, {
              unsupportedExportKind: label,
              suggestion: exportSuggestions[label]
            });
          }
          if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131)) {
            node.declaration = this.flowParseDeclare(this.startNode());
            node.default = false;
            return this.finishNode(node, "DeclareExportDeclaration");
          } else if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131)) {
            node = this.parseExport(node, null);
            if (node.type === "ExportNamedDeclaration") {
              node.type = "ExportDeclaration";
              node.default = false;
              delete node.exportKind;
            }
            node.type = "Declare" + node.type;
            return node;
          }
        }
        this.unexpected();
      }
      flowParseDeclareModuleExports(node) {
        this.next();
        this.expectContextual(111);
        node.typeAnnotation = this.flowParseTypeAnnotation();
        this.semicolon();
        return this.finishNode(node, "DeclareModuleExports");
      }
      flowParseDeclareTypeAlias(node) {
        this.next();
        const finished = this.flowParseTypeAlias(node);
        finished.type = "DeclareTypeAlias";
        return finished;
      }
      flowParseDeclareOpaqueType(node) {
        this.next();
        const finished = this.flowParseOpaqueType(node, true);
        finished.type = "DeclareOpaqueType";
        return finished;
      }
      flowParseDeclareInterface(node) {
        this.next();
        this.flowParseInterfaceish(node, false);
        return this.finishNode(node, "DeclareInterface");
      }
      flowParseInterfaceish(node, isClass) {
        node.id = this.flowParseRestrictedIdentifier(!isClass, true);
        this.scope.declareName(node.id.name, isClass ? 17 : 8201, node.id.loc.start);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }
        node.extends = [];
        if (this.eat(81)) {
          do {
            node.extends.push(this.flowParseInterfaceExtends());
          } while (!isClass && this.eat(12));
        }
        if (isClass) {
          node.implements = [];
          node.mixins = [];
          if (this.eatContextual(117)) {
            do {
              node.mixins.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
          }
          if (this.eatContextual(113)) {
            do {
              node.implements.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
          }
        }
        node.body = this.flowParseObjectType({
          allowStatic: isClass,
          allowExact: false,
          allowSpread: false,
          allowProto: isClass,
          allowInexact: false
        });
      }
      flowParseInterfaceExtends() {
        const node = this.startNode();
        node.id = this.flowParseQualifiedTypeIdentifier();
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterInstantiation();
        } else {
          node.typeParameters = null;
        }
        return this.finishNode(node, "InterfaceExtends");
      }
      flowParseInterface(node) {
        this.flowParseInterfaceish(node, false);
        return this.finishNode(node, "InterfaceDeclaration");
      }
      checkNotUnderscore(word) {
        if (word === "_") {
          this.raise(FlowErrors.UnexpectedReservedUnderscore, this.state.startLoc);
        }
      }
      checkReservedType(word, startLoc, declaration) {
        if (!reservedTypes.has(word))
          return;
        this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, startLoc, {
          reservedType: word
        });
      }
      flowParseRestrictedIdentifier(liberal, declaration) {
        this.checkReservedType(this.state.value, this.state.startLoc, declaration);
        return this.parseIdentifier(liberal);
      }
      flowParseTypeAlias(node) {
        node.id = this.flowParseRestrictedIdentifier(false, true);
        this.scope.declareName(node.id.name, 8201, node.id.loc.start);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }
        node.right = this.flowParseTypeInitialiser(29);
        this.semicolon();
        return this.finishNode(node, "TypeAlias");
      }
      flowParseOpaqueType(node, declare) {
        this.expectContextual(130);
        node.id = this.flowParseRestrictedIdentifier(true, true);
        this.scope.declareName(node.id.name, 8201, node.id.loc.start);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }
        node.supertype = null;
        if (this.match(14)) {
          node.supertype = this.flowParseTypeInitialiser(14);
        }
        node.impltype = null;
        if (!declare) {
          node.impltype = this.flowParseTypeInitialiser(29);
        }
        this.semicolon();
        return this.finishNode(node, "OpaqueType");
      }
      flowParseTypeParameter(requireDefault = false) {
        const nodeStartLoc = this.state.startLoc;
        const node = this.startNode();
        const variance = this.flowParseVariance();
        const ident = this.flowParseTypeAnnotatableIdentifier();
        node.name = ident.name;
        node.variance = variance;
        node.bound = ident.typeAnnotation;
        if (this.match(29)) {
          this.eat(29);
          node.default = this.flowParseType();
        } else {
          if (requireDefault) {
            this.raise(FlowErrors.MissingTypeParamDefault, nodeStartLoc);
          }
        }
        return this.finishNode(node, "TypeParameter");
      }
      flowParseTypeParameterDeclaration() {
        const oldInType = this.state.inType;
        const node = this.startNode();
        node.params = [];
        this.state.inType = true;
        if (this.match(47) || this.match(142)) {
          this.next();
        } else {
          this.unexpected();
        }
        let defaultRequired = false;
        do {
          const typeParameter = this.flowParseTypeParameter(defaultRequired);
          node.params.push(typeParameter);
          if (typeParameter.default) {
            defaultRequired = true;
          }
          if (!this.match(48)) {
            this.expect(12);
          }
        } while (!this.match(48));
        this.expect(48);
        this.state.inType = oldInType;
        return this.finishNode(node, "TypeParameterDeclaration");
      }
      flowParseTypeParameterInstantiation() {
        const node = this.startNode();
        const oldInType = this.state.inType;
        node.params = [];
        this.state.inType = true;
        this.expect(47);
        const oldNoAnonFunctionType = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = false;
        while (!this.match(48)) {
          node.params.push(this.flowParseType());
          if (!this.match(48)) {
            this.expect(12);
          }
        }
        this.state.noAnonFunctionType = oldNoAnonFunctionType;
        this.expect(48);
        this.state.inType = oldInType;
        return this.finishNode(node, "TypeParameterInstantiation");
      }
      flowParseTypeParameterInstantiationCallOrNew() {
        const node = this.startNode();
        const oldInType = this.state.inType;
        node.params = [];
        this.state.inType = true;
        this.expect(47);
        while (!this.match(48)) {
          node.params.push(this.flowParseTypeOrImplicitInstantiation());
          if (!this.match(48)) {
            this.expect(12);
          }
        }
        this.expect(48);
        this.state.inType = oldInType;
        return this.finishNode(node, "TypeParameterInstantiation");
      }
      flowParseInterfaceType() {
        const node = this.startNode();
        this.expectContextual(129);
        node.extends = [];
        if (this.eat(81)) {
          do {
            node.extends.push(this.flowParseInterfaceExtends());
          } while (this.eat(12));
        }
        node.body = this.flowParseObjectType({
          allowStatic: false,
          allowExact: false,
          allowSpread: false,
          allowProto: false,
          allowInexact: false
        });
        return this.finishNode(node, "InterfaceTypeAnnotation");
      }
      flowParseObjectPropertyKey() {
        return this.match(134) || this.match(133) ? super.parseExprAtom() : this.parseIdentifier(true);
      }
      flowParseObjectTypeIndexer(node, isStatic, variance) {
        node.static = isStatic;
        if (this.lookahead().type === 14) {
          node.id = this.flowParseObjectPropertyKey();
          node.key = this.flowParseTypeInitialiser();
        } else {
          node.id = null;
          node.key = this.flowParseType();
        }
        this.expect(3);
        node.value = this.flowParseTypeInitialiser();
        node.variance = variance;
        return this.finishNode(node, "ObjectTypeIndexer");
      }
      flowParseObjectTypeInternalSlot(node, isStatic) {
        node.static = isStatic;
        node.id = this.flowParseObjectPropertyKey();
        this.expect(3);
        this.expect(3);
        if (this.match(47) || this.match(10)) {
          node.method = true;
          node.optional = false;
          node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));
        } else {
          node.method = false;
          if (this.eat(17)) {
            node.optional = true;
          }
          node.value = this.flowParseTypeInitialiser();
        }
        return this.finishNode(node, "ObjectTypeInternalSlot");
      }
      flowParseObjectTypeMethodish(node) {
        node.params = [];
        node.rest = null;
        node.typeParameters = null;
        node.this = null;
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        this.expect(10);
        if (this.match(78)) {
          node.this = this.flowParseFunctionTypeParam(true);
          node.this.name = null;
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        while (!this.match(11) && !this.match(21)) {
          node.params.push(this.flowParseFunctionTypeParam(false));
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        if (this.eat(21)) {
          node.rest = this.flowParseFunctionTypeParam(false);
        }
        this.expect(11);
        node.returnType = this.flowParseTypeInitialiser();
        return this.finishNode(node, "FunctionTypeAnnotation");
      }
      flowParseObjectTypeCallProperty(node, isStatic) {
        const valueNode = this.startNode();
        node.static = isStatic;
        node.value = this.flowParseObjectTypeMethodish(valueNode);
        return this.finishNode(node, "ObjectTypeCallProperty");
      }
      flowParseObjectType({
        allowStatic,
        allowExact,
        allowSpread,
        allowProto,
        allowInexact
      }) {
        const oldInType = this.state.inType;
        this.state.inType = true;
        const nodeStart = this.startNode();
        nodeStart.callProperties = [];
        nodeStart.properties = [];
        nodeStart.indexers = [];
        nodeStart.internalSlots = [];
        let endDelim;
        let exact;
        let inexact = false;
        if (allowExact && this.match(6)) {
          this.expect(6);
          endDelim = 9;
          exact = true;
        } else {
          this.expect(5);
          endDelim = 8;
          exact = false;
        }
        nodeStart.exact = exact;
        while (!this.match(endDelim)) {
          let isStatic = false;
          let protoStartLoc = null;
          let inexactStartLoc = null;
          const node = this.startNode();
          if (allowProto && this.isContextual(118)) {
            const lookahead = this.lookahead();
            if (lookahead.type !== 14 && lookahead.type !== 17) {
              this.next();
              protoStartLoc = this.state.startLoc;
              allowStatic = false;
            }
          }
          if (allowStatic && this.isContextual(106)) {
            const lookahead = this.lookahead();
            if (lookahead.type !== 14 && lookahead.type !== 17) {
              this.next();
              isStatic = true;
            }
          }
          const variance = this.flowParseVariance();
          if (this.eat(0)) {
            if (protoStartLoc != null) {
              this.unexpected(protoStartLoc);
            }
            if (this.eat(0)) {
              if (variance) {
                this.unexpected(variance.loc.start);
              }
              nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));
            } else {
              nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
            }
          } else if (this.match(10) || this.match(47)) {
            if (protoStartLoc != null) {
              this.unexpected(protoStartLoc);
            }
            if (variance) {
              this.unexpected(variance.loc.start);
            }
            nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
          } else {
            let kind = "init";
            if (this.isContextual(99) || this.isContextual(104)) {
              const lookahead = this.lookahead();
              if (tokenIsLiteralPropertyName(lookahead.type)) {
                kind = this.state.value;
                this.next();
              }
            }
            const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);
            if (propOrInexact === null) {
              inexact = true;
              inexactStartLoc = this.state.lastTokStartLoc;
            } else {
              nodeStart.properties.push(propOrInexact);
            }
          }
          this.flowObjectTypeSemicolon();
          if (inexactStartLoc && !this.match(8) && !this.match(9)) {
            this.raise(FlowErrors.UnexpectedExplicitInexactInObject, inexactStartLoc);
          }
        }
        this.expect(endDelim);
        if (allowSpread) {
          nodeStart.inexact = inexact;
        }
        const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
        this.state.inType = oldInType;
        return out;
      }
      flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {
        if (this.eat(21)) {
          const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);
          if (isInexactToken) {
            if (!allowSpread) {
              this.raise(FlowErrors.InexactInsideNonObject, this.state.lastTokStartLoc);
            } else if (!allowInexact) {
              this.raise(FlowErrors.InexactInsideExact, this.state.lastTokStartLoc);
            }
            if (variance) {
              this.raise(FlowErrors.InexactVariance, variance);
            }
            return null;
          }
          if (!allowSpread) {
            this.raise(FlowErrors.UnexpectedSpreadType, this.state.lastTokStartLoc);
          }
          if (protoStartLoc != null) {
            this.unexpected(protoStartLoc);
          }
          if (variance) {
            this.raise(FlowErrors.SpreadVariance, variance);
          }
          node.argument = this.flowParseType();
          return this.finishNode(node, "ObjectTypeSpreadProperty");
        } else {
          node.key = this.flowParseObjectPropertyKey();
          node.static = isStatic;
          node.proto = protoStartLoc != null;
          node.kind = kind;
          let optional = false;
          if (this.match(47) || this.match(10)) {
            node.method = true;
            if (protoStartLoc != null) {
              this.unexpected(protoStartLoc);
            }
            if (variance) {
              this.unexpected(variance.loc.start);
            }
            node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));
            if (kind === "get" || kind === "set") {
              this.flowCheckGetterSetterParams(node);
            }
            if (!allowSpread && node.key.name === "constructor" && node.value.this) {
              this.raise(FlowErrors.ThisParamBannedInConstructor, node.value.this);
            }
          } else {
            if (kind !== "init")
              this.unexpected();
            node.method = false;
            if (this.eat(17)) {
              optional = true;
            }
            node.value = this.flowParseTypeInitialiser();
            node.variance = variance;
          }
          node.optional = optional;
          return this.finishNode(node, "ObjectTypeProperty");
        }
      }
      flowCheckGetterSetterParams(property) {
        const paramCount = property.kind === "get" ? 0 : 1;
        const length = property.value.params.length + (property.value.rest ? 1 : 0);
        if (property.value.this) {
          this.raise(property.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, property.value.this);
        }
        if (length !== paramCount) {
          this.raise(property.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, property);
        }
        if (property.kind === "set" && property.value.rest) {
          this.raise(Errors.BadSetterRestParameter, property);
        }
      }
      flowObjectTypeSemicolon() {
        if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {
          this.unexpected();
        }
      }
      flowParseQualifiedTypeIdentifier(startLoc, id) {
        var _startLoc;
        (_startLoc = startLoc) != null ? _startLoc : startLoc = this.state.startLoc;
        let node = id || this.flowParseRestrictedIdentifier(true);
        while (this.eat(16)) {
          const node2 = this.startNodeAt(startLoc);
          node2.qualification = node;
          node2.id = this.flowParseRestrictedIdentifier(true);
          node = this.finishNode(node2, "QualifiedTypeIdentifier");
        }
        return node;
      }
      flowParseGenericType(startLoc, id) {
        const node = this.startNodeAt(startLoc);
        node.typeParameters = null;
        node.id = this.flowParseQualifiedTypeIdentifier(startLoc, id);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterInstantiation();
        }
        return this.finishNode(node, "GenericTypeAnnotation");
      }
      flowParseTypeofType() {
        const node = this.startNode();
        this.expect(87);
        node.argument = this.flowParsePrimaryType();
        return this.finishNode(node, "TypeofTypeAnnotation");
      }
      flowParseTupleType() {
        const node = this.startNode();
        node.types = [];
        this.expect(0);
        while (this.state.pos < this.length && !this.match(3)) {
          node.types.push(this.flowParseType());
          if (this.match(3))
            break;
          this.expect(12);
        }
        this.expect(3);
        return this.finishNode(node, "TupleTypeAnnotation");
      }
      flowParseFunctionTypeParam(first) {
        let name = null;
        let optional = false;
        let typeAnnotation = null;
        const node = this.startNode();
        const lh = this.lookahead();
        const isThis = this.state.type === 78;
        if (lh.type === 14 || lh.type === 17) {
          if (isThis && !first) {
            this.raise(FlowErrors.ThisParamMustBeFirst, node);
          }
          name = this.parseIdentifier(isThis);
          if (this.eat(17)) {
            optional = true;
            if (isThis) {
              this.raise(FlowErrors.ThisParamMayNotBeOptional, node);
            }
          }
          typeAnnotation = this.flowParseTypeInitialiser();
        } else {
          typeAnnotation = this.flowParseType();
        }
        node.name = name;
        node.optional = optional;
        node.typeAnnotation = typeAnnotation;
        return this.finishNode(node, "FunctionTypeParam");
      }
      reinterpretTypeAsFunctionTypeParam(type) {
        const node = this.startNodeAt(type.loc.start);
        node.name = null;
        node.optional = false;
        node.typeAnnotation = type;
        return this.finishNode(node, "FunctionTypeParam");
      }
      flowParseFunctionTypeParams(params = []) {
        let rest = null;
        let _this = null;
        if (this.match(78)) {
          _this = this.flowParseFunctionTypeParam(true);
          _this.name = null;
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        while (!this.match(11) && !this.match(21)) {
          params.push(this.flowParseFunctionTypeParam(false));
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        if (this.eat(21)) {
          rest = this.flowParseFunctionTypeParam(false);
        }
        return {
          params,
          rest,
          _this
        };
      }
      flowIdentToTypeAnnotation(startLoc, node, id) {
        switch (id.name) {
          case "any":
            return this.finishNode(node, "AnyTypeAnnotation");
          case "bool":
          case "boolean":
            return this.finishNode(node, "BooleanTypeAnnotation");
          case "mixed":
            return this.finishNode(node, "MixedTypeAnnotation");
          case "empty":
            return this.finishNode(node, "EmptyTypeAnnotation");
          case "number":
            return this.finishNode(node, "NumberTypeAnnotation");
          case "string":
            return this.finishNode(node, "StringTypeAnnotation");
          case "symbol":
            return this.finishNode(node, "SymbolTypeAnnotation");
          default:
            this.checkNotUnderscore(id.name);
            return this.flowParseGenericType(startLoc, id);
        }
      }
      flowParsePrimaryType() {
        const startLoc = this.state.startLoc;
        const node = this.startNode();
        let tmp;
        let type;
        let isGroupedType = false;
        const oldNoAnonFunctionType = this.state.noAnonFunctionType;
        switch (this.state.type) {
          case 5:
            return this.flowParseObjectType({
              allowStatic: false,
              allowExact: false,
              allowSpread: true,
              allowProto: false,
              allowInexact: true
            });
          case 6:
            return this.flowParseObjectType({
              allowStatic: false,
              allowExact: true,
              allowSpread: true,
              allowProto: false,
              allowInexact: false
            });
          case 0:
            this.state.noAnonFunctionType = false;
            type = this.flowParseTupleType();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
            return type;
          case 47: {
            const node2 = this.startNode();
            node2.typeParameters = this.flowParseTypeParameterDeclaration();
            this.expect(10);
            tmp = this.flowParseFunctionTypeParams();
            node2.params = tmp.params;
            node2.rest = tmp.rest;
            node2.this = tmp._this;
            this.expect(11);
            this.expect(19);
            node2.returnType = this.flowParseType();
            return this.finishNode(node2, "FunctionTypeAnnotation");
          }
          case 10: {
            const node2 = this.startNode();
            this.next();
            if (!this.match(11) && !this.match(21)) {
              if (tokenIsIdentifier(this.state.type) || this.match(78)) {
                const token = this.lookahead().type;
                isGroupedType = token !== 17 && token !== 14;
              } else {
                isGroupedType = true;
              }
            }
            if (isGroupedType) {
              this.state.noAnonFunctionType = false;
              type = this.flowParseType();
              this.state.noAnonFunctionType = oldNoAnonFunctionType;
              if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {
                this.expect(11);
                return type;
              } else {
                this.eat(12);
              }
            }
            if (type) {
              tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
            } else {
              tmp = this.flowParseFunctionTypeParams();
            }
            node2.params = tmp.params;
            node2.rest = tmp.rest;
            node2.this = tmp._this;
            this.expect(11);
            this.expect(19);
            node2.returnType = this.flowParseType();
            node2.typeParameters = null;
            return this.finishNode(node2, "FunctionTypeAnnotation");
          }
          case 133:
            return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
          case 85:
          case 86:
            node.value = this.match(85);
            this.next();
            return this.finishNode(node, "BooleanLiteralTypeAnnotation");
          case 53:
            if (this.state.value === "-") {
              this.next();
              if (this.match(134)) {
                return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node);
              }
              if (this.match(135)) {
                return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node);
              }
              throw this.raise(FlowErrors.UnexpectedSubtractionOperand, this.state.startLoc);
            }
            this.unexpected();
            return;
          case 134:
            return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
          case 135:
            return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
          case 88:
            this.next();
            return this.finishNode(node, "VoidTypeAnnotation");
          case 84:
            this.next();
            return this.finishNode(node, "NullLiteralTypeAnnotation");
          case 78:
            this.next();
            return this.finishNode(node, "ThisTypeAnnotation");
          case 55:
            this.next();
            return this.finishNode(node, "ExistsTypeAnnotation");
          case 87:
            return this.flowParseTypeofType();
          default:
            if (tokenIsKeyword(this.state.type)) {
              const label = tokenLabelName(this.state.type);
              this.next();
              return super.createIdentifier(node, label);
            } else if (tokenIsIdentifier(this.state.type)) {
              if (this.isContextual(129)) {
                return this.flowParseInterfaceType();
              }
              return this.flowIdentToTypeAnnotation(startLoc, node, this.parseIdentifier());
            }
        }
        this.unexpected();
      }
      flowParsePostfixType() {
        const startLoc = this.state.startLoc;
        let type = this.flowParsePrimaryType();
        let seenOptionalIndexedAccess = false;
        while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {
          const node = this.startNodeAt(startLoc);
          const optional = this.eat(18);
          seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;
          this.expect(0);
          if (!optional && this.match(3)) {
            node.elementType = type;
            this.next();
            type = this.finishNode(node, "ArrayTypeAnnotation");
          } else {
            node.objectType = type;
            node.indexType = this.flowParseType();
            this.expect(3);
            if (seenOptionalIndexedAccess) {
              node.optional = optional;
              type = this.finishNode(node, "OptionalIndexedAccessType");
            } else {
              type = this.finishNode(node, "IndexedAccessType");
            }
          }
        }
        return type;
      }
      flowParsePrefixType() {
        const node = this.startNode();
        if (this.eat(17)) {
          node.typeAnnotation = this.flowParsePrefixType();
          return this.finishNode(node, "NullableTypeAnnotation");
        } else {
          return this.flowParsePostfixType();
        }
      }
      flowParseAnonFunctionWithoutParens() {
        const param = this.flowParsePrefixType();
        if (!this.state.noAnonFunctionType && this.eat(19)) {
          const node = this.startNodeAt(param.loc.start);
          node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
          node.rest = null;
          node.this = null;
          node.returnType = this.flowParseType();
          node.typeParameters = null;
          return this.finishNode(node, "FunctionTypeAnnotation");
        }
        return param;
      }
      flowParseIntersectionType() {
        const node = this.startNode();
        this.eat(45);
        const type = this.flowParseAnonFunctionWithoutParens();
        node.types = [type];
        while (this.eat(45)) {
          node.types.push(this.flowParseAnonFunctionWithoutParens());
        }
        return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
      }
      flowParseUnionType() {
        const node = this.startNode();
        this.eat(43);
        const type = this.flowParseIntersectionType();
        node.types = [type];
        while (this.eat(43)) {
          node.types.push(this.flowParseIntersectionType());
        }
        return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
      }
      flowParseType() {
        const oldInType = this.state.inType;
        this.state.inType = true;
        const type = this.flowParseUnionType();
        this.state.inType = oldInType;
        return type;
      }
      flowParseTypeOrImplicitInstantiation() {
        if (this.state.type === 132 && this.state.value === "_") {
          const startLoc = this.state.startLoc;
          const node = this.parseIdentifier();
          return this.flowParseGenericType(startLoc, node);
        } else {
          return this.flowParseType();
        }
      }
      flowParseTypeAnnotation() {
        const node = this.startNode();
        node.typeAnnotation = this.flowParseTypeInitialiser();
        return this.finishNode(node, "TypeAnnotation");
      }
      flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
        const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
        if (this.match(14)) {
          ident.typeAnnotation = this.flowParseTypeAnnotation();
          this.resetEndLocation(ident);
        }
        return ident;
      }
      typeCastToParameter(node) {
        node.expression.typeAnnotation = node.typeAnnotation;
        this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
        return node.expression;
      }
      flowParseVariance() {
        let variance = null;
        if (this.match(53)) {
          variance = this.startNode();
          if (this.state.value === "+") {
            variance.kind = "plus";
          } else {
            variance.kind = "minus";
          }
          this.next();
          return this.finishNode(variance, "Variance");
        }
        return variance;
      }
      parseFunctionBody(node, allowExpressionBody, isMethod = false) {
        if (allowExpressionBody) {
          this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));
          return;
        }
        super.parseFunctionBody(node, false, isMethod);
      }
      parseFunctionBodyAndFinish(node, type, isMethod = false) {
        if (this.match(14)) {
          const typeNode = this.startNode();
          [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
          node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
        }
        return super.parseFunctionBodyAndFinish(node, type, isMethod);
      }
      parseStatementLike(flags) {
        if (this.state.strict && this.isContextual(129)) {
          const lookahead = this.lookahead();
          if (tokenIsKeywordOrIdentifier(lookahead.type)) {
            const node = this.startNode();
            this.next();
            return this.flowParseInterface(node);
          }
        } else if (this.shouldParseEnums() && this.isContextual(126)) {
          const node = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(node);
        }
        const stmt = super.parseStatementLike(flags);
        if (this.flowPragma === void 0 && !this.isValidDirective(stmt)) {
          this.flowPragma = null;
        }
        return stmt;
      }
      parseExpressionStatement(node, expr, decorators) {
        if (expr.type === "Identifier") {
          if (expr.name === "declare") {
            if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {
              return this.flowParseDeclare(node);
            }
          } else if (tokenIsIdentifier(this.state.type)) {
            if (expr.name === "interface") {
              return this.flowParseInterface(node);
            } else if (expr.name === "type") {
              return this.flowParseTypeAlias(node);
            } else if (expr.name === "opaque") {
              return this.flowParseOpaqueType(node, false);
            }
          }
        }
        return super.parseExpressionStatement(node, expr, decorators);
      }
      shouldParseExportDeclaration() {
        const {
          type
        } = this.state;
        if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 126) {
          return !this.state.containsEsc;
        }
        return super.shouldParseExportDeclaration();
      }
      isExportDefaultSpecifier() {
        const {
          type
        } = this.state;
        if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 126) {
          return this.state.containsEsc;
        }
        return super.isExportDefaultSpecifier();
      }
      parseExportDefaultExpression() {
        if (this.shouldParseEnums() && this.isContextual(126)) {
          const node = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(node);
        }
        return super.parseExportDefaultExpression();
      }
      parseConditional(expr, startLoc, refExpressionErrors) {
        if (!this.match(17))
          return expr;
        if (this.state.maybeInArrowParameters) {
          const nextCh = this.lookaheadCharCode();
          if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
            this.setOptionalParametersError(refExpressionErrors);
            return expr;
          }
        }
        this.expect(17);
        const state = this.state.clone();
        const originalNoArrowAt = this.state.noArrowAt;
        const node = this.startNodeAt(startLoc);
        let {
          consequent,
          failed
        } = this.tryParseConditionalConsequent();
        let [valid, invalid] = this.getArrowLikeExpressions(consequent);
        if (failed || invalid.length > 0) {
          const noArrowAt = [...originalNoArrowAt];
          if (invalid.length > 0) {
            this.state = state;
            this.state.noArrowAt = noArrowAt;
            for (let i = 0; i < invalid.length; i++) {
              noArrowAt.push(invalid[i].start);
            }
            ({
              consequent,
              failed
            } = this.tryParseConditionalConsequent());
            [valid, invalid] = this.getArrowLikeExpressions(consequent);
          }
          if (failed && valid.length > 1) {
            this.raise(FlowErrors.AmbiguousConditionalArrow, state.startLoc);
          }
          if (failed && valid.length === 1) {
            this.state = state;
            noArrowAt.push(valid[0].start);
            this.state.noArrowAt = noArrowAt;
            ({
              consequent,
              failed
            } = this.tryParseConditionalConsequent());
          }
        }
        this.getArrowLikeExpressions(consequent, true);
        this.state.noArrowAt = originalNoArrowAt;
        this.expect(14);
        node.test = expr;
        node.consequent = consequent;
        node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(void 0, void 0));
        return this.finishNode(node, "ConditionalExpression");
      }
      tryParseConditionalConsequent() {
        this.state.noArrowParamsConversionAt.push(this.state.start);
        const consequent = this.parseMaybeAssignAllowIn();
        const failed = !this.match(14);
        this.state.noArrowParamsConversionAt.pop();
        return {
          consequent,
          failed
        };
      }
      getArrowLikeExpressions(node, disallowInvalid) {
        const stack = [node];
        const arrows = [];
        while (stack.length !== 0) {
          const node2 = stack.pop();
          if (node2.type === "ArrowFunctionExpression" && node2.body.type !== "BlockStatement") {
            if (node2.typeParameters || !node2.returnType) {
              this.finishArrowValidation(node2);
            } else {
              arrows.push(node2);
            }
            stack.push(node2.body);
          } else if (node2.type === "ConditionalExpression") {
            stack.push(node2.consequent);
            stack.push(node2.alternate);
          }
        }
        if (disallowInvalid) {
          arrows.forEach((node2) => this.finishArrowValidation(node2));
          return [arrows, []];
        }
        return partition(arrows, (node2) => node2.params.every((param) => this.isAssignable(param, true)));
      }
      finishArrowValidation(node) {
        var _node$extra;
        this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingCommaLoc, false);
        this.scope.enter(2 | 4);
        super.checkParams(node, false, true);
        this.scope.exit();
      }
      forwardNoArrowParamsConversionAt(node, parse2) {
        let result;
        if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
          this.state.noArrowParamsConversionAt.push(this.state.start);
          result = parse2();
          this.state.noArrowParamsConversionAt.pop();
        } else {
          result = parse2();
        }
        return result;
      }
      parseParenItem(node, startLoc) {
        const newNode = super.parseParenItem(node, startLoc);
        if (this.eat(17)) {
          newNode.optional = true;
          this.resetEndLocation(node);
        }
        if (this.match(14)) {
          const typeCastNode = this.startNodeAt(startLoc);
          typeCastNode.expression = newNode;
          typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
          return this.finishNode(typeCastNode, "TypeCastExpression");
        }
        return newNode;
      }
      assertModuleNodeAllowed(node) {
        if (node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type") {
          return;
        }
        super.assertModuleNodeAllowed(node);
      }
      parseExportDeclaration(node) {
        if (this.isContextual(130)) {
          node.exportKind = "type";
          const declarationNode = this.startNode();
          this.next();
          if (this.match(5)) {
            node.specifiers = this.parseExportSpecifiers(true);
            super.parseExportFrom(node);
            return null;
          } else {
            return this.flowParseTypeAlias(declarationNode);
          }
        } else if (this.isContextual(131)) {
          node.exportKind = "type";
          const declarationNode = this.startNode();
          this.next();
          return this.flowParseOpaqueType(declarationNode, false);
        } else if (this.isContextual(129)) {
          node.exportKind = "type";
          const declarationNode = this.startNode();
          this.next();
          return this.flowParseInterface(declarationNode);
        } else if (this.shouldParseEnums() && this.isContextual(126)) {
          node.exportKind = "value";
          const declarationNode = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(declarationNode);
        } else {
          return super.parseExportDeclaration(node);
        }
      }
      eatExportStar(node) {
        if (super.eatExportStar(node))
          return true;
        if (this.isContextual(130) && this.lookahead().type === 55) {
          node.exportKind = "type";
          this.next();
          this.next();
          return true;
        }
        return false;
      }
      maybeParseExportNamespaceSpecifier(node) {
        const {
          startLoc
        } = this.state;
        const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);
        if (hasNamespace && node.exportKind === "type") {
          this.unexpected(startLoc);
        }
        return hasNamespace;
      }
      parseClassId(node, isStatement, optionalId) {
        super.parseClassId(node, isStatement, optionalId);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }
      }
      parseClassMember(classBody, member, state) {
        const {
          startLoc
        } = this.state;
        if (this.isContextual(125)) {
          if (super.parseClassMemberFromModifier(classBody, member)) {
            return;
          }
          member.declare = true;
        }
        super.parseClassMember(classBody, member, state);
        if (member.declare) {
          if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition") {
            this.raise(FlowErrors.DeclareClassElement, startLoc);
          } else if (member.value) {
            this.raise(FlowErrors.DeclareClassFieldInitializer, member.value);
          }
        }
      }
      isIterator(word) {
        return word === "iterator" || word === "asyncIterator";
      }
      readIterator() {
        const word = super.readWord1();
        const fullWord = "@@" + word;
        if (!this.isIterator(word) || !this.state.inType) {
          this.raise(Errors.InvalidIdentifier, this.state.curPosition(), {
            identifierName: fullWord
          });
        }
        this.finishToken(132, fullWord);
      }
      getTokenFromCode(code2) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (code2 === 123 && next === 124) {
          this.finishOp(6, 2);
        } else if (this.state.inType && (code2 === 62 || code2 === 60)) {
          this.finishOp(code2 === 62 ? 48 : 47, 1);
        } else if (this.state.inType && code2 === 63) {
          if (next === 46) {
            this.finishOp(18, 2);
          } else {
            this.finishOp(17, 1);
          }
        } else if (isIteratorStart(code2, next, this.input.charCodeAt(this.state.pos + 2))) {
          this.state.pos += 2;
          this.readIterator();
        } else {
          super.getTokenFromCode(code2);
        }
      }
      isAssignable(node, isBinding) {
        if (node.type === "TypeCastExpression") {
          return this.isAssignable(node.expression, isBinding);
        } else {
          return super.isAssignable(node, isBinding);
        }
      }
      toAssignable(node, isLHS = false) {
        if (!isLHS && node.type === "AssignmentExpression" && node.left.type === "TypeCastExpression") {
          node.left = this.typeCastToParameter(node.left);
        }
        super.toAssignable(node, isLHS);
      }
      toAssignableList(exprList, trailingCommaLoc, isLHS) {
        for (let i = 0; i < exprList.length; i++) {
          const expr = exprList[i];
          if ((expr == null ? void 0 : expr.type) === "TypeCastExpression") {
            exprList[i] = this.typeCastToParameter(expr);
          }
        }
        super.toAssignableList(exprList, trailingCommaLoc, isLHS);
      }
      toReferencedList(exprList, isParenthesizedExpr) {
        for (let i = 0; i < exprList.length; i++) {
          var _expr$extra;
          const expr = exprList[i];
          if (expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
            this.raise(FlowErrors.TypeCastInPattern, expr.typeAnnotation);
          }
        }
        return exprList;
      }
      parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
        const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
        if (canBePattern && !this.state.maybeInArrowParameters) {
          this.toReferencedList(node.elements);
        }
        return node;
      }
      isValidLVal(type, isParenthesized, binding) {
        return type === "TypeCastExpression" || super.isValidLVal(type, isParenthesized, binding);
      }
      parseClassProperty(node) {
        if (this.match(14)) {
          node.typeAnnotation = this.flowParseTypeAnnotation();
        }
        return super.parseClassProperty(node);
      }
      parseClassPrivateProperty(node) {
        if (this.match(14)) {
          node.typeAnnotation = this.flowParseTypeAnnotation();
        }
        return super.parseClassPrivateProperty(node);
      }
      isClassMethod() {
        return this.match(47) || super.isClassMethod();
      }
      isClassProperty() {
        return this.match(14) || super.isClassProperty();
      }
      isNonstaticConstructor(method) {
        return !this.match(14) && super.isNonstaticConstructor(method);
      }
      pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        if (method.variance) {
          this.unexpected(method.variance.loc.start);
        }
        delete method.variance;
        if (this.match(47)) {
          method.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
        if (method.params && isConstructor) {
          const params = method.params;
          if (params.length > 0 && this.isThisParam(params[0])) {
            this.raise(FlowErrors.ThisParamBannedInConstructor, method);
          }
        } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
          const params = method.value.params;
          if (params.length > 0 && this.isThisParam(params[0])) {
            this.raise(FlowErrors.ThisParamBannedInConstructor, method);
          }
        }
      }
      pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        if (method.variance) {
          this.unexpected(method.variance.loc.start);
        }
        delete method.variance;
        if (this.match(47)) {
          method.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
      }
      parseClassSuper(node) {
        super.parseClassSuper(node);
        if (node.superClass && this.match(47)) {
          node.superTypeParameters = this.flowParseTypeParameterInstantiation();
        }
        if (this.isContextual(113)) {
          this.next();
          const implemented = node.implements = [];
          do {
            const node2 = this.startNode();
            node2.id = this.flowParseRestrictedIdentifier(true);
            if (this.match(47)) {
              node2.typeParameters = this.flowParseTypeParameterInstantiation();
            } else {
              node2.typeParameters = null;
            }
            implemented.push(this.finishNode(node2, "ClassImplements"));
          } while (this.eat(12));
        }
      }
      checkGetterSetterParams(method) {
        super.checkGetterSetterParams(method);
        const params = this.getObjectOrClassMethodParams(method);
        if (params.length > 0) {
          const param = params[0];
          if (this.isThisParam(param) && method.kind === "get") {
            this.raise(FlowErrors.GetterMayNotHaveThisParam, param);
          } else if (this.isThisParam(param)) {
            this.raise(FlowErrors.SetterMayNotHaveThisParam, param);
          }
        }
      }
      parsePropertyNamePrefixOperator(node) {
        node.variance = this.flowParseVariance();
      }
      parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
        if (prop.variance) {
          this.unexpected(prop.variance.loc.start);
        }
        delete prop.variance;
        let typeParameters;
        if (this.match(47) && !isAccessor) {
          typeParameters = this.flowParseTypeParameterDeclaration();
          if (!this.match(10))
            this.unexpected();
        }
        const result = super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
        if (typeParameters) {
          (result.value || result).typeParameters = typeParameters;
        }
        return result;
      }
      parseAssignableListItemTypes(param) {
        if (this.eat(17)) {
          if (param.type !== "Identifier") {
            this.raise(FlowErrors.PatternIsOptional, param);
          }
          if (this.isThisParam(param)) {
            this.raise(FlowErrors.ThisParamMayNotBeOptional, param);
          }
          param.optional = true;
        }
        if (this.match(14)) {
          param.typeAnnotation = this.flowParseTypeAnnotation();
        } else if (this.isThisParam(param)) {
          this.raise(FlowErrors.ThisParamAnnotationRequired, param);
        }
        if (this.match(29) && this.isThisParam(param)) {
          this.raise(FlowErrors.ThisParamNoDefault, param);
        }
        this.resetEndLocation(param);
        return param;
      }
      parseMaybeDefault(startLoc, left) {
        const node = super.parseMaybeDefault(startLoc, left);
        if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
          this.raise(FlowErrors.TypeBeforeInitializer, node.typeAnnotation);
        }
        return node;
      }
      checkImportReflection(node) {
        super.checkImportReflection(node);
        if (node.module && node.importKind !== "value") {
          this.raise(FlowErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);
        }
      }
      parseImportSpecifierLocal(node, specifier, type) {
        specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
        node.specifiers.push(this.finishImportSpecifier(specifier, type));
      }
      isPotentialImportPhase(isExport) {
        if (super.isPotentialImportPhase(isExport))
          return true;
        if (this.isContextual(130)) {
          if (!isExport)
            return true;
          const ch = this.lookaheadCharCode();
          return ch === 123 || ch === 42;
        }
        return !isExport && this.isContextual(87);
      }
      applyImportPhase(node, isExport, phase, loc) {
        super.applyImportPhase(node, isExport, phase, loc);
        if (isExport) {
          if (!phase && this.match(65)) {
            return;
          }
          node.exportKind = phase === "type" ? phase : "value";
        } else {
          if (phase === "type" && this.match(55))
            this.unexpected();
          node.importKind = phase === "type" || phase === "typeof" ? phase : "value";
        }
      }
      parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
        const firstIdent = specifier.imported;
        let specifierTypeKind = null;
        if (firstIdent.type === "Identifier") {
          if (firstIdent.name === "type") {
            specifierTypeKind = "type";
          } else if (firstIdent.name === "typeof") {
            specifierTypeKind = "typeof";
          }
        }
        let isBinding = false;
        if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
          const as_ident = this.parseIdentifier(true);
          if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {
            specifier.imported = as_ident;
            specifier.importKind = specifierTypeKind;
            specifier.local = cloneIdentifier(as_ident);
          } else {
            specifier.imported = firstIdent;
            specifier.importKind = null;
            specifier.local = this.parseIdentifier();
          }
        } else {
          if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {
            specifier.imported = this.parseIdentifier(true);
            specifier.importKind = specifierTypeKind;
          } else {
            if (importedIsString) {
              throw this.raise(Errors.ImportBindingIsString, specifier, {
                importName: firstIdent.value
              });
            }
            specifier.imported = firstIdent;
            specifier.importKind = null;
          }
          if (this.eatContextual(93)) {
            specifier.local = this.parseIdentifier();
          } else {
            isBinding = true;
            specifier.local = cloneIdentifier(specifier.imported);
          }
        }
        const specifierIsTypeImport = hasTypeImportKind(specifier);
        if (isInTypeOnlyImport && specifierIsTypeImport) {
          this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, specifier);
        }
        if (isInTypeOnlyImport || specifierIsTypeImport) {
          this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);
        }
        if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {
          this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);
        }
        return this.finishImportSpecifier(specifier, "ImportSpecifier");
      }
      parseBindingAtom() {
        switch (this.state.type) {
          case 78:
            return this.parseIdentifier(true);
          default:
            return super.parseBindingAtom();
        }
      }
      parseFunctionParams(node, isConstructor) {
        const kind = node.kind;
        if (kind !== "get" && kind !== "set" && this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        super.parseFunctionParams(node, isConstructor);
      }
      parseVarId(decl, kind) {
        super.parseVarId(decl, kind);
        if (this.match(14)) {
          decl.id.typeAnnotation = this.flowParseTypeAnnotation();
          this.resetEndLocation(decl.id);
        }
      }
      parseAsyncArrowFromCallExpression(node, call) {
        if (this.match(14)) {
          const oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = true;
          node.returnType = this.flowParseTypeAnnotation();
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
        }
        return super.parseAsyncArrowFromCallExpression(node, call);
      }
      shouldParseAsyncArrow() {
        return this.match(14) || super.shouldParseAsyncArrow();
      }
      parseMaybeAssign(refExpressionErrors, afterLeftParse) {
        var _jsx;
        let state = null;
        let jsx2;
        if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
          state = this.state.clone();
          jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
          if (!jsx2.error)
            return jsx2.node;
          const {
            context
          } = this.state;
          const currentContext = context[context.length - 1];
          if (currentContext === types.j_oTag || currentContext === types.j_expr) {
            context.pop();
          }
        }
        if ((_jsx = jsx2) != null && _jsx.error || this.match(47)) {
          var _jsx2, _jsx3;
          state = state || this.state.clone();
          let typeParameters;
          const arrow = this.tryParse((abort) => {
            var _arrowExpression$extr;
            typeParameters = this.flowParseTypeParameterDeclaration();
            const arrowExpression2 = this.forwardNoArrowParamsConversionAt(typeParameters, () => {
              const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
              this.resetStartLocationFromNode(result, typeParameters);
              return result;
            });
            if ((_arrowExpression$extr = arrowExpression2.extra) != null && _arrowExpression$extr.parenthesized)
              abort();
            const expr = this.maybeUnwrapTypeCastExpression(arrowExpression2);
            if (expr.type !== "ArrowFunctionExpression")
              abort();
            expr.typeParameters = typeParameters;
            this.resetStartLocationFromNode(expr, typeParameters);
            return arrowExpression2;
          }, state);
          let arrowExpression = null;
          if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
            if (!arrow.error && !arrow.aborted) {
              if (arrow.node.async) {
                this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, typeParameters);
              }
              return arrow.node;
            }
            arrowExpression = arrow.node;
          }
          if ((_jsx2 = jsx2) != null && _jsx2.node) {
            this.state = jsx2.failState;
            return jsx2.node;
          }
          if (arrowExpression) {
            this.state = arrow.failState;
            return arrowExpression;
          }
          if ((_jsx3 = jsx2) != null && _jsx3.thrown)
            throw jsx2.error;
          if (arrow.thrown)
            throw arrow.error;
          throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, typeParameters);
        }
        return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
      }
      parseArrow(node) {
        if (this.match(14)) {
          const result = this.tryParse(() => {
            const oldNoAnonFunctionType = this.state.noAnonFunctionType;
            this.state.noAnonFunctionType = true;
            const typeNode = this.startNode();
            [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
            if (this.canInsertSemicolon())
              this.unexpected();
            if (!this.match(19))
              this.unexpected();
            return typeNode;
          });
          if (result.thrown)
            return null;
          if (result.error)
            this.state = result.failState;
          node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
        }
        return super.parseArrow(node);
      }
      shouldParseArrow(params) {
        return this.match(14) || super.shouldParseArrow(params);
      }
      setArrowFunctionParameters(node, params) {
        if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
          node.params = params;
        } else {
          super.setArrowFunctionParameters(node, params);
        }
      }
      checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
        if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
          return;
        }
        for (let i = 0; i < node.params.length; i++) {
          if (this.isThisParam(node.params[i]) && i > 0) {
            this.raise(FlowErrors.ThisParamMustBeFirst, node.params[i]);
          }
        }
        super.checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged);
      }
      parseParenAndDistinguishExpression(canBeArrow) {
        return super.parseParenAndDistinguishExpression(canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);
      }
      parseSubscripts(base, startLoc, noCalls) {
        if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.indexOf(startLoc.index) !== -1) {
          this.next();
          const node = this.startNodeAt(startLoc);
          node.callee = base;
          node.arguments = super.parseCallExpressionArguments(11, false);
          base = this.finishNode(node, "CallExpression");
        } else if (base.type === "Identifier" && base.name === "async" && this.match(47)) {
          const state = this.state.clone();
          const arrow = this.tryParse((abort) => this.parseAsyncArrowWithTypeParameters(startLoc) || abort(), state);
          if (!arrow.error && !arrow.aborted)
            return arrow.node;
          const result = this.tryParse(() => super.parseSubscripts(base, startLoc, noCalls), state);
          if (result.node && !result.error)
            return result.node;
          if (arrow.node) {
            this.state = arrow.failState;
            return arrow.node;
          }
          if (result.node) {
            this.state = result.failState;
            return result.node;
          }
          throw arrow.error || result.error;
        }
        return super.parseSubscripts(base, startLoc, noCalls);
      }
      parseSubscript(base, startLoc, noCalls, subscriptState) {
        if (this.match(18) && this.isLookaheadToken_lt()) {
          subscriptState.optionalChainMember = true;
          if (noCalls) {
            subscriptState.stop = true;
            return base;
          }
          this.next();
          const node = this.startNodeAt(startLoc);
          node.callee = base;
          node.typeArguments = this.flowParseTypeParameterInstantiation();
          this.expect(10);
          node.arguments = this.parseCallExpressionArguments(11, false);
          node.optional = true;
          return this.finishCallExpression(node, true);
        } else if (!noCalls && this.shouldParseTypes() && this.match(47)) {
          const node = this.startNodeAt(startLoc);
          node.callee = base;
          const result = this.tryParse(() => {
            node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();
            this.expect(10);
            node.arguments = super.parseCallExpressionArguments(11, false);
            if (subscriptState.optionalChainMember) {
              node.optional = false;
            }
            return this.finishCallExpression(node, subscriptState.optionalChainMember);
          });
          if (result.node) {
            if (result.error)
              this.state = result.failState;
            return result.node;
          }
        }
        return super.parseSubscript(base, startLoc, noCalls, subscriptState);
      }
      parseNewCallee(node) {
        super.parseNewCallee(node);
        let targs = null;
        if (this.shouldParseTypes() && this.match(47)) {
          targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;
        }
        node.typeArguments = targs;
      }
      parseAsyncArrowWithTypeParameters(startLoc) {
        const node = this.startNodeAt(startLoc);
        this.parseFunctionParams(node, false);
        if (!this.parseArrow(node))
          return;
        return super.parseArrowExpression(node, void 0, true);
      }
      readToken_mult_modulo(code2) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (code2 === 42 && next === 47 && this.state.hasFlowComment) {
          this.state.hasFlowComment = false;
          this.state.pos += 2;
          this.nextToken();
          return;
        }
        super.readToken_mult_modulo(code2);
      }
      readToken_pipe_amp(code2) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (code2 === 124 && next === 125) {
          this.finishOp(9, 2);
          return;
        }
        super.readToken_pipe_amp(code2);
      }
      parseTopLevel(file, program) {
        const fileNode = super.parseTopLevel(file, program);
        if (this.state.hasFlowComment) {
          this.raise(FlowErrors.UnterminatedFlowComment, this.state.curPosition());
        }
        return fileNode;
      }
      skipBlockComment() {
        if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
          if (this.state.hasFlowComment) {
            throw this.raise(FlowErrors.NestedFlowComment, this.state.startLoc);
          }
          this.hasFlowCommentCompletion();
          const commentSkip = this.skipFlowComment();
          if (commentSkip) {
            this.state.pos += commentSkip;
            this.state.hasFlowComment = true;
          }
          return;
        }
        return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
      }
      skipFlowComment() {
        const {
          pos
        } = this.state;
        let shiftToFirstNonWhiteSpace = 2;
        while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {
          shiftToFirstNonWhiteSpace++;
        }
        const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
        const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);
        if (ch2 === 58 && ch3 === 58) {
          return shiftToFirstNonWhiteSpace + 2;
        }
        if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
          return shiftToFirstNonWhiteSpace + 12;
        }
        if (ch2 === 58 && ch3 !== 58) {
          return shiftToFirstNonWhiteSpace;
        }
        return false;
      }
      hasFlowCommentCompletion() {
        const end = this.input.indexOf("*/", this.state.pos);
        if (end === -1) {
          throw this.raise(Errors.UnterminatedComment, this.state.curPosition());
        }
      }
      flowEnumErrorBooleanMemberNotInitialized(loc, {
        enumName,
        memberName
      }) {
        this.raise(FlowErrors.EnumBooleanMemberNotInitialized, loc, {
          memberName,
          enumName
        });
      }
      flowEnumErrorInvalidMemberInitializer(loc, enumContext) {
        return this.raise(!enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerUnknownType : enumContext.explicitType === "symbol" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType, loc, enumContext);
      }
      flowEnumErrorNumberMemberNotInitialized(loc, details) {
        this.raise(FlowErrors.EnumNumberMemberNotInitialized, loc, details);
      }
      flowEnumErrorStringMemberInconsistentlyInitialized(node, details) {
        this.raise(FlowErrors.EnumStringMemberInconsistentlyInitialized, node, details);
      }
      flowEnumMemberInit() {
        const startLoc = this.state.startLoc;
        const endOfInit = () => this.match(12) || this.match(8);
        switch (this.state.type) {
          case 134: {
            const literal = this.parseNumericLiteral(this.state.value);
            if (endOfInit()) {
              return {
                type: "number",
                loc: literal.loc.start,
                value: literal
              };
            }
            return {
              type: "invalid",
              loc: startLoc
            };
          }
          case 133: {
            const literal = this.parseStringLiteral(this.state.value);
            if (endOfInit()) {
              return {
                type: "string",
                loc: literal.loc.start,
                value: literal
              };
            }
            return {
              type: "invalid",
              loc: startLoc
            };
          }
          case 85:
          case 86: {
            const literal = this.parseBooleanLiteral(this.match(85));
            if (endOfInit()) {
              return {
                type: "boolean",
                loc: literal.loc.start,
                value: literal
              };
            }
            return {
              type: "invalid",
              loc: startLoc
            };
          }
          default:
            return {
              type: "invalid",
              loc: startLoc
            };
        }
      }
      flowEnumMemberRaw() {
        const loc = this.state.startLoc;
        const id = this.parseIdentifier(true);
        const init = this.eat(29) ? this.flowEnumMemberInit() : {
          type: "none",
          loc
        };
        return {
          id,
          init
        };
      }
      flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {
        const {
          explicitType
        } = context;
        if (explicitType === null) {
          return;
        }
        if (explicitType !== expectedType) {
          this.flowEnumErrorInvalidMemberInitializer(loc, context);
        }
      }
      flowEnumMembers({
        enumName,
        explicitType
      }) {
        const seenNames = /* @__PURE__ */ new Set();
        const members = {
          booleanMembers: [],
          numberMembers: [],
          stringMembers: [],
          defaultedMembers: []
        };
        let hasUnknownMembers = false;
        while (!this.match(8)) {
          if (this.eat(21)) {
            hasUnknownMembers = true;
            break;
          }
          const memberNode = this.startNode();
          const {
            id,
            init
          } = this.flowEnumMemberRaw();
          const memberName = id.name;
          if (memberName === "") {
            continue;
          }
          if (/^[a-z]/.test(memberName)) {
            this.raise(FlowErrors.EnumInvalidMemberName, id, {
              memberName,
              suggestion: memberName[0].toUpperCase() + memberName.slice(1),
              enumName
            });
          }
          if (seenNames.has(memberName)) {
            this.raise(FlowErrors.EnumDuplicateMemberName, id, {
              memberName,
              enumName
            });
          }
          seenNames.add(memberName);
          const context = {
            enumName,
            explicitType,
            memberName
          };
          memberNode.id = id;
          switch (init.type) {
            case "boolean": {
              this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "boolean");
              memberNode.init = init.value;
              members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
              break;
            }
            case "number": {
              this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "number");
              memberNode.init = init.value;
              members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
              break;
            }
            case "string": {
              this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "string");
              memberNode.init = init.value;
              members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
              break;
            }
            case "invalid": {
              throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);
            }
            case "none": {
              switch (explicitType) {
                case "boolean":
                  this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);
                  break;
                case "number":
                  this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);
                  break;
                default:
                  members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
              }
            }
          }
          if (!this.match(8)) {
            this.expect(12);
          }
        }
        return {
          members,
          hasUnknownMembers
        };
      }
      flowEnumStringMembers(initializedMembers, defaultedMembers, {
        enumName
      }) {
        if (initializedMembers.length === 0) {
          return defaultedMembers;
        } else if (defaultedMembers.length === 0) {
          return initializedMembers;
        } else if (defaultedMembers.length > initializedMembers.length) {
          for (const member of initializedMembers) {
            this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {
              enumName
            });
          }
          return defaultedMembers;
        } else {
          for (const member of defaultedMembers) {
            this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {
              enumName
            });
          }
          return initializedMembers;
        }
      }
      flowEnumParseExplicitType({
        enumName
      }) {
        if (!this.eatContextual(102))
          return null;
        if (!tokenIsIdentifier(this.state.type)) {
          throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
            enumName
          });
        }
        const {
          value
        } = this.state;
        this.next();
        if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") {
          this.raise(FlowErrors.EnumInvalidExplicitType, this.state.startLoc, {
            enumName,
            invalidEnumType: value
          });
        }
        return value;
      }
      flowEnumBody(node, id) {
        const enumName = id.name;
        const nameLoc = id.loc.start;
        const explicitType = this.flowEnumParseExplicitType({
          enumName
        });
        this.expect(5);
        const {
          members,
          hasUnknownMembers
        } = this.flowEnumMembers({
          enumName,
          explicitType
        });
        node.hasUnknownMembers = hasUnknownMembers;
        switch (explicitType) {
          case "boolean":
            node.explicitType = true;
            node.members = members.booleanMembers;
            this.expect(8);
            return this.finishNode(node, "EnumBooleanBody");
          case "number":
            node.explicitType = true;
            node.members = members.numberMembers;
            this.expect(8);
            return this.finishNode(node, "EnumNumberBody");
          case "string":
            node.explicitType = true;
            node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
              enumName
            });
            this.expect(8);
            return this.finishNode(node, "EnumStringBody");
          case "symbol":
            node.members = members.defaultedMembers;
            this.expect(8);
            return this.finishNode(node, "EnumSymbolBody");
          default: {
            const empty = () => {
              node.members = [];
              this.expect(8);
              return this.finishNode(node, "EnumStringBody");
            };
            node.explicitType = false;
            const boolsLen = members.booleanMembers.length;
            const numsLen = members.numberMembers.length;
            const strsLen = members.stringMembers.length;
            const defaultedLen = members.defaultedMembers.length;
            if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
              return empty();
            } else if (!boolsLen && !numsLen) {
              node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                enumName
              });
              this.expect(8);
              return this.finishNode(node, "EnumStringBody");
            } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
              for (const member of members.defaultedMembers) {
                this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {
                  enumName,
                  memberName: member.id.name
                });
              }
              node.members = members.booleanMembers;
              this.expect(8);
              return this.finishNode(node, "EnumBooleanBody");
            } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
              for (const member of members.defaultedMembers) {
                this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {
                  enumName,
                  memberName: member.id.name
                });
              }
              node.members = members.numberMembers;
              this.expect(8);
              return this.finishNode(node, "EnumNumberBody");
            } else {
              this.raise(FlowErrors.EnumInconsistentMemberValues, nameLoc, {
                enumName
              });
              return empty();
            }
          }
        }
      }
      flowParseEnumDeclaration(node) {
        const id = this.parseIdentifier();
        node.id = id;
        node.body = this.flowEnumBody(this.startNode(), id);
        return this.finishNode(node, "EnumDeclaration");
      }
      isLookaheadToken_lt() {
        const next = this.nextTokenStart();
        if (this.input.charCodeAt(next) === 60) {
          const afterNext = this.input.charCodeAt(next + 1);
          return afterNext !== 60 && afterNext !== 61;
        }
        return false;
      }
      maybeUnwrapTypeCastExpression(node) {
        return node.type === "TypeCastExpression" ? node.expression : node;
      }
    };
    var entities = {
      __proto__: null,
      quot: '"',
      amp: "&",
      apos: "'",
      lt: "<",
      gt: ">",
      nbsp: "\xA0",
      iexcl: "\xA1",
      cent: "\xA2",
      pound: "\xA3",
      curren: "\xA4",
      yen: "\xA5",
      brvbar: "\xA6",
      sect: "\xA7",
      uml: "\xA8",
      copy: "\xA9",
      ordf: "\xAA",
      laquo: "\xAB",
      not: "\xAC",
      shy: "\xAD",
      reg: "\xAE",
      macr: "\xAF",
      deg: "\xB0",
      plusmn: "\xB1",
      sup2: "\xB2",
      sup3: "\xB3",
      acute: "\xB4",
      micro: "\xB5",
      para: "\xB6",
      middot: "\xB7",
      cedil: "\xB8",
      sup1: "\xB9",
      ordm: "\xBA",
      raquo: "\xBB",
      frac14: "\xBC",
      frac12: "\xBD",
      frac34: "\xBE",
      iquest: "\xBF",
      Agrave: "\xC0",
      Aacute: "\xC1",
      Acirc: "\xC2",
      Atilde: "\xC3",
      Auml: "\xC4",
      Aring: "\xC5",
      AElig: "\xC6",
      Ccedil: "\xC7",
      Egrave: "\xC8",
      Eacute: "\xC9",
      Ecirc: "\xCA",
      Euml: "\xCB",
      Igrave: "\xCC",
      Iacute: "\xCD",
      Icirc: "\xCE",
      Iuml: "\xCF",
      ETH: "\xD0",
      Ntilde: "\xD1",
      Ograve: "\xD2",
      Oacute: "\xD3",
      Ocirc: "\xD4",
      Otilde: "\xD5",
      Ouml: "\xD6",
      times: "\xD7",
      Oslash: "\xD8",
      Ugrave: "\xD9",
      Uacute: "\xDA",
      Ucirc: "\xDB",
      Uuml: "\xDC",
      Yacute: "\xDD",
      THORN: "\xDE",
      szlig: "\xDF",
      agrave: "\xE0",
      aacute: "\xE1",
      acirc: "\xE2",
      atilde: "\xE3",
      auml: "\xE4",
      aring: "\xE5",
      aelig: "\xE6",
      ccedil: "\xE7",
      egrave: "\xE8",
      eacute: "\xE9",
      ecirc: "\xEA",
      euml: "\xEB",
      igrave: "\xEC",
      iacute: "\xED",
      icirc: "\xEE",
      iuml: "\xEF",
      eth: "\xF0",
      ntilde: "\xF1",
      ograve: "\xF2",
      oacute: "\xF3",
      ocirc: "\xF4",
      otilde: "\xF5",
      ouml: "\xF6",
      divide: "\xF7",
      oslash: "\xF8",
      ugrave: "\xF9",
      uacute: "\xFA",
      ucirc: "\xFB",
      uuml: "\xFC",
      yacute: "\xFD",
      thorn: "\xFE",
      yuml: "\xFF",
      OElig: "\u0152",
      oelig: "\u0153",
      Scaron: "\u0160",
      scaron: "\u0161",
      Yuml: "\u0178",
      fnof: "\u0192",
      circ: "\u02C6",
      tilde: "\u02DC",
      Alpha: "\u0391",
      Beta: "\u0392",
      Gamma: "\u0393",
      Delta: "\u0394",
      Epsilon: "\u0395",
      Zeta: "\u0396",
      Eta: "\u0397",
      Theta: "\u0398",
      Iota: "\u0399",
      Kappa: "\u039A",
      Lambda: "\u039B",
      Mu: "\u039C",
      Nu: "\u039D",
      Xi: "\u039E",
      Omicron: "\u039F",
      Pi: "\u03A0",
      Rho: "\u03A1",
      Sigma: "\u03A3",
      Tau: "\u03A4",
      Upsilon: "\u03A5",
      Phi: "\u03A6",
      Chi: "\u03A7",
      Psi: "\u03A8",
      Omega: "\u03A9",
      alpha: "\u03B1",
      beta: "\u03B2",
      gamma: "\u03B3",
      delta: "\u03B4",
      epsilon: "\u03B5",
      zeta: "\u03B6",
      eta: "\u03B7",
      theta: "\u03B8",
      iota: "\u03B9",
      kappa: "\u03BA",
      lambda: "\u03BB",
      mu: "\u03BC",
      nu: "\u03BD",
      xi: "\u03BE",
      omicron: "\u03BF",
      pi: "\u03C0",
      rho: "\u03C1",
      sigmaf: "\u03C2",
      sigma: "\u03C3",
      tau: "\u03C4",
      upsilon: "\u03C5",
      phi: "\u03C6",
      chi: "\u03C7",
      psi: "\u03C8",
      omega: "\u03C9",
      thetasym: "\u03D1",
      upsih: "\u03D2",
      piv: "\u03D6",
      ensp: "\u2002",
      emsp: "\u2003",
      thinsp: "\u2009",
      zwnj: "\u200C",
      zwj: "\u200D",
      lrm: "\u200E",
      rlm: "\u200F",
      ndash: "\u2013",
      mdash: "\u2014",
      lsquo: "\u2018",
      rsquo: "\u2019",
      sbquo: "\u201A",
      ldquo: "\u201C",
      rdquo: "\u201D",
      bdquo: "\u201E",
      dagger: "\u2020",
      Dagger: "\u2021",
      bull: "\u2022",
      hellip: "\u2026",
      permil: "\u2030",
      prime: "\u2032",
      Prime: "\u2033",
      lsaquo: "\u2039",
      rsaquo: "\u203A",
      oline: "\u203E",
      frasl: "\u2044",
      euro: "\u20AC",
      image: "\u2111",
      weierp: "\u2118",
      real: "\u211C",
      trade: "\u2122",
      alefsym: "\u2135",
      larr: "\u2190",
      uarr: "\u2191",
      rarr: "\u2192",
      darr: "\u2193",
      harr: "\u2194",
      crarr: "\u21B5",
      lArr: "\u21D0",
      uArr: "\u21D1",
      rArr: "\u21D2",
      dArr: "\u21D3",
      hArr: "\u21D4",
      forall: "\u2200",
      part: "\u2202",
      exist: "\u2203",
      empty: "\u2205",
      nabla: "\u2207",
      isin: "\u2208",
      notin: "\u2209",
      ni: "\u220B",
      prod: "\u220F",
      sum: "\u2211",
      minus: "\u2212",
      lowast: "\u2217",
      radic: "\u221A",
      prop: "\u221D",
      infin: "\u221E",
      ang: "\u2220",
      and: "\u2227",
      or: "\u2228",
      cap: "\u2229",
      cup: "\u222A",
      int: "\u222B",
      there4: "\u2234",
      sim: "\u223C",
      cong: "\u2245",
      asymp: "\u2248",
      ne: "\u2260",
      equiv: "\u2261",
      le: "\u2264",
      ge: "\u2265",
      sub: "\u2282",
      sup: "\u2283",
      nsub: "\u2284",
      sube: "\u2286",
      supe: "\u2287",
      oplus: "\u2295",
      otimes: "\u2297",
      perp: "\u22A5",
      sdot: "\u22C5",
      lceil: "\u2308",
      rceil: "\u2309",
      lfloor: "\u230A",
      rfloor: "\u230B",
      lang: "\u2329",
      rang: "\u232A",
      loz: "\u25CA",
      spades: "\u2660",
      clubs: "\u2663",
      hearts: "\u2665",
      diams: "\u2666"
    };
    var JsxErrors = ParseErrorEnum`jsx`({
      AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
      MissingClosingTagElement: ({
        openingTagName
      }) => `Expected corresponding JSX closing tag for <${openingTagName}>.`,
      MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
      UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
      UnexpectedToken: ({
        unexpected,
        HTMLEntity
      }) => `Unexpected token \`${unexpected}\`. Did you mean \`${HTMLEntity}\` or \`{'${unexpected}'}\`?`,
      UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
      UnterminatedJsxContent: "Unterminated JSX contents.",
      UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
    });
    function isFragment(object) {
      return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
    }
    function getQualifiedJSXName(object) {
      if (object.type === "JSXIdentifier") {
        return object.name;
      }
      if (object.type === "JSXNamespacedName") {
        return object.namespace.name + ":" + object.name.name;
      }
      if (object.type === "JSXMemberExpression") {
        return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
      }
      throw new Error("Node had unexpected type: " + object.type);
    }
    var jsx = (superClass) => class JSXParserMixin extends superClass {
      jsxReadToken() {
        let out = "";
        let chunkStart = this.state.pos;
        for (; ; ) {
          if (this.state.pos >= this.length) {
            throw this.raise(JsxErrors.UnterminatedJsxContent, this.state.startLoc);
          }
          const ch = this.input.charCodeAt(this.state.pos);
          switch (ch) {
            case 60:
            case 123:
              if (this.state.pos === this.state.start) {
                if (ch === 60 && this.state.canStartJSXElement) {
                  ++this.state.pos;
                  this.finishToken(142);
                } else {
                  super.getTokenFromCode(ch);
                }
                return;
              }
              out += this.input.slice(chunkStart, this.state.pos);
              this.finishToken(141, out);
              return;
            case 38:
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadEntity();
              chunkStart = this.state.pos;
              break;
            case 62:
            case 125:
            default:
              if (isNewLine(ch)) {
                out += this.input.slice(chunkStart, this.state.pos);
                out += this.jsxReadNewLine(true);
                chunkStart = this.state.pos;
              } else {
                ++this.state.pos;
              }
          }
        }
      }
      jsxReadNewLine(normalizeCRLF) {
        const ch = this.input.charCodeAt(this.state.pos);
        let out;
        ++this.state.pos;
        if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
          ++this.state.pos;
          out = normalizeCRLF ? "\n" : "\r\n";
        } else {
          out = String.fromCharCode(ch);
        }
        ++this.state.curLine;
        this.state.lineStart = this.state.pos;
        return out;
      }
      jsxReadString(quote) {
        let out = "";
        let chunkStart = ++this.state.pos;
        for (; ; ) {
          if (this.state.pos >= this.length) {
            throw this.raise(Errors.UnterminatedString, this.state.startLoc);
          }
          const ch = this.input.charCodeAt(this.state.pos);
          if (ch === quote)
            break;
          if (ch === 38) {
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadEntity();
            chunkStart = this.state.pos;
          } else if (isNewLine(ch)) {
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadNewLine(false);
            chunkStart = this.state.pos;
          } else {
            ++this.state.pos;
          }
        }
        out += this.input.slice(chunkStart, this.state.pos++);
        this.finishToken(133, out);
      }
      jsxReadEntity() {
        const startPos = ++this.state.pos;
        if (this.codePointAtPos(this.state.pos) === 35) {
          ++this.state.pos;
          let radix = 10;
          if (this.codePointAtPos(this.state.pos) === 120) {
            radix = 16;
            ++this.state.pos;
          }
          const codePoint = this.readInt(radix, void 0, false, "bail");
          if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {
            ++this.state.pos;
            return String.fromCodePoint(codePoint);
          }
        } else {
          let count = 0;
          let semi = false;
          while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) === 59)) {
            ++this.state.pos;
          }
          if (semi) {
            const desc = this.input.slice(startPos, this.state.pos);
            const entity = entities[desc];
            ++this.state.pos;
            if (entity) {
              return entity;
            }
          }
        }
        this.state.pos = startPos;
        return "&";
      }
      jsxReadWord() {
        let ch;
        const start = this.state.pos;
        do {
          ch = this.input.charCodeAt(++this.state.pos);
        } while (isIdentifierChar(ch) || ch === 45);
        this.finishToken(140, this.input.slice(start, this.state.pos));
      }
      jsxParseIdentifier() {
        const node = this.startNode();
        if (this.match(140)) {
          node.name = this.state.value;
        } else if (tokenIsKeyword(this.state.type)) {
          node.name = tokenLabelName(this.state.type);
        } else {
          this.unexpected();
        }
        this.next();
        return this.finishNode(node, "JSXIdentifier");
      }
      jsxParseNamespacedName() {
        const startLoc = this.state.startLoc;
        const name = this.jsxParseIdentifier();
        if (!this.eat(14))
          return name;
        const node = this.startNodeAt(startLoc);
        node.namespace = name;
        node.name = this.jsxParseIdentifier();
        return this.finishNode(node, "JSXNamespacedName");
      }
      jsxParseElementName() {
        const startLoc = this.state.startLoc;
        let node = this.jsxParseNamespacedName();
        if (node.type === "JSXNamespacedName") {
          return node;
        }
        while (this.eat(16)) {
          const newNode = this.startNodeAt(startLoc);
          newNode.object = node;
          newNode.property = this.jsxParseIdentifier();
          node = this.finishNode(newNode, "JSXMemberExpression");
        }
        return node;
      }
      jsxParseAttributeValue() {
        let node;
        switch (this.state.type) {
          case 5:
            node = this.startNode();
            this.setContext(types.brace);
            this.next();
            node = this.jsxParseExpressionContainer(node, types.j_oTag);
            if (node.expression.type === "JSXEmptyExpression") {
              this.raise(JsxErrors.AttributeIsEmpty, node);
            }
            return node;
          case 142:
          case 133:
            return this.parseExprAtom();
          default:
            throw this.raise(JsxErrors.UnsupportedJsxValue, this.state.startLoc);
        }
      }
      jsxParseEmptyExpression() {
        const node = this.startNodeAt(this.state.lastTokEndLoc);
        return this.finishNodeAt(node, "JSXEmptyExpression", this.state.startLoc);
      }
      jsxParseSpreadChild(node) {
        this.next();
        node.expression = this.parseExpression();
        this.setContext(types.j_expr);
        this.state.canStartJSXElement = true;
        this.expect(8);
        return this.finishNode(node, "JSXSpreadChild");
      }
      jsxParseExpressionContainer(node, previousContext) {
        if (this.match(8)) {
          node.expression = this.jsxParseEmptyExpression();
        } else {
          const expression = this.parseExpression();
          node.expression = expression;
        }
        this.setContext(previousContext);
        this.state.canStartJSXElement = true;
        this.expect(8);
        return this.finishNode(node, "JSXExpressionContainer");
      }
      jsxParseAttribute() {
        const node = this.startNode();
        if (this.match(5)) {
          this.setContext(types.brace);
          this.next();
          this.expect(21);
          node.argument = this.parseMaybeAssignAllowIn();
          this.setContext(types.j_oTag);
          this.state.canStartJSXElement = true;
          this.expect(8);
          return this.finishNode(node, "JSXSpreadAttribute");
        }
        node.name = this.jsxParseNamespacedName();
        node.value = this.eat(29) ? this.jsxParseAttributeValue() : null;
        return this.finishNode(node, "JSXAttribute");
      }
      jsxParseOpeningElementAt(startLoc) {
        const node = this.startNodeAt(startLoc);
        if (this.eat(143)) {
          return this.finishNode(node, "JSXOpeningFragment");
        }
        node.name = this.jsxParseElementName();
        return this.jsxParseOpeningElementAfterName(node);
      }
      jsxParseOpeningElementAfterName(node) {
        const attributes = [];
        while (!this.match(56) && !this.match(143)) {
          attributes.push(this.jsxParseAttribute());
        }
        node.attributes = attributes;
        node.selfClosing = this.eat(56);
        this.expect(143);
        return this.finishNode(node, "JSXOpeningElement");
      }
      jsxParseClosingElementAt(startLoc) {
        const node = this.startNodeAt(startLoc);
        if (this.eat(143)) {
          return this.finishNode(node, "JSXClosingFragment");
        }
        node.name = this.jsxParseElementName();
        this.expect(143);
        return this.finishNode(node, "JSXClosingElement");
      }
      jsxParseElementAt(startLoc) {
        const node = this.startNodeAt(startLoc);
        const children = [];
        const openingElement = this.jsxParseOpeningElementAt(startLoc);
        let closingElement = null;
        if (!openingElement.selfClosing) {
          contents:
            for (; ; ) {
              switch (this.state.type) {
                case 142:
                  startLoc = this.state.startLoc;
                  this.next();
                  if (this.eat(56)) {
                    closingElement = this.jsxParseClosingElementAt(startLoc);
                    break contents;
                  }
                  children.push(this.jsxParseElementAt(startLoc));
                  break;
                case 141:
                  children.push(this.parseLiteral(this.state.value, "JSXText"));
                  break;
                case 5: {
                  const node2 = this.startNode();
                  this.setContext(types.brace);
                  this.next();
                  if (this.match(21)) {
                    children.push(this.jsxParseSpreadChild(node2));
                  } else {
                    children.push(this.jsxParseExpressionContainer(node2, types.j_expr));
                  }
                  break;
                }
                default:
                  this.unexpected();
              }
            }
          if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {
            this.raise(JsxErrors.MissingClosingTagFragment, closingElement);
          } else if (!isFragment(openingElement) && isFragment(closingElement)) {
            this.raise(JsxErrors.MissingClosingTagElement, closingElement, {
              openingTagName: getQualifiedJSXName(openingElement.name)
            });
          } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
            if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
              this.raise(JsxErrors.MissingClosingTagElement, closingElement, {
                openingTagName: getQualifiedJSXName(openingElement.name)
              });
            }
          }
        }
        if (isFragment(openingElement)) {
          node.openingFragment = openingElement;
          node.closingFragment = closingElement;
        } else {
          node.openingElement = openingElement;
          node.closingElement = closingElement;
        }
        node.children = children;
        if (this.match(47)) {
          throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, this.state.startLoc);
        }
        return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
      }
      jsxParseElement() {
        const startLoc = this.state.startLoc;
        this.next();
        return this.jsxParseElementAt(startLoc);
      }
      setContext(newContext) {
        const {
          context
        } = this.state;
        context[context.length - 1] = newContext;
      }
      parseExprAtom(refExpressionErrors) {
        if (this.match(142)) {
          return this.jsxParseElement();
        } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {
          this.replaceToken(142);
          return this.jsxParseElement();
        } else {
          return super.parseExprAtom(refExpressionErrors);
        }
      }
      skipSpace() {
        const curContext = this.curContext();
        if (!curContext.preserveSpace)
          super.skipSpace();
      }
      getTokenFromCode(code2) {
        const context = this.curContext();
        if (context === types.j_expr) {
          this.jsxReadToken();
          return;
        }
        if (context === types.j_oTag || context === types.j_cTag) {
          if (isIdentifierStart(code2)) {
            this.jsxReadWord();
            return;
          }
          if (code2 === 62) {
            ++this.state.pos;
            this.finishToken(143);
            return;
          }
          if ((code2 === 34 || code2 === 39) && context === types.j_oTag) {
            this.jsxReadString(code2);
            return;
          }
        }
        if (code2 === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
          ++this.state.pos;
          this.finishToken(142);
          return;
        }
        super.getTokenFromCode(code2);
      }
      updateContext(prevType) {
        const {
          context,
          type
        } = this.state;
        if (type === 56 && prevType === 142) {
          context.splice(-2, 2, types.j_cTag);
          this.state.canStartJSXElement = false;
        } else if (type === 142) {
          context.push(types.j_oTag);
        } else if (type === 143) {
          const out = context[context.length - 1];
          if (out === types.j_oTag && prevType === 56 || out === types.j_cTag) {
            context.pop();
            this.state.canStartJSXElement = context[context.length - 1] === types.j_expr;
          } else {
            this.setContext(types.j_expr);
            this.state.canStartJSXElement = true;
          }
        } else {
          this.state.canStartJSXElement = tokenComesBeforeExpression(type);
        }
      }
    };
    var TypeScriptScope = class extends Scope {
      constructor(...args) {
        super(...args);
        this.tsNames = /* @__PURE__ */ new Map();
      }
    };
    var TypeScriptScopeHandler = class extends ScopeHandler {
      constructor(...args) {
        super(...args);
        this.importsStack = [];
      }
      createScope(flags) {
        this.importsStack.push(/* @__PURE__ */ new Set());
        return new TypeScriptScope(flags);
      }
      enter(flags) {
        if (flags === 256) {
          this.importsStack.push(/* @__PURE__ */ new Set());
        }
        super.enter(flags);
      }
      exit() {
        const flags = super.exit();
        if (flags === 256) {
          this.importsStack.pop();
        }
        return flags;
      }
      hasImport(name, allowShadow) {
        const len = this.importsStack.length;
        if (this.importsStack[len - 1].has(name)) {
          return true;
        }
        if (!allowShadow && len > 1) {
          for (let i = 0; i < len - 1; i++) {
            if (this.importsStack[i].has(name))
              return true;
          }
        }
        return false;
      }
      declareName(name, bindingType, loc) {
        if (bindingType & 4096) {
          if (this.hasImport(name, true)) {
            this.parser.raise(Errors.VarRedeclaration, loc, {
              identifierName: name
            });
          }
          this.importsStack[this.importsStack.length - 1].add(name);
          return;
        }
        const scope = this.currentScope();
        let type = scope.tsNames.get(name) || 0;
        if (bindingType & 1024) {
          this.maybeExportDefined(scope, name);
          scope.tsNames.set(name, type | 16);
          return;
        }
        super.declareName(name, bindingType, loc);
        if (bindingType & 2) {
          if (!(bindingType & 1)) {
            this.checkRedeclarationInScope(scope, name, bindingType, loc);
            this.maybeExportDefined(scope, name);
          }
          type = type | 1;
        }
        if (bindingType & 256) {
          type = type | 2;
        }
        if (bindingType & 512) {
          type = type | 4;
        }
        if (bindingType & 128) {
          type = type | 8;
        }
        if (type)
          scope.tsNames.set(name, type);
      }
      isRedeclaredInScope(scope, name, bindingType) {
        const type = scope.tsNames.get(name);
        if ((type & 2) > 0) {
          if (bindingType & 256) {
            const isConst = !!(bindingType & 512);
            const wasConst = (type & 4) > 0;
            return isConst !== wasConst;
          }
          return true;
        }
        if (bindingType & 128 && (type & 8) > 0) {
          if (scope.names.get(name) & 2) {
            return !!(bindingType & 1);
          } else {
            return false;
          }
        }
        if (bindingType & 2 && (type & 1) > 0) {
          return true;
        }
        return super.isRedeclaredInScope(scope, name, bindingType);
      }
      checkLocalExport(id) {
        const {
          name
        } = id;
        if (this.hasImport(name))
          return;
        const len = this.scopeStack.length;
        for (let i = len - 1; i >= 0; i--) {
          const scope = this.scopeStack[i];
          const type = scope.tsNames.get(name);
          if ((type & 1) > 0 || (type & 16) > 0) {
            return;
          }
        }
        super.checkLocalExport(id);
      }
    };
    var getOwn$1 = (object, key) => hasOwnProperty.call(object, key) && object[key];
    var unwrapParenthesizedExpression = (node) => {
      return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
    };
    var LValParser = class extends NodeUtils {
      toAssignable(node, isLHS = false) {
        var _node$extra, _node$extra3;
        let parenthesized = void 0;
        if (node.type === "ParenthesizedExpression" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {
          parenthesized = unwrapParenthesizedExpression(node);
          if (isLHS) {
            if (parenthesized.type === "Identifier") {
              this.expressionScope.recordArrowParameterBindingError(Errors.InvalidParenthesizedAssignment, node);
            } else if (parenthesized.type !== "MemberExpression" && !this.isOptionalMemberExpression(parenthesized)) {
              this.raise(Errors.InvalidParenthesizedAssignment, node);
            }
          } else {
            this.raise(Errors.InvalidParenthesizedAssignment, node);
          }
        }
        switch (node.type) {
          case "Identifier":
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
            break;
          case "ObjectExpression":
            node.type = "ObjectPattern";
            for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {
              var _node$extra2;
              const prop = node.properties[i];
              const isLast = i === last;
              this.toAssignableObjectExpressionProp(prop, isLast, isLHS);
              if (isLast && prop.type === "RestElement" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc) {
                this.raise(Errors.RestTrailingComma, node.extra.trailingCommaLoc);
              }
            }
            break;
          case "ObjectProperty": {
            const {
              key,
              value
            } = node;
            if (this.isPrivateName(key)) {
              this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
            }
            this.toAssignable(value, isLHS);
            break;
          }
          case "SpreadElement": {
            throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
          }
          case "ArrayExpression":
            node.type = "ArrayPattern";
            this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);
            break;
          case "AssignmentExpression":
            if (node.operator !== "=") {
              this.raise(Errors.MissingEqInAssignment, node.left.loc.end);
            }
            node.type = "AssignmentPattern";
            delete node.operator;
            this.toAssignable(node.left, isLHS);
            break;
          case "ParenthesizedExpression":
            this.toAssignable(parenthesized, isLHS);
            break;
        }
      }
      toAssignableObjectExpressionProp(prop, isLast, isLHS) {
        if (prop.type === "ObjectMethod") {
          this.raise(prop.kind === "get" || prop.kind === "set" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, prop.key);
        } else if (prop.type === "SpreadElement") {
          prop.type = "RestElement";
          const arg = prop.argument;
          this.checkToRestConversion(arg, false);
          this.toAssignable(arg, isLHS);
          if (!isLast) {
            this.raise(Errors.RestTrailingComma, prop);
          }
        } else {
          this.toAssignable(prop, isLHS);
        }
      }
      toAssignableList(exprList, trailingCommaLoc, isLHS) {
        const end = exprList.length - 1;
        for (let i = 0; i <= end; i++) {
          const elt = exprList[i];
          if (!elt)
            continue;
          if (elt.type === "SpreadElement") {
            elt.type = "RestElement";
            const arg = elt.argument;
            this.checkToRestConversion(arg, true);
            this.toAssignable(arg, isLHS);
          } else {
            this.toAssignable(elt, isLHS);
          }
          if (elt.type === "RestElement") {
            if (i < end) {
              this.raise(Errors.RestTrailingComma, elt);
            } else if (trailingCommaLoc) {
              this.raise(Errors.RestTrailingComma, trailingCommaLoc);
            }
          }
        }
      }
      isAssignable(node, isBinding) {
        switch (node.type) {
          case "Identifier":
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
            return true;
          case "ObjectExpression": {
            const last = node.properties.length - 1;
            return node.properties.every((prop, i) => {
              return prop.type !== "ObjectMethod" && (i === last || prop.type !== "SpreadElement") && this.isAssignable(prop);
            });
          }
          case "ObjectProperty":
            return this.isAssignable(node.value);
          case "SpreadElement":
            return this.isAssignable(node.argument);
          case "ArrayExpression":
            return node.elements.every((element) => element === null || this.isAssignable(element));
          case "AssignmentExpression":
            return node.operator === "=";
          case "ParenthesizedExpression":
            return this.isAssignable(node.expression);
          case "MemberExpression":
          case "OptionalMemberExpression":
            return !isBinding;
          default:
            return false;
        }
      }
      toReferencedList(exprList, isParenthesizedExpr) {
        return exprList;
      }
      toReferencedListDeep(exprList, isParenthesizedExpr) {
        this.toReferencedList(exprList, isParenthesizedExpr);
        for (const expr of exprList) {
          if ((expr == null ? void 0 : expr.type) === "ArrayExpression") {
            this.toReferencedListDeep(expr.elements);
          }
        }
      }
      parseSpread(refExpressionErrors) {
        const node = this.startNode();
        this.next();
        node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, void 0);
        return this.finishNode(node, "SpreadElement");
      }
      parseRestBinding() {
        const node = this.startNode();
        this.next();
        node.argument = this.parseBindingAtom();
        return this.finishNode(node, "RestElement");
      }
      parseBindingAtom() {
        switch (this.state.type) {
          case 0: {
            const node = this.startNode();
            this.next();
            node.elements = this.parseBindingList(3, 93, 1);
            return this.finishNode(node, "ArrayPattern");
          }
          case 5:
            return this.parseObjectLike(8, true);
        }
        return this.parseIdentifier();
      }
      parseBindingList(close, closeCharCode, flags) {
        const allowEmpty = flags & 1;
        const elts = [];
        let first = true;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
          }
          if (allowEmpty && this.match(12)) {
            elts.push(null);
          } else if (this.eat(close)) {
            break;
          } else if (this.match(21)) {
            elts.push(this.parseAssignableListItemTypes(this.parseRestBinding(), flags));
            if (!this.checkCommaAfterRest(closeCharCode)) {
              this.expect(close);
              break;
            }
          } else {
            const decorators = [];
            if (this.match(26) && this.hasPlugin("decorators")) {
              this.raise(Errors.UnsupportedParameterDecorator, this.state.startLoc);
            }
            while (this.match(26)) {
              decorators.push(this.parseDecorator());
            }
            elts.push(this.parseAssignableListItem(flags, decorators));
          }
        }
        return elts;
      }
      parseBindingRestProperty(prop) {
        this.next();
        prop.argument = this.parseIdentifier();
        this.checkCommaAfterRest(125);
        return this.finishNode(prop, "RestElement");
      }
      parseBindingProperty() {
        const {
          type,
          startLoc
        } = this.state;
        if (type === 21) {
          return this.parseBindingRestProperty(this.startNode());
        }
        const prop = this.startNode();
        if (type === 138) {
          this.expectPlugin("destructuringPrivate", startLoc);
          this.classScope.usePrivateName(this.state.value, startLoc);
          prop.key = this.parsePrivateName();
        } else {
          this.parsePropertyName(prop);
        }
        prop.method = false;
        return this.parseObjPropValue(prop, startLoc, false, false, true, false);
      }
      parseAssignableListItem(flags, decorators) {
        const left = this.parseMaybeDefault();
        this.parseAssignableListItemTypes(left, flags);
        const elt = this.parseMaybeDefault(left.loc.start, left);
        if (decorators.length) {
          left.decorators = decorators;
        }
        return elt;
      }
      parseAssignableListItemTypes(param, flags) {
        return param;
      }
      parseMaybeDefault(startLoc, left) {
        var _startLoc, _left;
        (_startLoc = startLoc) != null ? _startLoc : startLoc = this.state.startLoc;
        left = (_left = left) != null ? _left : this.parseBindingAtom();
        if (!this.eat(29))
          return left;
        const node = this.startNodeAt(startLoc);
        node.left = left;
        node.right = this.parseMaybeAssignAllowIn();
        return this.finishNode(node, "AssignmentPattern");
      }
      isValidLVal(type, isUnparenthesizedInAssign, binding) {
        return getOwn$1({
          AssignmentPattern: "left",
          RestElement: "argument",
          ObjectProperty: "value",
          ParenthesizedExpression: "expression",
          ArrayPattern: "elements",
          ObjectPattern: "properties"
        }, type);
      }
      isOptionalMemberExpression(expression) {
        return expression.type === "OptionalMemberExpression";
      }
      checkLVal(expression, {
        in: ancestor,
        binding = 64,
        checkClashes = false,
        strictModeChanged = false,
        hasParenthesizedAncestor = false
      }) {
        var _expression$extra;
        const type = expression.type;
        if (this.isObjectMethod(expression))
          return;
        const isOptionalMemberExpression = this.isOptionalMemberExpression(expression);
        if (isOptionalMemberExpression || type === "MemberExpression") {
          if (isOptionalMemberExpression) {
            this.expectPlugin("optionalChainingAssign", expression.loc.start);
            if (ancestor.type !== "AssignmentExpression") {
              this.raise(Errors.InvalidLhsOptionalChaining, expression, {
                ancestor
              });
            }
          }
          if (binding !== 64) {
            this.raise(Errors.InvalidPropertyBindingPattern, expression);
          }
          return;
        }
        if (type === "Identifier") {
          this.checkIdentifier(expression, binding, strictModeChanged);
          const {
            name
          } = expression;
          if (checkClashes) {
            if (checkClashes.has(name)) {
              this.raise(Errors.ParamDupe, expression);
            } else {
              checkClashes.add(name);
            }
          }
          return;
        }
        const validity = this.isValidLVal(type, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === "AssignmentExpression", binding);
        if (validity === true)
          return;
        if (validity === false) {
          const ParseErrorClass = binding === 64 ? Errors.InvalidLhs : Errors.InvalidLhsBinding;
          this.raise(ParseErrorClass, expression, {
            ancestor
          });
          return;
        }
        const [key, isParenthesizedExpression] = Array.isArray(validity) ? validity : [validity, type === "ParenthesizedExpression"];
        const nextAncestor = type === "ArrayPattern" || type === "ObjectPattern" ? {
          type
        } : ancestor;
        for (const child of [].concat(expression[key])) {
          if (child) {
            this.checkLVal(child, {
              in: nextAncestor,
              binding,
              checkClashes,
              strictModeChanged,
              hasParenthesizedAncestor: isParenthesizedExpression
            });
          }
        }
      }
      checkIdentifier(at, bindingType, strictModeChanged = false) {
        if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name))) {
          if (bindingType === 64) {
            this.raise(Errors.StrictEvalArguments, at, {
              referenceName: at.name
            });
          } else {
            this.raise(Errors.StrictEvalArgumentsBinding, at, {
              bindingName: at.name
            });
          }
        }
        if (bindingType & 8192 && at.name === "let") {
          this.raise(Errors.LetInLexicalBinding, at);
        }
        if (!(bindingType & 64)) {
          this.declareNameFromIdentifier(at, bindingType);
        }
      }
      declareNameFromIdentifier(identifier, binding) {
        this.scope.declareName(identifier.name, binding, identifier.loc.start);
      }
      checkToRestConversion(node, allowPattern) {
        switch (node.type) {
          case "ParenthesizedExpression":
            this.checkToRestConversion(node.expression, allowPattern);
            break;
          case "Identifier":
          case "MemberExpression":
            break;
          case "ArrayExpression":
          case "ObjectExpression":
            if (allowPattern)
              break;
          default:
            this.raise(Errors.InvalidRestAssignmentPattern, node);
        }
      }
      checkCommaAfterRest(close) {
        if (!this.match(12)) {
          return false;
        }
        this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, this.state.startLoc);
        return true;
      }
    };
    var getOwn = (object, key) => hasOwnProperty.call(object, key) && object[key];
    function nonNull(x) {
      if (x == null) {
        throw new Error(`Unexpected ${x} value.`);
      }
      return x;
    }
    function assert(x) {
      if (!x) {
        throw new Error("Assert fail");
      }
    }
    var TSErrors = ParseErrorEnum`typescript`({
      AbstractMethodHasImplementation: ({
        methodName
      }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,
      AbstractPropertyHasInitializer: ({
        propertyName
      }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,
      AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
      AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
      AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
      ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
      ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
      ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
      ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
      DeclareAccessor: ({
        kind
      }) => `'declare' is not allowed in ${kind}ters.`,
      DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
      DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
      DuplicateAccessibilityModifier: ({
        modifier
      }) => `Accessibility modifier already seen.`,
      DuplicateModifier: ({
        modifier
      }) => `Duplicate modifier: '${modifier}'.`,
      EmptyHeritageClauseType: ({
        token
      }) => `'${token}' list cannot be empty.`,
      EmptyTypeArguments: "Type argument list cannot be empty.",
      EmptyTypeParameters: "Type parameter list cannot be empty.",
      ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
      ImportAliasHasImportType: "An import alias can not use 'import type'.",
      ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
      IncompatibleModifiers: ({
        modifiers
      }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,
      IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
      IndexSignatureHasAccessibility: ({
        modifier
      }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,
      IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
      IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
      IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
      InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
      InvalidModifierOnTypeMember: ({
        modifier
      }) => `'${modifier}' modifier cannot appear on a type member.`,
      InvalidModifierOnTypeParameter: ({
        modifier
      }) => `'${modifier}' modifier cannot appear on a type parameter.`,
      InvalidModifierOnTypeParameterPositions: ({
        modifier
      }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,
      InvalidModifiersOrder: ({
        orderedModifiers
      }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,
      InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
      InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
      MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
      NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
      NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
      OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
      OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
      PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
      PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
      PrivateElementHasAccessibility: ({
        modifier
      }) => `Private elements cannot have an accessibility modifier ('${modifier}').`,
      ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
      ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
      ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
      SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
      SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
      SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
      SingleTypeParameterWithoutTrailingComma: ({
        typeParameterName
      }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,
      StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
      TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",
      TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
      TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
      TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
      TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
      UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
      UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
      UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
      UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
      UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
      UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
      UnsupportedSignatureParameterKind: ({
        type
      }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`
    });
    function keywordTypeFromName(value) {
      switch (value) {
        case "any":
          return "TSAnyKeyword";
        case "boolean":
          return "TSBooleanKeyword";
        case "bigint":
          return "TSBigIntKeyword";
        case "never":
          return "TSNeverKeyword";
        case "number":
          return "TSNumberKeyword";
        case "object":
          return "TSObjectKeyword";
        case "string":
          return "TSStringKeyword";
        case "symbol":
          return "TSSymbolKeyword";
        case "undefined":
          return "TSUndefinedKeyword";
        case "unknown":
          return "TSUnknownKeyword";
        default:
          return void 0;
      }
    }
    function tsIsAccessModifier(modifier) {
      return modifier === "private" || modifier === "public" || modifier === "protected";
    }
    function tsIsVarianceAnnotations(modifier) {
      return modifier === "in" || modifier === "out";
    }
    var typescript = (superClass) => class TypeScriptParserMixin extends superClass {
      constructor(...args) {
        super(...args);
        this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
          allowedModifiers: ["in", "out"],
          disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
          errorTemplate: TSErrors.InvalidModifierOnTypeParameter
        });
        this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
          allowedModifiers: ["const"],
          disallowedModifiers: ["in", "out"],
          errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
        });
        this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
          allowedModifiers: ["in", "out", "const"],
          disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
          errorTemplate: TSErrors.InvalidModifierOnTypeParameter
        });
      }
      getScopeHandler() {
        return TypeScriptScopeHandler;
      }
      tsIsIdentifier() {
        return tokenIsIdentifier(this.state.type);
      }
      tsTokenCanFollowModifier() {
        return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
      }
      tsNextTokenCanFollowModifier() {
        this.next();
        return this.tsTokenCanFollowModifier();
      }
      tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {
        if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58 && this.state.type !== 75) {
          return void 0;
        }
        const modifier = this.state.value;
        if (allowedModifiers.indexOf(modifier) !== -1) {
          if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {
            return void 0;
          }
          if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
            return modifier;
          }
        }
        return void 0;
      }
      tsParseModifiers({
        allowedModifiers,
        disallowedModifiers,
        stopOnStartOfClassStaticBlock,
        errorTemplate = TSErrors.InvalidModifierOnTypeMember
      }, modified) {
        const enforceOrder = (loc, modifier, before, after) => {
          if (modifier === before && modified[after]) {
            this.raise(TSErrors.InvalidModifiersOrder, loc, {
              orderedModifiers: [before, after]
            });
          }
        };
        const incompatible = (loc, modifier, mod1, mod2) => {
          if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
            this.raise(TSErrors.IncompatibleModifiers, loc, {
              modifiers: [mod1, mod2]
            });
          }
        };
        for (; ; ) {
          const {
            startLoc
          } = this.state;
          const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock);
          if (!modifier)
            break;
          if (tsIsAccessModifier(modifier)) {
            if (modified.accessibility) {
              this.raise(TSErrors.DuplicateAccessibilityModifier, startLoc, {
                modifier
              });
            } else {
              enforceOrder(startLoc, modifier, modifier, "override");
              enforceOrder(startLoc, modifier, modifier, "static");
              enforceOrder(startLoc, modifier, modifier, "readonly");
              modified.accessibility = modifier;
            }
          } else if (tsIsVarianceAnnotations(modifier)) {
            if (modified[modifier]) {
              this.raise(TSErrors.DuplicateModifier, startLoc, {
                modifier
              });
            }
            modified[modifier] = true;
            enforceOrder(startLoc, modifier, "in", "out");
          } else {
            if (hasOwnProperty.call(modified, modifier)) {
              this.raise(TSErrors.DuplicateModifier, startLoc, {
                modifier
              });
            } else {
              enforceOrder(startLoc, modifier, "static", "readonly");
              enforceOrder(startLoc, modifier, "static", "override");
              enforceOrder(startLoc, modifier, "override", "readonly");
              enforceOrder(startLoc, modifier, "abstract", "override");
              incompatible(startLoc, modifier, "declare", "override");
              incompatible(startLoc, modifier, "static", "abstract");
            }
            modified[modifier] = true;
          }
          if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {
            this.raise(errorTemplate, startLoc, {
              modifier
            });
          }
        }
      }
      tsIsListTerminator(kind) {
        switch (kind) {
          case "EnumMembers":
          case "TypeMembers":
            return this.match(8);
          case "HeritageClauseElement":
            return this.match(5);
          case "TupleElementTypes":
            return this.match(3);
          case "TypeParametersOrArguments":
            return this.match(48);
        }
      }
      tsParseList(kind, parseElement) {
        const result = [];
        while (!this.tsIsListTerminator(kind)) {
          result.push(parseElement());
        }
        return result;
      }
      tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
        return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));
      }
      tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
        const result = [];
        let trailingCommaPos = -1;
        for (; ; ) {
          if (this.tsIsListTerminator(kind)) {
            break;
          }
          trailingCommaPos = -1;
          const element = parseElement();
          if (element == null) {
            return void 0;
          }
          result.push(element);
          if (this.eat(12)) {
            trailingCommaPos = this.state.lastTokStartLoc.index;
            continue;
          }
          if (this.tsIsListTerminator(kind)) {
            break;
          }
          if (expectSuccess) {
            this.expect(12);
          }
          return void 0;
        }
        if (refTrailingCommaPos) {
          refTrailingCommaPos.value = trailingCommaPos;
        }
        return result;
      }
      tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
        if (!skipFirstToken) {
          if (bracket) {
            this.expect(0);
          } else {
            this.expect(47);
          }
        }
        const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);
        if (bracket) {
          this.expect(3);
        } else {
          this.expect(48);
        }
        return result;
      }
      tsParseImportType() {
        const node = this.startNode();
        this.expect(83);
        this.expect(10);
        if (!this.match(133)) {
          this.raise(TSErrors.UnsupportedImportTypeArgument, this.state.startLoc);
        }
        node.argument = super.parseExprAtom();
        if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
          node.options = null;
        }
        if (this.eat(12)) {
          this.expectImportAttributesPlugin();
          if (!this.match(11)) {
            node.options = super.parseMaybeAssignAllowIn();
            this.eat(12);
          }
        }
        this.expect(11);
        if (this.eat(16)) {
          node.qualifier = this.tsParseEntityName();
        }
        if (this.match(47)) {
          node.typeParameters = this.tsParseTypeArguments();
        }
        return this.finishNode(node, "TSImportType");
      }
      tsParseEntityName(allowReservedWords = true) {
        let entity = this.parseIdentifier(allowReservedWords);
        while (this.eat(16)) {
          const node = this.startNodeAtNode(entity);
          node.left = entity;
          node.right = this.parseIdentifier(allowReservedWords);
          entity = this.finishNode(node, "TSQualifiedName");
        }
        return entity;
      }
      tsParseTypeReference() {
        const node = this.startNode();
        node.typeName = this.tsParseEntityName();
        if (!this.hasPrecedingLineBreak() && this.match(47)) {
          node.typeParameters = this.tsParseTypeArguments();
        }
        return this.finishNode(node, "TSTypeReference");
      }
      tsParseThisTypePredicate(lhs) {
        this.next();
        const node = this.startNodeAtNode(lhs);
        node.parameterName = lhs;
        node.typeAnnotation = this.tsParseTypeAnnotation(false);
        node.asserts = false;
        return this.finishNode(node, "TSTypePredicate");
      }
      tsParseThisTypeNode() {
        const node = this.startNode();
        this.next();
        return this.finishNode(node, "TSThisType");
      }
      tsParseTypeQuery() {
        const node = this.startNode();
        this.expect(87);
        if (this.match(83)) {
          node.exprName = this.tsParseImportType();
        } else {
          node.exprName = this.tsParseEntityName();
        }
        if (!this.hasPrecedingLineBreak() && this.match(47)) {
          node.typeParameters = this.tsParseTypeArguments();
        }
        return this.finishNode(node, "TSTypeQuery");
      }
      tsParseTypeParameter(parseModifiers) {
        const node = this.startNode();
        parseModifiers(node);
        node.name = this.tsParseTypeParameterName();
        node.constraint = this.tsEatThenParseType(81);
        node.default = this.tsEatThenParseType(29);
        return this.finishNode(node, "TSTypeParameter");
      }
      tsTryParseTypeParameters(parseModifiers) {
        if (this.match(47)) {
          return this.tsParseTypeParameters(parseModifiers);
        }
      }
      tsParseTypeParameters(parseModifiers) {
        const node = this.startNode();
        if (this.match(47) || this.match(142)) {
          this.next();
        } else {
          this.unexpected();
        }
        const refTrailingCommaPos = {
          value: -1
        };
        node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos);
        if (node.params.length === 0) {
          this.raise(TSErrors.EmptyTypeParameters, node);
        }
        if (refTrailingCommaPos.value !== -1) {
          this.addExtra(node, "trailingComma", refTrailingCommaPos.value);
        }
        return this.finishNode(node, "TSTypeParameterDeclaration");
      }
      tsFillSignature(returnToken, signature) {
        const returnTokenRequired = returnToken === 19;
        const paramsKey = "parameters";
        const returnTypeKey = "typeAnnotation";
        signature.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        this.expect(10);
        signature[paramsKey] = this.tsParseBindingListForSignature();
        if (returnTokenRequired) {
          signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        } else if (this.match(returnToken)) {
          signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        }
      }
      tsParseBindingListForSignature() {
        const list = super.parseBindingList(11, 41, 2);
        for (const pattern of list) {
          const {
            type
          } = pattern;
          if (type === "AssignmentPattern" || type === "TSParameterProperty") {
            this.raise(TSErrors.UnsupportedSignatureParameterKind, pattern, {
              type
            });
          }
        }
        return list;
      }
      tsParseTypeMemberSemicolon() {
        if (!this.eat(12) && !this.isLineTerminator()) {
          this.expect(13);
        }
      }
      tsParseSignatureMember(kind, node) {
        this.tsFillSignature(14, node);
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node, kind);
      }
      tsIsUnambiguouslyIndexSignature() {
        this.next();
        if (tokenIsIdentifier(this.state.type)) {
          this.next();
          return this.match(14);
        }
        return false;
      }
      tsTryParseIndexSignature(node) {
        if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
          return;
        }
        this.expect(0);
        const id = this.parseIdentifier();
        id.typeAnnotation = this.tsParseTypeAnnotation();
        this.resetEndLocation(id);
        this.expect(3);
        node.parameters = [id];
        const type = this.tsTryParseTypeAnnotation();
        if (type)
          node.typeAnnotation = type;
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node, "TSIndexSignature");
      }
      tsParsePropertyOrMethodSignature(node, readonly) {
        if (this.eat(17))
          node.optional = true;
        const nodeAny = node;
        if (this.match(10) || this.match(47)) {
          if (readonly) {
            this.raise(TSErrors.ReadonlyForMethodSignature, node);
          }
          const method = nodeAny;
          if (method.kind && this.match(47)) {
            this.raise(TSErrors.AccesorCannotHaveTypeParameters, this.state.curPosition());
          }
          this.tsFillSignature(14, method);
          this.tsParseTypeMemberSemicolon();
          const paramsKey = "parameters";
          const returnTypeKey = "typeAnnotation";
          if (method.kind === "get") {
            if (method[paramsKey].length > 0) {
              this.raise(Errors.BadGetterArity, this.state.curPosition());
              if (this.isThisParam(method[paramsKey][0])) {
                this.raise(TSErrors.AccesorCannotDeclareThisParameter, this.state.curPosition());
              }
            }
          } else if (method.kind === "set") {
            if (method[paramsKey].length !== 1) {
              this.raise(Errors.BadSetterArity, this.state.curPosition());
            } else {
              const firstParameter = method[paramsKey][0];
              if (this.isThisParam(firstParameter)) {
                this.raise(TSErrors.AccesorCannotDeclareThisParameter, this.state.curPosition());
              }
              if (firstParameter.type === "Identifier" && firstParameter.optional) {
                this.raise(TSErrors.SetAccesorCannotHaveOptionalParameter, this.state.curPosition());
              }
              if (firstParameter.type === "RestElement") {
                this.raise(TSErrors.SetAccesorCannotHaveRestParameter, this.state.curPosition());
              }
            }
            if (method[returnTypeKey]) {
              this.raise(TSErrors.SetAccesorCannotHaveReturnType, method[returnTypeKey]);
            }
          } else {
            method.kind = "method";
          }
          return this.finishNode(method, "TSMethodSignature");
        } else {
          const property = nodeAny;
          if (readonly)
            property.readonly = true;
          const type = this.tsTryParseTypeAnnotation();
          if (type)
            property.typeAnnotation = type;
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(property, "TSPropertySignature");
        }
      }
      tsParseTypeMember() {
        const node = this.startNode();
        if (this.match(10) || this.match(47)) {
          return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
        }
        if (this.match(77)) {
          const id = this.startNode();
          this.next();
          if (this.match(10) || this.match(47)) {
            return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
          } else {
            node.key = this.createIdentifier(id, "new");
            return this.tsParsePropertyOrMethodSignature(node, false);
          }
        }
        this.tsParseModifiers({
          allowedModifiers: ["readonly"],
          disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
        }, node);
        const idx = this.tsTryParseIndexSignature(node);
        if (idx) {
          return idx;
        }
        super.parsePropertyName(node);
        if (!node.computed && node.key.type === "Identifier" && (node.key.name === "get" || node.key.name === "set") && this.tsTokenCanFollowModifier()) {
          node.kind = node.key.name;
          super.parsePropertyName(node);
        }
        return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);
      }
      tsParseTypeLiteral() {
        const node = this.startNode();
        node.members = this.tsParseObjectTypeMembers();
        return this.finishNode(node, "TSTypeLiteral");
      }
      tsParseObjectTypeMembers() {
        this.expect(5);
        const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
        this.expect(8);
        return members;
      }
      tsIsStartOfMappedType() {
        this.next();
        if (this.eat(53)) {
          return this.isContextual(122);
        }
        if (this.isContextual(122)) {
          this.next();
        }
        if (!this.match(0)) {
          return false;
        }
        this.next();
        if (!this.tsIsIdentifier()) {
          return false;
        }
        this.next();
        return this.match(58);
      }
      tsParseMappedTypeParameter() {
        const node = this.startNode();
        node.name = this.tsParseTypeParameterName();
        node.constraint = this.tsExpectThenParseType(58);
        return this.finishNode(node, "TSTypeParameter");
      }
      tsParseMappedType() {
        const node = this.startNode();
        this.expect(5);
        if (this.match(53)) {
          node.readonly = this.state.value;
          this.next();
          this.expectContextual(122);
        } else if (this.eatContextual(122)) {
          node.readonly = true;
        }
        this.expect(0);
        node.typeParameter = this.tsParseMappedTypeParameter();
        node.nameType = this.eatContextual(93) ? this.tsParseType() : null;
        this.expect(3);
        if (this.match(53)) {
          node.optional = this.state.value;
          this.next();
          this.expect(17);
        } else if (this.eat(17)) {
          node.optional = true;
        }
        node.typeAnnotation = this.tsTryParseType();
        this.semicolon();
        this.expect(8);
        return this.finishNode(node, "TSMappedType");
      }
      tsParseTupleType() {
        const node = this.startNode();
        node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
        let seenOptionalElement = false;
        node.elementTypes.forEach((elementNode) => {
          const {
            type
          } = elementNode;
          if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) {
            this.raise(TSErrors.OptionalTypeBeforeRequired, elementNode);
          }
          seenOptionalElement || (seenOptionalElement = type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType");
        });
        return this.finishNode(node, "TSTupleType");
      }
      tsParseTupleElementType() {
        const {
          startLoc
        } = this.state;
        const rest = this.eat(21);
        let labeled;
        let label;
        let optional;
        let type;
        const isWord = tokenIsKeywordOrIdentifier(this.state.type);
        const chAfterWord = isWord ? this.lookaheadCharCode() : null;
        if (chAfterWord === 58) {
          labeled = true;
          optional = false;
          label = this.parseIdentifier(true);
          this.expect(14);
          type = this.tsParseType();
        } else if (chAfterWord === 63) {
          optional = true;
          const startLoc2 = this.state.startLoc;
          const wordName = this.state.value;
          const typeOrLabel = this.tsParseNonArrayType();
          if (this.lookaheadCharCode() === 58) {
            labeled = true;
            label = this.createIdentifier(this.startNodeAt(startLoc2), wordName);
            this.expect(17);
            this.expect(14);
            type = this.tsParseType();
          } else {
            labeled = false;
            type = typeOrLabel;
            this.expect(17);
          }
        } else {
          type = this.tsParseType();
          optional = this.eat(17);
          labeled = this.eat(14);
        }
        if (labeled) {
          let labeledNode;
          if (label) {
            labeledNode = this.startNodeAtNode(label);
            labeledNode.optional = optional;
            labeledNode.label = label;
            labeledNode.elementType = type;
            if (this.eat(17)) {
              labeledNode.optional = true;
              this.raise(TSErrors.TupleOptionalAfterType, this.state.lastTokStartLoc);
            }
          } else {
            labeledNode = this.startNodeAtNode(type);
            labeledNode.optional = optional;
            this.raise(TSErrors.InvalidTupleMemberLabel, type);
            labeledNode.label = type;
            labeledNode.elementType = this.tsParseType();
          }
          type = this.finishNode(labeledNode, "TSNamedTupleMember");
        } else if (optional) {
          const optionalTypeNode = this.startNodeAtNode(type);
          optionalTypeNode.typeAnnotation = type;
          type = this.finishNode(optionalTypeNode, "TSOptionalType");
        }
        if (rest) {
          const restNode = this.startNodeAt(startLoc);
          restNode.typeAnnotation = type;
          type = this.finishNode(restNode, "TSRestType");
        }
        return type;
      }
      tsParseParenthesizedType() {
        const node = this.startNode();
        this.expect(10);
        node.typeAnnotation = this.tsParseType();
        this.expect(11);
        return this.finishNode(node, "TSParenthesizedType");
      }
      tsParseFunctionOrConstructorType(type, abstract) {
        const node = this.startNode();
        if (type === "TSConstructorType") {
          node.abstract = !!abstract;
          if (abstract)
            this.next();
          this.next();
        }
        this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node));
        return this.finishNode(node, type);
      }
      tsParseLiteralTypeNode() {
        const node = this.startNode();
        switch (this.state.type) {
          case 134:
          case 135:
          case 133:
          case 85:
          case 86:
            node.literal = super.parseExprAtom();
            break;
          default:
            this.unexpected();
        }
        return this.finishNode(node, "TSLiteralType");
      }
      tsParseTemplateLiteralType() {
        const node = this.startNode();
        node.literal = super.parseTemplate(false);
        return this.finishNode(node, "TSLiteralType");
      }
      parseTemplateSubstitution() {
        if (this.state.inType)
          return this.tsParseType();
        return super.parseTemplateSubstitution();
      }
      tsParseThisTypeOrThisTypePredicate() {
        const thisKeyword = this.tsParseThisTypeNode();
        if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
          return this.tsParseThisTypePredicate(thisKeyword);
        } else {
          return thisKeyword;
        }
      }
      tsParseNonArrayType() {
        switch (this.state.type) {
          case 133:
          case 134:
          case 135:
          case 85:
          case 86:
            return this.tsParseLiteralTypeNode();
          case 53:
            if (this.state.value === "-") {
              const node = this.startNode();
              const nextToken = this.lookahead();
              if (nextToken.type !== 134 && nextToken.type !== 135) {
                this.unexpected();
              }
              node.literal = this.parseMaybeUnary();
              return this.finishNode(node, "TSLiteralType");
            }
            break;
          case 78:
            return this.tsParseThisTypeOrThisTypePredicate();
          case 87:
            return this.tsParseTypeQuery();
          case 83:
            return this.tsParseImportType();
          case 5:
            return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
          case 0:
            return this.tsParseTupleType();
          case 10:
            return this.tsParseParenthesizedType();
          case 25:
          case 24:
            return this.tsParseTemplateLiteralType();
          default: {
            const {
              type
            } = this.state;
            if (tokenIsIdentifier(type) || type === 88 || type === 84) {
              const nodeType = type === 88 ? "TSVoidKeyword" : type === 84 ? "TSNullKeyword" : keywordTypeFromName(this.state.value);
              if (nodeType !== void 0 && this.lookaheadCharCode() !== 46) {
                const node = this.startNode();
                this.next();
                return this.finishNode(node, nodeType);
              }
              return this.tsParseTypeReference();
            }
          }
        }
        this.unexpected();
      }
      tsParseArrayTypeOrHigher() {
        let type = this.tsParseNonArrayType();
        while (!this.hasPrecedingLineBreak() && this.eat(0)) {
          if (this.match(3)) {
            const node = this.startNodeAtNode(type);
            node.elementType = type;
            this.expect(3);
            type = this.finishNode(node, "TSArrayType");
          } else {
            const node = this.startNodeAtNode(type);
            node.objectType = type;
            node.indexType = this.tsParseType();
            this.expect(3);
            type = this.finishNode(node, "TSIndexedAccessType");
          }
        }
        return type;
      }
      tsParseTypeOperator() {
        const node = this.startNode();
        const operator = this.state.value;
        this.next();
        node.operator = operator;
        node.typeAnnotation = this.tsParseTypeOperatorOrHigher();
        if (operator === "readonly") {
          this.tsCheckTypeAnnotationForReadOnly(node);
        }
        return this.finishNode(node, "TSTypeOperator");
      }
      tsCheckTypeAnnotationForReadOnly(node) {
        switch (node.typeAnnotation.type) {
          case "TSTupleType":
          case "TSArrayType":
            return;
          default:
            this.raise(TSErrors.UnexpectedReadonly, node);
        }
      }
      tsParseInferType() {
        const node = this.startNode();
        this.expectContextual(115);
        const typeParameter = this.startNode();
        typeParameter.name = this.tsParseTypeParameterName();
        typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());
        node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
        return this.finishNode(node, "TSInferType");
      }
      tsParseConstraintForInferType() {
        if (this.eat(81)) {
          const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
          if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {
            return constraint;
          }
        }
      }
      tsParseTypeOperatorOrHigher() {
        const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;
        return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
      }
      tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
        const node = this.startNode();
        const hasLeadingOperator = this.eat(operator);
        const types2 = [];
        do {
          types2.push(parseConstituentType());
        } while (this.eat(operator));
        if (types2.length === 1 && !hasLeadingOperator) {
          return types2[0];
        }
        node.types = types2;
        return this.finishNode(node, kind);
      }
      tsParseIntersectionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
      }
      tsParseUnionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
      }
      tsIsStartOfFunctionType() {
        if (this.match(47)) {
          return true;
        }
        return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
      }
      tsSkipParameterStart() {
        if (tokenIsIdentifier(this.state.type) || this.match(78)) {
          this.next();
          return true;
        }
        if (this.match(5)) {
          const {
            errors
          } = this.state;
          const previousErrorCount = errors.length;
          try {
            this.parseObjectLike(8, true);
            return errors.length === previousErrorCount;
          } catch (_unused) {
            return false;
          }
        }
        if (this.match(0)) {
          this.next();
          const {
            errors
          } = this.state;
          const previousErrorCount = errors.length;
          try {
            super.parseBindingList(3, 93, 1);
            return errors.length === previousErrorCount;
          } catch (_unused2) {
            return false;
          }
        }
        return false;
      }
      tsIsUnambiguouslyStartOfFunctionType() {
        this.next();
        if (this.match(11) || this.match(21)) {
          return true;
        }
        if (this.tsSkipParameterStart()) {
          if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {
            return true;
          }
          if (this.match(11)) {
            this.next();
            if (this.match(19)) {
              return true;
            }
          }
        }
        return false;
      }
      tsParseTypeOrTypePredicateAnnotation(returnToken) {
        return this.tsInType(() => {
          const t = this.startNode();
          this.expect(returnToken);
          const node = this.startNode();
          const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
          if (asserts && this.match(78)) {
            let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
            if (thisTypePredicate.type === "TSThisType") {
              node.parameterName = thisTypePredicate;
              node.asserts = true;
              node.typeAnnotation = null;
              thisTypePredicate = this.finishNode(node, "TSTypePredicate");
            } else {
              this.resetStartLocationFromNode(thisTypePredicate, node);
              thisTypePredicate.asserts = true;
            }
            t.typeAnnotation = thisTypePredicate;
            return this.finishNode(t, "TSTypeAnnotation");
          }
          const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
          if (!typePredicateVariable) {
            if (!asserts) {
              return this.tsParseTypeAnnotation(false, t);
            }
            node.parameterName = this.parseIdentifier();
            node.asserts = asserts;
            node.typeAnnotation = null;
            t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
            return this.finishNode(t, "TSTypeAnnotation");
          }
          const type = this.tsParseTypeAnnotation(false);
          node.parameterName = typePredicateVariable;
          node.typeAnnotation = type;
          node.asserts = asserts;
          t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
          return this.finishNode(t, "TSTypeAnnotation");
        });
      }
      tsTryParseTypeOrTypePredicateAnnotation() {
        if (this.match(14)) {
          return this.tsParseTypeOrTypePredicateAnnotation(14);
        }
      }
      tsTryParseTypeAnnotation() {
        if (this.match(14)) {
          return this.tsParseTypeAnnotation();
        }
      }
      tsTryParseType() {
        return this.tsEatThenParseType(14);
      }
      tsParseTypePredicatePrefix() {
        const id = this.parseIdentifier();
        if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
          this.next();
          return id;
        }
      }
      tsParseTypePredicateAsserts() {
        if (this.state.type !== 109) {
          return false;
        }
        const containsEsc = this.state.containsEsc;
        this.next();
        if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {
          return false;
        }
        if (containsEsc) {
          this.raise(Errors.InvalidEscapedReservedWord, this.state.lastTokStartLoc, {
            reservedWord: "asserts"
          });
        }
        return true;
      }
      tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {
        this.tsInType(() => {
          if (eatColon)
            this.expect(14);
          t.typeAnnotation = this.tsParseType();
        });
        return this.finishNode(t, "TSTypeAnnotation");
      }
      tsParseType() {
        assert(this.state.inType);
        const type = this.tsParseNonConditionalType();
        if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {
          return type;
        }
        const node = this.startNodeAtNode(type);
        node.checkType = type;
        node.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType());
        this.expect(17);
        node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
        this.expect(14);
        node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
        return this.finishNode(node, "TSConditionalType");
      }
      isAbstractConstructorSignature() {
        return this.isContextual(124) && this.lookahead().type === 77;
      }
      tsParseNonConditionalType() {
        if (this.tsIsStartOfFunctionType()) {
          return this.tsParseFunctionOrConstructorType("TSFunctionType");
        }
        if (this.match(77)) {
          return this.tsParseFunctionOrConstructorType("TSConstructorType");
        } else if (this.isAbstractConstructorSignature()) {
          return this.tsParseFunctionOrConstructorType("TSConstructorType", true);
        }
        return this.tsParseUnionTypeOrHigher();
      }
      tsParseTypeAssertion() {
        if (this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
          this.raise(TSErrors.ReservedTypeAssertion, this.state.startLoc);
        }
        const node = this.startNode();
        node.typeAnnotation = this.tsInType(() => {
          this.next();
          return this.match(75) ? this.tsParseTypeReference() : this.tsParseType();
        });
        this.expect(48);
        node.expression = this.parseMaybeUnary();
        return this.finishNode(node, "TSTypeAssertion");
      }
      tsParseHeritageClause(token) {
        const originalStartLoc = this.state.startLoc;
        const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", () => {
          const node = this.startNode();
          node.expression = this.tsParseEntityName();
          if (this.match(47)) {
            node.typeParameters = this.tsParseTypeArguments();
          }
          return this.finishNode(node, "TSExpressionWithTypeArguments");
        });
        if (!delimitedList.length) {
          this.raise(TSErrors.EmptyHeritageClauseType, originalStartLoc, {
            token
          });
        }
        return delimitedList;
      }
      tsParseInterfaceDeclaration(node, properties = {}) {
        if (this.hasFollowingLineBreak())
          return null;
        this.expectContextual(129);
        if (properties.declare)
          node.declare = true;
        if (tokenIsIdentifier(this.state.type)) {
          node.id = this.parseIdentifier();
          this.checkIdentifier(node.id, 130);
        } else {
          node.id = null;
          this.raise(TSErrors.MissingInterfaceName, this.state.startLoc);
        }
        node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
        if (this.eat(81)) {
          node.extends = this.tsParseHeritageClause("extends");
        }
        const body = this.startNode();
        body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
        node.body = this.finishNode(body, "TSInterfaceBody");
        return this.finishNode(node, "TSInterfaceDeclaration");
      }
      tsParseTypeAliasDeclaration(node) {
        node.id = this.parseIdentifier();
        this.checkIdentifier(node.id, 2);
        node.typeAnnotation = this.tsInType(() => {
          node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers);
          this.expect(29);
          if (this.isContextual(114) && this.lookahead().type !== 16) {
            const node2 = this.startNode();
            this.next();
            return this.finishNode(node2, "TSIntrinsicKeyword");
          }
          return this.tsParseType();
        });
        this.semicolon();
        return this.finishNode(node, "TSTypeAliasDeclaration");
      }
      tsInNoContext(cb) {
        const oldContext = this.state.context;
        this.state.context = [oldContext[0]];
        try {
          return cb();
        } finally {
          this.state.context = oldContext;
        }
      }
      tsInType(cb) {
        const oldInType = this.state.inType;
        this.state.inType = true;
        try {
          return cb();
        } finally {
          this.state.inType = oldInType;
        }
      }
      tsInDisallowConditionalTypesContext(cb) {
        const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
        this.state.inDisallowConditionalTypesContext = true;
        try {
          return cb();
        } finally {
          this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
        }
      }
      tsInAllowConditionalTypesContext(cb) {
        const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
        this.state.inDisallowConditionalTypesContext = false;
        try {
          return cb();
        } finally {
          this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
        }
      }
      tsEatThenParseType(token) {
        if (this.match(token)) {
          return this.tsNextThenParseType();
        }
      }
      tsExpectThenParseType(token) {
        return this.tsInType(() => {
          this.expect(token);
          return this.tsParseType();
        });
      }
      tsNextThenParseType() {
        return this.tsInType(() => {
          this.next();
          return this.tsParseType();
        });
      }
      tsParseEnumMember() {
        const node = this.startNode();
        node.id = this.match(133) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true);
        if (this.eat(29)) {
          node.initializer = super.parseMaybeAssignAllowIn();
        }
        return this.finishNode(node, "TSEnumMember");
      }
      tsParseEnumDeclaration(node, properties = {}) {
        if (properties.const)
          node.const = true;
        if (properties.declare)
          node.declare = true;
        this.expectContextual(126);
        node.id = this.parseIdentifier();
        this.checkIdentifier(node.id, node.const ? 8971 : 8459);
        this.expect(5);
        node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
        this.expect(8);
        return this.finishNode(node, "TSEnumDeclaration");
      }
      tsParseModuleBlock() {
        const node = this.startNode();
        this.scope.enter(0);
        this.expect(5);
        super.parseBlockOrModuleBlockBody(node.body = [], void 0, true, 8);
        this.scope.exit();
        return this.finishNode(node, "TSModuleBlock");
      }
      tsParseModuleOrNamespaceDeclaration(node, nested = false) {
        node.id = this.parseIdentifier();
        if (!nested) {
          this.checkIdentifier(node.id, 1024);
        }
        if (this.eat(16)) {
          const inner = this.startNode();
          this.tsParseModuleOrNamespaceDeclaration(inner, true);
          node.body = inner;
        } else {
          this.scope.enter(256);
          this.prodParam.enter(0);
          node.body = this.tsParseModuleBlock();
          this.prodParam.exit();
          this.scope.exit();
        }
        return this.finishNode(node, "TSModuleDeclaration");
      }
      tsParseAmbientExternalModuleDeclaration(node) {
        if (this.isContextual(112)) {
          node.global = true;
          node.id = this.parseIdentifier();
        } else if (this.match(133)) {
          node.id = super.parseStringLiteral(this.state.value);
        } else {
          this.unexpected();
        }
        if (this.match(5)) {
          this.scope.enter(256);
          this.prodParam.enter(0);
          node.body = this.tsParseModuleBlock();
          this.prodParam.exit();
          this.scope.exit();
        } else {
          this.semicolon();
        }
        return this.finishNode(node, "TSModuleDeclaration");
      }
      tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier, isExport) {
        node.isExport = isExport || false;
        node.id = maybeDefaultIdentifier || this.parseIdentifier();
        this.checkIdentifier(node.id, 4096);
        this.expect(29);
        const moduleReference = this.tsParseModuleReference();
        if (node.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") {
          this.raise(TSErrors.ImportAliasHasImportType, moduleReference);
        }
        node.moduleReference = moduleReference;
        this.semicolon();
        return this.finishNode(node, "TSImportEqualsDeclaration");
      }
      tsIsExternalModuleReference() {
        return this.isContextual(119) && this.lookaheadCharCode() === 40;
      }
      tsParseModuleReference() {
        return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
      }
      tsParseExternalModuleReference() {
        const node = this.startNode();
        this.expectContextual(119);
        this.expect(10);
        if (!this.match(133)) {
          this.unexpected();
        }
        node.expression = super.parseExprAtom();
        this.expect(11);
        this.sawUnambiguousESM = true;
        return this.finishNode(node, "TSExternalModuleReference");
      }
      tsLookAhead(f) {
        const state = this.state.clone();
        const res = f();
        this.state = state;
        return res;
      }
      tsTryParseAndCatch(f) {
        const result = this.tryParse((abort) => f() || abort());
        if (result.aborted || !result.node)
          return;
        if (result.error)
          this.state = result.failState;
        return result.node;
      }
      tsTryParse(f) {
        const state = this.state.clone();
        const result = f();
        if (result !== void 0 && result !== false) {
          return result;
        }
        this.state = state;
      }
      tsTryParseDeclare(nany) {
        if (this.isLineTerminator()) {
          return;
        }
        let startType = this.state.type;
        let kind;
        if (this.isContextual(100)) {
          startType = 74;
          kind = "let";
        }
        return this.tsInAmbientContext(() => {
          switch (startType) {
            case 68:
              nany.declare = true;
              return super.parseFunctionStatement(nany, false, false);
            case 80:
              nany.declare = true;
              return this.parseClass(nany, true, false);
            case 126:
              return this.tsParseEnumDeclaration(nany, {
                declare: true
              });
            case 112:
              return this.tsParseAmbientExternalModuleDeclaration(nany);
            case 75:
            case 74:
              if (!this.match(75) || !this.isLookaheadContextual("enum")) {
                nany.declare = true;
                return this.parseVarStatement(nany, kind || this.state.value, true);
              }
              this.expect(75);
              return this.tsParseEnumDeclaration(nany, {
                const: true,
                declare: true
              });
            case 129: {
              const result = this.tsParseInterfaceDeclaration(nany, {
                declare: true
              });
              if (result)
                return result;
            }
            default:
              if (tokenIsIdentifier(startType)) {
                return this.tsParseDeclaration(nany, this.state.value, true, null);
              }
          }
        });
      }
      tsTryParseExportDeclaration() {
        return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);
      }
      tsParseExpressionStatement(node, expr, decorators) {
        switch (expr.name) {
          case "declare": {
            const declaration = this.tsTryParseDeclare(node);
            if (declaration) {
              declaration.declare = true;
            }
            return declaration;
          }
          case "global":
            if (this.match(5)) {
              this.scope.enter(256);
              this.prodParam.enter(0);
              const mod = node;
              mod.global = true;
              mod.id = expr;
              mod.body = this.tsParseModuleBlock();
              this.scope.exit();
              this.prodParam.exit();
              return this.finishNode(mod, "TSModuleDeclaration");
            }
            break;
          default:
            return this.tsParseDeclaration(node, expr.name, false, decorators);
        }
      }
      tsParseDeclaration(node, value, next, decorators) {
        switch (value) {
          case "abstract":
            if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {
              return this.tsParseAbstractDeclaration(node, decorators);
            }
            break;
          case "module":
            if (this.tsCheckLineTerminator(next)) {
              if (this.match(133)) {
                return this.tsParseAmbientExternalModuleDeclaration(node);
              } else if (tokenIsIdentifier(this.state.type)) {
                return this.tsParseModuleOrNamespaceDeclaration(node);
              }
            }
            break;
          case "namespace":
            if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
              return this.tsParseModuleOrNamespaceDeclaration(node);
            }
            break;
          case "type":
            if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
              return this.tsParseTypeAliasDeclaration(node);
            }
            break;
        }
      }
      tsCheckLineTerminator(next) {
        if (next) {
          if (this.hasFollowingLineBreak())
            return false;
          this.next();
          return true;
        }
        return !this.isLineTerminator();
      }
      tsTryParseGenericAsyncArrowFunction(startLoc) {
        if (!this.match(47))
          return;
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        this.state.maybeInArrowParameters = true;
        const res = this.tsTryParseAndCatch(() => {
          const node = this.startNodeAt(startLoc);
          node.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
          super.parseFunctionParams(node);
          node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
          this.expect(19);
          return node;
        });
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        if (!res)
          return;
        return super.parseArrowExpression(res, null, true);
      }
      tsParseTypeArgumentsInExpression() {
        if (this.reScan_lt() !== 47)
          return;
        return this.tsParseTypeArguments();
      }
      tsParseTypeArguments() {
        const node = this.startNode();
        node.params = this.tsInType(() => this.tsInNoContext(() => {
          this.expect(47);
          return this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this));
        }));
        if (node.params.length === 0) {
          this.raise(TSErrors.EmptyTypeArguments, node);
        } else if (!this.state.inType && this.curContext() === types.brace) {
          this.reScan_lt_gt();
        }
        this.expect(48);
        return this.finishNode(node, "TSTypeParameterInstantiation");
      }
      tsIsDeclarationStart() {
        return tokenIsTSDeclarationStart(this.state.type);
      }
      isExportDefaultSpecifier() {
        if (this.tsIsDeclarationStart())
          return false;
        return super.isExportDefaultSpecifier();
      }
      parseAssignableListItem(flags, decorators) {
        const startLoc = this.state.startLoc;
        const modified = {};
        this.tsParseModifiers({
          allowedModifiers: ["public", "private", "protected", "override", "readonly"]
        }, modified);
        const accessibility = modified.accessibility;
        const override = modified.override;
        const readonly = modified.readonly;
        if (!(flags & 4) && (accessibility || readonly || override)) {
          this.raise(TSErrors.UnexpectedParameterModifier, startLoc);
        }
        const left = this.parseMaybeDefault();
        this.parseAssignableListItemTypes(left, flags);
        const elt = this.parseMaybeDefault(left.loc.start, left);
        if (accessibility || readonly || override) {
          const pp = this.startNodeAt(startLoc);
          if (decorators.length) {
            pp.decorators = decorators;
          }
          if (accessibility)
            pp.accessibility = accessibility;
          if (readonly)
            pp.readonly = readonly;
          if (override)
            pp.override = override;
          if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
            this.raise(TSErrors.UnsupportedParameterPropertyKind, pp);
          }
          pp.parameter = elt;
          return this.finishNode(pp, "TSParameterProperty");
        }
        if (decorators.length) {
          left.decorators = decorators;
        }
        return elt;
      }
      isSimpleParameter(node) {
        return node.type === "TSParameterProperty" && super.isSimpleParameter(node.parameter) || super.isSimpleParameter(node);
      }
      tsDisallowOptionalPattern(node) {
        for (const param of node.params) {
          if (param.type !== "Identifier" && param.optional && !this.state.isAmbientContext) {
            this.raise(TSErrors.PatternIsOptional, param);
          }
        }
      }
      setArrowFunctionParameters(node, params, trailingCommaLoc) {
        super.setArrowFunctionParameters(node, params, trailingCommaLoc);
        this.tsDisallowOptionalPattern(node);
      }
      parseFunctionBodyAndFinish(node, type, isMethod = false) {
        if (this.match(14)) {
          node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
        }
        const bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" || type === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
        if (bodilessType && !this.match(5) && this.isLineTerminator()) {
          return this.finishNode(node, bodilessType);
        }
        if (bodilessType === "TSDeclareFunction" && this.state.isAmbientContext) {
          this.raise(TSErrors.DeclareFunctionHasImplementation, node);
          if (node.declare) {
            return super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);
          }
        }
        this.tsDisallowOptionalPattern(node);
        return super.parseFunctionBodyAndFinish(node, type, isMethod);
      }
      registerFunctionStatementId(node) {
        if (!node.body && node.id) {
          this.checkIdentifier(node.id, 1024);
        } else {
          super.registerFunctionStatementId(node);
        }
      }
      tsCheckForInvalidTypeCasts(items) {
        items.forEach((node) => {
          if ((node == null ? void 0 : node.type) === "TSTypeCastExpression") {
            this.raise(TSErrors.UnexpectedTypeAnnotation, node.typeAnnotation);
          }
        });
      }
      toReferencedList(exprList, isInParens) {
        this.tsCheckForInvalidTypeCasts(exprList);
        return exprList;
      }
      parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
        const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
        if (node.type === "ArrayExpression") {
          this.tsCheckForInvalidTypeCasts(node.elements);
        }
        return node;
      }
      parseSubscript(base, startLoc, noCalls, state) {
        if (!this.hasPrecedingLineBreak() && this.match(35)) {
          this.state.canStartJSXElement = false;
          this.next();
          const nonNullExpression = this.startNodeAt(startLoc);
          nonNullExpression.expression = base;
          return this.finishNode(nonNullExpression, "TSNonNullExpression");
        }
        let isOptionalCall = false;
        if (this.match(18) && this.lookaheadCharCode() === 60) {
          if (noCalls) {
            state.stop = true;
            return base;
          }
          state.optionalChainMember = isOptionalCall = true;
          this.next();
        }
        if (this.match(47) || this.match(51)) {
          let missingParenErrorLoc;
          const result = this.tsTryParseAndCatch(() => {
            if (!noCalls && this.atPossibleAsyncArrow(base)) {
              const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startLoc);
              if (asyncArrowFn) {
                return asyncArrowFn;
              }
            }
            const typeArguments = this.tsParseTypeArgumentsInExpression();
            if (!typeArguments)
              return;
            if (isOptionalCall && !this.match(10)) {
              missingParenErrorLoc = this.state.curPosition();
              return;
            }
            if (tokenIsTemplate(this.state.type)) {
              const result2 = super.parseTaggedTemplateExpression(base, startLoc, state);
              result2.typeParameters = typeArguments;
              return result2;
            }
            if (!noCalls && this.eat(10)) {
              const node2 = this.startNodeAt(startLoc);
              node2.callee = base;
              node2.arguments = this.parseCallExpressionArguments(11, false);
              this.tsCheckForInvalidTypeCasts(node2.arguments);
              node2.typeParameters = typeArguments;
              if (state.optionalChainMember) {
                node2.optional = isOptionalCall;
              }
              return this.finishCallExpression(node2, state.optionalChainMember);
            }
            const tokenType = this.state.type;
            if (tokenType === 48 || tokenType === 52 || tokenType !== 10 && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak()) {
              return;
            }
            const node = this.startNodeAt(startLoc);
            node.expression = base;
            node.typeParameters = typeArguments;
            return this.finishNode(node, "TSInstantiationExpression");
          });
          if (missingParenErrorLoc) {
            this.unexpected(missingParenErrorLoc, 10);
          }
          if (result) {
            if (result.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40)) {
              this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc);
            }
            return result;
          }
        }
        return super.parseSubscript(base, startLoc, noCalls, state);
      }
      parseNewCallee(node) {
        var _callee$extra;
        super.parseNewCallee(node);
        const {
          callee
        } = node;
        if (callee.type === "TSInstantiationExpression" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)) {
          node.typeParameters = callee.typeParameters;
          node.callee = callee.expression;
        }
      }
      parseExprOp(left, leftStartLoc, minPrec) {
        let isSatisfies;
        if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (isSatisfies = this.isContextual(120)))) {
          const node = this.startNodeAt(leftStartLoc);
          node.expression = left;
          node.typeAnnotation = this.tsInType(() => {
            this.next();
            if (this.match(75)) {
              if (isSatisfies) {
                this.raise(Errors.UnexpectedKeyword, this.state.startLoc, {
                  keyword: "const"
                });
              }
              return this.tsParseTypeReference();
            }
            return this.tsParseType();
          });
          this.finishNode(node, isSatisfies ? "TSSatisfiesExpression" : "TSAsExpression");
          this.reScan_lt_gt();
          return this.parseExprOp(node, leftStartLoc, minPrec);
        }
        return super.parseExprOp(left, leftStartLoc, minPrec);
      }
      checkReservedWord(word, startLoc, checkKeywords, isBinding) {
        if (!this.state.isAmbientContext) {
          super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
        }
      }
      checkImportReflection(node) {
        super.checkImportReflection(node);
        if (node.module && node.importKind !== "value") {
          this.raise(TSErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);
        }
      }
      checkDuplicateExports() {
      }
      isPotentialImportPhase(isExport) {
        if (super.isPotentialImportPhase(isExport))
          return true;
        if (this.isContextual(130)) {
          const ch = this.lookaheadCharCode();
          return isExport ? ch === 123 || ch === 42 : ch !== 61;
        }
        return !isExport && this.isContextual(87);
      }
      applyImportPhase(node, isExport, phase, loc) {
        super.applyImportPhase(node, isExport, phase, loc);
        if (isExport) {
          node.exportKind = phase === "type" ? "type" : "value";
        } else {
          node.importKind = phase === "type" || phase === "typeof" ? phase : "value";
        }
      }
      parseImport(node) {
        if (this.match(133)) {
          node.importKind = "value";
          return super.parseImport(node);
        }
        let importNode;
        if (tokenIsIdentifier(this.state.type) && this.lookaheadCharCode() === 61) {
          node.importKind = "value";
          return this.tsParseImportEqualsDeclaration(node);
        } else if (this.isContextual(130)) {
          const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, false);
          if (this.lookaheadCharCode() === 61) {
            return this.tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier);
          } else {
            importNode = super.parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier);
          }
        } else {
          importNode = super.parseImport(node);
        }
        if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {
          this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, importNode);
        }
        return importNode;
      }
      parseExport(node, decorators) {
        if (this.match(83)) {
          this.next();
          const nodeImportEquals = node;
          let maybeDefaultIdentifier = null;
          if (this.isContextual(130) && this.isPotentialImportPhase(false)) {
            maybeDefaultIdentifier = this.parseMaybeImportPhase(nodeImportEquals, false);
          } else {
            nodeImportEquals.importKind = "value";
          }
          return this.tsParseImportEqualsDeclaration(nodeImportEquals, maybeDefaultIdentifier, true);
        } else if (this.eat(29)) {
          const assign = node;
          assign.expression = super.parseExpression();
          this.semicolon();
          this.sawUnambiguousESM = true;
          return this.finishNode(assign, "TSExportAssignment");
        } else if (this.eatContextual(93)) {
          const decl = node;
          this.expectContextual(128);
          decl.id = this.parseIdentifier();
          this.semicolon();
          return this.finishNode(decl, "TSNamespaceExportDeclaration");
        } else {
          return super.parseExport(node, decorators);
        }
      }
      isAbstractClass() {
        return this.isContextual(124) && this.lookahead().type === 80;
      }
      parseExportDefaultExpression() {
        if (this.isAbstractClass()) {
          const cls = this.startNode();
          this.next();
          cls.abstract = true;
          return this.parseClass(cls, true, true);
        }
        if (this.match(129)) {
          const result = this.tsParseInterfaceDeclaration(this.startNode());
          if (result)
            return result;
        }
        return super.parseExportDefaultExpression();
      }
      parseVarStatement(node, kind, allowMissingInitializer = false) {
        const {
          isAmbientContext
        } = this.state;
        const declaration = super.parseVarStatement(node, kind, allowMissingInitializer || isAmbientContext);
        if (!isAmbientContext)
          return declaration;
        for (const {
          id,
          init
        } of declaration.declarations) {
          if (!init)
            continue;
          if (kind !== "const" || !!id.typeAnnotation) {
            this.raise(TSErrors.InitializerNotAllowedInAmbientContext, init);
          } else if (!isValidAmbientConstInitializer(init, this.hasPlugin("estree"))) {
            this.raise(TSErrors.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, init);
          }
        }
        return declaration;
      }
      parseStatementContent(flags, decorators) {
        if (this.match(75) && this.isLookaheadContextual("enum")) {
          const node = this.startNode();
          this.expect(75);
          return this.tsParseEnumDeclaration(node, {
            const: true
          });
        }
        if (this.isContextual(126)) {
          return this.tsParseEnumDeclaration(this.startNode());
        }
        if (this.isContextual(129)) {
          const result = this.tsParseInterfaceDeclaration(this.startNode());
          if (result)
            return result;
        }
        return super.parseStatementContent(flags, decorators);
      }
      parseAccessModifier() {
        return this.tsParseModifier(["public", "protected", "private"]);
      }
      tsHasSomeModifiers(member, modifiers) {
        return modifiers.some((modifier) => {
          if (tsIsAccessModifier(modifier)) {
            return member.accessibility === modifier;
          }
          return !!member[modifier];
        });
      }
      tsIsStartOfStaticBlocks() {
        return this.isContextual(106) && this.lookaheadCharCode() === 123;
      }
      parseClassMember(classBody, member, state) {
        const modifiers = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
        this.tsParseModifiers({
          allowedModifiers: modifiers,
          disallowedModifiers: ["in", "out"],
          stopOnStartOfClassStaticBlock: true,
          errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
        }, member);
        const callParseClassMemberWithIsStatic = () => {
          if (this.tsIsStartOfStaticBlocks()) {
            this.next();
            this.next();
            if (this.tsHasSomeModifiers(member, modifiers)) {
              this.raise(TSErrors.StaticBlockCannotHaveModifier, this.state.curPosition());
            }
            super.parseClassStaticBlock(classBody, member);
          } else {
            this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);
          }
        };
        if (member.declare) {
          this.tsInAmbientContext(callParseClassMemberWithIsStatic);
        } else {
          callParseClassMemberWithIsStatic();
        }
      }
      parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
        const idx = this.tsTryParseIndexSignature(member);
        if (idx) {
          classBody.body.push(idx);
          if (member.abstract) {
            this.raise(TSErrors.IndexSignatureHasAbstract, member);
          }
          if (member.accessibility) {
            this.raise(TSErrors.IndexSignatureHasAccessibility, member, {
              modifier: member.accessibility
            });
          }
          if (member.declare) {
            this.raise(TSErrors.IndexSignatureHasDeclare, member);
          }
          if (member.override) {
            this.raise(TSErrors.IndexSignatureHasOverride, member);
          }
          return;
        }
        if (!this.state.inAbstractClass && member.abstract) {
          this.raise(TSErrors.NonAbstractClassHasAbstractMethod, member);
        }
        if (member.override) {
          if (!state.hadSuperClass) {
            this.raise(TSErrors.OverrideNotInSubClass, member);
          }
        }
        super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
      }
      parsePostMemberNameModifiers(methodOrProp) {
        const optional = this.eat(17);
        if (optional)
          methodOrProp.optional = true;
        if (methodOrProp.readonly && this.match(10)) {
          this.raise(TSErrors.ClassMethodHasReadonly, methodOrProp);
        }
        if (methodOrProp.declare && this.match(10)) {
          this.raise(TSErrors.ClassMethodHasDeclare, methodOrProp);
        }
      }
      parseExpressionStatement(node, expr, decorators) {
        const decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr, decorators) : void 0;
        return decl || super.parseExpressionStatement(node, expr, decorators);
      }
      shouldParseExportDeclaration() {
        if (this.tsIsDeclarationStart())
          return true;
        return super.shouldParseExportDeclaration();
      }
      parseConditional(expr, startLoc, refExpressionErrors) {
        if (!this.state.maybeInArrowParameters || !this.match(17)) {
          return super.parseConditional(expr, startLoc, refExpressionErrors);
        }
        const result = this.tryParse(() => super.parseConditional(expr, startLoc));
        if (!result.node) {
          if (result.error) {
            super.setOptionalParametersError(refExpressionErrors, result.error);
          }
          return expr;
        }
        if (result.error)
          this.state = result.failState;
        return result.node;
      }
      parseParenItem(node, startLoc) {
        const newNode = super.parseParenItem(node, startLoc);
        if (this.eat(17)) {
          newNode.optional = true;
          this.resetEndLocation(node);
        }
        if (this.match(14)) {
          const typeCastNode = this.startNodeAt(startLoc);
          typeCastNode.expression = node;
          typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
          return this.finishNode(typeCastNode, "TSTypeCastExpression");
        }
        return node;
      }
      parseExportDeclaration(node) {
        if (!this.state.isAmbientContext && this.isContextual(125)) {
          return this.tsInAmbientContext(() => this.parseExportDeclaration(node));
        }
        const startLoc = this.state.startLoc;
        const isDeclare = this.eatContextual(125);
        if (isDeclare && (this.isContextual(125) || !this.shouldParseExportDeclaration())) {
          throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
        }
        const isIdentifier = tokenIsIdentifier(this.state.type);
        const declaration = isIdentifier && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node);
        if (!declaration)
          return null;
        if (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare) {
          node.exportKind = "type";
        }
        if (isDeclare) {
          this.resetStartLocation(declaration, startLoc);
          declaration.declare = true;
        }
        return declaration;
      }
      parseClassId(node, isStatement, optionalId, bindingType) {
        if ((!isStatement || optionalId) && this.isContextual(113)) {
          return;
        }
        super.parseClassId(node, isStatement, optionalId, node.declare ? 1024 : 8331);
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
        if (typeParameters)
          node.typeParameters = typeParameters;
      }
      parseClassPropertyAnnotation(node) {
        if (!node.optional) {
          if (this.eat(35)) {
            node.definite = true;
          } else if (this.eat(17)) {
            node.optional = true;
          }
        }
        const type = this.tsTryParseTypeAnnotation();
        if (type)
          node.typeAnnotation = type;
      }
      parseClassProperty(node) {
        this.parseClassPropertyAnnotation(node);
        if (this.state.isAmbientContext && !(node.readonly && !node.typeAnnotation) && this.match(29)) {
          this.raise(TSErrors.DeclareClassFieldHasInitializer, this.state.startLoc);
        }
        if (node.abstract && this.match(29)) {
          const {
            key
          } = node;
          this.raise(TSErrors.AbstractPropertyHasInitializer, this.state.startLoc, {
            propertyName: key.type === "Identifier" && !node.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`
          });
        }
        return super.parseClassProperty(node);
      }
      parseClassPrivateProperty(node) {
        if (node.abstract) {
          this.raise(TSErrors.PrivateElementHasAbstract, node);
        }
        if (node.accessibility) {
          this.raise(TSErrors.PrivateElementHasAccessibility, node, {
            modifier: node.accessibility
          });
        }
        this.parseClassPropertyAnnotation(node);
        return super.parseClassPrivateProperty(node);
      }
      parseClassAccessorProperty(node) {
        this.parseClassPropertyAnnotation(node);
        if (node.optional) {
          this.raise(TSErrors.AccessorCannotBeOptional, node);
        }
        return super.parseClassAccessorProperty(node);
      }
      pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (typeParameters && isConstructor) {
          this.raise(TSErrors.ConstructorHasTypeParameters, typeParameters);
        }
        const {
          declare = false,
          kind
        } = method;
        if (declare && (kind === "get" || kind === "set")) {
          this.raise(TSErrors.DeclareAccessor, method, {
            kind
          });
        }
        if (typeParameters)
          method.typeParameters = typeParameters;
        super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
      }
      pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (typeParameters)
          method.typeParameters = typeParameters;
        super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
      }
      declareClassPrivateMethodInScope(node, kind) {
        if (node.type === "TSDeclareMethod")
          return;
        if (node.type === "MethodDefinition" && !hasOwnProperty.call(node.value, "body")) {
          return;
        }
        super.declareClassPrivateMethodInScope(node, kind);
      }
      parseClassSuper(node) {
        super.parseClassSuper(node);
        if (node.superClass && (this.match(47) || this.match(51))) {
          node.superTypeParameters = this.tsParseTypeArgumentsInExpression();
        }
        if (this.eatContextual(113)) {
          node.implements = this.tsParseHeritageClause("implements");
        }
      }
      parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (typeParameters)
          prop.typeParameters = typeParameters;
        return super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
      }
      parseFunctionParams(node, isConstructor) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (typeParameters)
          node.typeParameters = typeParameters;
        super.parseFunctionParams(node, isConstructor);
      }
      parseVarId(decl, kind) {
        super.parseVarId(decl, kind);
        if (decl.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35)) {
          decl.definite = true;
        }
        const type = this.tsTryParseTypeAnnotation();
        if (type) {
          decl.id.typeAnnotation = type;
          this.resetEndLocation(decl.id);
        }
      }
      parseAsyncArrowFromCallExpression(node, call) {
        if (this.match(14)) {
          node.returnType = this.tsParseTypeAnnotation();
        }
        return super.parseAsyncArrowFromCallExpression(node, call);
      }
      parseMaybeAssign(refExpressionErrors, afterLeftParse) {
        var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2;
        let state;
        let jsx2;
        let typeCast;
        if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
          state = this.state.clone();
          jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
          if (!jsx2.error)
            return jsx2.node;
          const {
            context
          } = this.state;
          const currentContext = context[context.length - 1];
          if (currentContext === types.j_oTag || currentContext === types.j_expr) {
            context.pop();
          }
        }
        if (!((_jsx = jsx2) != null && _jsx.error) && !this.match(47)) {
          return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
        }
        if (!state || state === this.state)
          state = this.state.clone();
        let typeParameters;
        const arrow = this.tryParse((abort) => {
          var _expr$extra, _typeParameters;
          typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
          const expr = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
          if (expr.type !== "ArrowFunctionExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
            abort();
          }
          if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {
            this.resetStartLocationFromNode(expr, typeParameters);
          }
          expr.typeParameters = typeParameters;
          return expr;
        }, state);
        if (!arrow.error && !arrow.aborted) {
          if (typeParameters)
            this.reportReservedArrowTypeParam(typeParameters);
          return arrow.node;
        }
        if (!jsx2) {
          assert(!this.hasPlugin("jsx"));
          typeCast = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
          if (!typeCast.error)
            return typeCast.node;
        }
        if ((_jsx2 = jsx2) != null && _jsx2.node) {
          this.state = jsx2.failState;
          return jsx2.node;
        }
        if (arrow.node) {
          this.state = arrow.failState;
          if (typeParameters)
            this.reportReservedArrowTypeParam(typeParameters);
          return arrow.node;
        }
        if ((_typeCast = typeCast) != null && _typeCast.node) {
          this.state = typeCast.failState;
          return typeCast.node;
        }
        throw ((_jsx3 = jsx2) == null ? void 0 : _jsx3.error) || arrow.error || ((_typeCast2 = typeCast) == null ? void 0 : _typeCast2.error);
      }
      reportReservedArrowTypeParam(node) {
        var _node$extra;
        if (node.params.length === 1 && !node.params[0].constraint && !((_node$extra = node.extra) != null && _node$extra.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
          this.raise(TSErrors.ReservedArrowTypeParam, node);
        }
      }
      parseMaybeUnary(refExpressionErrors, sawUnary) {
        if (!this.hasPlugin("jsx") && this.match(47)) {
          return this.tsParseTypeAssertion();
        }
        return super.parseMaybeUnary(refExpressionErrors, sawUnary);
      }
      parseArrow(node) {
        if (this.match(14)) {
          const result = this.tryParse((abort) => {
            const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
            if (this.canInsertSemicolon() || !this.match(19))
              abort();
            return returnType;
          });
          if (result.aborted)
            return;
          if (!result.thrown) {
            if (result.error)
              this.state = result.failState;
            node.returnType = result.node;
          }
        }
        return super.parseArrow(node);
      }
      parseAssignableListItemTypes(param, flags) {
        if (!(flags & 2))
          return param;
        if (this.eat(17)) {
          param.optional = true;
        }
        const type = this.tsTryParseTypeAnnotation();
        if (type)
          param.typeAnnotation = type;
        this.resetEndLocation(param);
        return param;
      }
      isAssignable(node, isBinding) {
        switch (node.type) {
          case "TSTypeCastExpression":
            return this.isAssignable(node.expression, isBinding);
          case "TSParameterProperty":
            return true;
          default:
            return super.isAssignable(node, isBinding);
        }
      }
      toAssignable(node, isLHS = false) {
        switch (node.type) {
          case "ParenthesizedExpression":
            this.toAssignableParenthesizedExpression(node, isLHS);
            break;
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
            if (isLHS) {
              this.expressionScope.recordArrowParameterBindingError(TSErrors.UnexpectedTypeCastInParameter, node);
            } else {
              this.raise(TSErrors.UnexpectedTypeCastInParameter, node);
            }
            this.toAssignable(node.expression, isLHS);
            break;
          case "AssignmentExpression":
            if (!isLHS && node.left.type === "TSTypeCastExpression") {
              node.left = this.typeCastToParameter(node.left);
            }
          default:
            super.toAssignable(node, isLHS);
        }
      }
      toAssignableParenthesizedExpression(node, isLHS) {
        switch (node.expression.type) {
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
          case "ParenthesizedExpression":
            this.toAssignable(node.expression, isLHS);
            break;
          default:
            super.toAssignable(node, isLHS);
        }
      }
      checkToRestConversion(node, allowPattern) {
        switch (node.type) {
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSTypeAssertion":
          case "TSNonNullExpression":
            this.checkToRestConversion(node.expression, false);
            break;
          default:
            super.checkToRestConversion(node, allowPattern);
        }
      }
      isValidLVal(type, isUnparenthesizedInAssign, binding) {
        return getOwn({
          TSTypeCastExpression: true,
          TSParameterProperty: "parameter",
          TSNonNullExpression: "expression",
          TSInstantiationExpression: "expression",
          TSAsExpression: (binding !== 64 || !isUnparenthesizedInAssign) && ["expression", true],
          TSSatisfiesExpression: (binding !== 64 || !isUnparenthesizedInAssign) && ["expression", true],
          TSTypeAssertion: (binding !== 64 || !isUnparenthesizedInAssign) && ["expression", true]
        }, type) || super.isValidLVal(type, isUnparenthesizedInAssign, binding);
      }
      parseBindingAtom() {
        if (this.state.type === 78) {
          return this.parseIdentifier(true);
        }
        return super.parseBindingAtom();
      }
      parseMaybeDecoratorArguments(expr) {
        if (this.match(47) || this.match(51)) {
          const typeArguments = this.tsParseTypeArgumentsInExpression();
          if (this.match(10)) {
            const call = super.parseMaybeDecoratorArguments(expr);
            call.typeParameters = typeArguments;
            return call;
          }
          this.unexpected(null, 10);
        }
        return super.parseMaybeDecoratorArguments(expr);
      }
      checkCommaAfterRest(close) {
        if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {
          this.next();
          return false;
        }
        return super.checkCommaAfterRest(close);
      }
      isClassMethod() {
        return this.match(47) || super.isClassMethod();
      }
      isClassProperty() {
        return this.match(35) || this.match(14) || super.isClassProperty();
      }
      parseMaybeDefault(startLoc, left) {
        const node = super.parseMaybeDefault(startLoc, left);
        if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
          this.raise(TSErrors.TypeAnnotationAfterAssign, node.typeAnnotation);
        }
        return node;
      }
      getTokenFromCode(code2) {
        if (this.state.inType) {
          if (code2 === 62) {
            this.finishOp(48, 1);
            return;
          }
          if (code2 === 60) {
            this.finishOp(47, 1);
            return;
          }
        }
        super.getTokenFromCode(code2);
      }
      reScan_lt_gt() {
        const {
          type
        } = this.state;
        if (type === 47) {
          this.state.pos -= 1;
          this.readToken_lt();
        } else if (type === 48) {
          this.state.pos -= 1;
          this.readToken_gt();
        }
      }
      reScan_lt() {
        const {
          type
        } = this.state;
        if (type === 51) {
          this.state.pos -= 2;
          this.finishOp(47, 1);
          return 47;
        }
        return type;
      }
      toAssignableList(exprList, trailingCommaLoc, isLHS) {
        for (let i = 0; i < exprList.length; i++) {
          const expr = exprList[i];
          if ((expr == null ? void 0 : expr.type) === "TSTypeCastExpression") {
            exprList[i] = this.typeCastToParameter(expr);
          }
        }
        super.toAssignableList(exprList, trailingCommaLoc, isLHS);
      }
      typeCastToParameter(node) {
        node.expression.typeAnnotation = node.typeAnnotation;
        this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
        return node.expression;
      }
      shouldParseArrow(params) {
        if (this.match(14)) {
          return params.every((expr) => this.isAssignable(expr, true));
        }
        return super.shouldParseArrow(params);
      }
      shouldParseAsyncArrow() {
        return this.match(14) || super.shouldParseAsyncArrow();
      }
      canHaveLeadingDecorator() {
        return super.canHaveLeadingDecorator() || this.isAbstractClass();
      }
      jsxParseOpeningElementAfterName(node) {
        if (this.match(47) || this.match(51)) {
          const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
          if (typeArguments)
            node.typeParameters = typeArguments;
        }
        return super.jsxParseOpeningElementAfterName(node);
      }
      getGetterSetterExpectedParamCount(method) {
        const baseCount = super.getGetterSetterExpectedParamCount(method);
        const params = this.getObjectOrClassMethodParams(method);
        const firstParam = params[0];
        const hasContextParam = firstParam && this.isThisParam(firstParam);
        return hasContextParam ? baseCount + 1 : baseCount;
      }
      parseCatchClauseParam() {
        const param = super.parseCatchClauseParam();
        const type = this.tsTryParseTypeAnnotation();
        if (type) {
          param.typeAnnotation = type;
          this.resetEndLocation(param);
        }
        return param;
      }
      tsInAmbientContext(cb) {
        const oldIsAmbientContext = this.state.isAmbientContext;
        this.state.isAmbientContext = true;
        try {
          return cb();
        } finally {
          this.state.isAmbientContext = oldIsAmbientContext;
        }
      }
      parseClass(node, isStatement, optionalId) {
        const oldInAbstractClass = this.state.inAbstractClass;
        this.state.inAbstractClass = !!node.abstract;
        try {
          return super.parseClass(node, isStatement, optionalId);
        } finally {
          this.state.inAbstractClass = oldInAbstractClass;
        }
      }
      tsParseAbstractDeclaration(node, decorators) {
        if (this.match(80)) {
          node.abstract = true;
          return this.maybeTakeDecorators(decorators, this.parseClass(node, true, false));
        } else if (this.isContextual(129)) {
          if (!this.hasFollowingLineBreak()) {
            node.abstract = true;
            this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, node);
            return this.tsParseInterfaceDeclaration(node);
          }
        } else {
          this.unexpected(null, 80);
        }
      }
      parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {
        const method = super.parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
        if (method.abstract) {
          const hasBody = this.hasPlugin("estree") ? !!method.value.body : !!method.body;
          if (hasBody) {
            const {
              key
            } = method;
            this.raise(TSErrors.AbstractMethodHasImplementation, method, {
              methodName: key.type === "Identifier" && !method.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`
            });
          }
        }
        return method;
      }
      tsParseTypeParameterName() {
        const typeName = this.parseIdentifier();
        return typeName.name;
      }
      shouldParseAsAmbientContext() {
        return !!this.getPluginOption("typescript", "dts");
      }
      parse() {
        if (this.shouldParseAsAmbientContext()) {
          this.state.isAmbientContext = true;
        }
        return super.parse();
      }
      getExpression() {
        if (this.shouldParseAsAmbientContext()) {
          this.state.isAmbientContext = true;
        }
        return super.getExpression();
      }
      parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
        if (!isString && isMaybeTypeOnly) {
          this.parseTypeOnlyImportExportSpecifier(node, false, isInTypeExport);
          return this.finishNode(node, "ExportSpecifier");
        }
        node.exportKind = "value";
        return super.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly);
      }
      parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
        if (!importedIsString && isMaybeTypeOnly) {
          this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);
          return this.finishNode(specifier, "ImportSpecifier");
        }
        specifier.importKind = "value";
        return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, isInTypeOnlyImport ? 4098 : 4096);
      }
      parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {
        const leftOfAsKey = isImport ? "imported" : "local";
        const rightOfAsKey = isImport ? "local" : "exported";
        let leftOfAs = node[leftOfAsKey];
        let rightOfAs;
        let hasTypeSpecifier = false;
        let canParseAsKeyword = true;
        const loc = leftOfAs.loc.start;
        if (this.isContextual(93)) {
          const firstAs = this.parseIdentifier();
          if (this.isContextual(93)) {
            const secondAs = this.parseIdentifier();
            if (tokenIsKeywordOrIdentifier(this.state.type)) {
              hasTypeSpecifier = true;
              leftOfAs = firstAs;
              rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
              canParseAsKeyword = false;
            } else {
              rightOfAs = secondAs;
              canParseAsKeyword = false;
            }
          } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
            canParseAsKeyword = false;
            rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
          } else {
            hasTypeSpecifier = true;
            leftOfAs = firstAs;
          }
        } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
          hasTypeSpecifier = true;
          if (isImport) {
            leftOfAs = this.parseIdentifier(true);
            if (!this.isContextual(93)) {
              this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);
            }
          } else {
            leftOfAs = this.parseModuleExportName();
          }
        }
        if (hasTypeSpecifier && isInTypeOnlyImportExport) {
          this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, loc);
        }
        node[leftOfAsKey] = leftOfAs;
        node[rightOfAsKey] = rightOfAs;
        const kindKey = isImport ? "importKind" : "exportKind";
        node[kindKey] = hasTypeSpecifier ? "type" : "value";
        if (canParseAsKeyword && this.eatContextual(93)) {
          node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();
        }
        if (!node[rightOfAsKey]) {
          node[rightOfAsKey] = cloneIdentifier(node[leftOfAsKey]);
        }
        if (isImport) {
          this.checkIdentifier(node[rightOfAsKey], hasTypeSpecifier ? 4098 : 4096);
        }
      }
    };
    function isPossiblyLiteralEnum(expression) {
      if (expression.type !== "MemberExpression")
        return false;
      const {
        computed,
        property
      } = expression;
      if (computed && property.type !== "StringLiteral" && (property.type !== "TemplateLiteral" || property.expressions.length > 0)) {
        return false;
      }
      return isUncomputedMemberExpressionChain(expression.object);
    }
    function isValidAmbientConstInitializer(expression, estree2) {
      var _expression$extra;
      const {
        type
      } = expression;
      if ((_expression$extra = expression.extra) != null && _expression$extra.parenthesized) {
        return false;
      }
      if (estree2) {
        if (type === "Literal") {
          const {
            value
          } = expression;
          if (typeof value === "string" || typeof value === "boolean") {
            return true;
          }
        }
      } else {
        if (type === "StringLiteral" || type === "BooleanLiteral") {
          return true;
        }
      }
      if (isNumber(expression, estree2) || isNegativeNumber(expression, estree2)) {
        return true;
      }
      if (type === "TemplateLiteral" && expression.expressions.length === 0) {
        return true;
      }
      if (isPossiblyLiteralEnum(expression)) {
        return true;
      }
      return false;
    }
    function isNumber(expression, estree2) {
      if (estree2) {
        return expression.type === "Literal" && (typeof expression.value === "number" || "bigint" in expression);
      }
      return expression.type === "NumericLiteral" || expression.type === "BigIntLiteral";
    }
    function isNegativeNumber(expression, estree2) {
      if (expression.type === "UnaryExpression") {
        const {
          operator,
          argument
        } = expression;
        if (operator === "-" && isNumber(argument, estree2)) {
          return true;
        }
      }
      return false;
    }
    function isUncomputedMemberExpressionChain(expression) {
      if (expression.type === "Identifier")
        return true;
      if (expression.type !== "MemberExpression" || expression.computed) {
        return false;
      }
      return isUncomputedMemberExpressionChain(expression.object);
    }
    var PlaceholderErrors = ParseErrorEnum`placeholders`({
      ClassNameIsRequired: "A class name is required.",
      UnexpectedSpace: "Unexpected space in placeholder."
    });
    var placeholders = (superClass) => class PlaceholdersParserMixin extends superClass {
      parsePlaceholder(expectedNode) {
        if (this.match(144)) {
          const node = this.startNode();
          this.next();
          this.assertNoSpace();
          node.name = super.parseIdentifier(true);
          this.assertNoSpace();
          this.expect(144);
          return this.finishPlaceholder(node, expectedNode);
        }
      }
      finishPlaceholder(node, expectedNode) {
        let placeholder = node;
        if (!placeholder.expectedNode || !placeholder.type) {
          placeholder = this.finishNode(placeholder, "Placeholder");
        }
        placeholder.expectedNode = expectedNode;
        return placeholder;
      }
      getTokenFromCode(code2) {
        if (code2 === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
          this.finishOp(144, 2);
        } else {
          super.getTokenFromCode(code2);
        }
      }
      parseExprAtom(refExpressionErrors) {
        return this.parsePlaceholder("Expression") || super.parseExprAtom(refExpressionErrors);
      }
      parseIdentifier(liberal) {
        return this.parsePlaceholder("Identifier") || super.parseIdentifier(liberal);
      }
      checkReservedWord(word, startLoc, checkKeywords, isBinding) {
        if (word !== void 0) {
          super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
        }
      }
      parseBindingAtom() {
        return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
      }
      isValidLVal(type, isParenthesized, binding) {
        return type === "Placeholder" || super.isValidLVal(type, isParenthesized, binding);
      }
      toAssignable(node, isLHS) {
        if (node && node.type === "Placeholder" && node.expectedNode === "Expression") {
          node.expectedNode = "Pattern";
        } else {
          super.toAssignable(node, isLHS);
        }
      }
      chStartsBindingIdentifier(ch, pos) {
        if (super.chStartsBindingIdentifier(ch, pos)) {
          return true;
        }
        const nextToken = this.lookahead();
        if (nextToken.type === 144) {
          return true;
        }
        return false;
      }
      verifyBreakContinue(node, isBreak) {
        if (node.label && node.label.type === "Placeholder")
          return;
        super.verifyBreakContinue(node, isBreak);
      }
      parseExpressionStatement(node, expr) {
        var _expr$extra;
        if (expr.type !== "Placeholder" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
          return super.parseExpressionStatement(node, expr);
        }
        if (this.match(14)) {
          const stmt = node;
          stmt.label = this.finishPlaceholder(expr, "Identifier");
          this.next();
          stmt.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration();
          return this.finishNode(stmt, "LabeledStatement");
        }
        this.semicolon();
        const stmtPlaceholder = node;
        stmtPlaceholder.name = expr.name;
        return this.finishPlaceholder(stmtPlaceholder, "Statement");
      }
      parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
        return this.parsePlaceholder("BlockStatement") || super.parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse);
      }
      parseFunctionId(requireId) {
        return this.parsePlaceholder("Identifier") || super.parseFunctionId(requireId);
      }
      parseClass(node, isStatement, optionalId) {
        const type = isStatement ? "ClassDeclaration" : "ClassExpression";
        this.next();
        const oldStrict = this.state.strict;
        const placeholder = this.parsePlaceholder("Identifier");
        if (placeholder) {
          if (this.match(81) || this.match(144) || this.match(5)) {
            node.id = placeholder;
          } else if (optionalId || !isStatement) {
            node.id = null;
            node.body = this.finishPlaceholder(placeholder, "ClassBody");
            return this.finishNode(node, type);
          } else {
            throw this.raise(PlaceholderErrors.ClassNameIsRequired, this.state.startLoc);
          }
        } else {
          this.parseClassId(node, isStatement, optionalId);
        }
        super.parseClassSuper(node);
        node.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!node.superClass, oldStrict);
        return this.finishNode(node, type);
      }
      parseExport(node, decorators) {
        const placeholder = this.parsePlaceholder("Identifier");
        if (!placeholder)
          return super.parseExport(node, decorators);
        const node2 = node;
        if (!this.isContextual(98) && !this.match(12)) {
          node2.specifiers = [];
          node2.source = null;
          node2.declaration = this.finishPlaceholder(placeholder, "Declaration");
          return this.finishNode(node2, "ExportNamedDeclaration");
        }
        this.expectPlugin("exportDefaultFrom");
        const specifier = this.startNode();
        specifier.exported = placeholder;
        node2.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
        return super.parseExport(node2, decorators);
      }
      isExportDefaultSpecifier() {
        if (this.match(65)) {
          const next = this.nextTokenStart();
          if (this.isUnparsedContextual(next, "from")) {
            if (this.input.startsWith(tokenLabelName(144), this.nextTokenStartSince(next + 4))) {
              return true;
            }
          }
        }
        return super.isExportDefaultSpecifier();
      }
      maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
        var _specifiers;
        if ((_specifiers = node.specifiers) != null && _specifiers.length) {
          return true;
        }
        return super.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);
      }
      checkExport(node) {
        const {
          specifiers
        } = node;
        if (specifiers != null && specifiers.length) {
          node.specifiers = specifiers.filter((node2) => node2.exported.type === "Placeholder");
        }
        super.checkExport(node);
        node.specifiers = specifiers;
      }
      parseImport(node) {
        const placeholder = this.parsePlaceholder("Identifier");
        if (!placeholder)
          return super.parseImport(node);
        node.specifiers = [];
        if (!this.isContextual(98) && !this.match(12)) {
          node.source = this.finishPlaceholder(placeholder, "StringLiteral");
          this.semicolon();
          return this.finishNode(node, "ImportDeclaration");
        }
        const specifier = this.startNodeAtNode(placeholder);
        specifier.local = placeholder;
        node.specifiers.push(this.finishNode(specifier, "ImportDefaultSpecifier"));
        if (this.eat(12)) {
          const hasStarImport = this.maybeParseStarImportSpecifier(node);
          if (!hasStarImport)
            this.parseNamedImportSpecifiers(node);
        }
        this.expectContextual(98);
        node.source = this.parseImportSource();
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      }
      parseImportSource() {
        return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
      }
      assertNoSpace() {
        if (this.state.start > this.state.lastTokEndLoc.index) {
          this.raise(PlaceholderErrors.UnexpectedSpace, this.state.lastTokEndLoc);
        }
      }
    };
    var v8intrinsic = (superClass) => class V8IntrinsicMixin extends superClass {
      parseV8Intrinsic() {
        if (this.match(54)) {
          const v8IntrinsicStartLoc = this.state.startLoc;
          const node = this.startNode();
          this.next();
          if (tokenIsIdentifier(this.state.type)) {
            const name = this.parseIdentifierName();
            const identifier = this.createIdentifier(node, name);
            identifier.type = "V8IntrinsicIdentifier";
            if (this.match(10)) {
              return identifier;
            }
          }
          this.unexpected(v8IntrinsicStartLoc);
        }
      }
      parseExprAtom(refExpressionErrors) {
        return this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors);
      }
    };
    function hasPlugin(plugins, expectedConfig) {
      const [expectedName, expectedOptions] = typeof expectedConfig === "string" ? [expectedConfig, {}] : expectedConfig;
      const expectedKeys = Object.keys(expectedOptions);
      const expectedOptionsIsEmpty = expectedKeys.length === 0;
      return plugins.some((p) => {
        if (typeof p === "string") {
          return expectedOptionsIsEmpty && p === expectedName;
        } else {
          const [pluginName, pluginOptions] = p;
          if (pluginName !== expectedName) {
            return false;
          }
          for (const key of expectedKeys) {
            if (pluginOptions[key] !== expectedOptions[key]) {
              return false;
            }
          }
          return true;
        }
      });
    }
    function getPluginOption(plugins, name, option) {
      const plugin = plugins.find((plugin2) => {
        if (Array.isArray(plugin2)) {
          return plugin2[0] === name;
        } else {
          return plugin2 === name;
        }
      });
      if (plugin && Array.isArray(plugin) && plugin.length > 1) {
        return plugin[1][option];
      }
      return null;
    }
    var PIPELINE_PROPOSALS = ["minimal", "fsharp", "hack", "smart"];
    var TOPIC_TOKENS = ["^^", "@@", "^", "%", "#"];
    function validatePlugins(plugins) {
      if (hasPlugin(plugins, "decorators")) {
        if (hasPlugin(plugins, "decorators-legacy")) {
          throw new Error("Cannot use the decorators and decorators-legacy plugin together");
        }
        const decoratorsBeforeExport = getPluginOption(plugins, "decorators", "decoratorsBeforeExport");
        if (decoratorsBeforeExport != null && typeof decoratorsBeforeExport !== "boolean") {
          throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
        }
        const allowCallParenthesized = getPluginOption(plugins, "decorators", "allowCallParenthesized");
        if (allowCallParenthesized != null && typeof allowCallParenthesized !== "boolean") {
          throw new Error("'allowCallParenthesized' must be a boolean.");
        }
      }
      if (hasPlugin(plugins, "flow") && hasPlugin(plugins, "typescript")) {
        throw new Error("Cannot combine flow and typescript plugins.");
      }
      if (hasPlugin(plugins, "placeholders") && hasPlugin(plugins, "v8intrinsic")) {
        throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
      }
      if (hasPlugin(plugins, "pipelineOperator")) {
        const proposal = getPluginOption(plugins, "pipelineOperator", "proposal");
        if (!PIPELINE_PROPOSALS.includes(proposal)) {
          const proposalList = PIPELINE_PROPOSALS.map((p) => `"${p}"`).join(", ");
          throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${proposalList}.`);
        }
        const recordAndTupleConfigItem = ["recordAndTuple", {
          syntaxType: "hash"
        }];
        const tupleSyntaxIsHash = hasPlugin(plugins, recordAndTupleConfigItem);
        if (proposal === "hack") {
          if (hasPlugin(plugins, "placeholders")) {
            throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
          }
          if (hasPlugin(plugins, "v8intrinsic")) {
            throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
          }
          const topicToken = getPluginOption(plugins, "pipelineOperator", "topicToken");
          if (!TOPIC_TOKENS.includes(topicToken)) {
            const tokenList = TOPIC_TOKENS.map((t) => `"${t}"`).join(", ");
            throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${tokenList}.`);
          }
          if (topicToken === "#" && tupleSyntaxIsHash) {
            throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(recordAndTupleConfigItem)}\`.`);
          }
        } else if (proposal === "smart" && tupleSyntaxIsHash) {
          throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(recordAndTupleConfigItem)}\`.`);
        }
      }
      if (hasPlugin(plugins, "moduleAttributes")) {
        {
          if (hasPlugin(plugins, "importAssertions") || hasPlugin(plugins, "importAttributes")) {
            throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
          }
          const moduleAttributesVersionPluginOption = getPluginOption(plugins, "moduleAttributes", "version");
          if (moduleAttributesVersionPluginOption !== "may-2020") {
            throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
          }
        }
      }
      if (hasPlugin(plugins, "importAssertions") && hasPlugin(plugins, "importAttributes")) {
        throw new Error("Cannot combine importAssertions and importAttributes plugins.");
      }
      if (hasPlugin(plugins, "recordAndTuple")) {
        const syntaxType = getPluginOption(plugins, "recordAndTuple", "syntaxType");
        if (syntaxType != null) {
          {
            const RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
            if (!RECORD_AND_TUPLE_SYNTAX_TYPES.includes(syntaxType)) {
              throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map((p) => `'${p}'`).join(", "));
            }
          }
        }
      }
      if (hasPlugin(plugins, "asyncDoExpressions") && !hasPlugin(plugins, "doExpressions")) {
        const error = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
        error.missingPlugins = "doExpressions";
        throw error;
      }
      if (hasPlugin(plugins, "optionalChainingAssign") && getPluginOption(plugins, "optionalChainingAssign", "version") !== "2023-07") {
        throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
      }
    }
    var mixinPlugins = {
      estree,
      jsx,
      flow,
      typescript,
      v8intrinsic,
      placeholders
    };
    var mixinPluginNames = Object.keys(mixinPlugins);
    var defaultOptions = {
      sourceType: "script",
      sourceFilename: void 0,
      startColumn: 0,
      startLine: 1,
      allowAwaitOutsideFunction: false,
      allowReturnOutsideFunction: false,
      allowNewTargetOutsideFunction: false,
      allowImportExportEverywhere: false,
      allowSuperOutsideMethod: false,
      allowUndeclaredExports: false,
      plugins: [],
      strictMode: null,
      ranges: false,
      tokens: false,
      createImportExpressions: false,
      createParenthesizedExpressions: false,
      errorRecovery: false,
      attachComment: true,
      annexB: true
    };
    function getOptions(opts) {
      if (opts == null) {
        return Object.assign({}, defaultOptions);
      }
      if (opts.annexB != null && opts.annexB !== false) {
        throw new Error("The `annexB` option can only be set to `false`.");
      }
      const options = {};
      for (const key of Object.keys(defaultOptions)) {
        var _opts$key;
        options[key] = (_opts$key = opts[key]) != null ? _opts$key : defaultOptions[key];
      }
      return options;
    }
    var ExpressionParser = class extends LValParser {
      checkProto(prop, isRecord, protoRef, refExpressionErrors) {
        if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {
          return;
        }
        const key = prop.key;
        const name = key.type === "Identifier" ? key.name : key.value;
        if (name === "__proto__") {
          if (isRecord) {
            this.raise(Errors.RecordNoProto, key);
            return;
          }
          if (protoRef.used) {
            if (refExpressionErrors) {
              if (refExpressionErrors.doubleProtoLoc === null) {
                refExpressionErrors.doubleProtoLoc = key.loc.start;
              }
            } else {
              this.raise(Errors.DuplicateProto, key);
            }
          }
          protoRef.used = true;
        }
      }
      shouldExitDescending(expr, potentialArrowAt) {
        return expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt;
      }
      getExpression() {
        this.enterInitialScopes();
        this.nextToken();
        const expr = this.parseExpression();
        if (!this.match(139)) {
          this.unexpected();
        }
        this.finalizeRemainingComments();
        expr.comments = this.comments;
        expr.errors = this.state.errors;
        if (this.options.tokens) {
          expr.tokens = this.tokens;
        }
        return expr;
      }
      parseExpression(disallowIn, refExpressionErrors) {
        if (disallowIn) {
          return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));
        }
        return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));
      }
      parseExpressionBase(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const expr = this.parseMaybeAssign(refExpressionErrors);
        if (this.match(12)) {
          const node = this.startNodeAt(startLoc);
          node.expressions = [expr];
          while (this.eat(12)) {
            node.expressions.push(this.parseMaybeAssign(refExpressionErrors));
          }
          this.toReferencedList(node.expressions);
          return this.finishNode(node, "SequenceExpression");
        }
        return expr;
      }
      parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
        return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
      }
      parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
        return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
      }
      setOptionalParametersError(refExpressionErrors, resultError) {
        var _resultError$loc;
        refExpressionErrors.optionalParametersLoc = (_resultError$loc = resultError == null ? void 0 : resultError.loc) != null ? _resultError$loc : this.state.startLoc;
      }
      parseMaybeAssign(refExpressionErrors, afterLeftParse) {
        const startLoc = this.state.startLoc;
        if (this.isContextual(108)) {
          if (this.prodParam.hasYield) {
            let left2 = this.parseYield();
            if (afterLeftParse) {
              left2 = afterLeftParse.call(this, left2, startLoc);
            }
            return left2;
          }
        }
        let ownExpressionErrors;
        if (refExpressionErrors) {
          ownExpressionErrors = false;
        } else {
          refExpressionErrors = new ExpressionErrors();
          ownExpressionErrors = true;
        }
        const {
          type
        } = this.state;
        if (type === 10 || tokenIsIdentifier(type)) {
          this.state.potentialArrowAt = this.state.start;
        }
        let left = this.parseMaybeConditional(refExpressionErrors);
        if (afterLeftParse) {
          left = afterLeftParse.call(this, left, startLoc);
        }
        if (tokenIsAssignment(this.state.type)) {
          const node = this.startNodeAt(startLoc);
          const operator = this.state.value;
          node.operator = operator;
          if (this.match(29)) {
            this.toAssignable(left, true);
            node.left = left;
            const startIndex = startLoc.index;
            if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startIndex) {
              refExpressionErrors.doubleProtoLoc = null;
            }
            if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startIndex) {
              refExpressionErrors.shorthandAssignLoc = null;
            }
            if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startIndex) {
              this.checkDestructuringPrivate(refExpressionErrors);
              refExpressionErrors.privateKeyLoc = null;
            }
          } else {
            node.left = left;
          }
          this.next();
          node.right = this.parseMaybeAssign();
          this.checkLVal(left, {
            in: this.finishNode(node, "AssignmentExpression")
          });
          return node;
        } else if (ownExpressionErrors) {
          this.checkExpressionErrors(refExpressionErrors, true);
        }
        return left;
      }
      parseMaybeConditional(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseExprOps(refExpressionErrors);
        if (this.shouldExitDescending(expr, potentialArrowAt)) {
          return expr;
        }
        return this.parseConditional(expr, startLoc, refExpressionErrors);
      }
      parseConditional(expr, startLoc, refExpressionErrors) {
        if (this.eat(17)) {
          const node = this.startNodeAt(startLoc);
          node.test = expr;
          node.consequent = this.parseMaybeAssignAllowIn();
          this.expect(14);
          node.alternate = this.parseMaybeAssign();
          return this.finishNode(node, "ConditionalExpression");
        }
        return expr;
      }
      parseMaybeUnaryOrPrivate(refExpressionErrors) {
        return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);
      }
      parseExprOps(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);
        if (this.shouldExitDescending(expr, potentialArrowAt)) {
          return expr;
        }
        return this.parseExprOp(expr, startLoc, -1);
      }
      parseExprOp(left, leftStartLoc, minPrec) {
        if (this.isPrivateName(left)) {
          const value = this.getPrivateNameSV(left);
          if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {
            this.raise(Errors.PrivateInExpectedIn, left, {
              identifierName: value
            });
          }
          this.classScope.usePrivateName(value, left.loc.start);
        }
        const op = this.state.type;
        if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {
          let prec = tokenOperatorPrecedence(op);
          if (prec > minPrec) {
            if (op === 39) {
              this.expectPlugin("pipelineOperator");
              if (this.state.inFSharpPipelineDirectBody) {
                return left;
              }
              this.checkPipelineAtInfixOperator(left, leftStartLoc);
            }
            const node = this.startNodeAt(leftStartLoc);
            node.left = left;
            node.operator = this.state.value;
            const logical = op === 41 || op === 42;
            const coalesce = op === 40;
            if (coalesce) {
              prec = tokenOperatorPrecedence(42);
            }
            this.next();
            if (op === 39 && this.hasPlugin(["pipelineOperator", {
              proposal: "minimal"
            }])) {
              if (this.state.type === 96 && this.prodParam.hasAwait) {
                throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
              }
            }
            node.right = this.parseExprOpRightExpr(op, prec);
            const finishedNode = this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
            const nextOp = this.state.type;
            if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {
              throw this.raise(Errors.MixingCoalesceWithLogical, this.state.startLoc);
            }
            return this.parseExprOp(finishedNode, leftStartLoc, minPrec);
          }
        }
        return left;
      }
      parseExprOpRightExpr(op, prec) {
        const startLoc = this.state.startLoc;
        switch (op) {
          case 39:
            switch (this.getPluginOption("pipelineOperator", "proposal")) {
              case "hack":
                return this.withTopicBindingContext(() => {
                  return this.parseHackPipeBody();
                });
              case "smart":
                return this.withTopicBindingContext(() => {
                  if (this.prodParam.hasYield && this.isContextual(108)) {
                    throw this.raise(Errors.PipeBodyIsTighter, this.state.startLoc);
                  }
                  return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startLoc);
                });
              case "fsharp":
                return this.withSoloAwaitPermittingContext(() => {
                  return this.parseFSharpPipelineBody(prec);
                });
            }
          default:
            return this.parseExprOpBaseRightExpr(op, prec);
        }
      }
      parseExprOpBaseRightExpr(op, prec) {
        const startLoc = this.state.startLoc;
        return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);
      }
      parseHackPipeBody() {
        var _body$extra;
        const {
          startLoc
        } = this.state;
        const body = this.parseMaybeAssign();
        const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body.type);
        if (requiredParentheses && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {
          this.raise(Errors.PipeUnparenthesizedBody, startLoc, {
            type: body.type
          });
        }
        if (!this.topicReferenceWasUsedInCurrentContext()) {
          this.raise(Errors.PipeTopicUnused, startLoc);
        }
        return body;
      }
      checkExponentialAfterUnary(node) {
        if (this.match(57)) {
          this.raise(Errors.UnexpectedTokenUnaryExponentiation, node.argument);
        }
      }
      parseMaybeUnary(refExpressionErrors, sawUnary) {
        const startLoc = this.state.startLoc;
        const isAwait = this.isContextual(96);
        if (isAwait && this.isAwaitAllowed()) {
          this.next();
          const expr2 = this.parseAwait(startLoc);
          if (!sawUnary)
            this.checkExponentialAfterUnary(expr2);
          return expr2;
        }
        const update = this.match(34);
        const node = this.startNode();
        if (tokenIsPrefix(this.state.type)) {
          node.operator = this.state.value;
          node.prefix = true;
          if (this.match(72)) {
            this.expectPlugin("throwExpressions");
          }
          const isDelete = this.match(89);
          this.next();
          node.argument = this.parseMaybeUnary(null, true);
          this.checkExpressionErrors(refExpressionErrors, true);
          if (this.state.strict && isDelete) {
            const arg = node.argument;
            if (arg.type === "Identifier") {
              this.raise(Errors.StrictDelete, node);
            } else if (this.hasPropertyAsPrivateName(arg)) {
              this.raise(Errors.DeletePrivateField, node);
            }
          }
          if (!update) {
            if (!sawUnary) {
              this.checkExponentialAfterUnary(node);
            }
            return this.finishNode(node, "UnaryExpression");
          }
        }
        const expr = this.parseUpdate(node, update, refExpressionErrors);
        if (isAwait) {
          const {
            type
          } = this.state;
          const startsExpr2 = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);
          if (startsExpr2 && !this.isAmbiguousAwait()) {
            this.raiseOverwrite(Errors.AwaitNotInAsyncContext, startLoc);
            return this.parseAwait(startLoc);
          }
        }
        return expr;
      }
      parseUpdate(node, update, refExpressionErrors) {
        if (update) {
          const updateExpressionNode = node;
          this.checkLVal(updateExpressionNode.argument, {
            in: this.finishNode(updateExpressionNode, "UpdateExpression")
          });
          return node;
        }
        const startLoc = this.state.startLoc;
        let expr = this.parseExprSubscripts(refExpressionErrors);
        if (this.checkExpressionErrors(refExpressionErrors, false))
          return expr;
        while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {
          const node2 = this.startNodeAt(startLoc);
          node2.operator = this.state.value;
          node2.prefix = false;
          node2.argument = expr;
          this.next();
          this.checkLVal(expr, {
            in: expr = this.finishNode(node2, "UpdateExpression")
          });
        }
        return expr;
      }
      parseExprSubscripts(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseExprAtom(refExpressionErrors);
        if (this.shouldExitDescending(expr, potentialArrowAt)) {
          return expr;
        }
        return this.parseSubscripts(expr, startLoc);
      }
      parseSubscripts(base, startLoc, noCalls) {
        const state = {
          optionalChainMember: false,
          maybeAsyncArrow: this.atPossibleAsyncArrow(base),
          stop: false
        };
        do {
          base = this.parseSubscript(base, startLoc, noCalls, state);
          state.maybeAsyncArrow = false;
        } while (!state.stop);
        return base;
      }
      parseSubscript(base, startLoc, noCalls, state) {
        const {
          type
        } = this.state;
        if (!noCalls && type === 15) {
          return this.parseBind(base, startLoc, noCalls, state);
        } else if (tokenIsTemplate(type)) {
          return this.parseTaggedTemplateExpression(base, startLoc, state);
        }
        let optional = false;
        if (type === 18) {
          if (noCalls) {
            this.raise(Errors.OptionalChainingNoNew, this.state.startLoc);
            if (this.lookaheadCharCode() === 40) {
              state.stop = true;
              return base;
            }
          }
          state.optionalChainMember = optional = true;
          this.next();
        }
        if (!noCalls && this.match(10)) {
          return this.parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional);
        } else {
          const computed = this.eat(0);
          if (computed || optional || this.eat(16)) {
            return this.parseMember(base, startLoc, state, computed, optional);
          } else {
            state.stop = true;
            return base;
          }
        }
      }
      parseMember(base, startLoc, state, computed, optional) {
        const node = this.startNodeAt(startLoc);
        node.object = base;
        node.computed = computed;
        if (computed) {
          node.property = this.parseExpression();
          this.expect(3);
        } else if (this.match(138)) {
          if (base.type === "Super") {
            this.raise(Errors.SuperPrivateField, startLoc);
          }
          this.classScope.usePrivateName(this.state.value, this.state.startLoc);
          node.property = this.parsePrivateName();
        } else {
          node.property = this.parseIdentifier(true);
        }
        if (state.optionalChainMember) {
          node.optional = optional;
          return this.finishNode(node, "OptionalMemberExpression");
        } else {
          return this.finishNode(node, "MemberExpression");
        }
      }
      parseBind(base, startLoc, noCalls, state) {
        const node = this.startNodeAt(startLoc);
        node.object = base;
        this.next();
        node.callee = this.parseNoCallExpr();
        state.stop = true;
        return this.parseSubscripts(this.finishNode(node, "BindExpression"), startLoc, noCalls);
      }
      parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional) {
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        let refExpressionErrors = null;
        this.state.maybeInArrowParameters = true;
        this.next();
        const node = this.startNodeAt(startLoc);
        node.callee = base;
        const {
          maybeAsyncArrow,
          optionalChainMember
        } = state;
        if (maybeAsyncArrow) {
          this.expressionScope.enter(newAsyncArrowScope());
          refExpressionErrors = new ExpressionErrors();
        }
        if (optionalChainMember) {
          node.optional = optional;
        }
        if (optional) {
          node.arguments = this.parseCallExpressionArguments(11);
        } else {
          node.arguments = this.parseCallExpressionArguments(11, base.type === "Import", base.type !== "Super", node, refExpressionErrors);
        }
        let finishedNode = this.finishCallExpression(node, optionalChainMember);
        if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
          state.stop = true;
          this.checkDestructuringPrivate(refExpressionErrors);
          this.expressionScope.validateAsPattern();
          this.expressionScope.exit();
          finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc), finishedNode);
        } else {
          if (maybeAsyncArrow) {
            this.checkExpressionErrors(refExpressionErrors, true);
            this.expressionScope.exit();
          }
          this.toReferencedArguments(finishedNode);
        }
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return finishedNode;
      }
      toReferencedArguments(node, isParenthesizedExpr) {
        this.toReferencedListDeep(node.arguments, isParenthesizedExpr);
      }
      parseTaggedTemplateExpression(base, startLoc, state) {
        const node = this.startNodeAt(startLoc);
        node.tag = base;
        node.quasi = this.parseTemplate(true);
        if (state.optionalChainMember) {
          this.raise(Errors.OptionalChainingNoTemplate, startLoc);
        }
        return this.finishNode(node, "TaggedTemplateExpression");
      }
      atPossibleAsyncArrow(base) {
        return base.type === "Identifier" && base.name === "async" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;
      }
      expectImportAttributesPlugin() {
        if (!this.hasPlugin("importAssertions")) {
          this.expectPlugin("importAttributes");
        }
      }
      finishCallExpression(node, optional) {
        if (node.callee.type === "Import") {
          if (node.arguments.length === 2) {
            {
              if (!this.hasPlugin("moduleAttributes")) {
                this.expectImportAttributesPlugin();
              }
            }
          }
          if (node.arguments.length === 0 || node.arguments.length > 2) {
            this.raise(Errors.ImportCallArity, node, {
              maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1
            });
          } else {
            for (const arg of node.arguments) {
              if (arg.type === "SpreadElement") {
                this.raise(Errors.ImportCallSpreadArgument, arg);
              }
            }
          }
        }
        return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
      }
      parseCallExpressionArguments(close, dynamicImport, allowPlaceholder, nodeForExtra, refExpressionErrors) {
        const elts = [];
        let first = true;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = false;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
            if (this.match(close)) {
              if (dynamicImport && !this.hasPlugin("importAttributes") && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes")) {
                this.raise(Errors.ImportCallArgumentTrailingComma, this.state.lastTokStartLoc);
              }
              if (nodeForExtra) {
                this.addTrailingCommaExtraToNode(nodeForExtra);
              }
              this.next();
              break;
            }
          }
          elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));
        }
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return elts;
      }
      shouldParseAsyncArrow() {
        return this.match(19) && !this.canInsertSemicolon();
      }
      parseAsyncArrowFromCallExpression(node, call) {
        var _call$extra;
        this.resetPreviousNodeTrailingComments(call);
        this.expect(19);
        this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingCommaLoc);
        if (call.innerComments) {
          setInnerComments(node, call.innerComments);
        }
        if (call.callee.trailingComments) {
          setInnerComments(node, call.callee.trailingComments);
        }
        return node;
      }
      parseNoCallExpr() {
        const startLoc = this.state.startLoc;
        return this.parseSubscripts(this.parseExprAtom(), startLoc, true);
      }
      parseExprAtom(refExpressionErrors) {
        let node;
        let decorators = null;
        const {
          type
        } = this.state;
        switch (type) {
          case 79:
            return this.parseSuper();
          case 83:
            node = this.startNode();
            this.next();
            if (this.match(16)) {
              return this.parseImportMetaProperty(node);
            }
            if (this.match(10)) {
              if (this.options.createImportExpressions) {
                return this.parseImportCall(node);
              } else {
                return this.finishNode(node, "Import");
              }
            } else {
              this.raise(Errors.UnsupportedImport, this.state.lastTokStartLoc);
              return this.finishNode(node, "Import");
            }
          case 78:
            node = this.startNode();
            this.next();
            return this.finishNode(node, "ThisExpression");
          case 90: {
            return this.parseDo(this.startNode(), false);
          }
          case 56:
          case 31: {
            this.readRegexp();
            return this.parseRegExpLiteral(this.state.value);
          }
          case 134:
            return this.parseNumericLiteral(this.state.value);
          case 135:
            return this.parseBigIntLiteral(this.state.value);
          case 136:
            return this.parseDecimalLiteral(this.state.value);
          case 133:
            return this.parseStringLiteral(this.state.value);
          case 84:
            return this.parseNullLiteral();
          case 85:
            return this.parseBooleanLiteral(true);
          case 86:
            return this.parseBooleanLiteral(false);
          case 10: {
            const canBeArrow = this.state.potentialArrowAt === this.state.start;
            return this.parseParenAndDistinguishExpression(canBeArrow);
          }
          case 2:
          case 1: {
            return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
          }
          case 0: {
            return this.parseArrayLike(3, true, false, refExpressionErrors);
          }
          case 6:
          case 7: {
            return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
          }
          case 5: {
            return this.parseObjectLike(8, false, false, refExpressionErrors);
          }
          case 68:
            return this.parseFunctionOrFunctionSent();
          case 26:
            decorators = this.parseDecorators();
          case 80:
            return this.parseClass(this.maybeTakeDecorators(decorators, this.startNode()), false);
          case 77:
            return this.parseNewOrNewTarget();
          case 25:
          case 24:
            return this.parseTemplate(false);
          case 15: {
            node = this.startNode();
            this.next();
            node.object = null;
            const callee = node.callee = this.parseNoCallExpr();
            if (callee.type === "MemberExpression") {
              return this.finishNode(node, "BindExpression");
            } else {
              throw this.raise(Errors.UnsupportedBind, callee);
            }
          }
          case 138: {
            this.raise(Errors.PrivateInExpectedIn, this.state.startLoc, {
              identifierName: this.state.value
            });
            return this.parsePrivateName();
          }
          case 33: {
            return this.parseTopicReferenceThenEqualsSign(54, "%");
          }
          case 32: {
            return this.parseTopicReferenceThenEqualsSign(44, "^");
          }
          case 37:
          case 38: {
            return this.parseTopicReference("hack");
          }
          case 44:
          case 54:
          case 27: {
            const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
            if (pipeProposal) {
              return this.parseTopicReference(pipeProposal);
            }
            this.unexpected();
            break;
          }
          case 47: {
            const lookaheadCh = this.input.codePointAt(this.nextTokenStart());
            if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {
              this.expectOnePlugin(["jsx", "flow", "typescript"]);
            } else {
              this.unexpected();
            }
            break;
          }
          default:
            if (tokenIsIdentifier(type)) {
              if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123) {
                return this.parseModuleExpression();
              }
              const canBeArrow = this.state.potentialArrowAt === this.state.start;
              const containsEsc = this.state.containsEsc;
              const id = this.parseIdentifier();
              if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
                const {
                  type: type2
                } = this.state;
                if (type2 === 68) {
                  this.resetPreviousNodeTrailingComments(id);
                  this.next();
                  return this.parseAsyncFunctionExpression(this.startNodeAtNode(id));
                } else if (tokenIsIdentifier(type2)) {
                  if (this.lookaheadCharCode() === 61) {
                    return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));
                  } else {
                    return id;
                  }
                } else if (type2 === 90) {
                  this.resetPreviousNodeTrailingComments(id);
                  return this.parseDo(this.startNodeAtNode(id), true);
                }
              }
              if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {
                this.next();
                return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);
              }
              return id;
            } else {
              this.unexpected();
            }
        }
      }
      parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
        const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
        if (pipeProposal) {
          this.state.type = topicTokenType;
          this.state.value = topicTokenValue;
          this.state.pos--;
          this.state.end--;
          this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);
          return this.parseTopicReference(pipeProposal);
        } else {
          this.unexpected();
        }
      }
      parseTopicReference(pipeProposal) {
        const node = this.startNode();
        const startLoc = this.state.startLoc;
        const tokenType = this.state.type;
        this.next();
        return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);
      }
      finishTopicReference(node, startLoc, pipeProposal, tokenType) {
        if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {
          const nodeType = pipeProposal === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
          if (!this.topicReferenceIsAllowedInCurrentContext()) {
            this.raise(pipeProposal === "smart" ? Errors.PrimaryTopicNotAllowed : Errors.PipeTopicUnbound, startLoc);
          }
          this.registerTopicReference();
          return this.finishNode(node, nodeType);
        } else {
          throw this.raise(Errors.PipeTopicUnconfiguredToken, startLoc, {
            token: tokenLabelName(tokenType)
          });
        }
      }
      testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {
        switch (pipeProposal) {
          case "hack": {
            return this.hasPlugin(["pipelineOperator", {
              topicToken: tokenLabelName(tokenType)
            }]);
          }
          case "smart":
            return tokenType === 27;
          default:
            throw this.raise(Errors.PipeTopicRequiresHackPipes, startLoc);
        }
      }
      parseAsyncArrowUnaryFunction(node) {
        this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
        const params = [this.parseIdentifier()];
        this.prodParam.exit();
        if (this.hasPrecedingLineBreak()) {
          this.raise(Errors.LineTerminatorBeforeArrow, this.state.curPosition());
        }
        this.expect(19);
        return this.parseArrowExpression(node, params, true);
      }
      parseDo(node, isAsync) {
        this.expectPlugin("doExpressions");
        if (isAsync) {
          this.expectPlugin("asyncDoExpressions");
        }
        node.async = isAsync;
        this.next();
        const oldLabels = this.state.labels;
        this.state.labels = [];
        if (isAsync) {
          this.prodParam.enter(2);
          node.body = this.parseBlock();
          this.prodParam.exit();
        } else {
          node.body = this.parseBlock();
        }
        this.state.labels = oldLabels;
        return this.finishNode(node, "DoExpression");
      }
      parseSuper() {
        const node = this.startNode();
        this.next();
        if (this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {
          this.raise(Errors.SuperNotAllowed, node);
        } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {
          this.raise(Errors.UnexpectedSuper, node);
        }
        if (!this.match(10) && !this.match(0) && !this.match(16)) {
          this.raise(Errors.UnsupportedSuper, node);
        }
        return this.finishNode(node, "Super");
      }
      parsePrivateName() {
        const node = this.startNode();
        const id = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1));
        const name = this.state.value;
        this.next();
        node.id = this.createIdentifier(id, name);
        return this.finishNode(node, "PrivateName");
      }
      parseFunctionOrFunctionSent() {
        const node = this.startNode();
        this.next();
        if (this.prodParam.hasYield && this.match(16)) {
          const meta = this.createIdentifier(this.startNodeAtNode(node), "function");
          this.next();
          if (this.match(103)) {
            this.expectPlugin("functionSent");
          } else if (!this.hasPlugin("functionSent")) {
            this.unexpected();
          }
          return this.parseMetaProperty(node, meta, "sent");
        }
        return this.parseFunction(node);
      }
      parseMetaProperty(node, meta, propertyName) {
        node.meta = meta;
        const containsEsc = this.state.containsEsc;
        node.property = this.parseIdentifier(true);
        if (node.property.name !== propertyName || containsEsc) {
          this.raise(Errors.UnsupportedMetaProperty, node.property, {
            target: meta.name,
            onlyValidPropertyName: propertyName
          });
        }
        return this.finishNode(node, "MetaProperty");
      }
      parseImportMetaProperty(node) {
        const id = this.createIdentifier(this.startNodeAtNode(node), "import");
        this.next();
        if (this.isContextual(101)) {
          if (!this.inModule) {
            this.raise(Errors.ImportMetaOutsideModule, id);
          }
          this.sawUnambiguousESM = true;
        } else if (this.isContextual(105) || this.isContextual(97)) {
          const isSource = this.isContextual(105);
          if (!isSource)
            this.unexpected();
          this.expectPlugin(isSource ? "sourcePhaseImports" : "deferredImportEvaluation");
          if (!this.options.createImportExpressions) {
            throw this.raise(Errors.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, {
              phase: this.state.value
            });
          }
          this.next();
          node.phase = isSource ? "source" : "defer";
          return this.parseImportCall(node);
        }
        return this.parseMetaProperty(node, id, "meta");
      }
      parseLiteralAtNode(value, type, node) {
        this.addExtra(node, "rawValue", value);
        this.addExtra(node, "raw", this.input.slice(node.start, this.state.end));
        node.value = value;
        this.next();
        return this.finishNode(node, type);
      }
      parseLiteral(value, type) {
        const node = this.startNode();
        return this.parseLiteralAtNode(value, type, node);
      }
      parseStringLiteral(value) {
        return this.parseLiteral(value, "StringLiteral");
      }
      parseNumericLiteral(value) {
        return this.parseLiteral(value, "NumericLiteral");
      }
      parseBigIntLiteral(value) {
        return this.parseLiteral(value, "BigIntLiteral");
      }
      parseDecimalLiteral(value) {
        return this.parseLiteral(value, "DecimalLiteral");
      }
      parseRegExpLiteral(value) {
        const node = this.parseLiteral(value.value, "RegExpLiteral");
        node.pattern = value.pattern;
        node.flags = value.flags;
        return node;
      }
      parseBooleanLiteral(value) {
        const node = this.startNode();
        node.value = value;
        this.next();
        return this.finishNode(node, "BooleanLiteral");
      }
      parseNullLiteral() {
        const node = this.startNode();
        this.next();
        return this.finishNode(node, "NullLiteral");
      }
      parseParenAndDistinguishExpression(canBeArrow) {
        const startLoc = this.state.startLoc;
        let val;
        this.next();
        this.expressionScope.enter(newArrowHeadScope());
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.maybeInArrowParameters = true;
        this.state.inFSharpPipelineDirectBody = false;
        const innerStartLoc = this.state.startLoc;
        const exprList = [];
        const refExpressionErrors = new ExpressionErrors();
        let first = true;
        let spreadStartLoc;
        let optionalCommaStartLoc;
        while (!this.match(11)) {
          if (first) {
            first = false;
          } else {
            this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);
            if (this.match(11)) {
              optionalCommaStartLoc = this.state.startLoc;
              break;
            }
          }
          if (this.match(21)) {
            const spreadNodeStartLoc = this.state.startLoc;
            spreadStartLoc = this.state.startLoc;
            exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc));
            if (!this.checkCommaAfterRest(41)) {
              break;
            }
          } else {
            exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));
          }
        }
        const innerEndLoc = this.state.lastTokEndLoc;
        this.expect(11);
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        let arrowNode = this.startNodeAt(startLoc);
        if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {
          this.checkDestructuringPrivate(refExpressionErrors);
          this.expressionScope.validateAsPattern();
          this.expressionScope.exit();
          this.parseArrowExpression(arrowNode, exprList, false);
          return arrowNode;
        }
        this.expressionScope.exit();
        if (!exprList.length) {
          this.unexpected(this.state.lastTokStartLoc);
        }
        if (optionalCommaStartLoc)
          this.unexpected(optionalCommaStartLoc);
        if (spreadStartLoc)
          this.unexpected(spreadStartLoc);
        this.checkExpressionErrors(refExpressionErrors, true);
        this.toReferencedListDeep(exprList, true);
        if (exprList.length > 1) {
          val = this.startNodeAt(innerStartLoc);
          val.expressions = exprList;
          this.finishNode(val, "SequenceExpression");
          this.resetEndLocation(val, innerEndLoc);
        } else {
          val = exprList[0];
        }
        return this.wrapParenthesis(startLoc, val);
      }
      wrapParenthesis(startLoc, expression) {
        if (!this.options.createParenthesizedExpressions) {
          this.addExtra(expression, "parenthesized", true);
          this.addExtra(expression, "parenStart", startLoc.index);
          this.takeSurroundingComments(expression, startLoc.index, this.state.lastTokEndLoc.index);
          return expression;
        }
        const parenExpression = this.startNodeAt(startLoc);
        parenExpression.expression = expression;
        return this.finishNode(parenExpression, "ParenthesizedExpression");
      }
      shouldParseArrow(params) {
        return !this.canInsertSemicolon();
      }
      parseArrow(node) {
        if (this.eat(19)) {
          return node;
        }
      }
      parseParenItem(node, startLoc) {
        return node;
      }
      parseNewOrNewTarget() {
        const node = this.startNode();
        this.next();
        if (this.match(16)) {
          const meta = this.createIdentifier(this.startNodeAtNode(node), "new");
          this.next();
          const metaProp = this.parseMetaProperty(node, meta, "target");
          if (!this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction) {
            this.raise(Errors.UnexpectedNewTarget, metaProp);
          }
          return metaProp;
        }
        return this.parseNew(node);
      }
      parseNew(node) {
        this.parseNewCallee(node);
        if (this.eat(10)) {
          const args = this.parseExprList(11);
          this.toReferencedList(args);
          node.arguments = args;
        } else {
          node.arguments = [];
        }
        return this.finishNode(node, "NewExpression");
      }
      parseNewCallee(node) {
        const isImport = this.match(83);
        const callee = this.parseNoCallExpr();
        node.callee = callee;
        if (isImport && (callee.type === "Import" || callee.type === "ImportExpression")) {
          this.raise(Errors.ImportCallNotNewExpression, callee);
        }
      }
      parseTemplateElement(isTagged) {
        const {
          start,
          startLoc,
          end,
          value
        } = this.state;
        const elemStart = start + 1;
        const elem = this.startNodeAt(createPositionWithColumnOffset(startLoc, 1));
        if (value === null) {
          if (!isTagged) {
            this.raise(Errors.InvalidEscapeSequenceTemplate, createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1));
          }
        }
        const isTail = this.match(24);
        const endOffset = isTail ? -1 : -2;
        const elemEnd = end + endOffset;
        elem.value = {
          raw: this.input.slice(elemStart, elemEnd).replace(/\r\n?/g, "\n"),
          cooked: value === null ? null : value.slice(1, endOffset)
        };
        elem.tail = isTail;
        this.next();
        const finishedNode = this.finishNode(elem, "TemplateElement");
        this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));
        return finishedNode;
      }
      parseTemplate(isTagged) {
        const node = this.startNode();
        let curElt = this.parseTemplateElement(isTagged);
        const quasis = [curElt];
        const substitutions = [];
        while (!curElt.tail) {
          substitutions.push(this.parseTemplateSubstitution());
          this.readTemplateContinuation();
          quasis.push(curElt = this.parseTemplateElement(isTagged));
        }
        node.expressions = substitutions;
        node.quasis = quasis;
        return this.finishNode(node, "TemplateLiteral");
      }
      parseTemplateSubstitution() {
        return this.parseExpression();
      }
      parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
        if (isRecord) {
          this.expectPlugin("recordAndTuple");
        }
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = false;
        const propHash = /* @__PURE__ */ Object.create(null);
        let first = true;
        const node = this.startNode();
        node.properties = [];
        this.next();
        while (!this.match(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
            if (this.match(close)) {
              this.addTrailingCommaExtraToNode(node);
              break;
            }
          }
          let prop;
          if (isPattern) {
            prop = this.parseBindingProperty();
          } else {
            prop = this.parsePropertyDefinition(refExpressionErrors);
            this.checkProto(prop, isRecord, propHash, refExpressionErrors);
          }
          if (isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement") {
            this.raise(Errors.InvalidRecordProperty, prop);
          }
          {
            if (prop.shorthand) {
              this.addExtra(prop, "shorthand", true);
            }
          }
          node.properties.push(prop);
        }
        this.next();
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        let type = "ObjectExpression";
        if (isPattern) {
          type = "ObjectPattern";
        } else if (isRecord) {
          type = "RecordExpression";
        }
        return this.finishNode(node, type);
      }
      addTrailingCommaExtraToNode(node) {
        this.addExtra(node, "trailingComma", this.state.lastTokStartLoc.index);
        this.addExtra(node, "trailingCommaLoc", this.state.lastTokStartLoc, false);
      }
      maybeAsyncOrAccessorProp(prop) {
        return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
      }
      parsePropertyDefinition(refExpressionErrors) {
        let decorators = [];
        if (this.match(26)) {
          if (this.hasPlugin("decorators")) {
            this.raise(Errors.UnsupportedPropertyDecorator, this.state.startLoc);
          }
          while (this.match(26)) {
            decorators.push(this.parseDecorator());
          }
        }
        const prop = this.startNode();
        let isAsync = false;
        let isAccessor = false;
        let startLoc;
        if (this.match(21)) {
          if (decorators.length)
            this.unexpected();
          return this.parseSpread();
        }
        if (decorators.length) {
          prop.decorators = decorators;
          decorators = [];
        }
        prop.method = false;
        if (refExpressionErrors) {
          startLoc = this.state.startLoc;
        }
        let isGenerator = this.eat(55);
        this.parsePropertyNamePrefixOperator(prop);
        const containsEsc = this.state.containsEsc;
        this.parsePropertyName(prop, refExpressionErrors);
        if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
          const {
            key
          } = prop;
          const keyName = key.name;
          if (keyName === "async" && !this.hasPrecedingLineBreak()) {
            isAsync = true;
            this.resetPreviousNodeTrailingComments(key);
            isGenerator = this.eat(55);
            this.parsePropertyName(prop);
          }
          if (keyName === "get" || keyName === "set") {
            isAccessor = true;
            this.resetPreviousNodeTrailingComments(key);
            prop.kind = keyName;
            if (this.match(55)) {
              isGenerator = true;
              this.raise(Errors.AccessorIsGenerator, this.state.curPosition(), {
                kind: keyName
              });
              this.next();
            }
            this.parsePropertyName(prop);
          }
        }
        return this.parseObjPropValue(prop, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors);
      }
      getGetterSetterExpectedParamCount(method) {
        return method.kind === "get" ? 0 : 1;
      }
      getObjectOrClassMethodParams(method) {
        return method.params;
      }
      checkGetterSetterParams(method) {
        var _params;
        const paramCount = this.getGetterSetterExpectedParamCount(method);
        const params = this.getObjectOrClassMethodParams(method);
        if (params.length !== paramCount) {
          this.raise(method.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, method);
        }
        if (method.kind === "set" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === "RestElement") {
          this.raise(Errors.BadSetterRestParameter, method);
        }
      }
      parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
        if (isAccessor) {
          const finishedProp = this.parseMethod(prop, isGenerator, false, false, false, "ObjectMethod");
          this.checkGetterSetterParams(finishedProp);
          return finishedProp;
        }
        if (isAsync || isGenerator || this.match(10)) {
          if (isPattern)
            this.unexpected();
          prop.kind = "method";
          prop.method = true;
          return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
        }
      }
      parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
        prop.shorthand = false;
        if (this.eat(14)) {
          prop.value = isPattern ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);
          return this.finishNode(prop, "ObjectProperty");
        }
        if (!prop.computed && prop.key.type === "Identifier") {
          this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);
          if (isPattern) {
            prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));
          } else if (this.match(29)) {
            const shorthandAssignLoc = this.state.startLoc;
            if (refExpressionErrors != null) {
              if (refExpressionErrors.shorthandAssignLoc === null) {
                refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;
              }
            } else {
              this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);
            }
            prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));
          } else {
            prop.value = cloneIdentifier(prop.key);
          }
          prop.shorthand = true;
          return this.finishNode(prop, "ObjectProperty");
        }
      }
      parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
        const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
        if (!node)
          this.unexpected();
        return node;
      }
      parsePropertyName(prop, refExpressionErrors) {
        if (this.eat(0)) {
          prop.computed = true;
          prop.key = this.parseMaybeAssignAllowIn();
          this.expect(3);
        } else {
          const {
            type,
            value
          } = this.state;
          let key;
          if (tokenIsKeywordOrIdentifier(type)) {
            key = this.parseIdentifier(true);
          } else {
            switch (type) {
              case 134:
                key = this.parseNumericLiteral(value);
                break;
              case 133:
                key = this.parseStringLiteral(value);
                break;
              case 135:
                key = this.parseBigIntLiteral(value);
                break;
              case 136:
                key = this.parseDecimalLiteral(value);
                break;
              case 138: {
                const privateKeyLoc = this.state.startLoc;
                if (refExpressionErrors != null) {
                  if (refExpressionErrors.privateKeyLoc === null) {
                    refExpressionErrors.privateKeyLoc = privateKeyLoc;
                  }
                } else {
                  this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);
                }
                key = this.parsePrivateName();
                break;
              }
              default:
                this.unexpected();
            }
          }
          prop.key = key;
          if (type !== 138) {
            prop.computed = false;
          }
        }
      }
      initFunction(node, isAsync) {
        node.id = null;
        node.generator = false;
        node.async = isAsync;
      }
      parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
        this.initFunction(node, isAsync);
        node.generator = isGenerator;
        this.scope.enter(2 | 16 | (inClassScope ? 64 : 0) | (allowDirectSuper ? 32 : 0));
        this.prodParam.enter(functionFlags(isAsync, node.generator));
        this.parseFunctionParams(node, isConstructor);
        const finishedNode = this.parseFunctionBodyAndFinish(node, type, true);
        this.prodParam.exit();
        this.scope.exit();
        return finishedNode;
      }
      parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
        if (isTuple) {
          this.expectPlugin("recordAndTuple");
        }
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = false;
        const node = this.startNode();
        this.next();
        node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return this.finishNode(node, isTuple ? "TupleExpression" : "ArrayExpression");
      }
      parseArrowExpression(node, params, isAsync, trailingCommaLoc) {
        this.scope.enter(2 | 4);
        let flags = functionFlags(isAsync, false);
        if (!this.match(5) && this.prodParam.hasIn) {
          flags |= 8;
        }
        this.prodParam.enter(flags);
        this.initFunction(node, isAsync);
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        if (params) {
          this.state.maybeInArrowParameters = true;
          this.setArrowFunctionParameters(node, params, trailingCommaLoc);
        }
        this.state.maybeInArrowParameters = false;
        this.parseFunctionBody(node, true);
        this.prodParam.exit();
        this.scope.exit();
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return this.finishNode(node, "ArrowFunctionExpression");
      }
      setArrowFunctionParameters(node, params, trailingCommaLoc) {
        this.toAssignableList(params, trailingCommaLoc, false);
        node.params = params;
      }
      parseFunctionBodyAndFinish(node, type, isMethod = false) {
        this.parseFunctionBody(node, false, isMethod);
        return this.finishNode(node, type);
      }
      parseFunctionBody(node, allowExpression, isMethod = false) {
        const isExpression = allowExpression && !this.match(5);
        this.expressionScope.enter(newExpressionScope());
        if (isExpression) {
          node.body = this.parseMaybeAssign();
          this.checkParams(node, false, allowExpression, false);
        } else {
          const oldStrict = this.state.strict;
          const oldLabels = this.state.labels;
          this.state.labels = [];
          this.prodParam.enter(this.prodParam.currentFlags() | 4);
          node.body = this.parseBlock(true, false, (hasStrictModeDirective) => {
            const nonSimple = !this.isSimpleParamList(node.params);
            if (hasStrictModeDirective && nonSimple) {
              this.raise(Errors.IllegalLanguageModeDirective, (node.kind === "method" || node.kind === "constructor") && !!node.key ? node.key.loc.end : node);
            }
            const strictModeChanged = !oldStrict && this.state.strict;
            this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);
            if (this.state.strict && node.id) {
              this.checkIdentifier(node.id, 65, strictModeChanged);
            }
          });
          this.prodParam.exit();
          this.state.labels = oldLabels;
        }
        this.expressionScope.exit();
      }
      isSimpleParameter(node) {
        return node.type === "Identifier";
      }
      isSimpleParamList(params) {
        for (let i = 0, len = params.length; i < len; i++) {
          if (!this.isSimpleParameter(params[i]))
            return false;
        }
        return true;
      }
      checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
        const checkClashes = !allowDuplicates && /* @__PURE__ */ new Set();
        const formalParameters = {
          type: "FormalParameters"
        };
        for (const param of node.params) {
          this.checkLVal(param, {
            in: formalParameters,
            binding: 5,
            checkClashes,
            strictModeChanged
          });
        }
      }
      parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
        const elts = [];
        let first = true;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
            if (this.match(close)) {
              if (nodeForExtra) {
                this.addTrailingCommaExtraToNode(nodeForExtra);
              }
              this.next();
              break;
            }
          }
          elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
        }
        return elts;
      }
      parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
        let elt;
        if (this.match(12)) {
          if (!allowEmpty) {
            this.raise(Errors.UnexpectedToken, this.state.curPosition(), {
              unexpected: ","
            });
          }
          elt = null;
        } else if (this.match(21)) {
          const spreadNodeStartLoc = this.state.startLoc;
          elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartLoc);
        } else if (this.match(17)) {
          this.expectPlugin("partialApplication");
          if (!allowPlaceholder) {
            this.raise(Errors.UnexpectedArgumentPlaceholder, this.state.startLoc);
          }
          const node = this.startNode();
          this.next();
          elt = this.finishNode(node, "ArgumentPlaceholder");
        } else {
          elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);
        }
        return elt;
      }
      parseIdentifier(liberal) {
        const node = this.startNode();
        const name = this.parseIdentifierName(liberal);
        return this.createIdentifier(node, name);
      }
      createIdentifier(node, name) {
        node.name = name;
        node.loc.identifierName = name;
        return this.finishNode(node, "Identifier");
      }
      parseIdentifierName(liberal) {
        let name;
        const {
          startLoc,
          type
        } = this.state;
        if (tokenIsKeywordOrIdentifier(type)) {
          name = this.state.value;
        } else {
          this.unexpected();
        }
        const tokenIsKeyword2 = tokenKeywordOrIdentifierIsKeyword(type);
        if (liberal) {
          if (tokenIsKeyword2) {
            this.replaceToken(132);
          }
        } else {
          this.checkReservedWord(name, startLoc, tokenIsKeyword2, false);
        }
        this.next();
        return name;
      }
      checkReservedWord(word, startLoc, checkKeywords, isBinding) {
        if (word.length > 10) {
          return;
        }
        if (!canBeReservedWord(word)) {
          return;
        }
        if (checkKeywords && isKeyword(word)) {
          this.raise(Errors.UnexpectedKeyword, startLoc, {
            keyword: word
          });
          return;
        }
        const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;
        if (reservedTest(word, this.inModule)) {
          this.raise(Errors.UnexpectedReservedWord, startLoc, {
            reservedWord: word
          });
          return;
        } else if (word === "yield") {
          if (this.prodParam.hasYield) {
            this.raise(Errors.YieldBindingIdentifier, startLoc);
            return;
          }
        } else if (word === "await") {
          if (this.prodParam.hasAwait) {
            this.raise(Errors.AwaitBindingIdentifier, startLoc);
            return;
          }
          if (this.scope.inStaticBlock) {
            this.raise(Errors.AwaitBindingIdentifierInStaticBlock, startLoc);
            return;
          }
          this.expressionScope.recordAsyncArrowParametersError(startLoc);
        } else if (word === "arguments") {
          if (this.scope.inClassAndNotInNonArrowFunction) {
            this.raise(Errors.ArgumentsInClass, startLoc);
            return;
          }
        }
      }
      isAwaitAllowed() {
        if (this.prodParam.hasAwait)
          return true;
        if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {
          return true;
        }
        return false;
      }
      parseAwait(startLoc) {
        const node = this.startNodeAt(startLoc);
        this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, node);
        if (this.eat(55)) {
          this.raise(Errors.ObsoleteAwaitStar, node);
        }
        if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {
          if (this.isAmbiguousAwait()) {
            this.ambiguousScriptDifferentAst = true;
          } else {
            this.sawUnambiguousESM = true;
          }
        }
        if (!this.state.soloAwait) {
          node.argument = this.parseMaybeUnary(null, true);
        }
        return this.finishNode(node, "AwaitExpression");
      }
      isAmbiguousAwait() {
        if (this.hasPrecedingLineBreak())
          return true;
        const {
          type
        } = this.state;
        return type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 102 && !this.state.containsEsc || type === 137 || type === 56 || this.hasPlugin("v8intrinsic") && type === 54;
      }
      parseYield() {
        const node = this.startNode();
        this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, node);
        this.next();
        let delegating = false;
        let argument = null;
        if (!this.hasPrecedingLineBreak()) {
          delegating = this.eat(55);
          switch (this.state.type) {
            case 13:
            case 139:
            case 8:
            case 11:
            case 3:
            case 9:
            case 14:
            case 12:
              if (!delegating)
                break;
            default:
              argument = this.parseMaybeAssign();
          }
        }
        node.delegate = delegating;
        node.argument = argument;
        return this.finishNode(node, "YieldExpression");
      }
      parseImportCall(node) {
        this.next();
        node.source = this.parseMaybeAssignAllowIn();
        if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
          node.options = null;
        }
        if (this.eat(12)) {
          this.expectImportAttributesPlugin();
          if (!this.match(11)) {
            node.options = this.parseMaybeAssignAllowIn();
            this.eat(12);
          }
        }
        this.expect(11);
        return this.finishNode(node, "ImportExpression");
      }
      checkPipelineAtInfixOperator(left, leftStartLoc) {
        if (this.hasPlugin(["pipelineOperator", {
          proposal: "smart"
        }])) {
          if (left.type === "SequenceExpression") {
            this.raise(Errors.PipelineHeadSequenceExpression, leftStartLoc);
          }
        }
      }
      parseSmartPipelineBodyInStyle(childExpr, startLoc) {
        if (this.isSimpleReference(childExpr)) {
          const bodyNode = this.startNodeAt(startLoc);
          bodyNode.callee = childExpr;
          return this.finishNode(bodyNode, "PipelineBareFunction");
        } else {
          const bodyNode = this.startNodeAt(startLoc);
          this.checkSmartPipeTopicBodyEarlyErrors(startLoc);
          bodyNode.expression = childExpr;
          return this.finishNode(bodyNode, "PipelineTopicExpression");
        }
      }
      isSimpleReference(expression) {
        switch (expression.type) {
          case "MemberExpression":
            return !expression.computed && this.isSimpleReference(expression.object);
          case "Identifier":
            return true;
          default:
            return false;
        }
      }
      checkSmartPipeTopicBodyEarlyErrors(startLoc) {
        if (this.match(19)) {
          throw this.raise(Errors.PipelineBodyNoArrow, this.state.startLoc);
        }
        if (!this.topicReferenceWasUsedInCurrentContext()) {
          this.raise(Errors.PipelineTopicUnused, startLoc);
        }
      }
      withTopicBindingContext(callback) {
        const outerContextTopicState = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 1,
          maxTopicIndex: null
        };
        try {
          return callback();
        } finally {
          this.state.topicContext = outerContextTopicState;
        }
      }
      withSmartMixTopicForbiddingContext(callback) {
        if (this.hasPlugin(["pipelineOperator", {
          proposal: "smart"
        }])) {
          const outerContextTopicState = this.state.topicContext;
          this.state.topicContext = {
            maxNumOfResolvableTopics: 0,
            maxTopicIndex: null
          };
          try {
            return callback();
          } finally {
            this.state.topicContext = outerContextTopicState;
          }
        } else {
          return callback();
        }
      }
      withSoloAwaitPermittingContext(callback) {
        const outerContextSoloAwaitState = this.state.soloAwait;
        this.state.soloAwait = true;
        try {
          return callback();
        } finally {
          this.state.soloAwait = outerContextSoloAwaitState;
        }
      }
      allowInAnd(callback) {
        const flags = this.prodParam.currentFlags();
        const prodParamToSet = 8 & ~flags;
        if (prodParamToSet) {
          this.prodParam.enter(flags | 8);
          try {
            return callback();
          } finally {
            this.prodParam.exit();
          }
        }
        return callback();
      }
      disallowInAnd(callback) {
        const flags = this.prodParam.currentFlags();
        const prodParamToClear = 8 & flags;
        if (prodParamToClear) {
          this.prodParam.enter(flags & ~8);
          try {
            return callback();
          } finally {
            this.prodParam.exit();
          }
        }
        return callback();
      }
      registerTopicReference() {
        this.state.topicContext.maxTopicIndex = 0;
      }
      topicReferenceIsAllowedInCurrentContext() {
        return this.state.topicContext.maxNumOfResolvableTopics >= 1;
      }
      topicReferenceWasUsedInCurrentContext() {
        return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
      }
      parseFSharpPipelineBody(prec) {
        const startLoc = this.state.startLoc;
        this.state.potentialArrowAt = this.state.start;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = true;
        const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, prec);
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return ret;
      }
      parseModuleExpression() {
        this.expectPlugin("moduleBlocks");
        const node = this.startNode();
        this.next();
        if (!this.match(5)) {
          this.unexpected(null, 5);
        }
        const program = this.startNodeAt(this.state.endLoc);
        this.next();
        const revertScopes = this.initializeScopes(true);
        this.enterInitialScopes();
        try {
          node.body = this.parseProgram(program, 8, "module");
        } finally {
          revertScopes();
        }
        return this.finishNode(node, "ModuleExpression");
      }
      parsePropertyNamePrefixOperator(prop) {
      }
    };
    var loopLabel = {
      kind: 1
    };
    var switchLabel = {
      kind: 2
    };
    var loneSurrogate = /[\uD800-\uDFFF]/u;
    var keywordRelationalOperator = /in(?:stanceof)?/y;
    function babel7CompatTokens(tokens, input) {
      for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i];
        const {
          type
        } = token;
        if (typeof type === "number") {
          {
            if (type === 138) {
              const {
                loc,
                start,
                value,
                end
              } = token;
              const hashEndPos = start + 1;
              const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);
              tokens.splice(i, 1, new Token({
                type: getExportedToken(27),
                value: "#",
                start,
                end: hashEndPos,
                startLoc: loc.start,
                endLoc: hashEndLoc
              }), new Token({
                type: getExportedToken(132),
                value,
                start: hashEndPos,
                end,
                startLoc: hashEndLoc,
                endLoc: loc.end
              }));
              i++;
              continue;
            }
            if (tokenIsTemplate(type)) {
              const {
                loc,
                start,
                value,
                end
              } = token;
              const backquoteEnd = start + 1;
              const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);
              let startToken;
              if (input.charCodeAt(start) === 96) {
                startToken = new Token({
                  type: getExportedToken(22),
                  value: "`",
                  start,
                  end: backquoteEnd,
                  startLoc: loc.start,
                  endLoc: backquoteEndLoc
                });
              } else {
                startToken = new Token({
                  type: getExportedToken(8),
                  value: "}",
                  start,
                  end: backquoteEnd,
                  startLoc: loc.start,
                  endLoc: backquoteEndLoc
                });
              }
              let templateValue, templateElementEnd, templateElementEndLoc, endToken;
              if (type === 24) {
                templateElementEnd = end - 1;
                templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);
                templateValue = value === null ? null : value.slice(1, -1);
                endToken = new Token({
                  type: getExportedToken(22),
                  value: "`",
                  start: templateElementEnd,
                  end,
                  startLoc: templateElementEndLoc,
                  endLoc: loc.end
                });
              } else {
                templateElementEnd = end - 2;
                templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);
                templateValue = value === null ? null : value.slice(1, -2);
                endToken = new Token({
                  type: getExportedToken(23),
                  value: "${",
                  start: templateElementEnd,
                  end,
                  startLoc: templateElementEndLoc,
                  endLoc: loc.end
                });
              }
              tokens.splice(i, 1, startToken, new Token({
                type: getExportedToken(20),
                value: templateValue,
                start: backquoteEnd,
                end: templateElementEnd,
                startLoc: backquoteEndLoc,
                endLoc: templateElementEndLoc
              }), endToken);
              i += 2;
              continue;
            }
          }
          token.type = getExportedToken(type);
        }
      }
      return tokens;
    }
    var StatementParser = class extends ExpressionParser {
      parseTopLevel(file, program) {
        file.program = this.parseProgram(program);
        file.comments = this.comments;
        if (this.options.tokens) {
          file.tokens = babel7CompatTokens(this.tokens, this.input);
        }
        return this.finishNode(file, "File");
      }
      parseProgram(program, end = 139, sourceType = this.options.sourceType) {
        program.sourceType = sourceType;
        program.interpreter = this.parseInterpreterDirective();
        this.parseBlockBody(program, true, true, end);
        if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {
          for (const [localName, at] of Array.from(this.scope.undefinedExports)) {
            this.raise(Errors.ModuleExportUndefined, at, {
              localName
            });
          }
        }
        let finishedProgram;
        if (end === 139) {
          finishedProgram = this.finishNode(program, "Program");
        } else {
          finishedProgram = this.finishNodeAt(program, "Program", createPositionWithColumnOffset(this.state.startLoc, -1));
        }
        return finishedProgram;
      }
      stmtToDirective(stmt) {
        const directive = stmt;
        directive.type = "Directive";
        directive.value = directive.expression;
        delete directive.expression;
        const directiveLiteral = directive.value;
        const expressionValue = directiveLiteral.value;
        const raw = this.input.slice(directiveLiteral.start, directiveLiteral.end);
        const val = directiveLiteral.value = raw.slice(1, -1);
        this.addExtra(directiveLiteral, "raw", raw);
        this.addExtra(directiveLiteral, "rawValue", val);
        this.addExtra(directiveLiteral, "expressionValue", expressionValue);
        directiveLiteral.type = "DirectiveLiteral";
        return directive;
      }
      parseInterpreterDirective() {
        if (!this.match(28)) {
          return null;
        }
        const node = this.startNode();
        node.value = this.state.value;
        this.next();
        return this.finishNode(node, "InterpreterDirective");
      }
      isLet() {
        if (!this.isContextual(100)) {
          return false;
        }
        return this.hasFollowingBindingAtom();
      }
      chStartsBindingIdentifier(ch, pos) {
        if (isIdentifierStart(ch)) {
          keywordRelationalOperator.lastIndex = pos;
          if (keywordRelationalOperator.test(this.input)) {
            const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);
            if (!isIdentifierChar(endCh) && endCh !== 92) {
              return false;
            }
          }
          return true;
        } else if (ch === 92) {
          return true;
        } else {
          return false;
        }
      }
      chStartsBindingPattern(ch) {
        return ch === 91 || ch === 123;
      }
      hasFollowingBindingAtom() {
        const next = this.nextTokenStart();
        const nextCh = this.codePointAtPos(next);
        return this.chStartsBindingPattern(nextCh) || this.chStartsBindingIdentifier(nextCh, next);
      }
      hasInLineFollowingBindingIdentifier() {
        const next = this.nextTokenInLineStart();
        const nextCh = this.codePointAtPos(next);
        return this.chStartsBindingIdentifier(nextCh, next);
      }
      startsUsingForOf() {
        const {
          type,
          containsEsc
        } = this.lookahead();
        if (type === 102 && !containsEsc) {
          return false;
        } else if (tokenIsIdentifier(type) && !this.hasFollowingLineBreak()) {
          this.expectPlugin("explicitResourceManagement");
          return true;
        }
      }
      startsAwaitUsing() {
        let next = this.nextTokenInLineStart();
        if (this.isUnparsedContextual(next, "using")) {
          next = this.nextTokenInLineStartSince(next + 5);
          const nextCh = this.codePointAtPos(next);
          if (this.chStartsBindingIdentifier(nextCh, next)) {
            this.expectPlugin("explicitResourceManagement");
            return true;
          }
        }
        return false;
      }
      parseModuleItem() {
        return this.parseStatementLike(1 | 2 | 4 | 8);
      }
      parseStatementListItem() {
        return this.parseStatementLike(2 | 4 | (!this.options.annexB || this.state.strict ? 0 : 8));
      }
      parseStatementOrSloppyAnnexBFunctionDeclaration(allowLabeledFunction = false) {
        let flags = 0;
        if (this.options.annexB && !this.state.strict) {
          flags |= 4;
          if (allowLabeledFunction) {
            flags |= 8;
          }
        }
        return this.parseStatementLike(flags);
      }
      parseStatement() {
        return this.parseStatementLike(0);
      }
      parseStatementLike(flags) {
        let decorators = null;
        if (this.match(26)) {
          decorators = this.parseDecorators(true);
        }
        return this.parseStatementContent(flags, decorators);
      }
      parseStatementContent(flags, decorators) {
        const starttype = this.state.type;
        const node = this.startNode();
        const allowDeclaration = !!(flags & 2);
        const allowFunctionDeclaration = !!(flags & 4);
        const topLevel = flags & 1;
        switch (starttype) {
          case 60:
            return this.parseBreakContinueStatement(node, true);
          case 63:
            return this.parseBreakContinueStatement(node, false);
          case 64:
            return this.parseDebuggerStatement(node);
          case 90:
            return this.parseDoWhileStatement(node);
          case 91:
            return this.parseForStatement(node);
          case 68:
            if (this.lookaheadCharCode() === 46)
              break;
            if (!allowFunctionDeclaration) {
              this.raise(this.state.strict ? Errors.StrictFunction : this.options.annexB ? Errors.SloppyFunctionAnnexB : Errors.SloppyFunction, this.state.startLoc);
            }
            return this.parseFunctionStatement(node, false, !allowDeclaration && allowFunctionDeclaration);
          case 80:
            if (!allowDeclaration)
              this.unexpected();
            return this.parseClass(this.maybeTakeDecorators(decorators, node), true);
          case 69:
            return this.parseIfStatement(node);
          case 70:
            return this.parseReturnStatement(node);
          case 71:
            return this.parseSwitchStatement(node);
          case 72:
            return this.parseThrowStatement(node);
          case 73:
            return this.parseTryStatement(node);
          case 96:
            if (!this.state.containsEsc && this.startsAwaitUsing()) {
              if (!this.isAwaitAllowed()) {
                this.raise(Errors.AwaitUsingNotInAsyncContext, node);
              } else if (!allowDeclaration) {
                this.raise(Errors.UnexpectedLexicalDeclaration, node);
              }
              this.next();
              return this.parseVarStatement(node, "await using");
            }
            break;
          case 107:
            if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier()) {
              break;
            }
            this.expectPlugin("explicitResourceManagement");
            if (!this.scope.inModule && this.scope.inTopLevel) {
              this.raise(Errors.UnexpectedUsingDeclaration, this.state.startLoc);
            } else if (!allowDeclaration) {
              this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);
            }
            return this.parseVarStatement(node, "using");
          case 100: {
            if (this.state.containsEsc) {
              break;
            }
            const next = this.nextTokenStart();
            const nextCh = this.codePointAtPos(next);
            if (nextCh !== 91) {
              if (!allowDeclaration && this.hasFollowingLineBreak())
                break;
              if (!this.chStartsBindingIdentifier(nextCh, next) && nextCh !== 123) {
                break;
              }
            }
          }
          case 75: {
            if (!allowDeclaration) {
              this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);
            }
          }
          case 74: {
            const kind = this.state.value;
            return this.parseVarStatement(node, kind);
          }
          case 92:
            return this.parseWhileStatement(node);
          case 76:
            return this.parseWithStatement(node);
          case 5:
            return this.parseBlock();
          case 13:
            return this.parseEmptyStatement(node);
          case 83: {
            const nextTokenCharCode = this.lookaheadCharCode();
            if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
              break;
            }
          }
          case 82: {
            if (!this.options.allowImportExportEverywhere && !topLevel) {
              this.raise(Errors.UnexpectedImportExport, this.state.startLoc);
            }
            this.next();
            let result;
            if (starttype === 83) {
              result = this.parseImport(node);
              if (result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value")) {
                this.sawUnambiguousESM = true;
              }
            } else {
              result = this.parseExport(node, decorators);
              if (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") {
                this.sawUnambiguousESM = true;
              }
            }
            this.assertModuleNodeAllowed(result);
            return result;
          }
          default: {
            if (this.isAsyncFunction()) {
              if (!allowDeclaration) {
                this.raise(Errors.AsyncFunctionInSingleStatementContext, this.state.startLoc);
              }
              this.next();
              return this.parseFunctionStatement(node, true, !allowDeclaration && allowFunctionDeclaration);
            }
          }
        }
        const maybeName = this.state.value;
        const expr = this.parseExpression();
        if (tokenIsIdentifier(starttype) && expr.type === "Identifier" && this.eat(14)) {
          return this.parseLabeledStatement(node, maybeName, expr, flags);
        } else {
          return this.parseExpressionStatement(node, expr, decorators);
        }
      }
      assertModuleNodeAllowed(node) {
        if (!this.options.allowImportExportEverywhere && !this.inModule) {
          this.raise(Errors.ImportOutsideModule, node);
        }
      }
      decoratorsEnabledBeforeExport() {
        if (this.hasPlugin("decorators-legacy"))
          return true;
        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== false;
      }
      maybeTakeDecorators(maybeDecorators, classNode, exportNode) {
        if (maybeDecorators) {
          if (classNode.decorators && classNode.decorators.length > 0) {
            if (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") !== "boolean") {
              this.raise(Errors.DecoratorsBeforeAfterExport, classNode.decorators[0]);
            }
            classNode.decorators.unshift(...maybeDecorators);
          } else {
            classNode.decorators = maybeDecorators;
          }
          this.resetStartLocationFromNode(classNode, maybeDecorators[0]);
          if (exportNode)
            this.resetStartLocationFromNode(exportNode, classNode);
        }
        return classNode;
      }
      canHaveLeadingDecorator() {
        return this.match(80);
      }
      parseDecorators(allowExport) {
        const decorators = [];
        do {
          decorators.push(this.parseDecorator());
        } while (this.match(26));
        if (this.match(82)) {
          if (!allowExport) {
            this.unexpected();
          }
          if (!this.decoratorsEnabledBeforeExport()) {
            this.raise(Errors.DecoratorExportClass, this.state.startLoc);
          }
        } else if (!this.canHaveLeadingDecorator()) {
          throw this.raise(Errors.UnexpectedLeadingDecorator, this.state.startLoc);
        }
        return decorators;
      }
      parseDecorator() {
        this.expectOnePlugin(["decorators", "decorators-legacy"]);
        const node = this.startNode();
        this.next();
        if (this.hasPlugin("decorators")) {
          const startLoc = this.state.startLoc;
          let expr;
          if (this.match(10)) {
            const startLoc2 = this.state.startLoc;
            this.next();
            expr = this.parseExpression();
            this.expect(11);
            expr = this.wrapParenthesis(startLoc2, expr);
            const paramsStartLoc = this.state.startLoc;
            node.expression = this.parseMaybeDecoratorArguments(expr);
            if (this.getPluginOption("decorators", "allowCallParenthesized") === false && node.expression !== expr) {
              this.raise(Errors.DecoratorArgumentsOutsideParentheses, paramsStartLoc);
            }
          } else {
            expr = this.parseIdentifier(false);
            while (this.eat(16)) {
              const node2 = this.startNodeAt(startLoc);
              node2.object = expr;
              if (this.match(138)) {
                this.classScope.usePrivateName(this.state.value, this.state.startLoc);
                node2.property = this.parsePrivateName();
              } else {
                node2.property = this.parseIdentifier(true);
              }
              node2.computed = false;
              expr = this.finishNode(node2, "MemberExpression");
            }
            node.expression = this.parseMaybeDecoratorArguments(expr);
          }
        } else {
          node.expression = this.parseExprSubscripts();
        }
        return this.finishNode(node, "Decorator");
      }
      parseMaybeDecoratorArguments(expr) {
        if (this.eat(10)) {
          const node = this.startNodeAtNode(expr);
          node.callee = expr;
          node.arguments = this.parseCallExpressionArguments(11, false);
          this.toReferencedList(node.arguments);
          return this.finishNode(node, "CallExpression");
        }
        return expr;
      }
      parseBreakContinueStatement(node, isBreak) {
        this.next();
        if (this.isLineTerminator()) {
          node.label = null;
        } else {
          node.label = this.parseIdentifier();
          this.semicolon();
        }
        this.verifyBreakContinue(node, isBreak);
        return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
      }
      verifyBreakContinue(node, isBreak) {
        let i;
        for (i = 0; i < this.state.labels.length; ++i) {
          const lab = this.state.labels[i];
          if (node.label == null || lab.name === node.label.name) {
            if (lab.kind != null && (isBreak || lab.kind === 1)) {
              break;
            }
            if (node.label && isBreak)
              break;
          }
        }
        if (i === this.state.labels.length) {
          const type = isBreak ? "BreakStatement" : "ContinueStatement";
          this.raise(Errors.IllegalBreakContinue, node, {
            type
          });
        }
      }
      parseDebuggerStatement(node) {
        this.next();
        this.semicolon();
        return this.finishNode(node, "DebuggerStatement");
      }
      parseHeaderExpression() {
        this.expect(10);
        const val = this.parseExpression();
        this.expect(11);
        return val;
      }
      parseDoWhileStatement(node) {
        this.next();
        this.state.labels.push(loopLabel);
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        this.state.labels.pop();
        this.expect(92);
        node.test = this.parseHeaderExpression();
        this.eat(13);
        return this.finishNode(node, "DoWhileStatement");
      }
      parseForStatement(node) {
        this.next();
        this.state.labels.push(loopLabel);
        let awaitAt = null;
        if (this.isAwaitAllowed() && this.eatContextual(96)) {
          awaitAt = this.state.lastTokStartLoc;
        }
        this.scope.enter(0);
        this.expect(10);
        if (this.match(13)) {
          if (awaitAt !== null) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, null);
        }
        const startsWithLet = this.isContextual(100);
        {
          const startsWithAwaitUsing = this.isContextual(96) && this.startsAwaitUsing();
          const starsWithUsingDeclaration = startsWithAwaitUsing || this.isContextual(107) && this.startsUsingForOf();
          const isLetOrUsing = startsWithLet && this.hasFollowingBindingAtom() || starsWithUsingDeclaration;
          if (this.match(74) || this.match(75) || isLetOrUsing) {
            const initNode = this.startNode();
            let kind;
            if (startsWithAwaitUsing) {
              kind = "await using";
              if (!this.isAwaitAllowed()) {
                this.raise(Errors.AwaitUsingNotInAsyncContext, this.state.startLoc);
              }
              this.next();
            } else {
              kind = this.state.value;
            }
            this.next();
            this.parseVar(initNode, true, kind);
            const init2 = this.finishNode(initNode, "VariableDeclaration");
            const isForIn = this.match(58);
            if (isForIn && starsWithUsingDeclaration) {
              this.raise(Errors.ForInUsing, init2);
            }
            if ((isForIn || this.isContextual(102)) && init2.declarations.length === 1) {
              return this.parseForIn(node, init2, awaitAt);
            }
            if (awaitAt !== null) {
              this.unexpected(awaitAt);
            }
            return this.parseFor(node, init2);
          }
        }
        const startsWithAsync = this.isContextual(95);
        const refExpressionErrors = new ExpressionErrors();
        const init = this.parseExpression(true, refExpressionErrors);
        const isForOf = this.isContextual(102);
        if (isForOf) {
          if (startsWithLet) {
            this.raise(Errors.ForOfLet, init);
          }
          if (awaitAt === null && startsWithAsync && init.type === "Identifier") {
            this.raise(Errors.ForOfAsync, init);
          }
        }
        if (isForOf || this.match(58)) {
          this.checkDestructuringPrivate(refExpressionErrors);
          this.toAssignable(init, true);
          const type = isForOf ? "ForOfStatement" : "ForInStatement";
          this.checkLVal(init, {
            in: {
              type
            }
          });
          return this.parseForIn(node, init, awaitAt);
        } else {
          this.checkExpressionErrors(refExpressionErrors, true);
        }
        if (awaitAt !== null) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node, init);
      }
      parseFunctionStatement(node, isAsync, isHangingDeclaration) {
        this.next();
        return this.parseFunction(node, 1 | (isHangingDeclaration ? 2 : 0) | (isAsync ? 8 : 0));
      }
      parseIfStatement(node) {
        this.next();
        node.test = this.parseHeaderExpression();
        node.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration();
        node.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null;
        return this.finishNode(node, "IfStatement");
      }
      parseReturnStatement(node) {
        if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {
          this.raise(Errors.IllegalReturn, this.state.startLoc);
        }
        this.next();
        if (this.isLineTerminator()) {
          node.argument = null;
        } else {
          node.argument = this.parseExpression();
          this.semicolon();
        }
        return this.finishNode(node, "ReturnStatement");
      }
      parseSwitchStatement(node) {
        this.next();
        node.discriminant = this.parseHeaderExpression();
        const cases = node.cases = [];
        this.expect(5);
        this.state.labels.push(switchLabel);
        this.scope.enter(0);
        let cur;
        for (let sawDefault; !this.match(8); ) {
          if (this.match(61) || this.match(65)) {
            const isCase = this.match(61);
            if (cur)
              this.finishNode(cur, "SwitchCase");
            cases.push(cur = this.startNode());
            cur.consequent = [];
            this.next();
            if (isCase) {
              cur.test = this.parseExpression();
            } else {
              if (sawDefault) {
                this.raise(Errors.MultipleDefaultsInSwitch, this.state.lastTokStartLoc);
              }
              sawDefault = true;
              cur.test = null;
            }
            this.expect(14);
          } else {
            if (cur) {
              cur.consequent.push(this.parseStatementListItem());
            } else {
              this.unexpected();
            }
          }
        }
        this.scope.exit();
        if (cur)
          this.finishNode(cur, "SwitchCase");
        this.next();
        this.state.labels.pop();
        return this.finishNode(node, "SwitchStatement");
      }
      parseThrowStatement(node) {
        this.next();
        if (this.hasPrecedingLineBreak()) {
          this.raise(Errors.NewlineAfterThrow, this.state.lastTokEndLoc);
        }
        node.argument = this.parseExpression();
        this.semicolon();
        return this.finishNode(node, "ThrowStatement");
      }
      parseCatchClauseParam() {
        const param = this.parseBindingAtom();
        this.scope.enter(this.options.annexB && param.type === "Identifier" ? 8 : 0);
        this.checkLVal(param, {
          in: {
            type: "CatchClause"
          },
          binding: 9
        });
        return param;
      }
      parseTryStatement(node) {
        this.next();
        node.block = this.parseBlock();
        node.handler = null;
        if (this.match(62)) {
          const clause = this.startNode();
          this.next();
          if (this.match(10)) {
            this.expect(10);
            clause.param = this.parseCatchClauseParam();
            this.expect(11);
          } else {
            clause.param = null;
            this.scope.enter(0);
          }
          clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false));
          this.scope.exit();
          node.handler = this.finishNode(clause, "CatchClause");
        }
        node.finalizer = this.eat(67) ? this.parseBlock() : null;
        if (!node.handler && !node.finalizer) {
          this.raise(Errors.NoCatchOrFinally, node);
        }
        return this.finishNode(node, "TryStatement");
      }
      parseVarStatement(node, kind, allowMissingInitializer = false) {
        this.next();
        this.parseVar(node, false, kind, allowMissingInitializer);
        this.semicolon();
        return this.finishNode(node, "VariableDeclaration");
      }
      parseWhileStatement(node) {
        this.next();
        node.test = this.parseHeaderExpression();
        this.state.labels.push(loopLabel);
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        this.state.labels.pop();
        return this.finishNode(node, "WhileStatement");
      }
      parseWithStatement(node) {
        if (this.state.strict) {
          this.raise(Errors.StrictWith, this.state.startLoc);
        }
        this.next();
        node.object = this.parseHeaderExpression();
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        return this.finishNode(node, "WithStatement");
      }
      parseEmptyStatement(node) {
        this.next();
        return this.finishNode(node, "EmptyStatement");
      }
      parseLabeledStatement(node, maybeName, expr, flags) {
        for (const label of this.state.labels) {
          if (label.name === maybeName) {
            this.raise(Errors.LabelRedeclaration, expr, {
              labelName: maybeName
            });
          }
        }
        const kind = tokenIsLoop(this.state.type) ? 1 : this.match(71) ? 2 : null;
        for (let i = this.state.labels.length - 1; i >= 0; i--) {
          const label = this.state.labels[i];
          if (label.statementStart === node.start) {
            label.statementStart = this.state.start;
            label.kind = kind;
          } else {
            break;
          }
        }
        this.state.labels.push({
          name: maybeName,
          kind,
          statementStart: this.state.start
        });
        node.body = flags & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement();
        this.state.labels.pop();
        node.label = expr;
        return this.finishNode(node, "LabeledStatement");
      }
      parseExpressionStatement(node, expr, decorators) {
        node.expression = expr;
        this.semicolon();
        return this.finishNode(node, "ExpressionStatement");
      }
      parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {
        const node = this.startNode();
        if (allowDirectives) {
          this.state.strictErrors.clear();
        }
        this.expect(5);
        if (createNewLexicalScope) {
          this.scope.enter(0);
        }
        this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse);
        if (createNewLexicalScope) {
          this.scope.exit();
        }
        return this.finishNode(node, "BlockStatement");
      }
      isValidDirective(stmt) {
        return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
      }
      parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
        const body = node.body = [];
        const directives = node.directives = [];
        this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : void 0, topLevel, end, afterBlockParse);
      }
      parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
        const oldStrict = this.state.strict;
        let hasStrictModeDirective = false;
        let parsedNonDirective = false;
        while (!this.match(end)) {
          const stmt = topLevel ? this.parseModuleItem() : this.parseStatementListItem();
          if (directives && !parsedNonDirective) {
            if (this.isValidDirective(stmt)) {
              const directive = this.stmtToDirective(stmt);
              directives.push(directive);
              if (!hasStrictModeDirective && directive.value.value === "use strict") {
                hasStrictModeDirective = true;
                this.setStrict(true);
              }
              continue;
            }
            parsedNonDirective = true;
            this.state.strictErrors.clear();
          }
          body.push(stmt);
        }
        afterBlockParse == null || afterBlockParse.call(this, hasStrictModeDirective);
        if (!oldStrict) {
          this.setStrict(false);
        }
        this.next();
      }
      parseFor(node, init) {
        node.init = init;
        this.semicolon(false);
        node.test = this.match(13) ? null : this.parseExpression();
        this.semicolon(false);
        node.update = this.match(11) ? null : this.parseExpression();
        this.expect(11);
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        this.scope.exit();
        this.state.labels.pop();
        return this.finishNode(node, "ForStatement");
      }
      parseForIn(node, init, awaitAt) {
        const isForIn = this.match(58);
        this.next();
        if (isForIn) {
          if (awaitAt !== null)
            this.unexpected(awaitAt);
        } else {
          node.await = awaitAt !== null;
        }
        if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || !this.options.annexB || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
          this.raise(Errors.ForInOfLoopInitializer, init, {
            type: isForIn ? "ForInStatement" : "ForOfStatement"
          });
        }
        if (init.type === "AssignmentPattern") {
          this.raise(Errors.InvalidLhs, init, {
            ancestor: {
              type: "ForStatement"
            }
          });
        }
        node.left = init;
        node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
        this.expect(11);
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        this.scope.exit();
        this.state.labels.pop();
        return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
      }
      parseVar(node, isFor, kind, allowMissingInitializer = false) {
        const declarations = node.declarations = [];
        node.kind = kind;
        for (; ; ) {
          const decl = this.startNode();
          this.parseVarId(decl, kind);
          decl.init = !this.eat(29) ? null : isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
          if (decl.init === null && !allowMissingInitializer) {
            if (decl.id.type !== "Identifier" && !(isFor && (this.match(58) || this.isContextual(102)))) {
              this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
                kind: "destructuring"
              });
            } else if ((kind === "const" || kind === "using" || kind === "await using") && !(this.match(58) || this.isContextual(102))) {
              this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
                kind
              });
            }
          }
          declarations.push(this.finishNode(decl, "VariableDeclarator"));
          if (!this.eat(12))
            break;
        }
        return node;
      }
      parseVarId(decl, kind) {
        const id = this.parseBindingAtom();
        this.checkLVal(id, {
          in: {
            type: "VariableDeclarator"
          },
          binding: kind === "var" ? 5 : 8201
        });
        decl.id = id;
      }
      parseAsyncFunctionExpression(node) {
        return this.parseFunction(node, 8);
      }
      parseFunction(node, flags = 0) {
        const hangingDeclaration = flags & 2;
        const isDeclaration = !!(flags & 1);
        const requireId = isDeclaration && !(flags & 4);
        const isAsync = !!(flags & 8);
        this.initFunction(node, isAsync);
        if (this.match(55)) {
          if (hangingDeclaration) {
            this.raise(Errors.GeneratorInSingleStatementContext, this.state.startLoc);
          }
          this.next();
          node.generator = true;
        }
        if (isDeclaration) {
          node.id = this.parseFunctionId(requireId);
        }
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        this.state.maybeInArrowParameters = false;
        this.scope.enter(2);
        this.prodParam.enter(functionFlags(isAsync, node.generator));
        if (!isDeclaration) {
          node.id = this.parseFunctionId();
        }
        this.parseFunctionParams(node, false);
        this.withSmartMixTopicForbiddingContext(() => {
          this.parseFunctionBodyAndFinish(node, isDeclaration ? "FunctionDeclaration" : "FunctionExpression");
        });
        this.prodParam.exit();
        this.scope.exit();
        if (isDeclaration && !hangingDeclaration) {
          this.registerFunctionStatementId(node);
        }
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return node;
      }
      parseFunctionId(requireId) {
        return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
      }
      parseFunctionParams(node, isConstructor) {
        this.expect(10);
        this.expressionScope.enter(newParameterDeclarationScope());
        node.params = this.parseBindingList(11, 41, 2 | (isConstructor ? 4 : 0));
        this.expressionScope.exit();
      }
      registerFunctionStatementId(node) {
        if (!node.id)
          return;
        this.scope.declareName(node.id.name, !this.options.annexB || this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, node.id.loc.start);
      }
      parseClass(node, isStatement, optionalId) {
        this.next();
        const oldStrict = this.state.strict;
        this.state.strict = true;
        this.parseClassId(node, isStatement, optionalId);
        this.parseClassSuper(node);
        node.body = this.parseClassBody(!!node.superClass, oldStrict);
        return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
      }
      isClassProperty() {
        return this.match(29) || this.match(13) || this.match(8);
      }
      isClassMethod() {
        return this.match(10);
      }
      nameIsConstructor(key) {
        return key.type === "Identifier" && key.name === "constructor" || key.type === "StringLiteral" && key.value === "constructor";
      }
      isNonstaticConstructor(method) {
        return !method.computed && !method.static && this.nameIsConstructor(method.key);
      }
      parseClassBody(hadSuperClass, oldStrict) {
        this.classScope.enter();
        const state = {
          hadConstructor: false,
          hadSuperClass
        };
        let decorators = [];
        const classBody = this.startNode();
        classBody.body = [];
        this.expect(5);
        this.withSmartMixTopicForbiddingContext(() => {
          while (!this.match(8)) {
            if (this.eat(13)) {
              if (decorators.length > 0) {
                throw this.raise(Errors.DecoratorSemicolon, this.state.lastTokEndLoc);
              }
              continue;
            }
            if (this.match(26)) {
              decorators.push(this.parseDecorator());
              continue;
            }
            const member = this.startNode();
            if (decorators.length) {
              member.decorators = decorators;
              this.resetStartLocationFromNode(member, decorators[0]);
              decorators = [];
            }
            this.parseClassMember(classBody, member, state);
            if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
              this.raise(Errors.DecoratorConstructor, member);
            }
          }
        });
        this.state.strict = oldStrict;
        this.next();
        if (decorators.length) {
          throw this.raise(Errors.TrailingDecorator, this.state.startLoc);
        }
        this.classScope.exit();
        return this.finishNode(classBody, "ClassBody");
      }
      parseClassMemberFromModifier(classBody, member) {
        const key = this.parseIdentifier(true);
        if (this.isClassMethod()) {
          const method = member;
          method.kind = "method";
          method.computed = false;
          method.key = key;
          method.static = false;
          this.pushClassMethod(classBody, method, false, false, false, false);
          return true;
        } else if (this.isClassProperty()) {
          const prop = member;
          prop.computed = false;
          prop.key = key;
          prop.static = false;
          classBody.body.push(this.parseClassProperty(prop));
          return true;
        }
        this.resetPreviousNodeTrailingComments(key);
        return false;
      }
      parseClassMember(classBody, member, state) {
        const isStatic = this.isContextual(106);
        if (isStatic) {
          if (this.parseClassMemberFromModifier(classBody, member)) {
            return;
          }
          if (this.eat(5)) {
            this.parseClassStaticBlock(classBody, member);
            return;
          }
        }
        this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
      }
      parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
        const publicMethod = member;
        const privateMethod = member;
        const publicProp = member;
        const privateProp = member;
        const accessorProp = member;
        const method = publicMethod;
        const publicMember = publicMethod;
        member.static = isStatic;
        this.parsePropertyNamePrefixOperator(member);
        if (this.eat(55)) {
          method.kind = "method";
          const isPrivateName = this.match(138);
          this.parseClassElementName(method);
          if (isPrivateName) {
            this.pushClassPrivateMethod(classBody, privateMethod, true, false);
            return;
          }
          if (this.isNonstaticConstructor(publicMethod)) {
            this.raise(Errors.ConstructorIsGenerator, publicMethod.key);
          }
          this.pushClassMethod(classBody, publicMethod, true, false, false, false);
          return;
        }
        const isContextual = !this.state.containsEsc && tokenIsIdentifier(this.state.type);
        const key = this.parseClassElementName(member);
        const maybeContextualKw = isContextual ? key.name : null;
        const isPrivate = this.isPrivateName(key);
        const maybeQuestionTokenStartLoc = this.state.startLoc;
        this.parsePostMemberNameModifiers(publicMember);
        if (this.isClassMethod()) {
          method.kind = "method";
          if (isPrivate) {
            this.pushClassPrivateMethod(classBody, privateMethod, false, false);
            return;
          }
          const isConstructor = this.isNonstaticConstructor(publicMethod);
          let allowsDirectSuper = false;
          if (isConstructor) {
            publicMethod.kind = "constructor";
            if (state.hadConstructor && !this.hasPlugin("typescript")) {
              this.raise(Errors.DuplicateConstructor, key);
            }
            if (isConstructor && this.hasPlugin("typescript") && member.override) {
              this.raise(Errors.OverrideOnConstructor, key);
            }
            state.hadConstructor = true;
            allowsDirectSuper = state.hadSuperClass;
          }
          this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
        } else if (this.isClassProperty()) {
          if (isPrivate) {
            this.pushClassPrivateProperty(classBody, privateProp);
          } else {
            this.pushClassProperty(classBody, publicProp);
          }
        } else if (maybeContextualKw === "async" && !this.isLineTerminator()) {
          this.resetPreviousNodeTrailingComments(key);
          const isGenerator = this.eat(55);
          if (publicMember.optional) {
            this.unexpected(maybeQuestionTokenStartLoc);
          }
          method.kind = "method";
          const isPrivate2 = this.match(138);
          this.parseClassElementName(method);
          this.parsePostMemberNameModifiers(publicMember);
          if (isPrivate2) {
            this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
          } else {
            if (this.isNonstaticConstructor(publicMethod)) {
              this.raise(Errors.ConstructorIsAsync, publicMethod.key);
            }
            this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
          }
        } else if ((maybeContextualKw === "get" || maybeContextualKw === "set") && !(this.match(55) && this.isLineTerminator())) {
          this.resetPreviousNodeTrailingComments(key);
          method.kind = maybeContextualKw;
          const isPrivate2 = this.match(138);
          this.parseClassElementName(publicMethod);
          if (isPrivate2) {
            this.pushClassPrivateMethod(classBody, privateMethod, false, false);
          } else {
            if (this.isNonstaticConstructor(publicMethod)) {
              this.raise(Errors.ConstructorIsAccessor, publicMethod.key);
            }
            this.pushClassMethod(classBody, publicMethod, false, false, false, false);
          }
          this.checkGetterSetterParams(publicMethod);
        } else if (maybeContextualKw === "accessor" && !this.isLineTerminator()) {
          this.expectPlugin("decoratorAutoAccessors");
          this.resetPreviousNodeTrailingComments(key);
          const isPrivate2 = this.match(138);
          this.parseClassElementName(publicProp);
          this.pushClassAccessorProperty(classBody, accessorProp, isPrivate2);
        } else if (this.isLineTerminator()) {
          if (isPrivate) {
            this.pushClassPrivateProperty(classBody, privateProp);
          } else {
            this.pushClassProperty(classBody, publicProp);
          }
        } else {
          this.unexpected();
        }
      }
      parseClassElementName(member) {
        const {
          type,
          value
        } = this.state;
        if ((type === 132 || type === 133) && member.static && value === "prototype") {
          this.raise(Errors.StaticPrototype, this.state.startLoc);
        }
        if (type === 138) {
          if (value === "constructor") {
            this.raise(Errors.ConstructorClassPrivateField, this.state.startLoc);
          }
          const key = this.parsePrivateName();
          member.key = key;
          return key;
        }
        this.parsePropertyName(member);
        return member.key;
      }
      parseClassStaticBlock(classBody, member) {
        var _member$decorators;
        this.scope.enter(64 | 128 | 16);
        const oldLabels = this.state.labels;
        this.state.labels = [];
        this.prodParam.enter(0);
        const body = member.body = [];
        this.parseBlockOrModuleBlockBody(body, void 0, false, 8);
        this.prodParam.exit();
        this.scope.exit();
        this.state.labels = oldLabels;
        classBody.body.push(this.finishNode(member, "StaticBlock"));
        if ((_member$decorators = member.decorators) != null && _member$decorators.length) {
          this.raise(Errors.DecoratorStaticBlock, member);
        }
      }
      pushClassProperty(classBody, prop) {
        if (!prop.computed && this.nameIsConstructor(prop.key)) {
          this.raise(Errors.ConstructorClassField, prop.key);
        }
        classBody.body.push(this.parseClassProperty(prop));
      }
      pushClassPrivateProperty(classBody, prop) {
        const node = this.parseClassPrivateProperty(prop);
        classBody.body.push(node);
        this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);
      }
      pushClassAccessorProperty(classBody, prop, isPrivate) {
        if (!isPrivate && !prop.computed && this.nameIsConstructor(prop.key)) {
          this.raise(Errors.ConstructorClassField, prop.key);
        }
        const node = this.parseClassAccessorProperty(prop);
        classBody.body.push(node);
        if (isPrivate) {
          this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);
        }
      }
      pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
      }
      pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        const node = this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);
        classBody.body.push(node);
        const kind = node.kind === "get" ? node.static ? 6 : 2 : node.kind === "set" ? node.static ? 5 : 1 : 0;
        this.declareClassPrivateMethodInScope(node, kind);
      }
      declareClassPrivateMethodInScope(node, kind) {
        this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);
      }
      parsePostMemberNameModifiers(methodOrProp) {
      }
      parseClassPrivateProperty(node) {
        this.parseInitializer(node);
        this.semicolon();
        return this.finishNode(node, "ClassPrivateProperty");
      }
      parseClassProperty(node) {
        this.parseInitializer(node);
        this.semicolon();
        return this.finishNode(node, "ClassProperty");
      }
      parseClassAccessorProperty(node) {
        this.parseInitializer(node);
        this.semicolon();
        return this.finishNode(node, "ClassAccessorProperty");
      }
      parseInitializer(node) {
        this.scope.enter(64 | 16);
        this.expressionScope.enter(newExpressionScope());
        this.prodParam.enter(0);
        node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;
        this.expressionScope.exit();
        this.prodParam.exit();
        this.scope.exit();
      }
      parseClassId(node, isStatement, optionalId, bindingType = 8331) {
        if (tokenIsIdentifier(this.state.type)) {
          node.id = this.parseIdentifier();
          if (isStatement) {
            this.declareNameFromIdentifier(node.id, bindingType);
          }
        } else {
          if (optionalId || !isStatement) {
            node.id = null;
          } else {
            throw this.raise(Errors.MissingClassName, this.state.startLoc);
          }
        }
      }
      parseClassSuper(node) {
        node.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
      }
      parseExport(node, decorators) {
        const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, true);
        const hasDefault = this.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);
        const parseAfterDefault = !hasDefault || this.eat(12);
        const hasStar = parseAfterDefault && this.eatExportStar(node);
        const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);
        const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));
        const isFromRequired = hasDefault || hasStar;
        if (hasStar && !hasNamespace) {
          if (hasDefault)
            this.unexpected();
          if (decorators) {
            throw this.raise(Errors.UnsupportedDecoratorExport, node);
          }
          this.parseExportFrom(node, true);
          return this.finishNode(node, "ExportAllDeclaration");
        }
        const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);
        if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) {
          this.unexpected(null, 5);
        }
        if (hasNamespace && parseAfterNamespace) {
          this.unexpected(null, 98);
        }
        let hasDeclaration;
        if (isFromRequired || hasSpecifiers) {
          hasDeclaration = false;
          if (decorators) {
            throw this.raise(Errors.UnsupportedDecoratorExport, node);
          }
          this.parseExportFrom(node, isFromRequired);
        } else {
          hasDeclaration = this.maybeParseExportDeclaration(node);
        }
        if (isFromRequired || hasSpecifiers || hasDeclaration) {
          var _node2$declaration;
          const node2 = node;
          this.checkExport(node2, true, false, !!node2.source);
          if (((_node2$declaration = node2.declaration) == null ? void 0 : _node2$declaration.type) === "ClassDeclaration") {
            this.maybeTakeDecorators(decorators, node2.declaration, node2);
          } else if (decorators) {
            throw this.raise(Errors.UnsupportedDecoratorExport, node);
          }
          return this.finishNode(node2, "ExportNamedDeclaration");
        }
        if (this.eat(65)) {
          const node2 = node;
          const decl = this.parseExportDefaultExpression();
          node2.declaration = decl;
          if (decl.type === "ClassDeclaration") {
            this.maybeTakeDecorators(decorators, decl, node2);
          } else if (decorators) {
            throw this.raise(Errors.UnsupportedDecoratorExport, node);
          }
          this.checkExport(node2, true, true);
          return this.finishNode(node2, "ExportDefaultDeclaration");
        }
        this.unexpected(null, 5);
      }
      eatExportStar(node) {
        return this.eat(55);
      }
      maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
        if (maybeDefaultIdentifier || this.isExportDefaultSpecifier()) {
          this.expectPlugin("exportDefaultFrom", maybeDefaultIdentifier == null ? void 0 : maybeDefaultIdentifier.loc.start);
          const id = maybeDefaultIdentifier || this.parseIdentifier(true);
          const specifier = this.startNodeAtNode(id);
          specifier.exported = id;
          node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
          return true;
        }
        return false;
      }
      maybeParseExportNamespaceSpecifier(node) {
        if (this.isContextual(93)) {
          var _ref, _ref$specifiers;
          (_ref$specifiers = (_ref = node).specifiers) != null ? _ref$specifiers : _ref.specifiers = [];
          const specifier = this.startNodeAt(this.state.lastTokStartLoc);
          this.next();
          specifier.exported = this.parseModuleExportName();
          node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
          return true;
        }
        return false;
      }
      maybeParseExportNamedSpecifiers(node) {
        if (this.match(5)) {
          const node2 = node;
          if (!node2.specifiers)
            node2.specifiers = [];
          const isTypeExport = node2.exportKind === "type";
          node2.specifiers.push(...this.parseExportSpecifiers(isTypeExport));
          node2.source = null;
          node2.declaration = null;
          if (this.hasPlugin("importAssertions")) {
            node2.assertions = [];
          }
          return true;
        }
        return false;
      }
      maybeParseExportDeclaration(node) {
        if (this.shouldParseExportDeclaration()) {
          node.specifiers = [];
          node.source = null;
          if (this.hasPlugin("importAssertions")) {
            node.assertions = [];
          }
          node.declaration = this.parseExportDeclaration(node);
          return true;
        }
        return false;
      }
      isAsyncFunction() {
        if (!this.isContextual(95))
          return false;
        const next = this.nextTokenInLineStart();
        return this.isUnparsedContextual(next, "function");
      }
      parseExportDefaultExpression() {
        const expr = this.startNode();
        if (this.match(68)) {
          this.next();
          return this.parseFunction(expr, 1 | 4);
        } else if (this.isAsyncFunction()) {
          this.next();
          this.next();
          return this.parseFunction(expr, 1 | 4 | 8);
        }
        if (this.match(80)) {
          return this.parseClass(expr, true, true);
        }
        if (this.match(26)) {
          if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {
            this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);
          }
          return this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
        }
        if (this.match(75) || this.match(74) || this.isLet()) {
          throw this.raise(Errors.UnsupportedDefaultExport, this.state.startLoc);
        }
        const res = this.parseMaybeAssignAllowIn();
        this.semicolon();
        return res;
      }
      parseExportDeclaration(node) {
        if (this.match(80)) {
          const node2 = this.parseClass(this.startNode(), true, false);
          return node2;
        }
        return this.parseStatementListItem();
      }
      isExportDefaultSpecifier() {
        const {
          type
        } = this.state;
        if (tokenIsIdentifier(type)) {
          if (type === 95 && !this.state.containsEsc || type === 100) {
            return false;
          }
          if ((type === 130 || type === 129) && !this.state.containsEsc) {
            const {
              type: nextType
            } = this.lookahead();
            if (tokenIsIdentifier(nextType) && nextType !== 98 || nextType === 5) {
              this.expectOnePlugin(["flow", "typescript"]);
              return false;
            }
          }
        } else if (!this.match(65)) {
          return false;
        }
        const next = this.nextTokenStart();
        const hasFrom = this.isUnparsedContextual(next, "from");
        if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {
          return true;
        }
        if (this.match(65) && hasFrom) {
          const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
          return nextAfterFrom === 34 || nextAfterFrom === 39;
        }
        return false;
      }
      parseExportFrom(node, expect) {
        if (this.eatContextual(98)) {
          node.source = this.parseImportSource();
          this.checkExport(node);
          this.maybeParseImportAttributes(node);
          this.checkJSONModuleImport(node);
        } else if (expect) {
          this.unexpected();
        }
        this.semicolon();
      }
      shouldParseExportDeclaration() {
        const {
          type
        } = this.state;
        if (type === 26) {
          this.expectOnePlugin(["decorators", "decorators-legacy"]);
          if (this.hasPlugin("decorators")) {
            if (this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {
              this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);
            }
            return true;
          }
        }
        if (this.isContextual(107)) {
          this.raise(Errors.UsingDeclarationExport, this.state.startLoc);
          return true;
        }
        if (this.isContextual(96) && this.startsAwaitUsing()) {
          this.raise(Errors.UsingDeclarationExport, this.state.startLoc);
          return true;
        }
        return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();
      }
      checkExport(node, checkNames, isDefault, isFrom) {
        if (checkNames) {
          var _node$specifiers;
          if (isDefault) {
            this.checkDuplicateExports(node, "default");
            if (this.hasPlugin("exportDefaultFrom")) {
              var _declaration$extra;
              const declaration = node.declaration;
              if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {
                this.raise(Errors.ExportDefaultFromAsIdentifier, declaration);
              }
            }
          } else if ((_node$specifiers = node.specifiers) != null && _node$specifiers.length) {
            for (const specifier of node.specifiers) {
              const {
                exported
              } = specifier;
              const exportName = exported.type === "Identifier" ? exported.name : exported.value;
              this.checkDuplicateExports(specifier, exportName);
              if (!isFrom && specifier.local) {
                const {
                  local
                } = specifier;
                if (local.type !== "Identifier") {
                  this.raise(Errors.ExportBindingIsString, specifier, {
                    localName: local.value,
                    exportName
                  });
                } else {
                  this.checkReservedWord(local.name, local.loc.start, true, false);
                  this.scope.checkLocalExport(local);
                }
              }
            }
          } else if (node.declaration) {
            const decl = node.declaration;
            if (decl.type === "FunctionDeclaration" || decl.type === "ClassDeclaration") {
              const {
                id
              } = decl;
              if (!id)
                throw new Error("Assertion failure");
              this.checkDuplicateExports(node, id.name);
            } else if (decl.type === "VariableDeclaration") {
              for (const declaration of decl.declarations) {
                this.checkDeclaration(declaration.id);
              }
            }
          }
        }
      }
      checkDeclaration(node) {
        if (node.type === "Identifier") {
          this.checkDuplicateExports(node, node.name);
        } else if (node.type === "ObjectPattern") {
          for (const prop of node.properties) {
            this.checkDeclaration(prop);
          }
        } else if (node.type === "ArrayPattern") {
          for (const elem of node.elements) {
            if (elem) {
              this.checkDeclaration(elem);
            }
          }
        } else if (node.type === "ObjectProperty") {
          this.checkDeclaration(node.value);
        } else if (node.type === "RestElement") {
          this.checkDeclaration(node.argument);
        } else if (node.type === "AssignmentPattern") {
          this.checkDeclaration(node.left);
        }
      }
      checkDuplicateExports(node, exportName) {
        if (this.exportedIdentifiers.has(exportName)) {
          if (exportName === "default") {
            this.raise(Errors.DuplicateDefaultExport, node);
          } else {
            this.raise(Errors.DuplicateExport, node, {
              exportName
            });
          }
        }
        this.exportedIdentifiers.add(exportName);
      }
      parseExportSpecifiers(isInTypeExport) {
        const nodes = [];
        let first = true;
        this.expect(5);
        while (!this.eat(8)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
            if (this.eat(8))
              break;
          }
          const isMaybeTypeOnly = this.isContextual(130);
          const isString = this.match(133);
          const node = this.startNode();
          node.local = this.parseModuleExportName();
          nodes.push(this.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));
        }
        return nodes;
      }
      parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
        if (this.eatContextual(93)) {
          node.exported = this.parseModuleExportName();
        } else if (isString) {
          node.exported = cloneStringLiteral(node.local);
        } else if (!node.exported) {
          node.exported = cloneIdentifier(node.local);
        }
        return this.finishNode(node, "ExportSpecifier");
      }
      parseModuleExportName() {
        if (this.match(133)) {
          const result = this.parseStringLiteral(this.state.value);
          const surrogate = result.value.match(loneSurrogate);
          if (surrogate) {
            this.raise(Errors.ModuleExportNameHasLoneSurrogate, result, {
              surrogateCharCode: surrogate[0].charCodeAt(0)
            });
          }
          return result;
        }
        return this.parseIdentifier(true);
      }
      isJSONModuleImport(node) {
        if (node.assertions != null) {
          return node.assertions.some(({
            key,
            value
          }) => {
            return value.value === "json" && (key.type === "Identifier" ? key.name === "type" : key.value === "type");
          });
        }
        return false;
      }
      checkImportReflection(node) {
        const {
          specifiers
        } = node;
        const singleBindingType = specifiers.length === 1 ? specifiers[0].type : null;
        if (node.phase === "source") {
          if (singleBindingType !== "ImportDefaultSpecifier") {
            this.raise(Errors.SourcePhaseImportRequiresDefault, specifiers[0].loc.start);
          }
        } else if (node.phase === "defer") {
          if (singleBindingType !== "ImportNamespaceSpecifier") {
            this.raise(Errors.DeferImportRequiresNamespace, specifiers[0].loc.start);
          }
        } else if (node.module) {
          var _node$assertions;
          if (singleBindingType !== "ImportDefaultSpecifier") {
            this.raise(Errors.ImportReflectionNotBinding, specifiers[0].loc.start);
          }
          if (((_node$assertions = node.assertions) == null ? void 0 : _node$assertions.length) > 0) {
            this.raise(Errors.ImportReflectionHasAssertion, specifiers[0].loc.start);
          }
        }
      }
      checkJSONModuleImport(node) {
        if (this.isJSONModuleImport(node) && node.type !== "ExportAllDeclaration") {
          const {
            specifiers
          } = node;
          if (specifiers != null) {
            const nonDefaultNamedSpecifier = specifiers.find((specifier) => {
              let imported;
              if (specifier.type === "ExportSpecifier") {
                imported = specifier.local;
              } else if (specifier.type === "ImportSpecifier") {
                imported = specifier.imported;
              }
              if (imported !== void 0) {
                return imported.type === "Identifier" ? imported.name !== "default" : imported.value !== "default";
              }
            });
            if (nonDefaultNamedSpecifier !== void 0) {
              this.raise(Errors.ImportJSONBindingNotDefault, nonDefaultNamedSpecifier.loc.start);
            }
          }
        }
      }
      isPotentialImportPhase(isExport) {
        if (isExport)
          return false;
        return this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
      }
      applyImportPhase(node, isExport, phase, loc) {
        if (isExport) {
          return;
        }
        if (phase === "module") {
          this.expectPlugin("importReflection", loc);
          node.module = true;
        } else if (this.hasPlugin("importReflection")) {
          node.module = false;
        }
        if (phase === "source") {
          this.expectPlugin("sourcePhaseImports", loc);
          node.phase = "source";
        } else if (phase === "defer") {
          this.expectPlugin("deferredImportEvaluation", loc);
          node.phase = "defer";
        } else if (this.hasPlugin("sourcePhaseImports")) {
          node.phase = null;
        }
      }
      parseMaybeImportPhase(node, isExport) {
        if (!this.isPotentialImportPhase(isExport)) {
          this.applyImportPhase(node, isExport, null);
          return null;
        }
        const phaseIdentifier = this.parseIdentifier(true);
        const {
          type
        } = this.state;
        const isImportPhase = tokenIsKeywordOrIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;
        if (isImportPhase) {
          this.resetPreviousIdentifierLeadingComments(phaseIdentifier);
          this.applyImportPhase(node, isExport, phaseIdentifier.name, phaseIdentifier.loc.start);
          return null;
        } else {
          this.applyImportPhase(node, isExport, null);
          return phaseIdentifier;
        }
      }
      isPrecedingIdImportPhase(phase) {
        const {
          type
        } = this.state;
        return tokenIsIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;
      }
      parseImport(node) {
        if (this.match(133)) {
          return this.parseImportSourceAndAttributes(node);
        }
        return this.parseImportSpecifiersAndAfter(node, this.parseMaybeImportPhase(node, false));
      }
      parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier) {
        node.specifiers = [];
        const hasDefault = this.maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier);
        const parseNext = !hasDefault || this.eat(12);
        const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
        if (parseNext && !hasStar)
          this.parseNamedImportSpecifiers(node);
        this.expectContextual(98);
        return this.parseImportSourceAndAttributes(node);
      }
      parseImportSourceAndAttributes(node) {
        var _node$specifiers2;
        (_node$specifiers2 = node.specifiers) != null ? _node$specifiers2 : node.specifiers = [];
        node.source = this.parseImportSource();
        this.maybeParseImportAttributes(node);
        this.checkImportReflection(node);
        this.checkJSONModuleImport(node);
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      }
      parseImportSource() {
        if (!this.match(133))
          this.unexpected();
        return this.parseExprAtom();
      }
      parseImportSpecifierLocal(node, specifier, type) {
        specifier.local = this.parseIdentifier();
        node.specifiers.push(this.finishImportSpecifier(specifier, type));
      }
      finishImportSpecifier(specifier, type, bindingType = 8201) {
        this.checkLVal(specifier.local, {
          in: {
            type
          },
          binding: bindingType
        });
        return this.finishNode(specifier, type);
      }
      parseImportAttributes() {
        this.expect(5);
        const attrs = [];
        const attrNames = /* @__PURE__ */ new Set();
        do {
          if (this.match(8)) {
            break;
          }
          const node = this.startNode();
          const keyName = this.state.value;
          if (attrNames.has(keyName)) {
            this.raise(Errors.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
              key: keyName
            });
          }
          attrNames.add(keyName);
          if (this.match(133)) {
            node.key = this.parseStringLiteral(keyName);
          } else {
            node.key = this.parseIdentifier(true);
          }
          this.expect(14);
          if (!this.match(133)) {
            throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);
          }
          node.value = this.parseStringLiteral(this.state.value);
          attrs.push(this.finishNode(node, "ImportAttribute"));
        } while (this.eat(12));
        this.expect(8);
        return attrs;
      }
      parseModuleAttributes() {
        const attrs = [];
        const attributes = /* @__PURE__ */ new Set();
        do {
          const node = this.startNode();
          node.key = this.parseIdentifier(true);
          if (node.key.name !== "type") {
            this.raise(Errors.ModuleAttributeDifferentFromType, node.key);
          }
          if (attributes.has(node.key.name)) {
            this.raise(Errors.ModuleAttributesWithDuplicateKeys, node.key, {
              key: node.key.name
            });
          }
          attributes.add(node.key.name);
          this.expect(14);
          if (!this.match(133)) {
            throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);
          }
          node.value = this.parseStringLiteral(this.state.value);
          attrs.push(this.finishNode(node, "ImportAttribute"));
        } while (this.eat(12));
        return attrs;
      }
      maybeParseImportAttributes(node) {
        let attributes;
        let useWith = false;
        if (this.match(76)) {
          if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) {
            return;
          }
          this.next();
          {
            if (this.hasPlugin("moduleAttributes")) {
              attributes = this.parseModuleAttributes();
            } else {
              this.expectImportAttributesPlugin();
              attributes = this.parseImportAttributes();
            }
          }
          useWith = true;
        } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {
          if (this.hasPlugin("importAttributes")) {
            if (this.getPluginOption("importAttributes", "deprecatedAssertSyntax") !== true) {
              this.raise(Errors.ImportAttributesUseAssert, this.state.startLoc);
            }
            this.addExtra(node, "deprecatedAssertSyntax", true);
          } else {
            this.expectOnePlugin(["importAttributes", "importAssertions"]);
          }
          this.next();
          attributes = this.parseImportAttributes();
        } else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
          attributes = [];
        } else {
          if (this.hasPlugin("moduleAttributes")) {
            attributes = [];
          } else
            return;
        }
        if (!useWith && this.hasPlugin("importAssertions")) {
          node.assertions = attributes;
        } else {
          node.attributes = attributes;
        }
      }
      maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier) {
        if (maybeDefaultIdentifier) {
          const specifier = this.startNodeAtNode(maybeDefaultIdentifier);
          specifier.local = maybeDefaultIdentifier;
          node.specifiers.push(this.finishImportSpecifier(specifier, "ImportDefaultSpecifier"));
          return true;
        } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
          this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier");
          return true;
        }
        return false;
      }
      maybeParseStarImportSpecifier(node) {
        if (this.match(55)) {
          const specifier = this.startNode();
          this.next();
          this.expectContextual(93);
          this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier");
          return true;
        }
        return false;
      }
      parseNamedImportSpecifiers(node) {
        let first = true;
        this.expect(5);
        while (!this.eat(8)) {
          if (first) {
            first = false;
          } else {
            if (this.eat(14)) {
              throw this.raise(Errors.DestructureNamedImport, this.state.startLoc);
            }
            this.expect(12);
            if (this.eat(8))
              break;
          }
          const specifier = this.startNode();
          const importedIsString = this.match(133);
          const isMaybeTypeOnly = this.isContextual(130);
          specifier.imported = this.parseModuleExportName();
          const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node.importKind === "type" || node.importKind === "typeof", isMaybeTypeOnly, void 0);
          node.specifiers.push(importSpecifier);
        }
      }
      parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
        if (this.eatContextual(93)) {
          specifier.local = this.parseIdentifier();
        } else {
          const {
            imported
          } = specifier;
          if (importedIsString) {
            throw this.raise(Errors.ImportBindingIsString, specifier, {
              importName: imported.value
            });
          }
          this.checkReservedWord(imported.name, specifier.loc.start, true, true);
          if (!specifier.local) {
            specifier.local = cloneIdentifier(imported);
          }
        }
        return this.finishImportSpecifier(specifier, "ImportSpecifier", bindingType);
      }
      isThisParam(param) {
        return param.type === "Identifier" && param.name === "this";
      }
    };
    var Parser = class extends StatementParser {
      constructor(options, input) {
        options = getOptions(options);
        super(options, input);
        this.options = options;
        this.initializeScopes();
        this.plugins = pluginsMap(this.options.plugins);
        this.filename = options.sourceFilename;
      }
      getScopeHandler() {
        return ScopeHandler;
      }
      parse() {
        this.enterInitialScopes();
        const file = this.startNode();
        const program = this.startNode();
        this.nextToken();
        file.errors = null;
        this.parseTopLevel(file, program);
        file.errors = this.state.errors;
        file.comments.length = this.state.commentsLen;
        return file;
      }
    };
    function pluginsMap(plugins) {
      const pluginMap = /* @__PURE__ */ new Map();
      for (const plugin of plugins) {
        const [name, options] = Array.isArray(plugin) ? plugin : [plugin, {}];
        if (!pluginMap.has(name))
          pluginMap.set(name, options || {});
      }
      return pluginMap;
    }
    function parse(input, options) {
      var _options;
      if (((_options = options) == null ? void 0 : _options.sourceType) === "unambiguous") {
        options = Object.assign({}, options);
        try {
          options.sourceType = "module";
          const parser = getParser(options, input);
          const ast = parser.parse();
          if (parser.sawUnambiguousESM) {
            return ast;
          }
          if (parser.ambiguousScriptDifferentAst) {
            try {
              options.sourceType = "script";
              return getParser(options, input).parse();
            } catch (_unused) {
            }
          } else {
            ast.program.sourceType = "script";
          }
          return ast;
        } catch (moduleError) {
          try {
            options.sourceType = "script";
            return getParser(options, input).parse();
          } catch (_unused2) {
          }
          throw moduleError;
        }
      } else {
        return getParser(options, input).parse();
      }
    }
    function parseExpression(input, options) {
      const parser = getParser(options, input);
      if (parser.options.strictMode) {
        parser.state.strict = true;
      }
      return parser.getExpression();
    }
    function generateExportedTokenTypes(internalTokenTypes) {
      const tokenTypes2 = {};
      for (const typeName of Object.keys(internalTokenTypes)) {
        tokenTypes2[typeName] = getExportedToken(internalTokenTypes[typeName]);
      }
      return tokenTypes2;
    }
    var tokTypes = generateExportedTokenTypes(tt);
    function getParser(options, input) {
      let cls = Parser;
      if (options != null && options.plugins) {
        validatePlugins(options.plugins);
        cls = getParserClass(options.plugins);
      }
      return new cls(options, input);
    }
    var parserClassCache = {};
    function getParserClass(pluginsFromOptions) {
      const pluginList = mixinPluginNames.filter((name) => hasPlugin(pluginsFromOptions, name));
      const key = pluginList.join("/");
      let cls = parserClassCache[key];
      if (!cls) {
        cls = Parser;
        for (const plugin of pluginList) {
          cls = mixinPlugins[plugin](cls);
        }
        parserClassCache[key] = cls;
      }
      return cls;
    }
    exports.parse = parse;
    exports.parseExpression = parseExpression;
    exports.tokTypes = tokTypes;
  }
});

// node_modules/estree-walker/dist/umd/estree-walker.js
var require_estree_walker = __commonJS({
  "node_modules/estree-walker/dist/umd/estree-walker.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.estreeWalker = {}));
    })(exports, function(exports2) {
      "use strict";
      class WalkerBase {
        constructor() {
          this.should_skip = false;
          this.should_remove = false;
          this.replacement = null;
          this.context = {
            skip: () => this.should_skip = true,
            remove: () => this.should_remove = true,
            replace: (node) => this.replacement = node
          };
        }
        replace(parent, prop, index, node) {
          if (parent) {
            if (index !== null) {
              parent[prop][index] = node;
            } else {
              parent[prop] = node;
            }
          }
        }
        remove(parent, prop, index) {
          if (parent) {
            if (index !== null) {
              parent[prop].splice(index, 1);
            } else {
              delete parent[prop];
            }
          }
        }
      }
      class SyncWalker extends WalkerBase {
        constructor(enter, leave) {
          super();
          this.enter = enter;
          this.leave = leave;
        }
        visit(node, parent, prop, index) {
          if (node) {
            if (this.enter) {
              const _should_skip = this.should_skip;
              const _should_remove = this.should_remove;
              const _replacement = this.replacement;
              this.should_skip = false;
              this.should_remove = false;
              this.replacement = null;
              this.enter.call(this.context, node, parent, prop, index);
              if (this.replacement) {
                node = this.replacement;
                this.replace(parent, prop, index, node);
              }
              if (this.should_remove) {
                this.remove(parent, prop, index);
              }
              const skipped = this.should_skip;
              const removed = this.should_remove;
              this.should_skip = _should_skip;
              this.should_remove = _should_remove;
              this.replacement = _replacement;
              if (skipped)
                return node;
              if (removed)
                return null;
            }
            for (const key in node) {
              const value = node[key];
              if (typeof value !== "object") {
                continue;
              } else if (Array.isArray(value)) {
                for (let i = 0; i < value.length; i += 1) {
                  if (value[i] !== null && typeof value[i].type === "string") {
                    if (!this.visit(value[i], node, key, i)) {
                      i--;
                    }
                  }
                }
              } else if (value !== null && typeof value.type === "string") {
                this.visit(value, node, key, null);
              }
            }
            if (this.leave) {
              const _replacement = this.replacement;
              const _should_remove = this.should_remove;
              this.replacement = null;
              this.should_remove = false;
              this.leave.call(this.context, node, parent, prop, index);
              if (this.replacement) {
                node = this.replacement;
                this.replace(parent, prop, index, node);
              }
              if (this.should_remove) {
                this.remove(parent, prop, index);
              }
              const removed = this.should_remove;
              this.replacement = _replacement;
              this.should_remove = _should_remove;
              if (removed)
                return null;
            }
          }
          return node;
        }
      }
      class AsyncWalker extends WalkerBase {
        constructor(enter, leave) {
          super();
          this.enter = enter;
          this.leave = leave;
        }
        async visit(node, parent, prop, index) {
          if (node) {
            if (this.enter) {
              const _should_skip = this.should_skip;
              const _should_remove = this.should_remove;
              const _replacement = this.replacement;
              this.should_skip = false;
              this.should_remove = false;
              this.replacement = null;
              await this.enter.call(this.context, node, parent, prop, index);
              if (this.replacement) {
                node = this.replacement;
                this.replace(parent, prop, index, node);
              }
              if (this.should_remove) {
                this.remove(parent, prop, index);
              }
              const skipped = this.should_skip;
              const removed = this.should_remove;
              this.should_skip = _should_skip;
              this.should_remove = _should_remove;
              this.replacement = _replacement;
              if (skipped)
                return node;
              if (removed)
                return null;
            }
            for (const key in node) {
              const value = node[key];
              if (typeof value !== "object") {
                continue;
              } else if (Array.isArray(value)) {
                for (let i = 0; i < value.length; i += 1) {
                  if (value[i] !== null && typeof value[i].type === "string") {
                    if (!await this.visit(value[i], node, key, i)) {
                      i--;
                    }
                  }
                }
              } else if (value !== null && typeof value.type === "string") {
                await this.visit(value, node, key, null);
              }
            }
            if (this.leave) {
              const _replacement = this.replacement;
              const _should_remove = this.should_remove;
              this.replacement = null;
              this.should_remove = false;
              await this.leave.call(this.context, node, parent, prop, index);
              if (this.replacement) {
                node = this.replacement;
                this.replace(parent, prop, index, node);
              }
              if (this.should_remove) {
                this.remove(parent, prop, index);
              }
              const removed = this.should_remove;
              this.replacement = _replacement;
              this.should_remove = _should_remove;
              if (removed)
                return null;
            }
          }
          return node;
        }
      }
      function walk(ast, { enter, leave }) {
        const instance = new SyncWalker(enter, leave);
        return instance.visit(ast, null);
      }
      async function asyncWalk(ast, { enter, leave }) {
        const instance = new AsyncWalker(enter, leave);
        return await instance.visit(ast, null);
      }
      exports2.asyncWalk = asyncWalk;
      exports2.walk = walk;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/source-map-js/lib/base64.js
var require_base64 = __commonJS({
  "node_modules/source-map-js/lib/base64.js"(exports) {
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    exports.encode = function(number) {
      if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
      }
      throw new TypeError("Must be between 0 and 63: " + number);
    };
    exports.decode = function(charCode) {
      var bigA = 65;
      var bigZ = 90;
      var littleA = 97;
      var littleZ = 122;
      var zero = 48;
      var nine = 57;
      var plus = 43;
      var slash = 47;
      var littleOffset = 26;
      var numberOffset = 52;
      if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
      }
      if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
      }
      if (zero <= charCode && charCode <= nine) {
        return charCode - zero + numberOffset;
      }
      if (charCode == plus) {
        return 62;
      }
      if (charCode == slash) {
        return 63;
      }
      return -1;
    };
  }
});

// node_modules/source-map-js/lib/base64-vlq.js
var require_base64_vlq = __commonJS({
  "node_modules/source-map-js/lib/base64-vlq.js"(exports) {
    var base64 = require_base64();
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    var VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    function fromVLQSigned(aValue) {
      var isNegative = (aValue & 1) === 1;
      var shifted = aValue >> 1;
      return isNegative ? -shifted : shifted;
    }
    exports.encode = function base64VLQ_encode(aValue) {
      var encoded = "";
      var digit;
      var vlq = toVLQSigned(aValue);
      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
      } while (vlq > 0);
      return encoded;
    };
    exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
      var strLen = aStr.length;
      var result = 0;
      var shift = 0;
      var continuation, digit;
      do {
        if (aIndex >= strLen) {
          throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base64.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift);
        shift += VLQ_BASE_SHIFT;
      } while (continuation);
      aOutParam.value = fromVLQSigned(result);
      aOutParam.rest = aIndex;
    };
  }
});

// node_modules/source-map-js/lib/util.js
var require_util = __commonJS({
  "node_modules/source-map-js/lib/util.js"(exports) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);
      if (!match) {
        return null;
      }
      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      };
    }
    exports.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url = "";
      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ":";
      }
      url += "//";
      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }
      return url;
    }
    exports.urlGenerate = urlGenerate;
    var MAX_CACHED_INPUTS = 32;
    function lruMemoize(f) {
      var cache = [];
      return function(input) {
        for (var i = 0; i < cache.length; i++) {
          if (cache[i].input === input) {
            var temp = cache[0];
            cache[0] = cache[i];
            cache[i] = temp;
            return cache[0].result;
          }
        }
        var result = f(input);
        cache.unshift({
          input,
          result
        });
        if (cache.length > MAX_CACHED_INPUTS) {
          cache.pop();
        }
        return result;
      };
    }
    var normalize = lruMemoize(function normalize2(aPath) {
      var path = aPath;
      var url = urlParse(aPath);
      if (url) {
        if (!url.path) {
          return aPath;
        }
        path = url.path;
      }
      var isAbsolute = exports.isAbsolute(path);
      var parts = [];
      var start = 0;
      var i = 0;
      while (true) {
        start = i;
        i = path.indexOf("/", start);
        if (i === -1) {
          parts.push(path.slice(start));
          break;
        } else {
          parts.push(path.slice(start, i));
          while (i < path.length && path[i] === "/") {
            i++;
          }
        }
      }
      for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
        part = parts[i];
        if (part === ".") {
          parts.splice(i, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i + 1, up);
            up = 0;
          } else {
            parts.splice(i, 2);
            up--;
          }
        }
      }
      path = parts.join("/");
      if (path === "") {
        path = isAbsolute ? "/" : ".";
      }
      if (url) {
        url.path = path;
        return urlGenerate(url);
      }
      return path;
    });
    exports.normalize = normalize;
    function join(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports.join = join;
    exports.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      var level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        var index = aRoot.lastIndexOf("/");
        if (index < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports.relative = relative;
    var supportsNullProto = function() {
      var obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    }();
    function identity(s) {
      return s;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s) {
      if (!s) {
        return false;
      }
      var length = s.length;
      if (length < 9) {
        return false;
      }
      if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
        return false;
      }
      for (var i = length - 10; i >= 0; i--) {
        if (s.charCodeAt(i) !== 36) {
          return false;
        }
      }
      return true;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByOriginalPositions = compareByOriginalPositions;
    function compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {
      var cmp;
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 === null) {
        return 1;
      }
      if (aStr2 === null) {
        return -1;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
    }
    exports.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      sourceURL = sourceURL || "";
      if (sourceRoot) {
        if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
          sourceRoot += "/";
        }
        sourceURL = sourceRoot + sourceURL;
      }
      if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
          throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
          var index = parsed.path.lastIndexOf("/");
          if (index >= 0) {
            parsed.path = parsed.path.substring(0, index + 1);
          }
        }
        sourceURL = join(urlGenerate(parsed), sourceURL);
      }
      return normalize(sourceURL);
    }
    exports.computeSourceURL = computeSourceURL;
  }
});

// node_modules/source-map-js/lib/array-set.js
var require_array_set = __commonJS({
  "node_modules/source-map-js/lib/array-set.js"(exports) {
    var util = require_util();
    var has = Object.prototype.hasOwnProperty;
    var hasNativeMap = typeof Map !== "undefined";
    function ArraySet() {
      this._array = [];
      this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
    }
    ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
      var set = new ArraySet();
      for (var i = 0, len = aArray.length; i < len; i++) {
        set.add(aArray[i], aAllowDuplicates);
      }
      return set;
    };
    ArraySet.prototype.size = function ArraySet_size() {
      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };
    ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
      var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
      var idx = this._array.length;
      if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
      }
      if (!isDuplicate) {
        if (hasNativeMap) {
          this._set.set(aStr, idx);
        } else {
          this._set[sStr] = idx;
        }
      }
    };
    ArraySet.prototype.has = function ArraySet_has(aStr) {
      if (hasNativeMap) {
        return this._set.has(aStr);
      } else {
        var sStr = util.toSetString(aStr);
        return has.call(this._set, sStr);
      }
    };
    ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
      if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
          return idx;
        }
      } else {
        var sStr = util.toSetString(aStr);
        if (has.call(this._set, sStr)) {
          return this._set[sStr];
        }
      }
      throw new Error('"' + aStr + '" is not in the set.');
    };
    ArraySet.prototype.at = function ArraySet_at(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
      }
      throw new Error("No element indexed by " + aIdx);
    };
    ArraySet.prototype.toArray = function ArraySet_toArray() {
      return this._array.slice();
    };
    exports.ArraySet = ArraySet;
  }
});

// node_modules/source-map-js/lib/mapping-list.js
var require_mapping_list = __commonJS({
  "node_modules/source-map-js/lib/mapping-list.js"(exports) {
    var util = require_util();
    function generatedPositionAfter(mappingA, mappingB) {
      var lineA = mappingA.generatedLine;
      var lineB = mappingB.generatedLine;
      var columnA = mappingA.generatedColumn;
      var columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    function MappingList() {
      this._array = [];
      this._sorted = true;
      this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };
    MappingList.prototype.add = function MappingList_add(aMapping) {
      if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
      } else {
        this._sorted = false;
        this._array.push(aMapping);
      }
    };
    MappingList.prototype.toArray = function MappingList_toArray() {
      if (!this._sorted) {
        this._array.sort(util.compareByGeneratedPositionsInflated);
        this._sorted = true;
      }
      return this._array;
    };
    exports.MappingList = MappingList;
  }
});

// node_modules/source-map-js/lib/source-map-generator.js
var require_source_map_generator = __commonJS({
  "node_modules/source-map-js/lib/source-map-generator.js"(exports) {
    var base64VLQ = require_base64_vlq();
    var util = require_util();
    var ArraySet = require_array_set().ArraySet;
    var MappingList = require_mapping_list().MappingList;
    function SourceMapGenerator(aArgs) {
      if (!aArgs) {
        aArgs = {};
      }
      this._file = util.getArg(aArgs, "file", null);
      this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
      this._skipValidation = util.getArg(aArgs, "skipValidation", false);
      this._ignoreInvalidMapping = util.getArg(aArgs, "ignoreInvalidMapping", false);
      this._sources = new ArraySet();
      this._names = new ArraySet();
      this._mappings = new MappingList();
      this._sourcesContents = null;
    }
    SourceMapGenerator.prototype._version = 3;
    SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer, generatorOps) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator(Object.assign(generatorOps || {}, {
        file: aSourceMapConsumer.file,
        sourceRoot
      }));
      aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };
        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }
          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };
          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }
        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var sourceRelative = sourceFile;
        if (sourceRoot !== null) {
          sourceRelative = util.relative(sourceRoot, sourceFile);
        }
        if (!generator._sources.has(sourceRelative)) {
          generator._sources.add(sourceRelative);
        }
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };
    SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, "generated");
      var original = util.getArg(aArgs, "original", null);
      var source = util.getArg(aArgs, "source", null);
      var name = util.getArg(aArgs, "name", null);
      if (!this._skipValidation) {
        if (this._validateMapping(generated, original, source, name) === false) {
          return;
        }
      }
      if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
          this._sources.add(source);
        }
      }
      if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
          this._names.add(name);
        }
      }
      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source,
        name
      });
    };
    SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }
      if (aSourceContent != null) {
        if (!this._sourcesContents) {
          this._sourcesContents = /* @__PURE__ */ Object.create(null);
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };
    SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      var newSources = new ArraySet();
      var newNames = new ArraySet();
      this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }
        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }
        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }
      }, this);
      this._sources = newSources;
      this._names = newNames;
      aSourceMapConsumer.sources.forEach(function(sourceFile2) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile2 = util.join(aSourceMapPath, sourceFile2);
          }
          if (sourceRoot != null) {
            sourceFile2 = util.relative(sourceRoot, sourceFile2);
          }
          this.setSourceContent(sourceFile2, content);
        }
      }, this);
    };
    SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
        var message = "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.";
        if (this._ignoreInvalidMapping) {
          if (typeof console !== "undefined" && console.warn) {
            console.warn(message);
          }
          return false;
        } else {
          throw new Error(message);
        }
      }
      if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        return;
      } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        return;
      } else {
        var message = "Invalid mapping: " + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        });
        if (this._ignoreInvalidMapping) {
          if (typeof console !== "undefined" && console.warn) {
            console.warn(message);
          }
          return false;
        } else {
          throw new Error(message);
        }
      }
    };
    SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = "";
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;
      var mappings = this._mappings.toArray();
      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];
        next = "";
        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ";";
            previousGeneratedLine++;
          }
        } else {
          if (i > 0) {
            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
              continue;
            }
            next += ",";
          }
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64VLQ.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;
          next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;
          next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;
          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64VLQ.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }
        result += next;
      }
      return result;
    };
    SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function(source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
      }, this);
    };
    SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }
      return map;
    };
    SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };
    exports.SourceMapGenerator = SourceMapGenerator;
  }
});

// node_modules/source-map-js/lib/binary-search.js
var require_binary_search = __commonJS({
  "node_modules/source-map-js/lib/binary-search.js"(exports) {
    exports.GREATEST_LOWER_BOUND = 1;
    exports.LEAST_UPPER_BOUND = 2;
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow;
      var cmp = aCompare(aNeedle, aHaystack[mid], true);
      if (cmp === 0) {
        return mid;
      } else if (cmp > 0) {
        if (aHigh - mid > 1) {
          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        } else {
          return mid;
        }
      } else {
        if (mid - aLow > 1) {
          return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return mid;
        } else {
          return aLow < 0 ? -1 : aLow;
        }
      }
    }
    exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }
      var index = recursiveSearch(
        -1,
        aHaystack.length,
        aNeedle,
        aHaystack,
        aCompare,
        aBias || exports.GREATEST_LOWER_BOUND
      );
      if (index < 0) {
        return -1;
      }
      while (index - 1 >= 0) {
        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
          break;
        }
        --index;
      }
      return index;
    };
  }
});

// node_modules/source-map-js/lib/quick-sort.js
var require_quick_sort = __commonJS({
  "node_modules/source-map-js/lib/quick-sort.js"(exports) {
    function SortTemplate(comparator) {
      function swap(ary, x, y) {
        var temp = ary[x];
        ary[x] = ary[y];
        ary[y] = temp;
      }
      function randomIntInRange(low, high) {
        return Math.round(low + Math.random() * (high - low));
      }
      function doQuickSort(ary, comparator2, p, r) {
        if (p < r) {
          var pivotIndex = randomIntInRange(p, r);
          var i = p - 1;
          swap(ary, pivotIndex, r);
          var pivot = ary[r];
          for (var j = p; j < r; j++) {
            if (comparator2(ary[j], pivot, false) <= 0) {
              i += 1;
              swap(ary, i, j);
            }
          }
          swap(ary, i + 1, j);
          var q = i + 1;
          doQuickSort(ary, comparator2, p, q - 1);
          doQuickSort(ary, comparator2, q + 1, r);
        }
      }
      return doQuickSort;
    }
    function cloneSort(comparator) {
      let template = SortTemplate.toString();
      let templateFn = new Function(`return ${template}`)();
      return templateFn(comparator);
    }
    var sortCache = /* @__PURE__ */ new WeakMap();
    exports.quickSort = function(ary, comparator, start = 0) {
      let doQuickSort = sortCache.get(comparator);
      if (doQuickSort === void 0) {
        doQuickSort = cloneSort(comparator);
        sortCache.set(comparator, doQuickSort);
      }
      doQuickSort(ary, comparator, start, ary.length - 1);
    };
  }
});

// node_modules/source-map-js/lib/source-map-consumer.js
var require_source_map_consumer = __commonJS({
  "node_modules/source-map-js/lib/source-map-consumer.js"(exports) {
    var util = require_util();
    var binarySearch = require_binary_search();
    var ArraySet = require_array_set().ArraySet;
    var base64VLQ = require_base64_vlq();
    var quickSort = require_quick_sort().quickSort;
    function SourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
    }
    SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
      return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
    };
    SourceMapConsumer.prototype._version = 3;
    SourceMapConsumer.prototype.__generatedMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__generatedMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__generatedMappings;
      }
    });
    SourceMapConsumer.prototype.__originalMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__originalMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__originalMappings;
      }
    });
    SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
      var c = aStr.charAt(index);
      return c === ";" || c === ",";
    };
    SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };
    SourceMapConsumer.GENERATED_ORDER = 1;
    SourceMapConsumer.ORIGINAL_ORDER = 2;
    SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
    SourceMapConsumer.LEAST_UPPER_BOUND = 2;
    SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
      var mappings;
      switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
          mappings = this._generatedMappings;
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          mappings = this._originalMappings;
          break;
        default:
          throw new Error("Unknown order of iteration.");
      }
      var sourceRoot = this.sourceRoot;
      var boundCallback = aCallback.bind(context);
      var names = this._names;
      var sources = this._sources;
      var sourceMapURL = this._sourceMapURL;
      for (var i = 0, n = mappings.length; i < n; i++) {
        var mapping = mappings[i];
        var source = mapping.source === null ? null : sources.at(mapping.source);
        source = util.computeSourceURL(sourceRoot, source, sourceMapURL);
        boundCallback({
          source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : names.at(mapping.name)
        });
      }
    };
    SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      var line = util.getArg(aArgs, "line");
      var needle = {
        source: util.getArg(aArgs, "source"),
        originalLine: line,
        originalColumn: util.getArg(aArgs, "column", 0)
      };
      needle.source = this._findSourceIndex(needle.source);
      if (needle.source < 0) {
        return [];
      }
      var mappings = [];
      var index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        binarySearch.LEAST_UPPER_BOUND
      );
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (aArgs.column === void 0) {
          var originalLine = mapping.originalLine;
          while (mapping && mapping.originalLine === originalLine) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        } else {
          var originalColumn = mapping.originalColumn;
          while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        }
      }
      return mappings;
    };
    exports.SourceMapConsumer = SourceMapConsumer;
    function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      var version = util.getArg(sourceMap, "version");
      var sources = util.getArg(sourceMap, "sources");
      var names = util.getArg(sourceMap, "names", []);
      var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
      var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
      var mappings = util.getArg(sourceMap, "mappings");
      var file = util.getArg(sourceMap, "file", null);
      if (version != this._version) {
        throw new Error("Unsupported version: " + version);
      }
      if (sourceRoot) {
        sourceRoot = util.normalize(sourceRoot);
      }
      sources = sources.map(String).map(util.normalize).map(function(source) {
        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
      });
      this._names = ArraySet.fromArray(names.map(String), true);
      this._sources = ArraySet.fromArray(sources, true);
      this._absoluteSources = this._sources.toArray().map(function(s) {
        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
      });
      this.sourceRoot = sourceRoot;
      this.sourcesContent = sourcesContent;
      this._mappings = mappings;
      this._sourceMapURL = aSourceMapURL;
      this.file = file;
    }
    BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
    BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }
      if (this._sources.has(relativeSource)) {
        return this._sources.indexOf(relativeSource);
      }
      var i;
      for (i = 0; i < this._absoluteSources.length; ++i) {
        if (this._absoluteSources[i] == aSource) {
          return i;
        }
      }
      return -1;
    };
    BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);
      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(
        smc._sources.toArray(),
        smc.sourceRoot
      );
      smc.file = aSourceMap._file;
      smc._sourceMapURL = aSourceMapURL;
      smc._absoluteSources = smc._sources.toArray().map(function(s) {
        return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
      });
      var generatedMappings = aSourceMap._mappings.toArray().slice();
      var destGeneratedMappings = smc.__generatedMappings = [];
      var destOriginalMappings = smc.__originalMappings = [];
      for (var i = 0, length = generatedMappings.length; i < length; i++) {
        var srcMapping = generatedMappings[i];
        var destMapping = new Mapping();
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;
        if (srcMapping.source) {
          destMapping.source = sources.indexOf(srcMapping.source);
          destMapping.originalLine = srcMapping.originalLine;
          destMapping.originalColumn = srcMapping.originalColumn;
          if (srcMapping.name) {
            destMapping.name = names.indexOf(srcMapping.name);
          }
          destOriginalMappings.push(destMapping);
        }
        destGeneratedMappings.push(destMapping);
      }
      quickSort(smc.__originalMappings, util.compareByOriginalPositions);
      return smc;
    };
    BasicSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
      get: function() {
        return this._absoluteSources.slice();
      }
    });
    function Mapping() {
      this.generatedLine = 0;
      this.generatedColumn = 0;
      this.source = null;
      this.originalLine = null;
      this.originalColumn = null;
      this.name = null;
    }
    var compareGenerated = util.compareByGeneratedPositionsDeflatedNoLine;
    function sortGenerated(array, start) {
      let l = array.length;
      let n = array.length - start;
      if (n <= 1) {
        return;
      } else if (n == 2) {
        let a = array[start];
        let b = array[start + 1];
        if (compareGenerated(a, b) > 0) {
          array[start] = b;
          array[start + 1] = a;
        }
      } else if (n < 20) {
        for (let i = start; i < l; i++) {
          for (let j = i; j > start; j--) {
            let a = array[j - 1];
            let b = array[j];
            if (compareGenerated(a, b) <= 0) {
              break;
            }
            array[j - 1] = b;
            array[j] = a;
          }
        }
      } else {
        quickSort(array, compareGenerated, start);
      }
    }
    BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var length = aStr.length;
      var index = 0;
      var cachedSegments = {};
      var temp = {};
      var originalMappings = [];
      var generatedMappings = [];
      var mapping, str, segment, end, value;
      let subarrayStart = 0;
      while (index < length) {
        if (aStr.charAt(index) === ";") {
          generatedLine++;
          index++;
          previousGeneratedColumn = 0;
          sortGenerated(generatedMappings, subarrayStart);
          subarrayStart = generatedMappings.length;
        } else if (aStr.charAt(index) === ",") {
          index++;
        } else {
          mapping = new Mapping();
          mapping.generatedLine = generatedLine;
          for (end = index; end < length; end++) {
            if (this._charIsMappingSeparator(aStr, end)) {
              break;
            }
          }
          str = aStr.slice(index, end);
          segment = [];
          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }
          if (segment.length === 2) {
            throw new Error("Found a source, but no line and column");
          }
          if (segment.length === 3) {
            throw new Error("Found a source and line, but no column");
          }
          mapping.generatedColumn = previousGeneratedColumn + segment[0];
          previousGeneratedColumn = mapping.generatedColumn;
          if (segment.length > 1) {
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];
            mapping.originalLine = previousOriginalLine + segment[2];
            previousOriginalLine = mapping.originalLine;
            mapping.originalLine += 1;
            mapping.originalColumn = previousOriginalColumn + segment[3];
            previousOriginalColumn = mapping.originalColumn;
            if (segment.length > 4) {
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }
          generatedMappings.push(mapping);
          if (typeof mapping.originalLine === "number") {
            let currentSource = mapping.source;
            while (originalMappings.length <= currentSource) {
              originalMappings.push(null);
            }
            if (originalMappings[currentSource] === null) {
              originalMappings[currentSource] = [];
            }
            originalMappings[currentSource].push(mapping);
          }
        }
      }
      sortGenerated(generatedMappings, subarrayStart);
      this.__generatedMappings = generatedMappings;
      for (var i = 0; i < originalMappings.length; i++) {
        if (originalMappings[i] != null) {
          quickSort(originalMappings[i], util.compareByOriginalPositionsNoSource);
        }
      }
      this.__originalMappings = [].concat(...originalMappings);
    };
    BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
      if (aNeedle[aLineName] <= 0) {
        throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
      }
      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
    };
    BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];
          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }
        mapping.lastGeneratedColumn = Infinity;
      }
    };
    BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var index = this._findMapping(
        needle,
        this._generatedMappings,
        "generatedLine",
        "generatedColumn",
        util.compareByGeneratedPositionsDeflated,
        util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index >= 0) {
        var mapping = this._generatedMappings[index];
        if (mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, "source", null);
          if (source !== null) {
            source = this._sources.at(source);
            source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
          }
          var name = util.getArg(mapping, "name", null);
          if (name !== null) {
            name = this._names.at(name);
          }
          return {
            source,
            line: util.getArg(mapping, "originalLine", null),
            column: util.getArg(mapping, "originalColumn", null),
            name
          };
        }
      }
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };
    BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
      if (!this.sourcesContent) {
        return false;
      }
      return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
        return sc == null;
      });
    };
    BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }
      var index = this._findSourceIndex(aSource);
      if (index >= 0) {
        return this.sourcesContent[index];
      }
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }
      var url;
      if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
        var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
        if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        }
        if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + relativeSource + '" is not in the SourceMap.');
      }
    };
    BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
      var source = util.getArg(aArgs, "source");
      source = this._findSourceIndex(source);
      if (source < 0) {
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }
      var needle = {
        source,
        originalLine: util.getArg(aArgs, "line"),
        originalColumn: util.getArg(aArgs, "column")
      };
      var index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (mapping.source === needle.source) {
          return {
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          };
        }
      }
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };
    exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
    function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      var version = util.getArg(sourceMap, "version");
      var sections = util.getArg(sourceMap, "sections");
      if (version != this._version) {
        throw new Error("Unsupported version: " + version);
      }
      this._sources = new ArraySet();
      this._names = new ArraySet();
      var lastOffset = {
        line: -1,
        column: 0
      };
      this._sections = sections.map(function(s) {
        if (s.url) {
          throw new Error("Support for url field in sections not implemented.");
        }
        var offset = util.getArg(s, "offset");
        var offsetLine = util.getArg(offset, "line");
        var offsetColumn = util.getArg(offset, "column");
        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
          throw new Error("Section offsets must be ordered and non-overlapping.");
        }
        lastOffset = offset;
        return {
          generatedOffset: {
            generatedLine: offsetLine + 1,
            generatedColumn: offsetColumn + 1
          },
          consumer: new SourceMapConsumer(util.getArg(s, "map"), aSourceMapURL)
        };
      });
    }
    IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
    IndexedSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
      get: function() {
        var sources = [];
        for (var i = 0; i < this._sections.length; i++) {
          for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
            sources.push(this._sections[i].consumer.sources[j]);
          }
        }
        return sources;
      }
    });
    IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var sectionIndex = binarySearch.search(
        needle,
        this._sections,
        function(needle2, section2) {
          var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
          if (cmp) {
            return cmp;
          }
          return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
        }
      );
      var section = this._sections[sectionIndex];
      if (!section) {
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }
      return section.consumer.originalPositionFor({
        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        bias: aArgs.bias
      });
    };
    IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
      return this._sections.every(function(s) {
        return s.consumer.hasContentsOfAllSources();
      });
    };
    IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var content = section.consumer.sourceContentFor(aSource, true);
        if (content || content === "") {
          return content;
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };
    IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
          continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret = {
            line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
          };
          return ret;
        }
      }
      return {
        line: null,
        column: null
      };
    };
    IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j = 0; j < sectionMappings.length; j++) {
          var mapping = sectionMappings[j];
          var source = section.consumer._sources.at(mapping.source);
          source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
          this._sources.add(source);
          source = this._sources.indexOf(source);
          var name = null;
          if (mapping.name) {
            name = section.consumer._names.at(mapping.name);
            this._names.add(name);
            name = this._names.indexOf(name);
          }
          var adjustedMapping = {
            source,
            generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name
          };
          this.__generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === "number") {
            this.__originalMappings.push(adjustedMapping);
          }
        }
      }
      quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
      quickSort(this.__originalMappings, util.compareByOriginalPositions);
    };
    exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
  }
});

// node_modules/source-map-js/lib/source-node.js
var require_source_node = __commonJS({
  "node_modules/source-map-js/lib/source-node.js"(exports) {
    var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    var util = require_util();
    var REGEX_NEWLINE = /(\r?\n)/;
    var NEWLINE_CODE = 10;
    var isSourceNode = "$$$isSourceNode$$$";
    function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
      this.children = [];
      this.sourceContents = {};
      this.line = aLine == null ? null : aLine;
      this.column = aColumn == null ? null : aColumn;
      this.source = aSource == null ? null : aSource;
      this.name = aName == null ? null : aName;
      this[isSourceNode] = true;
      if (aChunks != null)
        this.add(aChunks);
    }
    SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      var node = new SourceNode();
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var remainingLinesIndex = 0;
      var shiftNextLine = function() {
        var lineContents = getNextLine();
        var newLine = getNextLine() || "";
        return lineContents + newLine;
        function getNextLine() {
          return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
        }
      };
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;
      var lastMapping = null;
      aSourceMapConsumer.eachMapping(function(mapping) {
        if (lastMapping !== null) {
          if (lastGeneratedLine < mapping.generatedLine) {
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
          } else {
            var nextLine = remainingLines[remainingLinesIndex] || "";
            var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            lastMapping = mapping;
            return;
          }
        }
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[remainingLinesIndex] || "";
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      if (remainingLinesIndex < remainingLines.length) {
        if (lastMapping) {
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        node.add(remainingLines.splice(remainingLinesIndex).join(""));
      }
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });
      return node;
      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === void 0) {
          node.add(code);
        } else {
          var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
          node.add(new SourceNode(
            mapping.originalLine,
            mapping.originalColumn,
            source,
            code,
            mapping.name
          ));
        }
      }
    };
    SourceNode.prototype.add = function SourceNode_add(aChunk) {
      if (Array.isArray(aChunk)) {
        aChunk.forEach(function(chunk) {
          this.add(chunk);
        }, this);
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        if (aChunk) {
          this.children.push(aChunk);
        }
      } else {
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      }
      return this;
    };
    SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
      if (Array.isArray(aChunk)) {
        for (var i = aChunk.length - 1; i >= 0; i--) {
          this.prepend(aChunk[i]);
        }
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        this.children.unshift(aChunk);
      } else {
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      }
      return this;
    };
    SourceNode.prototype.walk = function SourceNode_walk(aFn) {
      var chunk;
      for (var i = 0, len = this.children.length; i < len; i++) {
        chunk = this.children[i];
        if (chunk[isSourceNode]) {
          chunk.walk(aFn);
        } else {
          if (chunk !== "") {
            aFn(chunk, {
              source: this.source,
              line: this.line,
              column: this.column,
              name: this.name
            });
          }
        }
      }
    };
    SourceNode.prototype.join = function SourceNode_join(aSep) {
      var newChildren;
      var i;
      var len = this.children.length;
      if (len > 0) {
        newChildren = [];
        for (i = 0; i < len - 1; i++) {
          newChildren.push(this.children[i]);
          newChildren.push(aSep);
        }
        newChildren.push(this.children[i]);
        this.children = newChildren;
      }
      return this;
    };
    SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
      var lastChild = this.children[this.children.length - 1];
      if (lastChild[isSourceNode]) {
        lastChild.replaceRight(aPattern, aReplacement);
      } else if (typeof lastChild === "string") {
        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
      } else {
        this.children.push("".replace(aPattern, aReplacement));
      }
      return this;
    };
    SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };
    SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i][isSourceNode]) {
          this.children[i].walkSourceContents(aFn);
        }
      }
      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };
    SourceNode.prototype.toString = function SourceNode_toString() {
      var str = "";
      this.walk(function(chunk) {
        str += chunk;
      });
      return str;
    };
    SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
      var generated = {
        code: "",
        line: 1,
        column: 0
      };
      var map = new SourceMapGenerator(aArgs);
      var sourceMappingActive = false;
      var lastOriginalSource = null;
      var lastOriginalLine = null;
      var lastOriginalColumn = null;
      var lastOriginalName = null;
      this.walk(function(chunk, original) {
        generated.code += chunk;
        if (original.source !== null && original.line !== null && original.column !== null) {
          if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
          lastOriginalSource = original.source;
          lastOriginalLine = original.line;
          lastOriginalColumn = original.column;
          lastOriginalName = original.name;
          sourceMappingActive = true;
        } else if (sourceMappingActive) {
          map.addMapping({
            generated: {
              line: generated.line,
              column: generated.column
            }
          });
          lastOriginalSource = null;
          sourceMappingActive = false;
        }
        for (var idx = 0, length = chunk.length; idx < length; idx++) {
          if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
            generated.line++;
            generated.column = 0;
            if (idx + 1 === length) {
              lastOriginalSource = null;
              sourceMappingActive = false;
            } else if (sourceMappingActive) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
          } else {
            generated.column++;
          }
        }
      });
      this.walkSourceContents(function(sourceFile, sourceContent) {
        map.setSourceContent(sourceFile, sourceContent);
      });
      return { code: generated.code, map };
    };
    exports.SourceNode = SourceNode;
  }
});

// node_modules/source-map-js/source-map.js
var require_source_map = __commonJS({
  "node_modules/source-map-js/source-map.js"(exports) {
    exports.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    exports.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
    exports.SourceNode = require_source_node().SourceNode;
  }
});

// node_modules/@vue/compiler-core/dist/compiler-core.cjs.js
var require_compiler_core_cjs = __commonJS({
  "node_modules/@vue/compiler-core/dist/compiler-core.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var shared = require_shared();
    var decode_js = require_decode();
    var parser = require_lib();
    var estreeWalker = require_estree_walker();
    var sourceMapJs = require_source_map();
    var FRAGMENT = Symbol(`Fragment`);
    var TELEPORT = Symbol(`Teleport`);
    var SUSPENSE = Symbol(`Suspense`);
    var KEEP_ALIVE = Symbol(`KeepAlive`);
    var BASE_TRANSITION = Symbol(`BaseTransition`);
    var OPEN_BLOCK = Symbol(`openBlock`);
    var CREATE_BLOCK = Symbol(`createBlock`);
    var CREATE_ELEMENT_BLOCK = Symbol(`createElementBlock`);
    var CREATE_VNODE = Symbol(`createVNode`);
    var CREATE_ELEMENT_VNODE = Symbol(`createElementVNode`);
    var CREATE_COMMENT = Symbol(`createCommentVNode`);
    var CREATE_TEXT = Symbol(`createTextVNode`);
    var CREATE_STATIC = Symbol(`createStaticVNode`);
    var RESOLVE_COMPONENT = Symbol(`resolveComponent`);
    var RESOLVE_DYNAMIC_COMPONENT = Symbol(
      `resolveDynamicComponent`
    );
    var RESOLVE_DIRECTIVE = Symbol(`resolveDirective`);
    var RESOLVE_FILTER = Symbol(`resolveFilter`);
    var WITH_DIRECTIVES = Symbol(`withDirectives`);
    var RENDER_LIST = Symbol(`renderList`);
    var RENDER_SLOT = Symbol(`renderSlot`);
    var CREATE_SLOTS = Symbol(`createSlots`);
    var TO_DISPLAY_STRING = Symbol(`toDisplayString`);
    var MERGE_PROPS = Symbol(`mergeProps`);
    var NORMALIZE_CLASS = Symbol(`normalizeClass`);
    var NORMALIZE_STYLE = Symbol(`normalizeStyle`);
    var NORMALIZE_PROPS = Symbol(`normalizeProps`);
    var GUARD_REACTIVE_PROPS = Symbol(`guardReactiveProps`);
    var TO_HANDLERS = Symbol(`toHandlers`);
    var CAMELIZE = Symbol(`camelize`);
    var CAPITALIZE = Symbol(`capitalize`);
    var TO_HANDLER_KEY = Symbol(`toHandlerKey`);
    var SET_BLOCK_TRACKING = Symbol(`setBlockTracking`);
    var PUSH_SCOPE_ID = Symbol(`pushScopeId`);
    var POP_SCOPE_ID = Symbol(`popScopeId`);
    var WITH_CTX = Symbol(`withCtx`);
    var UNREF = Symbol(`unref`);
    var IS_REF = Symbol(`isRef`);
    var WITH_MEMO = Symbol(`withMemo`);
    var IS_MEMO_SAME = Symbol(`isMemoSame`);
    var helperNameMap = {
      [FRAGMENT]: `Fragment`,
      [TELEPORT]: `Teleport`,
      [SUSPENSE]: `Suspense`,
      [KEEP_ALIVE]: `KeepAlive`,
      [BASE_TRANSITION]: `BaseTransition`,
      [OPEN_BLOCK]: `openBlock`,
      [CREATE_BLOCK]: `createBlock`,
      [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
      [CREATE_VNODE]: `createVNode`,
      [CREATE_ELEMENT_VNODE]: `createElementVNode`,
      [CREATE_COMMENT]: `createCommentVNode`,
      [CREATE_TEXT]: `createTextVNode`,
      [CREATE_STATIC]: `createStaticVNode`,
      [RESOLVE_COMPONENT]: `resolveComponent`,
      [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
      [RESOLVE_DIRECTIVE]: `resolveDirective`,
      [RESOLVE_FILTER]: `resolveFilter`,
      [WITH_DIRECTIVES]: `withDirectives`,
      [RENDER_LIST]: `renderList`,
      [RENDER_SLOT]: `renderSlot`,
      [CREATE_SLOTS]: `createSlots`,
      [TO_DISPLAY_STRING]: `toDisplayString`,
      [MERGE_PROPS]: `mergeProps`,
      [NORMALIZE_CLASS]: `normalizeClass`,
      [NORMALIZE_STYLE]: `normalizeStyle`,
      [NORMALIZE_PROPS]: `normalizeProps`,
      [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
      [TO_HANDLERS]: `toHandlers`,
      [CAMELIZE]: `camelize`,
      [CAPITALIZE]: `capitalize`,
      [TO_HANDLER_KEY]: `toHandlerKey`,
      [SET_BLOCK_TRACKING]: `setBlockTracking`,
      [PUSH_SCOPE_ID]: `pushScopeId`,
      [POP_SCOPE_ID]: `popScopeId`,
      [WITH_CTX]: `withCtx`,
      [UNREF]: `unref`,
      [IS_REF]: `isRef`,
      [WITH_MEMO]: `withMemo`,
      [IS_MEMO_SAME]: `isMemoSame`
    };
    function registerRuntimeHelpers(helpers) {
      Object.getOwnPropertySymbols(helpers).forEach((s) => {
        helperNameMap[s] = helpers[s];
      });
    }
    var Namespaces = {
      "HTML": 0,
      "0": "HTML",
      "SVG": 1,
      "1": "SVG",
      "MATH_ML": 2,
      "2": "MATH_ML"
    };
    var NodeTypes = {
      "ROOT": 0,
      "0": "ROOT",
      "ELEMENT": 1,
      "1": "ELEMENT",
      "TEXT": 2,
      "2": "TEXT",
      "COMMENT": 3,
      "3": "COMMENT",
      "SIMPLE_EXPRESSION": 4,
      "4": "SIMPLE_EXPRESSION",
      "INTERPOLATION": 5,
      "5": "INTERPOLATION",
      "ATTRIBUTE": 6,
      "6": "ATTRIBUTE",
      "DIRECTIVE": 7,
      "7": "DIRECTIVE",
      "COMPOUND_EXPRESSION": 8,
      "8": "COMPOUND_EXPRESSION",
      "IF": 9,
      "9": "IF",
      "IF_BRANCH": 10,
      "10": "IF_BRANCH",
      "FOR": 11,
      "11": "FOR",
      "TEXT_CALL": 12,
      "12": "TEXT_CALL",
      "VNODE_CALL": 13,
      "13": "VNODE_CALL",
      "JS_CALL_EXPRESSION": 14,
      "14": "JS_CALL_EXPRESSION",
      "JS_OBJECT_EXPRESSION": 15,
      "15": "JS_OBJECT_EXPRESSION",
      "JS_PROPERTY": 16,
      "16": "JS_PROPERTY",
      "JS_ARRAY_EXPRESSION": 17,
      "17": "JS_ARRAY_EXPRESSION",
      "JS_FUNCTION_EXPRESSION": 18,
      "18": "JS_FUNCTION_EXPRESSION",
      "JS_CONDITIONAL_EXPRESSION": 19,
      "19": "JS_CONDITIONAL_EXPRESSION",
      "JS_CACHE_EXPRESSION": 20,
      "20": "JS_CACHE_EXPRESSION",
      "JS_BLOCK_STATEMENT": 21,
      "21": "JS_BLOCK_STATEMENT",
      "JS_TEMPLATE_LITERAL": 22,
      "22": "JS_TEMPLATE_LITERAL",
      "JS_IF_STATEMENT": 23,
      "23": "JS_IF_STATEMENT",
      "JS_ASSIGNMENT_EXPRESSION": 24,
      "24": "JS_ASSIGNMENT_EXPRESSION",
      "JS_SEQUENCE_EXPRESSION": 25,
      "25": "JS_SEQUENCE_EXPRESSION",
      "JS_RETURN_STATEMENT": 26,
      "26": "JS_RETURN_STATEMENT"
    };
    var ElementTypes = {
      "ELEMENT": 0,
      "0": "ELEMENT",
      "COMPONENT": 1,
      "1": "COMPONENT",
      "SLOT": 2,
      "2": "SLOT",
      "TEMPLATE": 3,
      "3": "TEMPLATE"
    };
    var ConstantTypes = {
      "NOT_CONSTANT": 0,
      "0": "NOT_CONSTANT",
      "CAN_SKIP_PATCH": 1,
      "1": "CAN_SKIP_PATCH",
      "CAN_HOIST": 2,
      "2": "CAN_HOIST",
      "CAN_STRINGIFY": 3,
      "3": "CAN_STRINGIFY"
    };
    var locStub = {
      start: { line: 1, column: 1, offset: 0 },
      end: { line: 1, column: 1, offset: 0 },
      source: ""
    };
    function createRoot(children, source = "") {
      return {
        type: 0,
        source,
        children,
        helpers: /* @__PURE__ */ new Set(),
        components: [],
        directives: [],
        hoists: [],
        imports: [],
        cached: 0,
        temps: 0,
        codegenNode: void 0,
        loc: locStub
      };
    }
    function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent2 = false, loc = locStub) {
      if (context) {
        if (isBlock) {
          context.helper(OPEN_BLOCK);
          context.helper(getVNodeBlockHelper(context.inSSR, isComponent2));
        } else {
          context.helper(getVNodeHelper(context.inSSR, isComponent2));
        }
        if (directives) {
          context.helper(WITH_DIRECTIVES);
        }
      }
      return {
        type: 13,
        tag,
        props,
        children,
        patchFlag,
        dynamicProps,
        directives,
        isBlock,
        disableTracking,
        isComponent: isComponent2,
        loc
      };
    }
    function createArrayExpression(elements, loc = locStub) {
      return {
        type: 17,
        loc,
        elements
      };
    }
    function createObjectExpression(properties, loc = locStub) {
      return {
        type: 15,
        loc,
        properties
      };
    }
    function createObjectProperty(key, value) {
      return {
        type: 16,
        loc: locStub,
        key: shared.isString(key) ? createSimpleExpression(key, true) : key,
        value
      };
    }
    function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0) {
      return {
        type: 4,
        loc,
        content,
        isStatic,
        constType: isStatic ? 3 : constType
      };
    }
    function createInterpolation(content, loc) {
      return {
        type: 5,
        loc,
        content: shared.isString(content) ? createSimpleExpression(content, false, loc) : content
      };
    }
    function createCompoundExpression(children, loc = locStub) {
      return {
        type: 8,
        loc,
        children
      };
    }
    function createCallExpression(callee, args = [], loc = locStub) {
      return {
        type: 14,
        loc,
        callee,
        arguments: args
      };
    }
    function createFunctionExpression(params, returns = void 0, newline = false, isSlot = false, loc = locStub) {
      return {
        type: 18,
        params,
        returns,
        newline,
        isSlot,
        loc
      };
    }
    function createConditionalExpression(test, consequent, alternate, newline = true) {
      return {
        type: 19,
        test,
        consequent,
        alternate,
        newline,
        loc: locStub
      };
    }
    function createCacheExpression(index, value, isVNode = false) {
      return {
        type: 20,
        index,
        value,
        isVNode,
        loc: locStub
      };
    }
    function createBlockStatement(body) {
      return {
        type: 21,
        body,
        loc: locStub
      };
    }
    function createTemplateLiteral(elements) {
      return {
        type: 22,
        elements,
        loc: locStub
      };
    }
    function createIfStatement(test, consequent, alternate) {
      return {
        type: 23,
        test,
        consequent,
        alternate,
        loc: locStub
      };
    }
    function createAssignmentExpression(left, right) {
      return {
        type: 24,
        left,
        right,
        loc: locStub
      };
    }
    function createSequenceExpression(expressions) {
      return {
        type: 25,
        expressions,
        loc: locStub
      };
    }
    function createReturnStatement(returns) {
      return {
        type: 26,
        returns,
        loc: locStub
      };
    }
    function getVNodeHelper(ssr, isComponent2) {
      return ssr || isComponent2 ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
    }
    function getVNodeBlockHelper(ssr, isComponent2) {
      return ssr || isComponent2 ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
    }
    function convertToBlock(node, { helper, removeHelper, inSSR }) {
      if (!node.isBlock) {
        node.isBlock = true;
        removeHelper(getVNodeHelper(inSSR, node.isComponent));
        helper(OPEN_BLOCK);
        helper(getVNodeBlockHelper(inSSR, node.isComponent));
      }
    }
    var defaultDelimitersOpen = new Uint8Array([123, 123]);
    var defaultDelimitersClose = new Uint8Array([125, 125]);
    function isTagStartChar(c) {
      return c >= 97 && c <= 122 || c >= 65 && c <= 90;
    }
    function isWhitespace(c) {
      return c === 32 || c === 10 || c === 9 || c === 12 || c === 13;
    }
    function isEndOfTagSection(c) {
      return c === 47 || c === 62 || isWhitespace(c);
    }
    function toCharCodes(str) {
      const ret = new Uint8Array(str.length);
      for (let i = 0; i < str.length; i++) {
        ret[i] = str.charCodeAt(i);
      }
      return ret;
    }
    var Sequences = {
      Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
      CdataEnd: new Uint8Array([93, 93, 62]),
      CommentEnd: new Uint8Array([45, 45, 62]),
      ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
      StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
      TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]),
      TextareaEnd: new Uint8Array([
        60,
        47,
        116,
        101,
        120,
        116,
        97,
        114,
        101,
        97
      ])
    };
    var Tokenizer = class {
      constructor(stack2, cbs) {
        this.stack = stack2;
        this.cbs = cbs;
        this.state = 1;
        this.buffer = "";
        this.sectionStart = 0;
        this.index = 0;
        this.entityStart = 0;
        this.baseState = 1;
        this.inRCDATA = false;
        this.inXML = false;
        this.inVPre = false;
        this.newlines = [];
        this.mode = 0;
        this.delimiterOpen = defaultDelimitersOpen;
        this.delimiterClose = defaultDelimitersClose;
        this.delimiterIndex = -1;
        this.currentSequence = void 0;
        this.sequenceIndex = 0;
        {
          this.entityDecoder = new decode_js.EntityDecoder(
            decode_js.htmlDecodeTree,
            (cp, consumed) => this.emitCodePoint(cp, consumed)
          );
        }
      }
      get inSFCRoot() {
        return this.mode === 2 && this.stack.length === 0;
      }
      reset() {
        this.state = 1;
        this.mode = 0;
        this.buffer = "";
        this.sectionStart = 0;
        this.index = 0;
        this.baseState = 1;
        this.inRCDATA = false;
        this.currentSequence = void 0;
        this.newlines.length = 0;
        this.delimiterOpen = defaultDelimitersOpen;
        this.delimiterClose = defaultDelimitersClose;
      }
      getPos(index) {
        let line = 1;
        let column = index + 1;
        for (let i = this.newlines.length - 1; i >= 0; i--) {
          const newlineIndex = this.newlines[i];
          if (index > newlineIndex) {
            line = i + 2;
            column = index - newlineIndex;
            break;
          }
        }
        return {
          column,
          line,
          offset: index
        };
      }
      peek() {
        return this.buffer.charCodeAt(this.index + 1);
      }
      stateText(c) {
        if (c === 60) {
          if (this.index > this.sectionStart) {
            this.cbs.ontext(this.sectionStart, this.index);
          }
          this.state = 5;
          this.sectionStart = this.index;
        } else if (c === 38) {
          this.startEntity();
        } else if (!this.inVPre && c === this.delimiterOpen[0]) {
          this.state = 2;
          this.delimiterIndex = 0;
          this.stateInterpolationOpen(c);
        }
      }
      stateInterpolationOpen(c) {
        if (c === this.delimiterOpen[this.delimiterIndex]) {
          if (this.delimiterIndex === this.delimiterOpen.length - 1) {
            const start = this.index + 1 - this.delimiterOpen.length;
            if (start > this.sectionStart) {
              this.cbs.ontext(this.sectionStart, start);
            }
            this.state = 3;
            this.sectionStart = start;
          } else {
            this.delimiterIndex++;
          }
        } else if (this.inRCDATA) {
          this.state = 32;
          this.stateInRCDATA(c);
        } else {
          this.state = 1;
          this.stateText(c);
        }
      }
      stateInterpolation(c) {
        if (c === this.delimiterClose[0]) {
          this.state = 4;
          this.delimiterIndex = 0;
          this.stateInterpolationClose(c);
        }
      }
      stateInterpolationClose(c) {
        if (c === this.delimiterClose[this.delimiterIndex]) {
          if (this.delimiterIndex === this.delimiterClose.length - 1) {
            this.cbs.oninterpolation(this.sectionStart, this.index + 1);
            if (this.inRCDATA) {
              this.state = 32;
            } else {
              this.state = 1;
            }
            this.sectionStart = this.index + 1;
          } else {
            this.delimiterIndex++;
          }
        } else {
          this.state = 3;
          this.stateInterpolation(c);
        }
      }
      stateSpecialStartSequence(c) {
        const isEnd = this.sequenceIndex === this.currentSequence.length;
        const isMatch = isEnd ? isEndOfTagSection(c) : (c | 32) === this.currentSequence[this.sequenceIndex];
        if (!isMatch) {
          this.inRCDATA = false;
        } else if (!isEnd) {
          this.sequenceIndex++;
          return;
        }
        this.sequenceIndex = 0;
        this.state = 6;
        this.stateInTagName(c);
      }
      stateInRCDATA(c) {
        if (this.sequenceIndex === this.currentSequence.length) {
          if (c === 62 || isWhitespace(c)) {
            const endOfText = this.index - this.currentSequence.length;
            if (this.sectionStart < endOfText) {
              const actualIndex = this.index;
              this.index = endOfText;
              this.cbs.ontext(this.sectionStart, endOfText);
              this.index = actualIndex;
            }
            this.sectionStart = endOfText + 2;
            this.stateInClosingTagName(c);
            this.inRCDATA = false;
            return;
          }
          this.sequenceIndex = 0;
        }
        if ((c | 32) === this.currentSequence[this.sequenceIndex]) {
          this.sequenceIndex += 1;
        } else if (this.sequenceIndex === 0) {
          if (this.currentSequence === Sequences.TitleEnd || this.currentSequence === Sequences.TextareaEnd && !this.inSFCRoot) {
            if (c === 38) {
              this.startEntity();
            } else if (c === this.delimiterOpen[0]) {
              this.state = 2;
              this.delimiterIndex = 0;
              this.stateInterpolationOpen(c);
            }
          } else if (this.fastForwardTo(60)) {
            this.sequenceIndex = 1;
          }
        } else {
          this.sequenceIndex = Number(c === 60);
        }
      }
      stateCDATASequence(c) {
        if (c === Sequences.Cdata[this.sequenceIndex]) {
          if (++this.sequenceIndex === Sequences.Cdata.length) {
            this.state = 28;
            this.currentSequence = Sequences.CdataEnd;
            this.sequenceIndex = 0;
            this.sectionStart = this.index + 1;
          }
        } else {
          this.sequenceIndex = 0;
          this.state = 23;
          this.stateInDeclaration(c);
        }
      }
      fastForwardTo(c) {
        while (++this.index < this.buffer.length) {
          const cc = this.buffer.charCodeAt(this.index);
          if (cc === 10) {
            this.newlines.push(this.index);
          }
          if (cc === c) {
            return true;
          }
        }
        this.index = this.buffer.length - 1;
        return false;
      }
      stateInCommentLike(c) {
        if (c === this.currentSequence[this.sequenceIndex]) {
          if (++this.sequenceIndex === this.currentSequence.length) {
            if (this.currentSequence === Sequences.CdataEnd) {
              this.cbs.oncdata(this.sectionStart, this.index - 2);
            } else {
              this.cbs.oncomment(this.sectionStart, this.index - 2);
            }
            this.sequenceIndex = 0;
            this.sectionStart = this.index + 1;
            this.state = 1;
          }
        } else if (this.sequenceIndex === 0) {
          if (this.fastForwardTo(this.currentSequence[0])) {
            this.sequenceIndex = 1;
          }
        } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
          this.sequenceIndex = 0;
        }
      }
      startSpecial(sequence, offset) {
        this.enterRCDATA(sequence, offset);
        this.state = 31;
      }
      enterRCDATA(sequence, offset) {
        this.inRCDATA = true;
        this.currentSequence = sequence;
        this.sequenceIndex = offset;
      }
      stateBeforeTagName(c) {
        if (c === 33) {
          this.state = 22;
          this.sectionStart = this.index + 1;
        } else if (c === 63) {
          this.state = 24;
          this.sectionStart = this.index + 1;
        } else if (isTagStartChar(c)) {
          this.sectionStart = this.index;
          if (this.mode === 0) {
            this.state = 6;
          } else if (this.inSFCRoot) {
            this.state = 34;
          } else if (!this.inXML) {
            if (c === 116) {
              this.state = 30;
            } else {
              this.state = c === 115 ? 29 : 6;
            }
          } else {
            this.state = 6;
          }
        } else if (c === 47) {
          this.state = 8;
        } else {
          this.state = 1;
          this.stateText(c);
        }
      }
      stateInTagName(c) {
        if (isEndOfTagSection(c)) {
          this.handleTagName(c);
        }
      }
      stateInSFCRootTagName(c) {
        if (isEndOfTagSection(c)) {
          const tag = this.buffer.slice(this.sectionStart, this.index);
          if (tag !== "template") {
            this.enterRCDATA(toCharCodes(`</` + tag), 0);
          }
          this.handleTagName(c);
        }
      }
      handleTagName(c) {
        this.cbs.onopentagname(this.sectionStart, this.index);
        this.sectionStart = -1;
        this.state = 11;
        this.stateBeforeAttrName(c);
      }
      stateBeforeClosingTagName(c) {
        if (isWhitespace(c))
          ;
        else if (c === 62) {
          {
            this.cbs.onerr(14, this.index);
          }
          this.state = 1;
          this.sectionStart = this.index + 1;
        } else {
          this.state = isTagStartChar(c) ? 9 : 27;
          this.sectionStart = this.index;
        }
      }
      stateInClosingTagName(c) {
        if (c === 62 || isWhitespace(c)) {
          this.cbs.onclosetag(this.sectionStart, this.index);
          this.sectionStart = -1;
          this.state = 10;
          this.stateAfterClosingTagName(c);
        }
      }
      stateAfterClosingTagName(c) {
        if (c === 62) {
          this.state = 1;
          this.sectionStart = this.index + 1;
        }
      }
      stateBeforeAttrName(c) {
        if (c === 62) {
          this.cbs.onopentagend(this.index);
          if (this.inRCDATA) {
            this.state = 32;
          } else {
            this.state = 1;
          }
          this.sectionStart = this.index + 1;
        } else if (c === 47) {
          this.state = 7;
          if (this.peek() !== 62) {
            this.cbs.onerr(22, this.index);
          }
        } else if (c === 60 && this.peek() === 47) {
          this.cbs.onopentagend(this.index);
          this.state = 5;
          this.sectionStart = this.index;
        } else if (!isWhitespace(c)) {
          if (c === 61) {
            this.cbs.onerr(
              19,
              this.index
            );
          }
          this.handleAttrStart(c);
        }
      }
      handleAttrStart(c) {
        if (c === 118 && this.peek() === 45) {
          this.state = 13;
          this.sectionStart = this.index;
        } else if (c === 46 || c === 58 || c === 64 || c === 35) {
          this.cbs.ondirname(this.index, this.index + 1);
          this.state = 14;
          this.sectionStart = this.index + 1;
        } else {
          this.state = 12;
          this.sectionStart = this.index;
        }
      }
      stateInSelfClosingTag(c) {
        if (c === 62) {
          this.cbs.onselfclosingtag(this.index);
          this.state = 1;
          this.sectionStart = this.index + 1;
          this.inRCDATA = false;
        } else if (!isWhitespace(c)) {
          this.state = 11;
          this.stateBeforeAttrName(c);
        }
      }
      stateInAttrName(c) {
        if (c === 61 || isEndOfTagSection(c)) {
          this.cbs.onattribname(this.sectionStart, this.index);
          this.handleAttrNameEnd(c);
        } else if (c === 34 || c === 39 || c === 60) {
          this.cbs.onerr(
            17,
            this.index
          );
        }
      }
      stateInDirName(c) {
        if (c === 61 || isEndOfTagSection(c)) {
          this.cbs.ondirname(this.sectionStart, this.index);
          this.handleAttrNameEnd(c);
        } else if (c === 58) {
          this.cbs.ondirname(this.sectionStart, this.index);
          this.state = 14;
          this.sectionStart = this.index + 1;
        } else if (c === 46) {
          this.cbs.ondirname(this.sectionStart, this.index);
          this.state = 16;
          this.sectionStart = this.index + 1;
        }
      }
      stateInDirArg(c) {
        if (c === 61 || isEndOfTagSection(c)) {
          this.cbs.ondirarg(this.sectionStart, this.index);
          this.handleAttrNameEnd(c);
        } else if (c === 91) {
          this.state = 15;
        } else if (c === 46) {
          this.cbs.ondirarg(this.sectionStart, this.index);
          this.state = 16;
          this.sectionStart = this.index + 1;
        }
      }
      stateInDynamicDirArg(c) {
        if (c === 93) {
          this.state = 14;
        } else if (c === 61 || isEndOfTagSection(c)) {
          this.cbs.ondirarg(this.sectionStart, this.index + 1);
          this.handleAttrNameEnd(c);
          {
            this.cbs.onerr(
              27,
              this.index
            );
          }
        }
      }
      stateInDirModifier(c) {
        if (c === 61 || isEndOfTagSection(c)) {
          this.cbs.ondirmodifier(this.sectionStart, this.index);
          this.handleAttrNameEnd(c);
        } else if (c === 46) {
          this.cbs.ondirmodifier(this.sectionStart, this.index);
          this.sectionStart = this.index + 1;
        }
      }
      handleAttrNameEnd(c) {
        this.sectionStart = this.index;
        this.state = 17;
        this.cbs.onattribnameend(this.index);
        this.stateAfterAttrName(c);
      }
      stateAfterAttrName(c) {
        if (c === 61) {
          this.state = 18;
        } else if (c === 47 || c === 62) {
          this.cbs.onattribend(0, this.sectionStart);
          this.sectionStart = -1;
          this.state = 11;
          this.stateBeforeAttrName(c);
        } else if (!isWhitespace(c)) {
          this.cbs.onattribend(0, this.sectionStart);
          this.handleAttrStart(c);
        }
      }
      stateBeforeAttrValue(c) {
        if (c === 34) {
          this.state = 19;
          this.sectionStart = this.index + 1;
        } else if (c === 39) {
          this.state = 20;
          this.sectionStart = this.index + 1;
        } else if (!isWhitespace(c)) {
          this.sectionStart = this.index;
          this.state = 21;
          this.stateInAttrValueNoQuotes(c);
        }
      }
      handleInAttrValue(c, quote) {
        if (c === quote || false) {
          this.cbs.onattribdata(this.sectionStart, this.index);
          this.sectionStart = -1;
          this.cbs.onattribend(
            quote === 34 ? 3 : 2,
            this.index + 1
          );
          this.state = 11;
        } else if (c === 38) {
          this.startEntity();
        }
      }
      stateInAttrValueDoubleQuotes(c) {
        this.handleInAttrValue(c, 34);
      }
      stateInAttrValueSingleQuotes(c) {
        this.handleInAttrValue(c, 39);
      }
      stateInAttrValueNoQuotes(c) {
        if (isWhitespace(c) || c === 62) {
          this.cbs.onattribdata(this.sectionStart, this.index);
          this.sectionStart = -1;
          this.cbs.onattribend(1, this.index);
          this.state = 11;
          this.stateBeforeAttrName(c);
        } else if (c === 34 || c === 39 || c === 60 || c === 61 || c === 96) {
          this.cbs.onerr(
            18,
            this.index
          );
        } else if (c === 38) {
          this.startEntity();
        }
      }
      stateBeforeDeclaration(c) {
        if (c === 91) {
          this.state = 26;
          this.sequenceIndex = 0;
        } else {
          this.state = c === 45 ? 25 : 23;
        }
      }
      stateInDeclaration(c) {
        if (c === 62 || this.fastForwardTo(62)) {
          this.state = 1;
          this.sectionStart = this.index + 1;
        }
      }
      stateInProcessingInstruction(c) {
        if (c === 62 || this.fastForwardTo(62)) {
          this.cbs.onprocessinginstruction(this.sectionStart, this.index);
          this.state = 1;
          this.sectionStart = this.index + 1;
        }
      }
      stateBeforeComment(c) {
        if (c === 45) {
          this.state = 28;
          this.currentSequence = Sequences.CommentEnd;
          this.sequenceIndex = 2;
          this.sectionStart = this.index + 1;
        } else {
          this.state = 23;
        }
      }
      stateInSpecialComment(c) {
        if (c === 62 || this.fastForwardTo(62)) {
          this.cbs.oncomment(this.sectionStart, this.index);
          this.state = 1;
          this.sectionStart = this.index + 1;
        }
      }
      stateBeforeSpecialS(c) {
        if (c === Sequences.ScriptEnd[3]) {
          this.startSpecial(Sequences.ScriptEnd, 4);
        } else if (c === Sequences.StyleEnd[3]) {
          this.startSpecial(Sequences.StyleEnd, 4);
        } else {
          this.state = 6;
          this.stateInTagName(c);
        }
      }
      stateBeforeSpecialT(c) {
        if (c === Sequences.TitleEnd[3]) {
          this.startSpecial(Sequences.TitleEnd, 4);
        } else if (c === Sequences.TextareaEnd[3]) {
          this.startSpecial(Sequences.TextareaEnd, 4);
        } else {
          this.state = 6;
          this.stateInTagName(c);
        }
      }
      startEntity() {
        {
          this.baseState = this.state;
          this.state = 33;
          this.entityStart = this.index;
          this.entityDecoder.startEntity(
            this.baseState === 1 || this.baseState === 32 ? decode_js.DecodingMode.Legacy : decode_js.DecodingMode.Attribute
          );
        }
      }
      stateInEntity() {
        {
          const length = this.entityDecoder.write(this.buffer, this.index);
          if (length >= 0) {
            this.state = this.baseState;
            if (length === 0) {
              this.index = this.entityStart;
            }
          } else {
            this.index = this.buffer.length - 1;
          }
        }
      }
      parse(input) {
        this.buffer = input;
        while (this.index < this.buffer.length) {
          const c = this.buffer.charCodeAt(this.index);
          if (c === 10) {
            this.newlines.push(this.index);
          }
          switch (this.state) {
            case 1: {
              this.stateText(c);
              break;
            }
            case 2: {
              this.stateInterpolationOpen(c);
              break;
            }
            case 3: {
              this.stateInterpolation(c);
              break;
            }
            case 4: {
              this.stateInterpolationClose(c);
              break;
            }
            case 31: {
              this.stateSpecialStartSequence(c);
              break;
            }
            case 32: {
              this.stateInRCDATA(c);
              break;
            }
            case 26: {
              this.stateCDATASequence(c);
              break;
            }
            case 19: {
              this.stateInAttrValueDoubleQuotes(c);
              break;
            }
            case 12: {
              this.stateInAttrName(c);
              break;
            }
            case 13: {
              this.stateInDirName(c);
              break;
            }
            case 14: {
              this.stateInDirArg(c);
              break;
            }
            case 15: {
              this.stateInDynamicDirArg(c);
              break;
            }
            case 16: {
              this.stateInDirModifier(c);
              break;
            }
            case 28: {
              this.stateInCommentLike(c);
              break;
            }
            case 27: {
              this.stateInSpecialComment(c);
              break;
            }
            case 11: {
              this.stateBeforeAttrName(c);
              break;
            }
            case 6: {
              this.stateInTagName(c);
              break;
            }
            case 34: {
              this.stateInSFCRootTagName(c);
              break;
            }
            case 9: {
              this.stateInClosingTagName(c);
              break;
            }
            case 5: {
              this.stateBeforeTagName(c);
              break;
            }
            case 17: {
              this.stateAfterAttrName(c);
              break;
            }
            case 20: {
              this.stateInAttrValueSingleQuotes(c);
              break;
            }
            case 18: {
              this.stateBeforeAttrValue(c);
              break;
            }
            case 8: {
              this.stateBeforeClosingTagName(c);
              break;
            }
            case 10: {
              this.stateAfterClosingTagName(c);
              break;
            }
            case 29: {
              this.stateBeforeSpecialS(c);
              break;
            }
            case 30: {
              this.stateBeforeSpecialT(c);
              break;
            }
            case 21: {
              this.stateInAttrValueNoQuotes(c);
              break;
            }
            case 7: {
              this.stateInSelfClosingTag(c);
              break;
            }
            case 23: {
              this.stateInDeclaration(c);
              break;
            }
            case 22: {
              this.stateBeforeDeclaration(c);
              break;
            }
            case 25: {
              this.stateBeforeComment(c);
              break;
            }
            case 24: {
              this.stateInProcessingInstruction(c);
              break;
            }
            case 33: {
              this.stateInEntity();
              break;
            }
          }
          this.index++;
        }
        this.cleanup();
        this.finish();
      }
      cleanup() {
        if (this.sectionStart !== this.index) {
          if (this.state === 1 || this.state === 32 && this.sequenceIndex === 0) {
            this.cbs.ontext(this.sectionStart, this.index);
            this.sectionStart = this.index;
          } else if (this.state === 19 || this.state === 20 || this.state === 21) {
            this.cbs.onattribdata(this.sectionStart, this.index);
            this.sectionStart = this.index;
          }
        }
      }
      finish() {
        if (this.state === 33) {
          this.entityDecoder.end();
          this.state = this.baseState;
        }
        this.handleTrailingData();
        this.cbs.onend();
      }
      handleTrailingData() {
        const endIndex = this.buffer.length;
        if (this.sectionStart >= endIndex) {
          return;
        }
        if (this.state === 28) {
          if (this.currentSequence === Sequences.CdataEnd) {
            this.cbs.oncdata(this.sectionStart, endIndex);
          } else {
            this.cbs.oncomment(this.sectionStart, endIndex);
          }
        } else if (this.state === 6 || this.state === 11 || this.state === 18 || this.state === 17 || this.state === 12 || this.state === 13 || this.state === 14 || this.state === 15 || this.state === 16 || this.state === 20 || this.state === 19 || this.state === 21 || this.state === 9)
          ;
        else {
          this.cbs.ontext(this.sectionStart, endIndex);
        }
      }
      emitCodePoint(cp, consumed) {
        {
          if (this.baseState !== 1 && this.baseState !== 32) {
            if (this.sectionStart < this.entityStart) {
              this.cbs.onattribdata(this.sectionStart, this.entityStart);
            }
            this.sectionStart = this.entityStart + consumed;
            this.index = this.sectionStart - 1;
            this.cbs.onattribentity(
              decode_js.fromCodePoint(cp),
              this.entityStart,
              this.sectionStart
            );
          } else {
            if (this.sectionStart < this.entityStart) {
              this.cbs.ontext(this.sectionStart, this.entityStart);
            }
            this.sectionStart = this.entityStart + consumed;
            this.index = this.sectionStart - 1;
            this.cbs.ontextentity(
              decode_js.fromCodePoint(cp),
              this.entityStart,
              this.sectionStart
            );
          }
        }
      }
    };
    var CompilerDeprecationTypes = {
      "COMPILER_IS_ON_ELEMENT": "COMPILER_IS_ON_ELEMENT",
      "COMPILER_V_BIND_SYNC": "COMPILER_V_BIND_SYNC",
      "COMPILER_V_BIND_OBJECT_ORDER": "COMPILER_V_BIND_OBJECT_ORDER",
      "COMPILER_V_ON_NATIVE": "COMPILER_V_ON_NATIVE",
      "COMPILER_V_IF_V_FOR_PRECEDENCE": "COMPILER_V_IF_V_FOR_PRECEDENCE",
      "COMPILER_NATIVE_TEMPLATE": "COMPILER_NATIVE_TEMPLATE",
      "COMPILER_INLINE_TEMPLATE": "COMPILER_INLINE_TEMPLATE",
      "COMPILER_FILTERS": "COMPILER_FILTERS"
    };
    var deprecationData = {
      ["COMPILER_IS_ON_ELEMENT"]: {
        message: `Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".`,
        link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`
      },
      ["COMPILER_V_BIND_SYNC"]: {
        message: (key) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${key}.sync\` should be changed to \`v-model:${key}\`.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`
      },
      ["COMPILER_V_BIND_OBJECT_ORDER"]: {
        message: `v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`
      },
      ["COMPILER_V_ON_NATIVE"]: {
        message: `.native modifier for v-on has been removed as is no longer necessary.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`
      },
      ["COMPILER_V_IF_V_FOR_PRECEDENCE"]: {
        message: `v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`
      },
      ["COMPILER_NATIVE_TEMPLATE"]: {
        message: `<template> with no special directives will render as a native template element instead of its inner content in Vue 3.`
      },
      ["COMPILER_INLINE_TEMPLATE"]: {
        message: `"inline-template" has been removed in Vue 3.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`
      },
      ["COMPILER_FILTERS"]: {
        message: `filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`
      }
    };
    function getCompatValue(key, { compatConfig }) {
      const value = compatConfig && compatConfig[key];
      if (key === "MODE") {
        return value || 3;
      } else {
        return value;
      }
    }
    function isCompatEnabled(key, context) {
      const mode = getCompatValue("MODE", context);
      const value = getCompatValue(key, context);
      return mode === 3 ? value === true : value !== false;
    }
    function checkCompatEnabled(key, context, loc, ...args) {
      const enabled = isCompatEnabled(key, context);
      if (enabled) {
        warnDeprecation(key, context, loc, ...args);
      }
      return enabled;
    }
    function warnDeprecation(key, context, loc, ...args) {
      const val = getCompatValue(key, context);
      if (val === "suppress-warning") {
        return;
      }
      const { message, link } = deprecationData[key];
      const msg = `(deprecation ${key}) ${typeof message === "function" ? message(...args) : message}${link ? `
  Details: ${link}` : ``}`;
      const err = new SyntaxError(msg);
      err.code = key;
      if (loc)
        err.loc = loc;
      context.onWarn(err);
    }
    function defaultOnError(error) {
      throw error;
    }
    function defaultOnWarn(msg) {
      console.warn(`[Vue warn] ${msg.message}`);
    }
    function createCompilerError(code, loc, messages, additionalMessage) {
      const msg = (messages || errorMessages)[code] + (additionalMessage || ``);
      const error = new SyntaxError(String(msg));
      error.code = code;
      error.loc = loc;
      return error;
    }
    var ErrorCodes = {
      "ABRUPT_CLOSING_OF_EMPTY_COMMENT": 0,
      "0": "ABRUPT_CLOSING_OF_EMPTY_COMMENT",
      "CDATA_IN_HTML_CONTENT": 1,
      "1": "CDATA_IN_HTML_CONTENT",
      "DUPLICATE_ATTRIBUTE": 2,
      "2": "DUPLICATE_ATTRIBUTE",
      "END_TAG_WITH_ATTRIBUTES": 3,
      "3": "END_TAG_WITH_ATTRIBUTES",
      "END_TAG_WITH_TRAILING_SOLIDUS": 4,
      "4": "END_TAG_WITH_TRAILING_SOLIDUS",
      "EOF_BEFORE_TAG_NAME": 5,
      "5": "EOF_BEFORE_TAG_NAME",
      "EOF_IN_CDATA": 6,
      "6": "EOF_IN_CDATA",
      "EOF_IN_COMMENT": 7,
      "7": "EOF_IN_COMMENT",
      "EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT": 8,
      "8": "EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT",
      "EOF_IN_TAG": 9,
      "9": "EOF_IN_TAG",
      "INCORRECTLY_CLOSED_COMMENT": 10,
      "10": "INCORRECTLY_CLOSED_COMMENT",
      "INCORRECTLY_OPENED_COMMENT": 11,
      "11": "INCORRECTLY_OPENED_COMMENT",
      "INVALID_FIRST_CHARACTER_OF_TAG_NAME": 12,
      "12": "INVALID_FIRST_CHARACTER_OF_TAG_NAME",
      "MISSING_ATTRIBUTE_VALUE": 13,
      "13": "MISSING_ATTRIBUTE_VALUE",
      "MISSING_END_TAG_NAME": 14,
      "14": "MISSING_END_TAG_NAME",
      "MISSING_WHITESPACE_BETWEEN_ATTRIBUTES": 15,
      "15": "MISSING_WHITESPACE_BETWEEN_ATTRIBUTES",
      "NESTED_COMMENT": 16,
      "16": "NESTED_COMMENT",
      "UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME": 17,
      "17": "UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME",
      "UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE": 18,
      "18": "UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE",
      "UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME": 19,
      "19": "UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME",
      "UNEXPECTED_NULL_CHARACTER": 20,
      "20": "UNEXPECTED_NULL_CHARACTER",
      "UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME": 21,
      "21": "UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME",
      "UNEXPECTED_SOLIDUS_IN_TAG": 22,
      "22": "UNEXPECTED_SOLIDUS_IN_TAG",
      "X_INVALID_END_TAG": 23,
      "23": "X_INVALID_END_TAG",
      "X_MISSING_END_TAG": 24,
      "24": "X_MISSING_END_TAG",
      "X_MISSING_INTERPOLATION_END": 25,
      "25": "X_MISSING_INTERPOLATION_END",
      "X_MISSING_DIRECTIVE_NAME": 26,
      "26": "X_MISSING_DIRECTIVE_NAME",
      "X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END": 27,
      "27": "X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END",
      "X_V_IF_NO_EXPRESSION": 28,
      "28": "X_V_IF_NO_EXPRESSION",
      "X_V_IF_SAME_KEY": 29,
      "29": "X_V_IF_SAME_KEY",
      "X_V_ELSE_NO_ADJACENT_IF": 30,
      "30": "X_V_ELSE_NO_ADJACENT_IF",
      "X_V_FOR_NO_EXPRESSION": 31,
      "31": "X_V_FOR_NO_EXPRESSION",
      "X_V_FOR_MALFORMED_EXPRESSION": 32,
      "32": "X_V_FOR_MALFORMED_EXPRESSION",
      "X_V_FOR_TEMPLATE_KEY_PLACEMENT": 33,
      "33": "X_V_FOR_TEMPLATE_KEY_PLACEMENT",
      "X_V_BIND_NO_EXPRESSION": 34,
      "34": "X_V_BIND_NO_EXPRESSION",
      "X_V_ON_NO_EXPRESSION": 35,
      "35": "X_V_ON_NO_EXPRESSION",
      "X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET": 36,
      "36": "X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET",
      "X_V_SLOT_MIXED_SLOT_USAGE": 37,
      "37": "X_V_SLOT_MIXED_SLOT_USAGE",
      "X_V_SLOT_DUPLICATE_SLOT_NAMES": 38,
      "38": "X_V_SLOT_DUPLICATE_SLOT_NAMES",
      "X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN": 39,
      "39": "X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN",
      "X_V_SLOT_MISPLACED": 40,
      "40": "X_V_SLOT_MISPLACED",
      "X_V_MODEL_NO_EXPRESSION": 41,
      "41": "X_V_MODEL_NO_EXPRESSION",
      "X_V_MODEL_MALFORMED_EXPRESSION": 42,
      "42": "X_V_MODEL_MALFORMED_EXPRESSION",
      "X_V_MODEL_ON_SCOPE_VARIABLE": 43,
      "43": "X_V_MODEL_ON_SCOPE_VARIABLE",
      "X_V_MODEL_ON_PROPS": 44,
      "44": "X_V_MODEL_ON_PROPS",
      "X_INVALID_EXPRESSION": 45,
      "45": "X_INVALID_EXPRESSION",
      "X_KEEP_ALIVE_INVALID_CHILDREN": 46,
      "46": "X_KEEP_ALIVE_INVALID_CHILDREN",
      "X_PREFIX_ID_NOT_SUPPORTED": 47,
      "47": "X_PREFIX_ID_NOT_SUPPORTED",
      "X_MODULE_MODE_NOT_SUPPORTED": 48,
      "48": "X_MODULE_MODE_NOT_SUPPORTED",
      "X_CACHE_HANDLER_NOT_SUPPORTED": 49,
      "49": "X_CACHE_HANDLER_NOT_SUPPORTED",
      "X_SCOPE_ID_NOT_SUPPORTED": 50,
      "50": "X_SCOPE_ID_NOT_SUPPORTED",
      "X_VNODE_HOOKS": 51,
      "51": "X_VNODE_HOOKS",
      "X_V_BIND_INVALID_SAME_NAME_ARGUMENT": 52,
      "52": "X_V_BIND_INVALID_SAME_NAME_ARGUMENT",
      "__EXTEND_POINT__": 53,
      "53": "__EXTEND_POINT__"
    };
    var errorMessages = {
      [0]: "Illegal comment.",
      [1]: "CDATA section is allowed only in XML context.",
      [2]: "Duplicate attribute.",
      [3]: "End tag cannot have attributes.",
      [4]: "Illegal '/' in tags.",
      [5]: "Unexpected EOF in tag.",
      [6]: "Unexpected EOF in CDATA section.",
      [7]: "Unexpected EOF in comment.",
      [8]: "Unexpected EOF in script.",
      [9]: "Unexpected EOF in tag.",
      [10]: "Incorrectly closed comment.",
      [11]: "Incorrectly opened comment.",
      [12]: "Illegal tag name. Use '&lt;' to print '<'.",
      [13]: "Attribute value was expected.",
      [14]: "End tag name was expected.",
      [15]: "Whitespace was expected.",
      [16]: "Unexpected '<!--' in comment.",
      [17]: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
      [18]: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
      [19]: "Attribute name cannot start with '='.",
      [21]: "'<?' is allowed only in XML context.",
      [20]: `Unexpected null character.`,
      [22]: "Illegal '/' in tags.",
      [23]: "Invalid end tag.",
      [24]: "Element is missing end tag.",
      [25]: "Interpolation end sign was not found.",
      [27]: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
      [26]: "Legal directive name was expected.",
      [28]: `v-if/v-else-if is missing expression.`,
      [29]: `v-if/else branches must use unique keys.`,
      [30]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,
      [31]: `v-for is missing expression.`,
      [32]: `v-for has invalid expression.`,
      [33]: `<template v-for> key should be placed on the <template> tag.`,
      [34]: `v-bind is missing expression.`,
      [52]: `v-bind with same-name shorthand only allows static argument.`,
      [35]: `v-on is missing expression.`,
      [36]: `Unexpected custom directive on <slot> outlet.`,
      [37]: `Mixed v-slot usage on both the component and nested <template>. When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.`,
      [38]: `Duplicate slot names found. `,
      [39]: `Extraneous children found when component already has explicitly named default slot. These children will be ignored.`,
      [40]: `v-slot can only be used on components or <template> tags.`,
      [41]: `v-model is missing expression.`,
      [42]: `v-model value must be a valid JavaScript member expression.`,
      [43]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
      [44]: `v-model cannot be used on a prop, because local prop bindings are not writable.
Use a v-bind binding combined with a v-on listener that emits update:x event instead.`,
      [45]: `Error parsing JavaScript expression: `,
      [46]: `<KeepAlive> expects exactly one child component.`,
      [51]: `@vnode-* hooks in templates are no longer supported. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support has been removed in 3.4.`,
      [47]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
      [48]: `ES module mode is not supported in this build of compiler.`,
      [49]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
      [50]: `"scopeId" option is only supported in module mode.`,
      [53]: ``
    };
    function walkIdentifiers(root, onIdentifier, includeAll = false, parentStack = [], knownIds = /* @__PURE__ */ Object.create(null)) {
      const rootExp = root.type === "Program" ? root.body[0].type === "ExpressionStatement" && root.body[0].expression : root;
      estreeWalker.walk(root, {
        enter(node, parent) {
          parent && parentStack.push(parent);
          if (parent && parent.type.startsWith("TS") && !TS_NODE_TYPES.includes(parent.type)) {
            return this.skip();
          }
          if (node.type === "Identifier") {
            const isLocal = !!knownIds[node.name];
            const isRefed = isReferencedIdentifier(node, parent, parentStack);
            if (includeAll || isRefed && !isLocal) {
              onIdentifier(node, parent, parentStack, isRefed, isLocal);
            }
          } else if (node.type === "ObjectProperty" && (parent == null ? void 0 : parent.type) === "ObjectPattern") {
            node.inPattern = true;
          } else if (isFunctionType(node)) {
            if (node.scopeIds) {
              node.scopeIds.forEach((id) => markKnownIds(id, knownIds));
            } else {
              walkFunctionParams(
                node,
                (id) => markScopeIdentifier(node, id, knownIds)
              );
            }
          } else if (node.type === "BlockStatement") {
            if (node.scopeIds) {
              node.scopeIds.forEach((id) => markKnownIds(id, knownIds));
            } else {
              walkBlockDeclarations(
                node,
                (id) => markScopeIdentifier(node, id, knownIds)
              );
            }
          }
        },
        leave(node, parent) {
          parent && parentStack.pop();
          if (node !== rootExp && node.scopeIds) {
            for (const id of node.scopeIds) {
              knownIds[id]--;
              if (knownIds[id] === 0) {
                delete knownIds[id];
              }
            }
          }
        }
      });
    }
    function isReferencedIdentifier(id, parent, parentStack) {
      if (!parent) {
        return true;
      }
      if (id.name === "arguments") {
        return false;
      }
      if (isReferenced(id, parent)) {
        return true;
      }
      switch (parent.type) {
        case "AssignmentExpression":
        case "AssignmentPattern":
          return true;
        case "ObjectPattern":
        case "ArrayPattern":
          return isInDestructureAssignment(parent, parentStack);
      }
      return false;
    }
    function isInDestructureAssignment(parent, parentStack) {
      if (parent && (parent.type === "ObjectProperty" || parent.type === "ArrayPattern")) {
        let i = parentStack.length;
        while (i--) {
          const p = parentStack[i];
          if (p.type === "AssignmentExpression") {
            return true;
          } else if (p.type !== "ObjectProperty" && !p.type.endsWith("Pattern")) {
            break;
          }
        }
      }
      return false;
    }
    function isInNewExpression(parentStack) {
      let i = parentStack.length;
      while (i--) {
        const p = parentStack[i];
        if (p.type === "NewExpression") {
          return true;
        } else if (p.type !== "MemberExpression") {
          break;
        }
      }
      return false;
    }
    function walkFunctionParams(node, onIdent) {
      for (const p of node.params) {
        for (const id of extractIdentifiers(p)) {
          onIdent(id);
        }
      }
    }
    function walkBlockDeclarations(block, onIdent) {
      for (const stmt of block.body) {
        if (stmt.type === "VariableDeclaration") {
          if (stmt.declare)
            continue;
          for (const decl of stmt.declarations) {
            for (const id of extractIdentifiers(decl.id)) {
              onIdent(id);
            }
          }
        } else if (stmt.type === "FunctionDeclaration" || stmt.type === "ClassDeclaration") {
          if (stmt.declare || !stmt.id)
            continue;
          onIdent(stmt.id);
        } else if (stmt.type === "ForOfStatement" || stmt.type === "ForInStatement" || stmt.type === "ForStatement") {
          const variable = stmt.type === "ForStatement" ? stmt.init : stmt.left;
          if (variable && variable.type === "VariableDeclaration") {
            for (const decl of variable.declarations) {
              for (const id of extractIdentifiers(decl.id)) {
                onIdent(id);
              }
            }
          }
        }
      }
    }
    function extractIdentifiers(param, nodes = []) {
      switch (param.type) {
        case "Identifier":
          nodes.push(param);
          break;
        case "MemberExpression":
          let object = param;
          while (object.type === "MemberExpression") {
            object = object.object;
          }
          nodes.push(object);
          break;
        case "ObjectPattern":
          for (const prop of param.properties) {
            if (prop.type === "RestElement") {
              extractIdentifiers(prop.argument, nodes);
            } else {
              extractIdentifiers(prop.value, nodes);
            }
          }
          break;
        case "ArrayPattern":
          param.elements.forEach((element) => {
            if (element)
              extractIdentifiers(element, nodes);
          });
          break;
        case "RestElement":
          extractIdentifiers(param.argument, nodes);
          break;
        case "AssignmentPattern":
          extractIdentifiers(param.left, nodes);
          break;
      }
      return nodes;
    }
    function markKnownIds(name, knownIds) {
      if (name in knownIds) {
        knownIds[name]++;
      } else {
        knownIds[name] = 1;
      }
    }
    function markScopeIdentifier(node, child, knownIds) {
      const { name } = child;
      if (node.scopeIds && node.scopeIds.has(name)) {
        return;
      }
      markKnownIds(name, knownIds);
      (node.scopeIds || (node.scopeIds = /* @__PURE__ */ new Set())).add(name);
    }
    var isFunctionType = (node) => {
      return /Function(?:Expression|Declaration)$|Method$/.test(node.type);
    };
    var isStaticProperty = (node) => node && (node.type === "ObjectProperty" || node.type === "ObjectMethod") && !node.computed;
    var isStaticPropertyKey = (node, parent) => isStaticProperty(parent) && parent.key === node;
    function isReferenced(node, parent, grandparent) {
      switch (parent.type) {
        case "MemberExpression":
        case "OptionalMemberExpression":
          if (parent.property === node) {
            return !!parent.computed;
          }
          return parent.object === node;
        case "JSXMemberExpression":
          return parent.object === node;
        case "VariableDeclarator":
          return parent.init === node;
        case "ArrowFunctionExpression":
          return parent.body === node;
        case "PrivateName":
          return false;
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "ObjectMethod":
          if (parent.key === node) {
            return !!parent.computed;
          }
          return false;
        case "ObjectProperty":
          if (parent.key === node) {
            return !!parent.computed;
          }
          return !grandparent;
        case "ClassProperty":
          if (parent.key === node) {
            return !!parent.computed;
          }
          return true;
        case "ClassPrivateProperty":
          return parent.key !== node;
        case "ClassDeclaration":
        case "ClassExpression":
          return parent.superClass === node;
        case "AssignmentExpression":
          return parent.right === node;
        case "AssignmentPattern":
          return parent.right === node;
        case "LabeledStatement":
          return false;
        case "CatchClause":
          return false;
        case "RestElement":
          return false;
        case "BreakStatement":
        case "ContinueStatement":
          return false;
        case "FunctionDeclaration":
        case "FunctionExpression":
          return false;
        case "ExportNamespaceSpecifier":
        case "ExportDefaultSpecifier":
          return false;
        case "ExportSpecifier":
          return parent.local === node;
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
          return false;
        case "ImportAttribute":
          return false;
        case "JSXAttribute":
          return false;
        case "ObjectPattern":
        case "ArrayPattern":
          return false;
        case "MetaProperty":
          return false;
        case "ObjectTypeProperty":
          return parent.key !== node;
        case "TSEnumMember":
          return parent.id !== node;
        case "TSPropertySignature":
          if (parent.key === node) {
            return !!parent.computed;
          }
          return true;
      }
      return true;
    }
    var TS_NODE_TYPES = [
      "TSAsExpression",
      "TSTypeAssertion",
      "TSNonNullExpression",
      "TSInstantiationExpression",
      "TSSatisfiesExpression"
    ];
    function unwrapTSNode(node) {
      if (TS_NODE_TYPES.includes(node.type)) {
        return unwrapTSNode(node.expression);
      } else {
        return node;
      }
    }
    var isStaticExp = (p) => p.type === 4 && p.isStatic;
    function isCoreComponent(tag) {
      switch (tag) {
        case "Teleport":
        case "teleport":
          return TELEPORT;
        case "Suspense":
        case "suspense":
          return SUSPENSE;
        case "KeepAlive":
        case "keep-alive":
          return KEEP_ALIVE;
        case "BaseTransition":
        case "base-transition":
          return BASE_TRANSITION;
      }
    }
    var nonIdentifierRE = /^\d|[^\$\w\xA0-\uFFFF]/;
    var isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
    var validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
    var validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
    var whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
    var isMemberExpressionBrowser = (path) => {
      path = path.trim().replace(whitespaceRE, (s) => s.trim());
      let state = 0;
      let stateStack = [];
      let currentOpenBracketCount = 0;
      let currentOpenParensCount = 0;
      let currentStringType = null;
      for (let i = 0; i < path.length; i++) {
        const char = path.charAt(i);
        switch (state) {
          case 0:
            if (char === "[") {
              stateStack.push(state);
              state = 1;
              currentOpenBracketCount++;
            } else if (char === "(") {
              stateStack.push(state);
              state = 2;
              currentOpenParensCount++;
            } else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
              return false;
            }
            break;
          case 1:
            if (char === `'` || char === `"` || char === "`") {
              stateStack.push(state);
              state = 3;
              currentStringType = char;
            } else if (char === `[`) {
              currentOpenBracketCount++;
            } else if (char === `]`) {
              if (!--currentOpenBracketCount) {
                state = stateStack.pop();
              }
            }
            break;
          case 2:
            if (char === `'` || char === `"` || char === "`") {
              stateStack.push(state);
              state = 3;
              currentStringType = char;
            } else if (char === `(`) {
              currentOpenParensCount++;
            } else if (char === `)`) {
              if (i === path.length - 1) {
                return false;
              }
              if (!--currentOpenParensCount) {
                state = stateStack.pop();
              }
            }
            break;
          case 3:
            if (char === currentStringType) {
              state = stateStack.pop();
              currentStringType = null;
            }
            break;
        }
      }
      return !currentOpenBracketCount && !currentOpenParensCount;
    };
    var isMemberExpressionNode = (path, context) => {
      try {
        let ret = parser.parseExpression(path, {
          plugins: context.expressionPlugins
        });
        ret = unwrapTSNode(ret);
        return ret.type === "MemberExpression" || ret.type === "OptionalMemberExpression" || ret.type === "Identifier" && ret.name !== "undefined";
      } catch (e) {
        return false;
      }
    };
    var isMemberExpression = isMemberExpressionNode;
    function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
      return advancePositionWithMutation(
        {
          offset: pos.offset,
          line: pos.line,
          column: pos.column
        },
        source,
        numberOfCharacters
      );
    }
    function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
      let linesCount = 0;
      let lastNewLinePos = -1;
      for (let i = 0; i < numberOfCharacters; i++) {
        if (source.charCodeAt(i) === 10) {
          linesCount++;
          lastNewLinePos = i;
        }
      }
      pos.offset += numberOfCharacters;
      pos.line += linesCount;
      pos.column = lastNewLinePos === -1 ? pos.column + numberOfCharacters : numberOfCharacters - lastNewLinePos;
      return pos;
    }
    function assert(condition, msg) {
      if (!condition) {
        throw new Error(msg || `unexpected compiler condition`);
      }
    }
    function findDir(node, name, allowEmpty = false) {
      for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 7 && (allowEmpty || p.exp) && (shared.isString(name) ? p.name === name : name.test(p.name))) {
          return p;
        }
      }
    }
    function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
      for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 6) {
          if (dynamicOnly)
            continue;
          if (p.name === name && (p.value || allowEmpty)) {
            return p;
          }
        } else if (p.name === "bind" && (p.exp || allowEmpty) && isStaticArgOf(p.arg, name)) {
          return p;
        }
      }
    }
    function isStaticArgOf(arg, name) {
      return !!(arg && isStaticExp(arg) && arg.content === name);
    }
    function hasDynamicKeyVBind(node) {
      return node.props.some(
        (p) => p.type === 7 && p.name === "bind" && (!p.arg || p.arg.type !== 4 || !p.arg.isStatic)
      );
    }
    function isText$1(node) {
      return node.type === 5 || node.type === 2;
    }
    function isVSlot(p) {
      return p.type === 7 && p.name === "slot";
    }
    function isTemplateNode(node) {
      return node.type === 1 && node.tagType === 3;
    }
    function isSlotOutlet(node) {
      return node.type === 1 && node.tagType === 2;
    }
    var propsHelperSet = /* @__PURE__ */ new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
    function getUnnormalizedProps(props, callPath = []) {
      if (props && !shared.isString(props) && props.type === 14) {
        const callee = props.callee;
        if (!shared.isString(callee) && propsHelperSet.has(callee)) {
          return getUnnormalizedProps(
            props.arguments[0],
            callPath.concat(props)
          );
        }
      }
      return [props, callPath];
    }
    function injectProp(node, prop, context) {
      let propsWithInjection;
      let props = node.type === 13 ? node.props : node.arguments[2];
      let callPath = [];
      let parentCall;
      if (props && !shared.isString(props) && props.type === 14) {
        const ret = getUnnormalizedProps(props);
        props = ret[0];
        callPath = ret[1];
        parentCall = callPath[callPath.length - 1];
      }
      if (props == null || shared.isString(props)) {
        propsWithInjection = createObjectExpression([prop]);
      } else if (props.type === 14) {
        const first = props.arguments[0];
        if (!shared.isString(first) && first.type === 15) {
          if (!hasProp(prop, first)) {
            first.properties.unshift(prop);
          }
        } else {
          if (props.callee === TO_HANDLERS) {
            propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
              createObjectExpression([prop]),
              props
            ]);
          } else {
            props.arguments.unshift(createObjectExpression([prop]));
          }
        }
        !propsWithInjection && (propsWithInjection = props);
      } else if (props.type === 15) {
        if (!hasProp(prop, props)) {
          props.properties.unshift(prop);
        }
        propsWithInjection = props;
      } else {
        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
          createObjectExpression([prop]),
          props
        ]);
        if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
          parentCall = callPath[callPath.length - 2];
        }
      }
      if (node.type === 13) {
        if (parentCall) {
          parentCall.arguments[0] = propsWithInjection;
        } else {
          node.props = propsWithInjection;
        }
      } else {
        if (parentCall) {
          parentCall.arguments[0] = propsWithInjection;
        } else {
          node.arguments[2] = propsWithInjection;
        }
      }
    }
    function hasProp(prop, props) {
      let result = false;
      if (prop.key.type === 4) {
        const propKeyName = prop.key.content;
        result = props.properties.some(
          (p) => p.key.type === 4 && p.key.content === propKeyName
        );
      }
      return result;
    }
    function toValidAssetId(name, type) {
      return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {
        return searchValue === "-" ? "_" : name.charCodeAt(replaceValue).toString();
      })}`;
    }
    function hasScopeRef(node, ids) {
      if (!node || Object.keys(ids).length === 0) {
        return false;
      }
      switch (node.type) {
        case 1:
          for (let i = 0; i < node.props.length; i++) {
            const p = node.props[i];
            if (p.type === 7 && (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) {
              return true;
            }
          }
          return node.children.some((c) => hasScopeRef(c, ids));
        case 11:
          if (hasScopeRef(node.source, ids)) {
            return true;
          }
          return node.children.some((c) => hasScopeRef(c, ids));
        case 9:
          return node.branches.some((b) => hasScopeRef(b, ids));
        case 10:
          if (hasScopeRef(node.condition, ids)) {
            return true;
          }
          return node.children.some((c) => hasScopeRef(c, ids));
        case 4:
          return !node.isStatic && isSimpleIdentifier(node.content) && !!ids[node.content];
        case 8:
          return node.children.some((c) => shared.isObject(c) && hasScopeRef(c, ids));
        case 5:
        case 12:
          return hasScopeRef(node.content, ids);
        case 2:
        case 3:
          return false;
        default:
          return false;
      }
    }
    function getMemoedVNodeCall(node) {
      if (node.type === 14 && node.callee === WITH_MEMO) {
        return node.arguments[1].returns;
      } else {
        return node;
      }
    }
    var forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+(\S[\s\S]*)/;
    var defaultParserOptions = {
      parseMode: "base",
      ns: 0,
      delimiters: [`{{`, `}}`],
      getNamespace: () => 0,
      isVoidTag: shared.NO,
      isPreTag: shared.NO,
      isCustomElement: shared.NO,
      onError: defaultOnError,
      onWarn: defaultOnWarn,
      comments: true,
      prefixIdentifiers: false
    };
    var currentOptions = defaultParserOptions;
    var currentRoot = null;
    var currentInput = "";
    var currentOpenTag = null;
    var currentProp = null;
    var currentAttrValue = "";
    var currentAttrStartIndex = -1;
    var currentAttrEndIndex = -1;
    var inPre = 0;
    var inVPre = false;
    var currentVPreBoundary = null;
    var stack = [];
    var tokenizer = new Tokenizer(stack, {
      onerr: emitError,
      ontext(start, end) {
        onText(getSlice(start, end), start, end);
      },
      ontextentity(char, start, end) {
        onText(char, start, end);
      },
      oninterpolation(start, end) {
        if (inVPre) {
          return onText(getSlice(start, end), start, end);
        }
        let innerStart = start + tokenizer.delimiterOpen.length;
        let innerEnd = end - tokenizer.delimiterClose.length;
        while (isWhitespace(currentInput.charCodeAt(innerStart))) {
          innerStart++;
        }
        while (isWhitespace(currentInput.charCodeAt(innerEnd - 1))) {
          innerEnd--;
        }
        let exp = getSlice(innerStart, innerEnd);
        if (exp.includes("&")) {
          {
            exp = decode_js.decodeHTML(exp);
          }
        }
        addNode({
          type: 5,
          content: createExp(exp, false, getLoc(innerStart, innerEnd)),
          loc: getLoc(start, end)
        });
      },
      onopentagname(start, end) {
        const name = getSlice(start, end);
        currentOpenTag = {
          type: 1,
          tag: name,
          ns: currentOptions.getNamespace(name, stack[0], currentOptions.ns),
          tagType: 0,
          props: [],
          children: [],
          loc: getLoc(start - 1, end),
          codegenNode: void 0
        };
      },
      onopentagend(end) {
        endOpenTag(end);
      },
      onclosetag(start, end) {
        const name = getSlice(start, end);
        if (!currentOptions.isVoidTag(name)) {
          let found = false;
          for (let i = 0; i < stack.length; i++) {
            const e = stack[i];
            if (e.tag.toLowerCase() === name.toLowerCase()) {
              found = true;
              if (i > 0) {
                emitError(24, stack[0].loc.start.offset);
              }
              for (let j = 0; j <= i; j++) {
                const el = stack.shift();
                onCloseTag(el, end, j < i);
              }
              break;
            }
          }
          if (!found) {
            emitError(23, backTrack(start, 60));
          }
        }
      },
      onselfclosingtag(end) {
        const name = currentOpenTag.tag;
        currentOpenTag.isSelfClosing = true;
        endOpenTag(end);
        if (stack[0] && stack[0].tag === name) {
          onCloseTag(stack.shift(), end);
        }
      },
      onattribname(start, end) {
        currentProp = {
          type: 6,
          name: getSlice(start, end),
          nameLoc: getLoc(start, end),
          value: void 0,
          loc: getLoc(start)
        };
      },
      ondirname(start, end) {
        const raw = getSlice(start, end);
        const name = raw === "." || raw === ":" ? "bind" : raw === "@" ? "on" : raw === "#" ? "slot" : raw.slice(2);
        if (!inVPre && name === "") {
          emitError(26, start);
        }
        if (inVPre || name === "") {
          currentProp = {
            type: 6,
            name: raw,
            nameLoc: getLoc(start, end),
            value: void 0,
            loc: getLoc(start)
          };
        } else {
          currentProp = {
            type: 7,
            name,
            rawName: raw,
            exp: void 0,
            arg: void 0,
            modifiers: raw === "." ? ["prop"] : [],
            loc: getLoc(start)
          };
          if (name === "pre") {
            inVPre = tokenizer.inVPre = true;
            currentVPreBoundary = currentOpenTag;
            const props = currentOpenTag.props;
            for (let i = 0; i < props.length; i++) {
              if (props[i].type === 7) {
                props[i] = dirToAttr(props[i]);
              }
            }
          }
        }
      },
      ondirarg(start, end) {
        if (start === end)
          return;
        const arg = getSlice(start, end);
        if (inVPre) {
          currentProp.name += arg;
          setLocEnd(currentProp.nameLoc, end);
        } else {
          const isStatic = arg[0] !== `[`;
          currentProp.arg = createExp(
            isStatic ? arg : arg.slice(1, -1),
            isStatic,
            getLoc(start, end),
            isStatic ? 3 : 0
          );
        }
      },
      ondirmodifier(start, end) {
        const mod = getSlice(start, end);
        if (inVPre) {
          currentProp.name += "." + mod;
          setLocEnd(currentProp.nameLoc, end);
        } else if (currentProp.name === "slot") {
          const arg = currentProp.arg;
          if (arg) {
            arg.content += "." + mod;
            setLocEnd(arg.loc, end);
          }
        } else {
          currentProp.modifiers.push(mod);
        }
      },
      onattribdata(start, end) {
        currentAttrValue += getSlice(start, end);
        if (currentAttrStartIndex < 0)
          currentAttrStartIndex = start;
        currentAttrEndIndex = end;
      },
      onattribentity(char, start, end) {
        currentAttrValue += char;
        if (currentAttrStartIndex < 0)
          currentAttrStartIndex = start;
        currentAttrEndIndex = end;
      },
      onattribnameend(end) {
        const start = currentProp.loc.start.offset;
        const name = getSlice(start, end);
        if (currentProp.type === 7) {
          currentProp.rawName = name;
        }
        if (currentOpenTag.props.some(
          (p) => (p.type === 7 ? p.rawName : p.name) === name
        )) {
          emitError(2, start);
        }
      },
      onattribend(quote, end) {
        if (currentOpenTag && currentProp) {
          setLocEnd(currentProp.loc, end);
          if (quote !== 0) {
            if (currentProp.type === 6) {
              if (currentProp.name === "class") {
                currentAttrValue = condense(currentAttrValue).trim();
              }
              if (quote === 1 && !currentAttrValue) {
                emitError(13, end);
              }
              currentProp.value = {
                type: 2,
                content: currentAttrValue,
                loc: quote === 1 ? getLoc(currentAttrStartIndex, currentAttrEndIndex) : getLoc(currentAttrStartIndex - 1, currentAttrEndIndex + 1)
              };
              if (tokenizer.inSFCRoot && currentOpenTag.tag === "template" && currentProp.name === "lang" && currentAttrValue && currentAttrValue !== "html") {
                tokenizer.enterRCDATA(toCharCodes(`</template`), 0);
              }
            } else {
              let expParseMode = 0;
              {
                if (currentProp.name === "for") {
                  expParseMode = 3;
                } else if (currentProp.name === "slot") {
                  expParseMode = 1;
                } else if (currentProp.name === "on" && currentAttrValue.includes(";")) {
                  expParseMode = 2;
                }
              }
              currentProp.exp = createExp(
                currentAttrValue,
                false,
                getLoc(currentAttrStartIndex, currentAttrEndIndex),
                0,
                expParseMode
              );
              if (currentProp.name === "for") {
                currentProp.forParseResult = parseForExpression(currentProp.exp);
              }
              let syncIndex = -1;
              if (currentProp.name === "bind" && (syncIndex = currentProp.modifiers.indexOf("sync")) > -1 && checkCompatEnabled(
                "COMPILER_V_BIND_SYNC",
                currentOptions,
                currentProp.loc,
                currentProp.rawName
              )) {
                currentProp.name = "model";
                currentProp.modifiers.splice(syncIndex, 1);
              }
            }
          }
          if (currentProp.type !== 7 || currentProp.name !== "pre") {
            currentOpenTag.props.push(currentProp);
          }
        }
        currentAttrValue = "";
        currentAttrStartIndex = currentAttrEndIndex = -1;
      },
      oncomment(start, end) {
        if (currentOptions.comments) {
          addNode({
            type: 3,
            content: getSlice(start, end),
            loc: getLoc(start - 4, end + 3)
          });
        }
      },
      onend() {
        const end = currentInput.length;
        if (tokenizer.state !== 1) {
          switch (tokenizer.state) {
            case 5:
            case 8:
              emitError(5, end);
              break;
            case 3:
            case 4:
              emitError(
                25,
                tokenizer.sectionStart
              );
              break;
            case 28:
              if (tokenizer.currentSequence === Sequences.CdataEnd) {
                emitError(6, end);
              } else {
                emitError(7, end);
              }
              break;
            case 6:
            case 7:
            case 9:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
              emitError(9, end);
              break;
          }
        }
        for (let index = 0; index < stack.length; index++) {
          onCloseTag(stack[index], end - 1);
          emitError(24, stack[index].loc.start.offset);
        }
      },
      oncdata(start, end) {
        if (stack[0].ns !== 0) {
          onText(getSlice(start, end), start, end);
        } else {
          emitError(1, start - 9);
        }
      },
      onprocessinginstruction(start) {
        if ((stack[0] ? stack[0].ns : currentOptions.ns) === 0) {
          emitError(
            21,
            start - 1
          );
        }
      }
    });
    var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
    var stripParensRE = /^\(|\)$/g;
    function parseForExpression(input) {
      const loc = input.loc;
      const exp = input.content;
      const inMatch = exp.match(forAliasRE);
      if (!inMatch)
        return;
      const [, LHS, RHS] = inMatch;
      const createAliasExpression = (content, offset, asParam = false) => {
        const start = loc.start.offset + offset;
        const end = start + content.length;
        return createExp(
          content,
          false,
          getLoc(start, end),
          0,
          asParam ? 1 : 0
        );
      };
      const result = {
        source: createAliasExpression(RHS.trim(), exp.indexOf(RHS, LHS.length)),
        value: void 0,
        key: void 0,
        index: void 0,
        finalized: false
      };
      let valueContent = LHS.trim().replace(stripParensRE, "").trim();
      const trimmedOffset = LHS.indexOf(valueContent);
      const iteratorMatch = valueContent.match(forIteratorRE);
      if (iteratorMatch) {
        valueContent = valueContent.replace(forIteratorRE, "").trim();
        const keyContent = iteratorMatch[1].trim();
        let keyOffset;
        if (keyContent) {
          keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
          result.key = createAliasExpression(keyContent, keyOffset, true);
        }
        if (iteratorMatch[2]) {
          const indexContent = iteratorMatch[2].trim();
          if (indexContent) {
            result.index = createAliasExpression(
              indexContent,
              exp.indexOf(
                indexContent,
                result.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length
              ),
              true
            );
          }
        }
      }
      if (valueContent) {
        result.value = createAliasExpression(valueContent, trimmedOffset, true);
      }
      return result;
    }
    function getSlice(start, end) {
      return currentInput.slice(start, end);
    }
    function endOpenTag(end) {
      if (tokenizer.inSFCRoot) {
        currentOpenTag.innerLoc = getLoc(end + 1, end + 1);
      }
      addNode(currentOpenTag);
      const { tag, ns } = currentOpenTag;
      if (ns === 0 && currentOptions.isPreTag(tag)) {
        inPre++;
      }
      if (currentOptions.isVoidTag(tag)) {
        onCloseTag(currentOpenTag, end);
      } else {
        stack.unshift(currentOpenTag);
        if (ns === 1 || ns === 2) {
          tokenizer.inXML = true;
        }
      }
      currentOpenTag = null;
    }
    function onText(content, start, end) {
      const parent = stack[0] || currentRoot;
      const lastNode = parent.children[parent.children.length - 1];
      if (lastNode && lastNode.type === 2) {
        lastNode.content += content;
        setLocEnd(lastNode.loc, end);
      } else {
        parent.children.push({
          type: 2,
          content,
          loc: getLoc(start, end)
        });
      }
    }
    function onCloseTag(el, end, isImplied = false) {
      if (isImplied) {
        setLocEnd(el.loc, backTrack(end, 60));
      } else {
        setLocEnd(el.loc, lookAhead(end, 62) + 1);
      }
      if (tokenizer.inSFCRoot) {
        if (el.children.length) {
          el.innerLoc.end = shared.extend({}, el.children[el.children.length - 1].loc.end);
        } else {
          el.innerLoc.end = shared.extend({}, el.innerLoc.start);
        }
        el.innerLoc.source = getSlice(
          el.innerLoc.start.offset,
          el.innerLoc.end.offset
        );
      }
      const { tag, ns } = el;
      if (!inVPre) {
        if (tag === "slot") {
          el.tagType = 2;
        } else if (isFragmentTemplate(el)) {
          el.tagType = 3;
        } else if (isComponent(el)) {
          el.tagType = 1;
        }
      }
      if (!tokenizer.inRCDATA) {
        el.children = condenseWhitespace(el.children, el.tag);
      }
      if (ns === 0 && currentOptions.isPreTag(tag)) {
        inPre--;
      }
      if (currentVPreBoundary === el) {
        inVPre = tokenizer.inVPre = false;
        currentVPreBoundary = null;
      }
      if (tokenizer.inXML && (stack[0] ? stack[0].ns : currentOptions.ns) === 0) {
        tokenizer.inXML = false;
      }
      {
        const props = el.props;
        if (isCompatEnabled(
          "COMPILER_V_IF_V_FOR_PRECEDENCE",
          currentOptions
        )) {
          let hasIf = false;
          let hasFor = false;
          for (let i = 0; i < props.length; i++) {
            const p = props[i];
            if (p.type === 7) {
              if (p.name === "if") {
                hasIf = true;
              } else if (p.name === "for") {
                hasFor = true;
              }
            }
            if (hasIf && hasFor) {
              warnDeprecation(
                "COMPILER_V_IF_V_FOR_PRECEDENCE",
                currentOptions,
                el.loc
              );
              break;
            }
          }
        }
        if (!tokenizer.inSFCRoot && isCompatEnabled(
          "COMPILER_NATIVE_TEMPLATE",
          currentOptions
        ) && el.tag === "template" && !isFragmentTemplate(el)) {
          warnDeprecation(
            "COMPILER_NATIVE_TEMPLATE",
            currentOptions,
            el.loc
          );
          const parent = stack[0] || currentRoot;
          const index = parent.children.indexOf(el);
          parent.children.splice(index, 1, ...el.children);
        }
        const inlineTemplateProp = props.find(
          (p) => p.type === 6 && p.name === "inline-template"
        );
        if (inlineTemplateProp && checkCompatEnabled(
          "COMPILER_INLINE_TEMPLATE",
          currentOptions,
          inlineTemplateProp.loc
        ) && el.children.length) {
          inlineTemplateProp.value = {
            type: 2,
            content: getSlice(
              el.children[0].loc.start.offset,
              el.children[el.children.length - 1].loc.end.offset
            ),
            loc: inlineTemplateProp.loc
          };
        }
      }
    }
    function lookAhead(index, c) {
      let i = index;
      while (currentInput.charCodeAt(i) !== c && i < currentInput.length - 1)
        i++;
      return i;
    }
    function backTrack(index, c) {
      let i = index;
      while (currentInput.charCodeAt(i) !== c && i >= 0)
        i--;
      return i;
    }
    var specialTemplateDir = /* @__PURE__ */ new Set(["if", "else", "else-if", "for", "slot"]);
    function isFragmentTemplate({ tag, props }) {
      if (tag === "template") {
        for (let i = 0; i < props.length; i++) {
          if (props[i].type === 7 && specialTemplateDir.has(props[i].name)) {
            return true;
          }
        }
      }
      return false;
    }
    function isComponent({ tag, props }) {
      if (currentOptions.isCustomElement(tag)) {
        return false;
      }
      if (tag === "component" || isUpperCase(tag.charCodeAt(0)) || isCoreComponent(tag) || currentOptions.isBuiltInComponent && currentOptions.isBuiltInComponent(tag) || currentOptions.isNativeTag && !currentOptions.isNativeTag(tag)) {
        return true;
      }
      for (let i = 0; i < props.length; i++) {
        const p = props[i];
        if (p.type === 6) {
          if (p.name === "is" && p.value) {
            if (p.value.content.startsWith("vue:")) {
              return true;
            } else if (checkCompatEnabled(
              "COMPILER_IS_ON_ELEMENT",
              currentOptions,
              p.loc
            )) {
              return true;
            }
          }
        } else if (p.name === "bind" && isStaticArgOf(p.arg, "is") && checkCompatEnabled(
          "COMPILER_IS_ON_ELEMENT",
          currentOptions,
          p.loc
        )) {
          return true;
        }
      }
      return false;
    }
    function isUpperCase(c) {
      return c > 64 && c < 91;
    }
    var windowsNewlineRE = /\r\n/g;
    function condenseWhitespace(nodes, tag) {
      const shouldCondense = currentOptions.whitespace !== "preserve";
      let removedWhitespace = false;
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (node.type === 2) {
          if (!inPre) {
            if (isAllWhitespace(node.content)) {
              const prev = nodes[i - 1] && nodes[i - 1].type;
              const next = nodes[i + 1] && nodes[i + 1].type;
              if (!prev || !next || shouldCondense && (prev === 3 && (next === 3 || next === 1) || prev === 1 && (next === 3 || next === 1 && hasNewlineChar(node.content)))) {
                removedWhitespace = true;
                nodes[i] = null;
              } else {
                node.content = " ";
              }
            } else if (shouldCondense) {
              node.content = condense(node.content);
            }
          } else {
            node.content = node.content.replace(windowsNewlineRE, "\n");
          }
        }
      }
      if (inPre && tag && currentOptions.isPreTag(tag)) {
        const first = nodes[0];
        if (first && first.type === 2) {
          first.content = first.content.replace(/^\r?\n/, "");
        }
      }
      return removedWhitespace ? nodes.filter(Boolean) : nodes;
    }
    function isAllWhitespace(str) {
      for (let i = 0; i < str.length; i++) {
        if (!isWhitespace(str.charCodeAt(i))) {
          return false;
        }
      }
      return true;
    }
    function hasNewlineChar(str) {
      for (let i = 0; i < str.length; i++) {
        const c = str.charCodeAt(i);
        if (c === 10 || c === 13) {
          return true;
        }
      }
      return false;
    }
    function condense(str) {
      let ret = "";
      let prevCharIsWhitespace = false;
      for (let i = 0; i < str.length; i++) {
        if (isWhitespace(str.charCodeAt(i))) {
          if (!prevCharIsWhitespace) {
            ret += " ";
            prevCharIsWhitespace = true;
          }
        } else {
          ret += str[i];
          prevCharIsWhitespace = false;
        }
      }
      return ret;
    }
    function addNode(node) {
      (stack[0] || currentRoot).children.push(node);
    }
    function getLoc(start, end) {
      return {
        start: tokenizer.getPos(start),
        end: end == null ? end : tokenizer.getPos(end),
        source: end == null ? end : getSlice(start, end)
      };
    }
    function setLocEnd(loc, end) {
      loc.end = tokenizer.getPos(end);
      loc.source = getSlice(loc.start.offset, end);
    }
    function dirToAttr(dir) {
      const attr = {
        type: 6,
        name: dir.rawName,
        nameLoc: getLoc(
          dir.loc.start.offset,
          dir.loc.start.offset + dir.rawName.length
        ),
        value: void 0,
        loc: dir.loc
      };
      if (dir.exp) {
        const loc = dir.exp.loc;
        if (loc.end.offset < dir.loc.end.offset) {
          loc.start.offset--;
          loc.start.column--;
          loc.end.offset++;
          loc.end.column++;
        }
        attr.value = {
          type: 2,
          content: dir.exp.content,
          loc
        };
      }
      return attr;
    }
    function createExp(content, isStatic = false, loc, constType = 0, parseMode = 0) {
      const exp = createSimpleExpression(content, isStatic, loc, constType);
      if (!isStatic && currentOptions.prefixIdentifiers && parseMode !== 3 && content.trim()) {
        if (isSimpleIdentifier(content)) {
          exp.ast = null;
          return exp;
        }
        try {
          const plugins = currentOptions.expressionPlugins;
          const options = {
            plugins: plugins ? [...plugins, "typescript"] : ["typescript"]
          };
          if (parseMode === 2) {
            exp.ast = parser.parse(` ${content} `, options).program;
          } else if (parseMode === 1) {
            exp.ast = parser.parseExpression(`(${content})=>{}`, options);
          } else {
            exp.ast = parser.parseExpression(`(${content})`, options);
          }
        } catch (e) {
          exp.ast = false;
          emitError(45, loc.start.offset, e.message);
        }
      }
      return exp;
    }
    function emitError(code, index, message) {
      currentOptions.onError(
        createCompilerError(code, getLoc(index, index), void 0, message)
      );
    }
    function reset() {
      tokenizer.reset();
      currentOpenTag = null;
      currentProp = null;
      currentAttrValue = "";
      currentAttrStartIndex = -1;
      currentAttrEndIndex = -1;
      stack.length = 0;
    }
    function baseParse(input, options) {
      reset();
      currentInput = input;
      currentOptions = shared.extend({}, defaultParserOptions);
      if (options) {
        let key;
        for (key in options) {
          if (options[key] != null) {
            currentOptions[key] = options[key];
          }
        }
      }
      {
        if (currentOptions.decodeEntities) {
          console.warn(
            `[@vue/compiler-core] decodeEntities option is passed but will be ignored in non-browser builds.`
          );
        }
      }
      tokenizer.mode = currentOptions.parseMode === "html" ? 1 : currentOptions.parseMode === "sfc" ? 2 : 0;
      tokenizer.inXML = currentOptions.ns === 1 || currentOptions.ns === 2;
      const delimiters = options && options.delimiters;
      if (delimiters) {
        tokenizer.delimiterOpen = toCharCodes(delimiters[0]);
        tokenizer.delimiterClose = toCharCodes(delimiters[1]);
      }
      const root = currentRoot = createRoot([], input);
      tokenizer.parse(currentInput);
      root.loc = getLoc(0, input.length);
      root.children = condenseWhitespace(root.children);
      currentRoot = null;
      return root;
    }
    function hoistStatic(root, context) {
      walk(
        root,
        context,
        isSingleElementRoot(root, root.children[0])
      );
    }
    function isSingleElementRoot(root, child) {
      const { children } = root;
      return children.length === 1 && child.type === 1 && !isSlotOutlet(child);
    }
    function walk(node, context, doNotHoistNode = false) {
      const { children } = node;
      const originalCount = children.length;
      let hoistedCount = 0;
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (child.type === 1 && child.tagType === 0) {
          const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
          if (constantType > 0) {
            if (constantType >= 2) {
              child.codegenNode.patchFlag = -1 + ` /* HOISTED */`;
              child.codegenNode = context.hoist(child.codegenNode);
              hoistedCount++;
              continue;
            }
          } else {
            const codegenNode = child.codegenNode;
            if (codegenNode.type === 13) {
              const flag = getPatchFlag(codegenNode);
              if ((!flag || flag === 512 || flag === 1) && getGeneratedPropsConstantType(child, context) >= 2) {
                const props = getNodeProps(child);
                if (props) {
                  codegenNode.props = context.hoist(props);
                }
              }
              if (codegenNode.dynamicProps) {
                codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
              }
            }
          }
        }
        if (child.type === 1) {
          const isComponent2 = child.tagType === 1;
          if (isComponent2) {
            context.scopes.vSlot++;
          }
          walk(child, context);
          if (isComponent2) {
            context.scopes.vSlot--;
          }
        } else if (child.type === 11) {
          walk(child, context, child.children.length === 1);
        } else if (child.type === 9) {
          for (let i2 = 0; i2 < child.branches.length; i2++) {
            walk(
              child.branches[i2],
              context,
              child.branches[i2].children.length === 1
            );
          }
        }
      }
      if (hoistedCount && context.transformHoist) {
        context.transformHoist(children, context, node);
      }
      if (hoistedCount && hoistedCount === originalCount && node.type === 1 && node.tagType === 0 && node.codegenNode && node.codegenNode.type === 13 && shared.isArray(node.codegenNode.children)) {
        const hoisted = context.hoist(
          createArrayExpression(node.codegenNode.children)
        );
        if (context.hmr) {
          hoisted.content = `[...${hoisted.content}]`;
        }
        node.codegenNode.children = hoisted;
      }
    }
    function getConstantType(node, context) {
      const { constantCache } = context;
      switch (node.type) {
        case 1:
          if (node.tagType !== 0) {
            return 0;
          }
          const cached = constantCache.get(node);
          if (cached !== void 0) {
            return cached;
          }
          const codegenNode = node.codegenNode;
          if (codegenNode.type !== 13) {
            return 0;
          }
          if (codegenNode.isBlock && node.tag !== "svg" && node.tag !== "foreignObject" && node.tag !== "math") {
            return 0;
          }
          const flag = getPatchFlag(codegenNode);
          if (!flag) {
            let returnType2 = 3;
            const generatedPropsType = getGeneratedPropsConstantType(node, context);
            if (generatedPropsType === 0) {
              constantCache.set(node, 0);
              return 0;
            }
            if (generatedPropsType < returnType2) {
              returnType2 = generatedPropsType;
            }
            for (let i = 0; i < node.children.length; i++) {
              const childType = getConstantType(node.children[i], context);
              if (childType === 0) {
                constantCache.set(node, 0);
                return 0;
              }
              if (childType < returnType2) {
                returnType2 = childType;
              }
            }
            if (returnType2 > 1) {
              for (let i = 0; i < node.props.length; i++) {
                const p = node.props[i];
                if (p.type === 7 && p.name === "bind" && p.exp) {
                  const expType = getConstantType(p.exp, context);
                  if (expType === 0) {
                    constantCache.set(node, 0);
                    return 0;
                  }
                  if (expType < returnType2) {
                    returnType2 = expType;
                  }
                }
              }
            }
            if (codegenNode.isBlock) {
              for (let i = 0; i < node.props.length; i++) {
                const p = node.props[i];
                if (p.type === 7) {
                  constantCache.set(node, 0);
                  return 0;
                }
              }
              context.removeHelper(OPEN_BLOCK);
              context.removeHelper(
                getVNodeBlockHelper(context.inSSR, codegenNode.isComponent)
              );
              codegenNode.isBlock = false;
              context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));
            }
            constantCache.set(node, returnType2);
            return returnType2;
          } else {
            constantCache.set(node, 0);
            return 0;
          }
        case 2:
        case 3:
          return 3;
        case 9:
        case 11:
        case 10:
          return 0;
        case 5:
        case 12:
          return getConstantType(node.content, context);
        case 4:
          return node.constType;
        case 8:
          let returnType = 3;
          for (let i = 0; i < node.children.length; i++) {
            const child = node.children[i];
            if (shared.isString(child) || shared.isSymbol(child)) {
              continue;
            }
            const childType = getConstantType(child, context);
            if (childType === 0) {
              return 0;
            } else if (childType < returnType) {
              returnType = childType;
            }
          }
          return returnType;
        default:
          return 0;
      }
    }
    var allowHoistedHelperSet = /* @__PURE__ */ new Set([
      NORMALIZE_CLASS,
      NORMALIZE_STYLE,
      NORMALIZE_PROPS,
      GUARD_REACTIVE_PROPS
    ]);
    function getConstantTypeOfHelperCall(value, context) {
      if (value.type === 14 && !shared.isString(value.callee) && allowHoistedHelperSet.has(value.callee)) {
        const arg = value.arguments[0];
        if (arg.type === 4) {
          return getConstantType(arg, context);
        } else if (arg.type === 14) {
          return getConstantTypeOfHelperCall(arg, context);
        }
      }
      return 0;
    }
    function getGeneratedPropsConstantType(node, context) {
      let returnType = 3;
      const props = getNodeProps(node);
      if (props && props.type === 15) {
        const { properties } = props;
        for (let i = 0; i < properties.length; i++) {
          const { key, value } = properties[i];
          const keyType = getConstantType(key, context);
          if (keyType === 0) {
            return keyType;
          }
          if (keyType < returnType) {
            returnType = keyType;
          }
          let valueType;
          if (value.type === 4) {
            valueType = getConstantType(value, context);
          } else if (value.type === 14) {
            valueType = getConstantTypeOfHelperCall(value, context);
          } else {
            valueType = 0;
          }
          if (valueType === 0) {
            return valueType;
          }
          if (valueType < returnType) {
            returnType = valueType;
          }
        }
      }
      return returnType;
    }
    function getNodeProps(node) {
      const codegenNode = node.codegenNode;
      if (codegenNode.type === 13) {
        return codegenNode.props;
      }
    }
    function getPatchFlag(node) {
      const flag = node.patchFlag;
      return flag ? parseInt(flag, 10) : void 0;
    }
    function createTransformContext(root, {
      filename = "",
      prefixIdentifiers = false,
      hoistStatic: hoistStatic2 = false,
      hmr = false,
      cacheHandlers = false,
      nodeTransforms = [],
      directiveTransforms = {},
      transformHoist = null,
      isBuiltInComponent = shared.NOOP,
      isCustomElement = shared.NOOP,
      expressionPlugins = [],
      scopeId = null,
      slotted = true,
      ssr = false,
      inSSR = false,
      ssrCssVars = ``,
      bindingMetadata = shared.EMPTY_OBJ,
      inline = false,
      isTS = false,
      onError = defaultOnError,
      onWarn = defaultOnWarn,
      compatConfig
    }) {
      const nameMatch = filename.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/);
      const context = {
        filename,
        selfName: nameMatch && shared.capitalize(shared.camelize(nameMatch[1])),
        prefixIdentifiers,
        hoistStatic: hoistStatic2,
        hmr,
        cacheHandlers,
        nodeTransforms,
        directiveTransforms,
        transformHoist,
        isBuiltInComponent,
        isCustomElement,
        expressionPlugins,
        scopeId,
        slotted,
        ssr,
        inSSR,
        ssrCssVars,
        bindingMetadata,
        inline,
        isTS,
        onError,
        onWarn,
        compatConfig,
        root,
        helpers: /* @__PURE__ */ new Map(),
        components: /* @__PURE__ */ new Set(),
        directives: /* @__PURE__ */ new Set(),
        hoists: [],
        imports: [],
        constantCache: /* @__PURE__ */ new WeakMap(),
        temps: 0,
        cached: 0,
        identifiers: /* @__PURE__ */ Object.create(null),
        scopes: {
          vFor: 0,
          vSlot: 0,
          vPre: 0,
          vOnce: 0
        },
        parent: null,
        grandParent: null,
        currentNode: root,
        childIndex: 0,
        inVOnce: false,
        helper(name) {
          const count = context.helpers.get(name) || 0;
          context.helpers.set(name, count + 1);
          return name;
        },
        removeHelper(name) {
          const count = context.helpers.get(name);
          if (count) {
            const currentCount = count - 1;
            if (!currentCount) {
              context.helpers.delete(name);
            } else {
              context.helpers.set(name, currentCount);
            }
          }
        },
        helperString(name) {
          return `_${helperNameMap[context.helper(name)]}`;
        },
        replaceNode(node) {
          {
            if (!context.currentNode) {
              throw new Error(`Node being replaced is already removed.`);
            }
            if (!context.parent) {
              throw new Error(`Cannot replace root node.`);
            }
          }
          context.parent.children[context.childIndex] = context.currentNode = node;
        },
        removeNode(node) {
          if (!context.parent) {
            throw new Error(`Cannot remove root node.`);
          }
          const list = context.parent.children;
          const removalIndex = node ? list.indexOf(node) : context.currentNode ? context.childIndex : -1;
          if (removalIndex < 0) {
            throw new Error(`node being removed is not a child of current parent`);
          }
          if (!node || node === context.currentNode) {
            context.currentNode = null;
            context.onNodeRemoved();
          } else {
            if (context.childIndex > removalIndex) {
              context.childIndex--;
              context.onNodeRemoved();
            }
          }
          context.parent.children.splice(removalIndex, 1);
        },
        onNodeRemoved: shared.NOOP,
        addIdentifiers(exp) {
          {
            if (shared.isString(exp)) {
              addId(exp);
            } else if (exp.identifiers) {
              exp.identifiers.forEach(addId);
            } else if (exp.type === 4) {
              addId(exp.content);
            }
          }
        },
        removeIdentifiers(exp) {
          {
            if (shared.isString(exp)) {
              removeId(exp);
            } else if (exp.identifiers) {
              exp.identifiers.forEach(removeId);
            } else if (exp.type === 4) {
              removeId(exp.content);
            }
          }
        },
        hoist(exp) {
          if (shared.isString(exp))
            exp = createSimpleExpression(exp);
          context.hoists.push(exp);
          const identifier = createSimpleExpression(
            `_hoisted_${context.hoists.length}`,
            false,
            exp.loc,
            2
          );
          identifier.hoisted = exp;
          return identifier;
        },
        cache(exp, isVNode = false) {
          return createCacheExpression(context.cached++, exp, isVNode);
        }
      };
      {
        context.filters = /* @__PURE__ */ new Set();
      }
      function addId(id) {
        const { identifiers } = context;
        if (identifiers[id] === void 0) {
          identifiers[id] = 0;
        }
        identifiers[id]++;
      }
      function removeId(id) {
        context.identifiers[id]--;
      }
      return context;
    }
    function transform(root, options) {
      const context = createTransformContext(root, options);
      traverseNode(root, context);
      if (options.hoistStatic) {
        hoistStatic(root, context);
      }
      if (!options.ssr) {
        createRootCodegen(root, context);
      }
      root.helpers = /* @__PURE__ */ new Set([...context.helpers.keys()]);
      root.components = [...context.components];
      root.directives = [...context.directives];
      root.imports = context.imports;
      root.hoists = context.hoists;
      root.temps = context.temps;
      root.cached = context.cached;
      root.transformed = true;
      {
        root.filters = [...context.filters];
      }
    }
    function createRootCodegen(root, context) {
      const { helper } = context;
      const { children } = root;
      if (children.length === 1) {
        const child = children[0];
        if (isSingleElementRoot(root, child) && child.codegenNode) {
          const codegenNode = child.codegenNode;
          if (codegenNode.type === 13) {
            convertToBlock(codegenNode, context);
          }
          root.codegenNode = codegenNode;
        } else {
          root.codegenNode = child;
        }
      } else if (children.length > 1) {
        let patchFlag = 64;
        let patchFlagText = shared.PatchFlagNames[64];
        if (children.filter((c) => c.type !== 3).length === 1) {
          patchFlag |= 2048;
          patchFlagText += `, ${shared.PatchFlagNames[2048]}`;
        }
        root.codegenNode = createVNodeCall(
          context,
          helper(FRAGMENT),
          void 0,
          root.children,
          patchFlag + ` /* ${patchFlagText} */`,
          void 0,
          void 0,
          true,
          void 0,
          false
        );
      } else
        ;
    }
    function traverseChildren(parent, context) {
      let i = 0;
      const nodeRemoved = () => {
        i--;
      };
      for (; i < parent.children.length; i++) {
        const child = parent.children[i];
        if (shared.isString(child))
          continue;
        context.grandParent = context.parent;
        context.parent = parent;
        context.childIndex = i;
        context.onNodeRemoved = nodeRemoved;
        traverseNode(child, context);
      }
    }
    function traverseNode(node, context) {
      context.currentNode = node;
      const { nodeTransforms } = context;
      const exitFns = [];
      for (let i2 = 0; i2 < nodeTransforms.length; i2++) {
        const onExit = nodeTransforms[i2](node, context);
        if (onExit) {
          if (shared.isArray(onExit)) {
            exitFns.push(...onExit);
          } else {
            exitFns.push(onExit);
          }
        }
        if (!context.currentNode) {
          return;
        } else {
          node = context.currentNode;
        }
      }
      switch (node.type) {
        case 3:
          if (!context.ssr) {
            context.helper(CREATE_COMMENT);
          }
          break;
        case 5:
          if (!context.ssr) {
            context.helper(TO_DISPLAY_STRING);
          }
          break;
        case 9:
          for (let i2 = 0; i2 < node.branches.length; i2++) {
            traverseNode(node.branches[i2], context);
          }
          break;
        case 10:
        case 11:
        case 1:
        case 0:
          traverseChildren(node, context);
          break;
      }
      context.currentNode = node;
      let i = exitFns.length;
      while (i--) {
        exitFns[i]();
      }
    }
    function createStructuralDirectiveTransform(name, fn) {
      const matches = shared.isString(name) ? (n) => n === name : (n) => name.test(n);
      return (node, context) => {
        if (node.type === 1) {
          const { props } = node;
          if (node.tagType === 3 && props.some(isVSlot)) {
            return;
          }
          const exitFns = [];
          for (let i = 0; i < props.length; i++) {
            const prop = props[i];
            if (prop.type === 7 && matches(prop.name)) {
              props.splice(i, 1);
              i--;
              const onExit = fn(node, prop, context);
              if (onExit)
                exitFns.push(onExit);
            }
          }
          return exitFns;
        }
      };
    }
    var PURE_ANNOTATION = `/*#__PURE__*/`;
    var aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;
    function createCodegenContext(ast, {
      mode = "function",
      prefixIdentifiers = mode === "module",
      sourceMap = false,
      filename = `template.vue.html`,
      scopeId = null,
      optimizeImports = false,
      runtimeGlobalName = `Vue`,
      runtimeModuleName = `vue`,
      ssrRuntimeModuleName = "vue/server-renderer",
      ssr = false,
      isTS = false,
      inSSR = false
    }) {
      const context = {
        mode,
        prefixIdentifiers,
        sourceMap,
        filename,
        scopeId,
        optimizeImports,
        runtimeGlobalName,
        runtimeModuleName,
        ssrRuntimeModuleName,
        ssr,
        isTS,
        inSSR,
        source: ast.source,
        code: ``,
        column: 1,
        line: 1,
        offset: 0,
        indentLevel: 0,
        pure: false,
        map: void 0,
        helper(key) {
          return `_${helperNameMap[key]}`;
        },
        push(code, newlineIndex = -2, node) {
          context.code += code;
          if (context.map) {
            if (node) {
              let name;
              if (node.type === 4 && !node.isStatic) {
                const content = node.content.replace(/^_ctx\./, "");
                if (content !== node.content && isSimpleIdentifier(content)) {
                  name = content;
                }
              }
              addMapping(node.loc.start, name);
            }
            if (newlineIndex === -3) {
              advancePositionWithMutation(context, code);
            } else {
              context.offset += code.length;
              if (newlineIndex === -2) {
                context.column += code.length;
              } else {
                if (newlineIndex === -1) {
                  newlineIndex = code.length - 1;
                }
                context.line++;
                context.column = code.length - newlineIndex;
              }
            }
            if (node && node.loc !== locStub) {
              addMapping(node.loc.end);
            }
          }
        },
        indent() {
          newline(++context.indentLevel);
        },
        deindent(withoutNewLine = false) {
          if (withoutNewLine) {
            --context.indentLevel;
          } else {
            newline(--context.indentLevel);
          }
        },
        newline() {
          newline(context.indentLevel);
        }
      };
      function newline(n) {
        context.push("\n" + `  `.repeat(n), 0);
      }
      function addMapping(loc, name = null) {
        const { _names, _mappings } = context.map;
        if (name !== null && !_names.has(name))
          _names.add(name);
        _mappings.add({
          originalLine: loc.line,
          originalColumn: loc.column - 1,
          generatedLine: context.line,
          generatedColumn: context.column - 1,
          source: filename,
          name
        });
      }
      if (sourceMap) {
        context.map = new sourceMapJs.SourceMapGenerator();
        context.map.setSourceContent(filename, context.source);
        context.map._sources.add(filename);
      }
      return context;
    }
    function generate(ast, options = {}) {
      const context = createCodegenContext(ast, options);
      if (options.onContextCreated)
        options.onContextCreated(context);
      const {
        mode,
        push,
        prefixIdentifiers,
        indent,
        deindent,
        newline,
        scopeId,
        ssr
      } = context;
      const helpers = Array.from(ast.helpers);
      const hasHelpers = helpers.length > 0;
      const useWithBlock = !prefixIdentifiers && mode !== "module";
      const genScopeId = scopeId != null && mode === "module";
      const isSetupInlined = !!options.inline;
      const preambleContext = isSetupInlined ? createCodegenContext(ast, options) : context;
      if (mode === "module") {
        genModulePreamble(ast, preambleContext, genScopeId, isSetupInlined);
      } else {
        genFunctionPreamble(ast, preambleContext);
      }
      const functionName = ssr ? `ssrRender` : `render`;
      const args = ssr ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
      if (options.bindingMetadata && !options.inline) {
        args.push("$props", "$setup", "$data", "$options");
      }
      const signature = options.isTS ? args.map((arg) => `${arg}: any`).join(",") : args.join(", ");
      if (isSetupInlined) {
        push(`(${signature}) => {`);
      } else {
        push(`function ${functionName}(${signature}) {`);
      }
      indent();
      if (useWithBlock) {
        push(`with (_ctx) {`);
        indent();
        if (hasHelpers) {
          push(
            `const { ${helpers.map(aliasHelper).join(", ")} } = _Vue
`,
            -1
          );
          newline();
        }
      }
      if (ast.components.length) {
        genAssets(ast.components, "component", context);
        if (ast.directives.length || ast.temps > 0) {
          newline();
        }
      }
      if (ast.directives.length) {
        genAssets(ast.directives, "directive", context);
        if (ast.temps > 0) {
          newline();
        }
      }
      if (ast.filters && ast.filters.length) {
        newline();
        genAssets(ast.filters, "filter", context);
        newline();
      }
      if (ast.temps > 0) {
        push(`let `);
        for (let i = 0; i < ast.temps; i++) {
          push(`${i > 0 ? `, ` : ``}_temp${i}`);
        }
      }
      if (ast.components.length || ast.directives.length || ast.temps) {
        push(`
`, 0);
        newline();
      }
      if (!ssr) {
        push(`return `);
      }
      if (ast.codegenNode) {
        genNode(ast.codegenNode, context);
      } else {
        push(`null`);
      }
      if (useWithBlock) {
        deindent();
        push(`}`);
      }
      deindent();
      push(`}`);
      return {
        ast,
        code: context.code,
        preamble: isSetupInlined ? preambleContext.code : ``,
        map: context.map ? context.map.toJSON() : void 0
      };
    }
    function genFunctionPreamble(ast, context) {
      const {
        ssr,
        prefixIdentifiers,
        push,
        newline,
        runtimeModuleName,
        runtimeGlobalName,
        ssrRuntimeModuleName
      } = context;
      const VueBinding = ssr ? `require(${JSON.stringify(runtimeModuleName)})` : runtimeGlobalName;
      const helpers = Array.from(ast.helpers);
      if (helpers.length > 0) {
        if (prefixIdentifiers) {
          push(
            `const { ${helpers.map(aliasHelper).join(", ")} } = ${VueBinding}
`,
            -1
          );
        } else {
          push(`const _Vue = ${VueBinding}
`, -1);
          if (ast.hoists.length) {
            const staticHelpers = [
              CREATE_VNODE,
              CREATE_ELEMENT_VNODE,
              CREATE_COMMENT,
              CREATE_TEXT,
              CREATE_STATIC
            ].filter((helper) => helpers.includes(helper)).map(aliasHelper).join(", ");
            push(`const { ${staticHelpers} } = _Vue
`, -1);
          }
        }
      }
      if (ast.ssrHelpers && ast.ssrHelpers.length) {
        push(
          `const { ${ast.ssrHelpers.map(aliasHelper).join(", ")} } = require("${ssrRuntimeModuleName}")
`,
          -1
        );
      }
      genHoists(ast.hoists, context);
      newline();
      push(`return `);
    }
    function genModulePreamble(ast, context, genScopeId, inline) {
      const {
        push,
        newline,
        optimizeImports,
        runtimeModuleName,
        ssrRuntimeModuleName
      } = context;
      if (genScopeId && ast.hoists.length) {
        ast.helpers.add(PUSH_SCOPE_ID);
        ast.helpers.add(POP_SCOPE_ID);
      }
      if (ast.helpers.size) {
        const helpers = Array.from(ast.helpers);
        if (optimizeImports) {
          push(
            `import { ${helpers.map((s) => helperNameMap[s]).join(", ")} } from ${JSON.stringify(runtimeModuleName)}
`,
            -1
          );
          push(
            `
// Binding optimization for webpack code-split
const ${helpers.map((s) => `_${helperNameMap[s]} = ${helperNameMap[s]}`).join(", ")}
`,
            -1
          );
        } else {
          push(
            `import { ${helpers.map((s) => `${helperNameMap[s]} as _${helperNameMap[s]}`).join(", ")} } from ${JSON.stringify(runtimeModuleName)}
`,
            -1
          );
        }
      }
      if (ast.ssrHelpers && ast.ssrHelpers.length) {
        push(
          `import { ${ast.ssrHelpers.map((s) => `${helperNameMap[s]} as _${helperNameMap[s]}`).join(", ")} } from "${ssrRuntimeModuleName}"
`,
          -1
        );
      }
      if (ast.imports.length) {
        genImports(ast.imports, context);
        newline();
      }
      genHoists(ast.hoists, context);
      newline();
      if (!inline) {
        push(`export `);
      }
    }
    function genAssets(assets, type, { helper, push, newline, isTS }) {
      const resolver = helper(
        type === "filter" ? RESOLVE_FILTER : type === "component" ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE
      );
      for (let i = 0; i < assets.length; i++) {
        let id = assets[i];
        const maybeSelfReference = id.endsWith("__self");
        if (maybeSelfReference) {
          id = id.slice(0, -6);
        }
        push(
          `const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`
        );
        if (i < assets.length - 1) {
          newline();
        }
      }
    }
    function genHoists(hoists, context) {
      if (!hoists.length) {
        return;
      }
      context.pure = true;
      const { push, newline, helper, scopeId, mode } = context;
      const genScopeId = scopeId != null && mode !== "function";
      newline();
      if (genScopeId) {
        const param = context.isTS ? "(n: any)" : "n";
        push(
          `const _withScopeId = ${param} => (${helper(
            PUSH_SCOPE_ID
          )}("${scopeId}"),n=n(),${helper(POP_SCOPE_ID)}(),n)`
        );
        newline();
      }
      for (let i = 0; i < hoists.length; i++) {
        const exp = hoists[i];
        if (exp) {
          const needScopeIdWrapper = genScopeId && exp.type === 13;
          push(
            `const _hoisted_${i + 1} = ${needScopeIdWrapper ? `${PURE_ANNOTATION} _withScopeId(() => ` : ``}`
          );
          genNode(exp, context);
          if (needScopeIdWrapper) {
            push(`)`);
          }
          newline();
        }
      }
      context.pure = false;
    }
    function genImports(importsOptions, context) {
      if (!importsOptions.length) {
        return;
      }
      importsOptions.forEach((imports) => {
        context.push(`import `);
        genNode(imports.exp, context);
        context.push(` from '${imports.path}'`);
        context.newline();
      });
    }
    function isText(n) {
      return shared.isString(n) || n.type === 4 || n.type === 2 || n.type === 5 || n.type === 8;
    }
    function genNodeListAsArray(nodes, context) {
      const multilines = nodes.length > 3 || nodes.some((n) => shared.isArray(n) || !isText(n));
      context.push(`[`);
      multilines && context.indent();
      genNodeList(nodes, context, multilines);
      multilines && context.deindent();
      context.push(`]`);
    }
    function genNodeList(nodes, context, multilines = false, comma = true) {
      const { push, newline } = context;
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (shared.isString(node)) {
          push(node, -3);
        } else if (shared.isArray(node)) {
          genNodeListAsArray(node, context);
        } else {
          genNode(node, context);
        }
        if (i < nodes.length - 1) {
          if (multilines) {
            comma && push(",");
            newline();
          } else {
            comma && push(", ");
          }
        }
      }
    }
    function genNode(node, context) {
      if (shared.isString(node)) {
        context.push(node, -3);
        return;
      }
      if (shared.isSymbol(node)) {
        context.push(context.helper(node));
        return;
      }
      switch (node.type) {
        case 1:
        case 9:
        case 11:
          assert(
            node.codegenNode != null,
            `Codegen node is missing for element/if/for node. Apply appropriate transforms first.`
          );
          genNode(node.codegenNode, context);
          break;
        case 2:
          genText(node, context);
          break;
        case 4:
          genExpression(node, context);
          break;
        case 5:
          genInterpolation(node, context);
          break;
        case 12:
          genNode(node.codegenNode, context);
          break;
        case 8:
          genCompoundExpression(node, context);
          break;
        case 3:
          genComment(node, context);
          break;
        case 13:
          genVNodeCall(node, context);
          break;
        case 14:
          genCallExpression(node, context);
          break;
        case 15:
          genObjectExpression(node, context);
          break;
        case 17:
          genArrayExpression(node, context);
          break;
        case 18:
          genFunctionExpression(node, context);
          break;
        case 19:
          genConditionalExpression(node, context);
          break;
        case 20:
          genCacheExpression(node, context);
          break;
        case 21:
          genNodeList(node.body, context, true, false);
          break;
        case 22:
          genTemplateLiteral(node, context);
          break;
        case 23:
          genIfStatement(node, context);
          break;
        case 24:
          genAssignmentExpression(node, context);
          break;
        case 25:
          genSequenceExpression(node, context);
          break;
        case 26:
          genReturnStatement(node, context);
          break;
        case 10:
          break;
        default: {
          assert(false, `unhandled codegen node type: ${node.type}`);
          const exhaustiveCheck = node;
          return exhaustiveCheck;
        }
      }
    }
    function genText(node, context) {
      context.push(JSON.stringify(node.content), -3, node);
    }
    function genExpression(node, context) {
      const { content, isStatic } = node;
      context.push(
        isStatic ? JSON.stringify(content) : content,
        -3,
        node
      );
    }
    function genInterpolation(node, context) {
      const { push, helper, pure } = context;
      if (pure)
        push(PURE_ANNOTATION);
      push(`${helper(TO_DISPLAY_STRING)}(`);
      genNode(node.content, context);
      push(`)`);
    }
    function genCompoundExpression(node, context) {
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if (shared.isString(child)) {
          context.push(child, -3);
        } else {
          genNode(child, context);
        }
      }
    }
    function genExpressionAsPropertyKey(node, context) {
      const { push } = context;
      if (node.type === 8) {
        push(`[`);
        genCompoundExpression(node, context);
        push(`]`);
      } else if (node.isStatic) {
        const text = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content);
        push(text, -2, node);
      } else {
        push(`[${node.content}]`, -3, node);
      }
    }
    function genComment(node, context) {
      const { push, helper, pure } = context;
      if (pure) {
        push(PURE_ANNOTATION);
      }
      push(
        `${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`,
        -3,
        node
      );
    }
    function genVNodeCall(node, context) {
      const { push, helper, pure } = context;
      const {
        tag,
        props,
        children,
        patchFlag,
        dynamicProps,
        directives,
        isBlock,
        disableTracking,
        isComponent: isComponent2
      } = node;
      if (directives) {
        push(helper(WITH_DIRECTIVES) + `(`);
      }
      if (isBlock) {
        push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
      }
      if (pure) {
        push(PURE_ANNOTATION);
      }
      const callHelper = isBlock ? getVNodeBlockHelper(context.inSSR, isComponent2) : getVNodeHelper(context.inSSR, isComponent2);
      push(helper(callHelper) + `(`, -2, node);
      genNodeList(
        genNullableArgs([tag, props, children, patchFlag, dynamicProps]),
        context
      );
      push(`)`);
      if (isBlock) {
        push(`)`);
      }
      if (directives) {
        push(`, `);
        genNode(directives, context);
        push(`)`);
      }
    }
    function genNullableArgs(args) {
      let i = args.length;
      while (i--) {
        if (args[i] != null)
          break;
      }
      return args.slice(0, i + 1).map((arg) => arg || `null`);
    }
    function genCallExpression(node, context) {
      const { push, helper, pure } = context;
      const callee = shared.isString(node.callee) ? node.callee : helper(node.callee);
      if (pure) {
        push(PURE_ANNOTATION);
      }
      push(callee + `(`, -2, node);
      genNodeList(node.arguments, context);
      push(`)`);
    }
    function genObjectExpression(node, context) {
      const { push, indent, deindent, newline } = context;
      const { properties } = node;
      if (!properties.length) {
        push(`{}`, -2, node);
        return;
      }
      const multilines = properties.length > 1 || properties.some((p) => p.value.type !== 4);
      push(multilines ? `{` : `{ `);
      multilines && indent();
      for (let i = 0; i < properties.length; i++) {
        const { key, value } = properties[i];
        genExpressionAsPropertyKey(key, context);
        push(`: `);
        genNode(value, context);
        if (i < properties.length - 1) {
          push(`,`);
          newline();
        }
      }
      multilines && deindent();
      push(multilines ? `}` : ` }`);
    }
    function genArrayExpression(node, context) {
      genNodeListAsArray(node.elements, context);
    }
    function genFunctionExpression(node, context) {
      const { push, indent, deindent } = context;
      const { params, returns, body, newline, isSlot } = node;
      if (isSlot) {
        push(`_${helperNameMap[WITH_CTX]}(`);
      }
      push(`(`, -2, node);
      if (shared.isArray(params)) {
        genNodeList(params, context);
      } else if (params) {
        genNode(params, context);
      }
      push(`) => `);
      if (newline || body) {
        push(`{`);
        indent();
      }
      if (returns) {
        if (newline) {
          push(`return `);
        }
        if (shared.isArray(returns)) {
          genNodeListAsArray(returns, context);
        } else {
          genNode(returns, context);
        }
      } else if (body) {
        genNode(body, context);
      }
      if (newline || body) {
        deindent();
        push(`}`);
      }
      if (isSlot) {
        if (node.isNonScopedSlot) {
          push(`, undefined, true`);
        }
        push(`)`);
      }
    }
    function genConditionalExpression(node, context) {
      const { test, consequent, alternate, newline: needNewline } = node;
      const { push, indent, deindent, newline } = context;
      if (test.type === 4) {
        const needsParens = !isSimpleIdentifier(test.content);
        needsParens && push(`(`);
        genExpression(test, context);
        needsParens && push(`)`);
      } else {
        push(`(`);
        genNode(test, context);
        push(`)`);
      }
      needNewline && indent();
      context.indentLevel++;
      needNewline || push(` `);
      push(`? `);
      genNode(consequent, context);
      context.indentLevel--;
      needNewline && newline();
      needNewline || push(` `);
      push(`: `);
      const isNested = alternate.type === 19;
      if (!isNested) {
        context.indentLevel++;
      }
      genNode(alternate, context);
      if (!isNested) {
        context.indentLevel--;
      }
      needNewline && deindent(
        true
      );
    }
    function genCacheExpression(node, context) {
      const { push, helper, indent, deindent, newline } = context;
      push(`_cache[${node.index}] || (`);
      if (node.isVNode) {
        indent();
        push(`${helper(SET_BLOCK_TRACKING)}(-1),`);
        newline();
      }
      push(`_cache[${node.index}] = `);
      genNode(node.value, context);
      if (node.isVNode) {
        push(`,`);
        newline();
        push(`${helper(SET_BLOCK_TRACKING)}(1),`);
        newline();
        push(`_cache[${node.index}]`);
        deindent();
      }
      push(`)`);
    }
    function genTemplateLiteral(node, context) {
      const { push, indent, deindent } = context;
      push("`");
      const l = node.elements.length;
      const multilines = l > 3;
      for (let i = 0; i < l; i++) {
        const e = node.elements[i];
        if (shared.isString(e)) {
          push(e.replace(/(`|\$|\\)/g, "\\$1"), -3);
        } else {
          push("${");
          if (multilines)
            indent();
          genNode(e, context);
          if (multilines)
            deindent();
          push("}");
        }
      }
      push("`");
    }
    function genIfStatement(node, context) {
      const { push, indent, deindent } = context;
      const { test, consequent, alternate } = node;
      push(`if (`);
      genNode(test, context);
      push(`) {`);
      indent();
      genNode(consequent, context);
      deindent();
      push(`}`);
      if (alternate) {
        push(` else `);
        if (alternate.type === 23) {
          genIfStatement(alternate, context);
        } else {
          push(`{`);
          indent();
          genNode(alternate, context);
          deindent();
          push(`}`);
        }
      }
    }
    function genAssignmentExpression(node, context) {
      genNode(node.left, context);
      context.push(` = `);
      genNode(node.right, context);
    }
    function genSequenceExpression(node, context) {
      context.push(`(`);
      genNodeList(node.expressions, context);
      context.push(`)`);
    }
    function genReturnStatement({ returns }, context) {
      context.push(`return `);
      if (shared.isArray(returns)) {
        genNodeListAsArray(returns, context);
      } else {
        genNode(returns, context);
      }
    }
    var isLiteralWhitelisted = shared.makeMap("true,false,null,this");
    var transformExpression = (node, context) => {
      if (node.type === 5) {
        node.content = processExpression(
          node.content,
          context
        );
      } else if (node.type === 1) {
        for (let i = 0; i < node.props.length; i++) {
          const dir = node.props[i];
          if (dir.type === 7 && dir.name !== "for") {
            const exp = dir.exp;
            const arg = dir.arg;
            if (exp && exp.type === 4 && !(dir.name === "on" && arg)) {
              dir.exp = processExpression(
                exp,
                context,
                dir.name === "slot"
              );
            }
            if (arg && arg.type === 4 && !arg.isStatic) {
              dir.arg = processExpression(arg, context);
            }
          }
        }
      }
    };
    function processExpression(node, context, asParams = false, asRawStatements = false, localVars = Object.create(context.identifiers)) {
      if (!context.prefixIdentifiers || !node.content.trim()) {
        return node;
      }
      const { inline, bindingMetadata } = context;
      const rewriteIdentifier = (raw, parent, id) => {
        const type = shared.hasOwn(bindingMetadata, raw) && bindingMetadata[raw];
        if (inline) {
          const isAssignmentLVal = parent && parent.type === "AssignmentExpression" && parent.left === id;
          const isUpdateArg = parent && parent.type === "UpdateExpression" && parent.argument === id;
          const isDestructureAssignment = parent && isInDestructureAssignment(parent, parentStack);
          const isNewExpression = parent && isInNewExpression(parentStack);
          const wrapWithUnref = (raw2) => {
            const wrapped = `${context.helperString(UNREF)}(${raw2})`;
            return isNewExpression ? `(${wrapped})` : wrapped;
          };
          if (isConst(type) || type === "setup-reactive-const" || localVars[raw]) {
            return raw;
          } else if (type === "setup-ref") {
            return `${raw}.value`;
          } else if (type === "setup-maybe-ref") {
            return isAssignmentLVal || isUpdateArg || isDestructureAssignment ? `${raw}.value` : wrapWithUnref(raw);
          } else if (type === "setup-let") {
            if (isAssignmentLVal) {
              const { right: rVal, operator } = parent;
              const rExp = rawExp.slice(rVal.start - 1, rVal.end - 1);
              const rExpString = stringifyExpression(
                processExpression(
                  createSimpleExpression(rExp, false),
                  context,
                  false,
                  false,
                  knownIds
                )
              );
              return `${context.helperString(IS_REF)}(${raw})${context.isTS ? ` //@ts-ignore
` : ``} ? ${raw}.value ${operator} ${rExpString} : ${raw}`;
            } else if (isUpdateArg) {
              id.start = parent.start;
              id.end = parent.end;
              const { prefix: isPrefix, operator } = parent;
              const prefix = isPrefix ? operator : ``;
              const postfix = isPrefix ? `` : operator;
              return `${context.helperString(IS_REF)}(${raw})${context.isTS ? ` //@ts-ignore
` : ``} ? ${prefix}${raw}.value${postfix} : ${prefix}${raw}${postfix}`;
            } else if (isDestructureAssignment) {
              return raw;
            } else {
              return wrapWithUnref(raw);
            }
          } else if (type === "props") {
            return shared.genPropsAccessExp(raw);
          } else if (type === "props-aliased") {
            return shared.genPropsAccessExp(bindingMetadata.__propsAliases[raw]);
          }
        } else {
          if (type && type.startsWith("setup") || type === "literal-const") {
            return `$setup.${raw}`;
          } else if (type === "props-aliased") {
            return `$props['${bindingMetadata.__propsAliases[raw]}']`;
          } else if (type) {
            return `$${type}.${raw}`;
          }
        }
        return `_ctx.${raw}`;
      };
      const rawExp = node.content;
      let ast = node.ast;
      if (ast === false) {
        return node;
      }
      if (ast === null || !ast && isSimpleIdentifier(rawExp)) {
        const isScopeVarReference = context.identifiers[rawExp];
        const isAllowedGlobal = shared.isGloballyAllowed(rawExp);
        const isLiteral = isLiteralWhitelisted(rawExp);
        if (!asParams && !isScopeVarReference && !isLiteral && (!isAllowedGlobal || bindingMetadata[rawExp])) {
          if (isConst(bindingMetadata[rawExp])) {
            node.constType = 1;
          }
          node.content = rewriteIdentifier(rawExp);
        } else if (!isScopeVarReference) {
          if (isLiteral) {
            node.constType = 3;
          } else {
            node.constType = 2;
          }
        }
        return node;
      }
      if (!ast) {
        const source = asRawStatements ? ` ${rawExp} ` : `(${rawExp})${asParams ? `=>{}` : ``}`;
        try {
          ast = parser.parseExpression(source, {
            sourceType: "module",
            plugins: context.expressionPlugins
          });
        } catch (e) {
          context.onError(
            createCompilerError(
              45,
              node.loc,
              void 0,
              e.message
            )
          );
          return node;
        }
      }
      const ids = [];
      const parentStack = [];
      const knownIds = Object.create(context.identifiers);
      walkIdentifiers(
        ast,
        (node2, parent, _, isReferenced2, isLocal) => {
          if (isStaticPropertyKey(node2, parent)) {
            return;
          }
          if (node2.name.startsWith("_filter_")) {
            return;
          }
          const needPrefix = isReferenced2 && canPrefix(node2);
          if (needPrefix && !isLocal) {
            if (isStaticProperty(parent) && parent.shorthand) {
              node2.prefix = `${node2.name}: `;
            }
            node2.name = rewriteIdentifier(node2.name, parent, node2);
            ids.push(node2);
          } else {
            if (!(needPrefix && isLocal) && parent.type !== "CallExpression" && parent.type !== "NewExpression" && parent.type !== "MemberExpression") {
              node2.isConstant = true;
            }
            ids.push(node2);
          }
        },
        true,
        parentStack,
        knownIds
      );
      const children = [];
      ids.sort((a, b) => a.start - b.start);
      ids.forEach((id, i) => {
        const start = id.start - 1;
        const end = id.end - 1;
        const last = ids[i - 1];
        const leadingText = rawExp.slice(last ? last.end - 1 : 0, start);
        if (leadingText.length || id.prefix) {
          children.push(leadingText + (id.prefix || ``));
        }
        const source = rawExp.slice(start, end);
        children.push(
          createSimpleExpression(
            id.name,
            false,
            {
              start: advancePositionWithClone(node.loc.start, source, start),
              end: advancePositionWithClone(node.loc.start, source, end),
              source
            },
            id.isConstant ? 3 : 0
          )
        );
        if (i === ids.length - 1 && end < rawExp.length) {
          children.push(rawExp.slice(end));
        }
      });
      let ret;
      if (children.length) {
        ret = createCompoundExpression(children, node.loc);
        ret.ast = ast;
      } else {
        ret = node;
        ret.constType = 3;
      }
      ret.identifiers = Object.keys(knownIds);
      return ret;
    }
    function canPrefix(id) {
      if (shared.isGloballyAllowed(id.name)) {
        return false;
      }
      if (id.name === "require") {
        return false;
      }
      return true;
    }
    function stringifyExpression(exp) {
      if (shared.isString(exp)) {
        return exp;
      } else if (exp.type === 4) {
        return exp.content;
      } else {
        return exp.children.map(stringifyExpression).join("");
      }
    }
    function isConst(type) {
      return type === "setup-const" || type === "literal-const";
    }
    var transformIf = createStructuralDirectiveTransform(
      /^(if|else|else-if)$/,
      (node, dir, context) => {
        return processIf(node, dir, context, (ifNode, branch, isRoot) => {
          const siblings = context.parent.children;
          let i = siblings.indexOf(ifNode);
          let key = 0;
          while (i-- >= 0) {
            const sibling = siblings[i];
            if (sibling && sibling.type === 9) {
              key += sibling.branches.length;
            }
          }
          return () => {
            if (isRoot) {
              ifNode.codegenNode = createCodegenNodeForBranch(
                branch,
                key,
                context
              );
            } else {
              const parentCondition = getParentCondition(ifNode.codegenNode);
              parentCondition.alternate = createCodegenNodeForBranch(
                branch,
                key + ifNode.branches.length - 1,
                context
              );
            }
          };
        });
      }
    );
    function processIf(node, dir, context, processCodegen) {
      if (dir.name !== "else" && (!dir.exp || !dir.exp.content.trim())) {
        const loc = dir.exp ? dir.exp.loc : node.loc;
        context.onError(
          createCompilerError(28, dir.loc)
        );
        dir.exp = createSimpleExpression(`true`, false, loc);
      }
      if (context.prefixIdentifiers && dir.exp) {
        dir.exp = processExpression(dir.exp, context);
      }
      if (dir.name === "if") {
        const branch = createIfBranch(node, dir);
        const ifNode = {
          type: 9,
          loc: node.loc,
          branches: [branch]
        };
        context.replaceNode(ifNode);
        if (processCodegen) {
          return processCodegen(ifNode, branch, true);
        }
      } else {
        const siblings = context.parent.children;
        const comments = [];
        let i = siblings.indexOf(node);
        while (i-- >= -1) {
          const sibling = siblings[i];
          if (sibling && sibling.type === 3) {
            context.removeNode(sibling);
            comments.unshift(sibling);
            continue;
          }
          if (sibling && sibling.type === 2 && !sibling.content.trim().length) {
            context.removeNode(sibling);
            continue;
          }
          if (sibling && sibling.type === 9) {
            if (dir.name === "else-if" && sibling.branches[sibling.branches.length - 1].condition === void 0) {
              context.onError(
                createCompilerError(30, node.loc)
              );
            }
            context.removeNode();
            const branch = createIfBranch(node, dir);
            if (comments.length && !(context.parent && context.parent.type === 1 && (context.parent.tag === "transition" || context.parent.tag === "Transition"))) {
              branch.children = [...comments, ...branch.children];
            }
            {
              const key = branch.userKey;
              if (key) {
                sibling.branches.forEach(({ userKey }) => {
                  if (isSameKey(userKey, key)) {
                    context.onError(
                      createCompilerError(
                        29,
                        branch.userKey.loc
                      )
                    );
                  }
                });
              }
            }
            sibling.branches.push(branch);
            const onExit = processCodegen && processCodegen(sibling, branch, false);
            traverseNode(branch, context);
            if (onExit)
              onExit();
            context.currentNode = null;
          } else {
            context.onError(
              createCompilerError(30, node.loc)
            );
          }
          break;
        }
      }
    }
    function createIfBranch(node, dir) {
      const isTemplateIf = node.tagType === 3;
      return {
        type: 10,
        loc: node.loc,
        condition: dir.name === "else" ? void 0 : dir.exp,
        children: isTemplateIf && !findDir(node, "for") ? node.children : [node],
        userKey: findProp(node, `key`),
        isTemplateIf
      };
    }
    function createCodegenNodeForBranch(branch, keyIndex, context) {
      if (branch.condition) {
        return createConditionalExpression(
          branch.condition,
          createChildrenCodegenNode(branch, keyIndex, context),
          createCallExpression(context.helper(CREATE_COMMENT), [
            '"v-if"',
            "true"
          ])
        );
      } else {
        return createChildrenCodegenNode(branch, keyIndex, context);
      }
    }
    function createChildrenCodegenNode(branch, keyIndex, context) {
      const { helper } = context;
      const keyProperty = createObjectProperty(
        `key`,
        createSimpleExpression(
          `${keyIndex}`,
          false,
          locStub,
          2
        )
      );
      const { children } = branch;
      const firstChild = children[0];
      const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1;
      if (needFragmentWrapper) {
        if (children.length === 1 && firstChild.type === 11) {
          const vnodeCall = firstChild.codegenNode;
          injectProp(vnodeCall, keyProperty, context);
          return vnodeCall;
        } else {
          let patchFlag = 64;
          let patchFlagText = shared.PatchFlagNames[64];
          if (!branch.isTemplateIf && children.filter((c) => c.type !== 3).length === 1) {
            patchFlag |= 2048;
            patchFlagText += `, ${shared.PatchFlagNames[2048]}`;
          }
          return createVNodeCall(
            context,
            helper(FRAGMENT),
            createObjectExpression([keyProperty]),
            children,
            patchFlag + ` /* ${patchFlagText} */`,
            void 0,
            void 0,
            true,
            false,
            false,
            branch.loc
          );
        }
      } else {
        const ret = firstChild.codegenNode;
        const vnodeCall = getMemoedVNodeCall(ret);
        if (vnodeCall.type === 13) {
          convertToBlock(vnodeCall, context);
        }
        injectProp(vnodeCall, keyProperty, context);
        return ret;
      }
    }
    function isSameKey(a, b) {
      if (!a || a.type !== b.type) {
        return false;
      }
      if (a.type === 6) {
        if (a.value.content !== b.value.content) {
          return false;
        }
      } else {
        const exp = a.exp;
        const branchExp = b.exp;
        if (exp.type !== branchExp.type) {
          return false;
        }
        if (exp.type !== 4 || exp.isStatic !== branchExp.isStatic || exp.content !== branchExp.content) {
          return false;
        }
      }
      return true;
    }
    function getParentCondition(node) {
      while (true) {
        if (node.type === 19) {
          if (node.alternate.type === 19) {
            node = node.alternate;
          } else {
            return node;
          }
        } else if (node.type === 20) {
          node = node.value;
        }
      }
    }
    var transformBind = (dir, _node, context) => {
      const { modifiers, loc } = dir;
      const arg = dir.arg;
      let { exp } = dir;
      if (exp && exp.type === 4 && !exp.content.trim()) {
        {
          context.onError(
            createCompilerError(34, loc)
          );
          return {
            props: [
              createObjectProperty(arg, createSimpleExpression("", true, loc))
            ]
          };
        }
      }
      if (!exp) {
        if (arg.type !== 4 || !arg.isStatic) {
          context.onError(
            createCompilerError(
              52,
              arg.loc
            )
          );
          return {
            props: [
              createObjectProperty(arg, createSimpleExpression("", true, loc))
            ]
          };
        }
        transformBindShorthand(dir, context);
        exp = dir.exp;
      }
      if (arg.type !== 4) {
        arg.children.unshift(`(`);
        arg.children.push(`) || ""`);
      } else if (!arg.isStatic) {
        arg.content = `${arg.content} || ""`;
      }
      if (modifiers.includes("camel")) {
        if (arg.type === 4) {
          if (arg.isStatic) {
            arg.content = shared.camelize(arg.content);
          } else {
            arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
          }
        } else {
          arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
          arg.children.push(`)`);
        }
      }
      if (!context.inSSR) {
        if (modifiers.includes("prop")) {
          injectPrefix(arg, ".");
        }
        if (modifiers.includes("attr")) {
          injectPrefix(arg, "^");
        }
      }
      return {
        props: [createObjectProperty(arg, exp)]
      };
    };
    var transformBindShorthand = (dir, context) => {
      const arg = dir.arg;
      const propName = shared.camelize(arg.content);
      dir.exp = createSimpleExpression(propName, false, arg.loc);
      {
        dir.exp = processExpression(dir.exp, context);
      }
    };
    var injectPrefix = (arg, prefix) => {
      if (arg.type === 4) {
        if (arg.isStatic) {
          arg.content = prefix + arg.content;
        } else {
          arg.content = `\`${prefix}\${${arg.content}}\``;
        }
      } else {
        arg.children.unshift(`'${prefix}' + (`);
        arg.children.push(`)`);
      }
    };
    var transformFor = createStructuralDirectiveTransform(
      "for",
      (node, dir, context) => {
        const { helper, removeHelper } = context;
        return processFor(node, dir, context, (forNode) => {
          const renderExp = createCallExpression(helper(RENDER_LIST), [
            forNode.source
          ]);
          const isTemplate = isTemplateNode(node);
          const memo = findDir(node, "memo");
          const keyProp = findProp(node, `key`, false, true);
          if (keyProp && keyProp.type === 7 && !keyProp.exp) {
            transformBindShorthand(keyProp, context);
          }
          const keyExp = keyProp && (keyProp.type === 6 ? keyProp.value ? createSimpleExpression(keyProp.value.content, true) : void 0 : keyProp.exp);
          const keyProperty = keyProp && keyExp ? createObjectProperty(`key`, keyExp) : null;
          if (isTemplate) {
            if (memo) {
              memo.exp = processExpression(
                memo.exp,
                context
              );
            }
            if (keyProperty && keyProp.type !== 6) {
              keyProperty.value = processExpression(
                keyProperty.value,
                context
              );
            }
          }
          const isStableFragment = forNode.source.type === 4 && forNode.source.constType > 0;
          const fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;
          forNode.codegenNode = createVNodeCall(
            context,
            helper(FRAGMENT),
            void 0,
            renderExp,
            fragmentFlag + ` /* ${shared.PatchFlagNames[fragmentFlag]} */`,
            void 0,
            void 0,
            true,
            !isStableFragment,
            false,
            node.loc
          );
          return () => {
            let childBlock;
            const { children } = forNode;
            if (isTemplate) {
              node.children.some((c) => {
                if (c.type === 1) {
                  const key = findProp(c, "key");
                  if (key) {
                    context.onError(
                      createCompilerError(
                        33,
                        key.loc
                      )
                    );
                    return true;
                  }
                }
              });
            }
            const needFragmentWrapper = children.length !== 1 || children[0].type !== 1;
            const slotOutlet = isSlotOutlet(node) ? node : isTemplate && node.children.length === 1 && isSlotOutlet(node.children[0]) ? node.children[0] : null;
            if (slotOutlet) {
              childBlock = slotOutlet.codegenNode;
              if (isTemplate && keyProperty) {
                injectProp(childBlock, keyProperty, context);
              }
            } else if (needFragmentWrapper) {
              childBlock = createVNodeCall(
                context,
                helper(FRAGMENT),
                keyProperty ? createObjectExpression([keyProperty]) : void 0,
                node.children,
                64 + ` /* ${shared.PatchFlagNames[64]} */`,
                void 0,
                void 0,
                true,
                void 0,
                false
              );
            } else {
              childBlock = children[0].codegenNode;
              if (isTemplate && keyProperty) {
                injectProp(childBlock, keyProperty, context);
              }
              if (childBlock.isBlock !== !isStableFragment) {
                if (childBlock.isBlock) {
                  removeHelper(OPEN_BLOCK);
                  removeHelper(
                    getVNodeBlockHelper(context.inSSR, childBlock.isComponent)
                  );
                } else {
                  removeHelper(
                    getVNodeHelper(context.inSSR, childBlock.isComponent)
                  );
                }
              }
              childBlock.isBlock = !isStableFragment;
              if (childBlock.isBlock) {
                helper(OPEN_BLOCK);
                helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
              } else {
                helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
              }
            }
            if (memo) {
              const loop = createFunctionExpression(
                createForLoopParams(forNode.parseResult, [
                  createSimpleExpression(`_cached`)
                ])
              );
              loop.body = createBlockStatement([
                createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
                createCompoundExpression([
                  `if (_cached`,
                  ...keyExp ? [` && _cached.key === `, keyExp] : [],
                  ` && ${context.helperString(
                    IS_MEMO_SAME
                  )}(_cached, _memo)) return _cached`
                ]),
                createCompoundExpression([`const _item = `, childBlock]),
                createSimpleExpression(`_item.memo = _memo`),
                createSimpleExpression(`return _item`)
              ]);
              renderExp.arguments.push(
                loop,
                createSimpleExpression(`_cache`),
                createSimpleExpression(String(context.cached++))
              );
            } else {
              renderExp.arguments.push(
                createFunctionExpression(
                  createForLoopParams(forNode.parseResult),
                  childBlock,
                  true
                )
              );
            }
          };
        });
      }
    );
    function processFor(node, dir, context, processCodegen) {
      if (!dir.exp) {
        context.onError(
          createCompilerError(31, dir.loc)
        );
        return;
      }
      const parseResult = dir.forParseResult;
      if (!parseResult) {
        context.onError(
          createCompilerError(32, dir.loc)
        );
        return;
      }
      finalizeForParseResult(parseResult, context);
      const { addIdentifiers, removeIdentifiers, scopes } = context;
      const { source, value, key, index } = parseResult;
      const forNode = {
        type: 11,
        loc: dir.loc,
        source,
        valueAlias: value,
        keyAlias: key,
        objectIndexAlias: index,
        parseResult,
        children: isTemplateNode(node) ? node.children : [node]
      };
      context.replaceNode(forNode);
      scopes.vFor++;
      if (context.prefixIdentifiers) {
        value && addIdentifiers(value);
        key && addIdentifiers(key);
        index && addIdentifiers(index);
      }
      const onExit = processCodegen && processCodegen(forNode);
      return () => {
        scopes.vFor--;
        if (context.prefixIdentifiers) {
          value && removeIdentifiers(value);
          key && removeIdentifiers(key);
          index && removeIdentifiers(index);
        }
        if (onExit)
          onExit();
      };
    }
    function finalizeForParseResult(result, context) {
      if (result.finalized)
        return;
      if (context.prefixIdentifiers) {
        result.source = processExpression(
          result.source,
          context
        );
        if (result.key) {
          result.key = processExpression(
            result.key,
            context,
            true
          );
        }
        if (result.index) {
          result.index = processExpression(
            result.index,
            context,
            true
          );
        }
        if (result.value) {
          result.value = processExpression(
            result.value,
            context,
            true
          );
        }
      }
      result.finalized = true;
    }
    function createForLoopParams({ value, key, index }, memoArgs = []) {
      return createParamsList([value, key, index, ...memoArgs]);
    }
    function createParamsList(args) {
      let i = args.length;
      while (i--) {
        if (args[i])
          break;
      }
      return args.slice(0, i + 1).map((arg, i2) => arg || createSimpleExpression(`_`.repeat(i2 + 1), false));
    }
    var defaultFallback = createSimpleExpression(`undefined`, false);
    var trackSlotScopes = (node, context) => {
      if (node.type === 1 && (node.tagType === 1 || node.tagType === 3)) {
        const vSlot = findDir(node, "slot");
        if (vSlot) {
          const slotProps = vSlot.exp;
          if (context.prefixIdentifiers) {
            slotProps && context.addIdentifiers(slotProps);
          }
          context.scopes.vSlot++;
          return () => {
            if (context.prefixIdentifiers) {
              slotProps && context.removeIdentifiers(slotProps);
            }
            context.scopes.vSlot--;
          };
        }
      }
    };
    var trackVForSlotScopes = (node, context) => {
      let vFor;
      if (isTemplateNode(node) && node.props.some(isVSlot) && (vFor = findDir(node, "for"))) {
        const result = vFor.forParseResult;
        if (result) {
          finalizeForParseResult(result, context);
          const { value, key, index } = result;
          const { addIdentifiers, removeIdentifiers } = context;
          value && addIdentifiers(value);
          key && addIdentifiers(key);
          index && addIdentifiers(index);
          return () => {
            value && removeIdentifiers(value);
            key && removeIdentifiers(key);
            index && removeIdentifiers(index);
          };
        }
      }
    };
    var buildClientSlotFn = (props, _vForExp, children, loc) => createFunctionExpression(
      props,
      children,
      false,
      true,
      children.length ? children[0].loc : loc
    );
    function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
      context.helper(WITH_CTX);
      const { children, loc } = node;
      const slotsProperties = [];
      const dynamicSlots = [];
      let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
      if (!context.ssr && context.prefixIdentifiers) {
        hasDynamicSlots = hasScopeRef(node, context.identifiers);
      }
      const onComponentSlot = findDir(node, "slot", true);
      if (onComponentSlot) {
        const { arg, exp } = onComponentSlot;
        if (arg && !isStaticExp(arg)) {
          hasDynamicSlots = true;
        }
        slotsProperties.push(
          createObjectProperty(
            arg || createSimpleExpression("default", true),
            buildSlotFn(exp, void 0, children, loc)
          )
        );
      }
      let hasTemplateSlots = false;
      let hasNamedDefaultSlot = false;
      const implicitDefaultChildren = [];
      const seenSlotNames = /* @__PURE__ */ new Set();
      let conditionalBranchIndex = 0;
      for (let i = 0; i < children.length; i++) {
        const slotElement = children[i];
        let slotDir;
        if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, "slot", true))) {
          if (slotElement.type !== 3) {
            implicitDefaultChildren.push(slotElement);
          }
          continue;
        }
        if (onComponentSlot) {
          context.onError(
            createCompilerError(37, slotDir.loc)
          );
          break;
        }
        hasTemplateSlots = true;
        const { children: slotChildren, loc: slotLoc } = slotElement;
        const {
          arg: slotName = createSimpleExpression(`default`, true),
          exp: slotProps,
          loc: dirLoc
        } = slotDir;
        let staticSlotName;
        if (isStaticExp(slotName)) {
          staticSlotName = slotName ? slotName.content : `default`;
        } else {
          hasDynamicSlots = true;
        }
        const vFor = findDir(slotElement, "for");
        const slotFunction = buildSlotFn(slotProps, vFor, slotChildren, slotLoc);
        let vIf;
        let vElse;
        if (vIf = findDir(slotElement, "if")) {
          hasDynamicSlots = true;
          dynamicSlots.push(
            createConditionalExpression(
              vIf.exp,
              buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++),
              defaultFallback
            )
          );
        } else if (vElse = findDir(
          slotElement,
          /^else(-if)?$/,
          true
        )) {
          let j = i;
          let prev;
          while (j--) {
            prev = children[j];
            if (prev.type !== 3) {
              break;
            }
          }
          if (prev && isTemplateNode(prev) && findDir(prev, "if")) {
            children.splice(i, 1);
            i--;
            let conditional = dynamicSlots[dynamicSlots.length - 1];
            while (conditional.alternate.type === 19) {
              conditional = conditional.alternate;
            }
            conditional.alternate = vElse.exp ? createConditionalExpression(
              vElse.exp,
              buildDynamicSlot(
                slotName,
                slotFunction,
                conditionalBranchIndex++
              ),
              defaultFallback
            ) : buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++);
          } else {
            context.onError(
              createCompilerError(30, vElse.loc)
            );
          }
        } else if (vFor) {
          hasDynamicSlots = true;
          const parseResult = vFor.forParseResult;
          if (parseResult) {
            finalizeForParseResult(parseResult, context);
            dynamicSlots.push(
              createCallExpression(context.helper(RENDER_LIST), [
                parseResult.source,
                createFunctionExpression(
                  createForLoopParams(parseResult),
                  buildDynamicSlot(slotName, slotFunction),
                  true
                )
              ])
            );
          } else {
            context.onError(
              createCompilerError(
                32,
                vFor.loc
              )
            );
          }
        } else {
          if (staticSlotName) {
            if (seenSlotNames.has(staticSlotName)) {
              context.onError(
                createCompilerError(
                  38,
                  dirLoc
                )
              );
              continue;
            }
            seenSlotNames.add(staticSlotName);
            if (staticSlotName === "default") {
              hasNamedDefaultSlot = true;
            }
          }
          slotsProperties.push(createObjectProperty(slotName, slotFunction));
        }
      }
      if (!onComponentSlot) {
        const buildDefaultSlotProperty = (props, children2) => {
          const fn = buildSlotFn(props, void 0, children2, loc);
          if (context.compatConfig) {
            fn.isNonScopedSlot = true;
          }
          return createObjectProperty(`default`, fn);
        };
        if (!hasTemplateSlots) {
          slotsProperties.push(buildDefaultSlotProperty(void 0, children));
        } else if (implicitDefaultChildren.length && implicitDefaultChildren.some((node2) => isNonWhitespaceContent(node2))) {
          if (hasNamedDefaultSlot) {
            context.onError(
              createCompilerError(
                39,
                implicitDefaultChildren[0].loc
              )
            );
          } else {
            slotsProperties.push(
              buildDefaultSlotProperty(void 0, implicitDefaultChildren)
            );
          }
        }
      }
      const slotFlag = hasDynamicSlots ? 2 : hasForwardedSlots(node.children) ? 3 : 1;
      let slots = createObjectExpression(
        slotsProperties.concat(
          createObjectProperty(
            `_`,
            createSimpleExpression(
              slotFlag + ` /* ${shared.slotFlagsText[slotFlag]} */`,
              false
            )
          )
        ),
        loc
      );
      if (dynamicSlots.length) {
        slots = createCallExpression(context.helper(CREATE_SLOTS), [
          slots,
          createArrayExpression(dynamicSlots)
        ]);
      }
      return {
        slots,
        hasDynamicSlots
      };
    }
    function buildDynamicSlot(name, fn, index) {
      const props = [
        createObjectProperty(`name`, name),
        createObjectProperty(`fn`, fn)
      ];
      if (index != null) {
        props.push(
          createObjectProperty(`key`, createSimpleExpression(String(index), true))
        );
      }
      return createObjectExpression(props);
    }
    function hasForwardedSlots(children) {
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        switch (child.type) {
          case 1:
            if (child.tagType === 2 || hasForwardedSlots(child.children)) {
              return true;
            }
            break;
          case 9:
            if (hasForwardedSlots(child.branches))
              return true;
            break;
          case 10:
          case 11:
            if (hasForwardedSlots(child.children))
              return true;
            break;
        }
      }
      return false;
    }
    function isNonWhitespaceContent(node) {
      if (node.type !== 2 && node.type !== 12)
        return true;
      return node.type === 2 ? !!node.content.trim() : isNonWhitespaceContent(node.content);
    }
    var directiveImportMap = /* @__PURE__ */ new WeakMap();
    var transformElement = (node, context) => {
      return function postTransformElement() {
        node = context.currentNode;
        if (!(node.type === 1 && (node.tagType === 0 || node.tagType === 1))) {
          return;
        }
        const { tag, props } = node;
        const isComponent2 = node.tagType === 1;
        let vnodeTag = isComponent2 ? resolveComponentType(node, context) : `"${tag}"`;
        const isDynamicComponent = shared.isObject(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
        let vnodeProps;
        let vnodeChildren;
        let vnodePatchFlag;
        let patchFlag = 0;
        let vnodeDynamicProps;
        let dynamicPropNames;
        let vnodeDirectives;
        let shouldUseBlock = isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent2 && (tag === "svg" || tag === "foreignObject" || tag === "math");
        if (props.length > 0) {
          const propsBuildResult = buildProps(
            node,
            context,
            void 0,
            isComponent2,
            isDynamicComponent
          );
          vnodeProps = propsBuildResult.props;
          patchFlag = propsBuildResult.patchFlag;
          dynamicPropNames = propsBuildResult.dynamicPropNames;
          const directives = propsBuildResult.directives;
          vnodeDirectives = directives && directives.length ? createArrayExpression(
            directives.map((dir) => buildDirectiveArgs(dir, context))
          ) : void 0;
          if (propsBuildResult.shouldUseBlock) {
            shouldUseBlock = true;
          }
        }
        if (node.children.length > 0) {
          if (vnodeTag === KEEP_ALIVE) {
            shouldUseBlock = true;
            patchFlag |= 1024;
            if (node.children.length > 1) {
              context.onError(
                createCompilerError(46, {
                  start: node.children[0].loc.start,
                  end: node.children[node.children.length - 1].loc.end,
                  source: ""
                })
              );
            }
          }
          const shouldBuildAsSlots = isComponent2 && vnodeTag !== TELEPORT && vnodeTag !== KEEP_ALIVE;
          if (shouldBuildAsSlots) {
            const { slots, hasDynamicSlots } = buildSlots(node, context);
            vnodeChildren = slots;
            if (hasDynamicSlots) {
              patchFlag |= 1024;
            }
          } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
            const child = node.children[0];
            const type = child.type;
            const hasDynamicTextChild = type === 5 || type === 8;
            if (hasDynamicTextChild && getConstantType(child, context) === 0) {
              patchFlag |= 1;
            }
            if (hasDynamicTextChild || type === 2) {
              vnodeChildren = child;
            } else {
              vnodeChildren = node.children;
            }
          } else {
            vnodeChildren = node.children;
          }
        }
        if (patchFlag !== 0) {
          {
            if (patchFlag < 0) {
              vnodePatchFlag = patchFlag + ` /* ${shared.PatchFlagNames[patchFlag]} */`;
            } else {
              const flagNames = Object.keys(shared.PatchFlagNames).map(Number).filter((n) => n > 0 && patchFlag & n).map((n) => shared.PatchFlagNames[n]).join(`, `);
              vnodePatchFlag = patchFlag + ` /* ${flagNames} */`;
            }
          }
          if (dynamicPropNames && dynamicPropNames.length) {
            vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
          }
        }
        node.codegenNode = createVNodeCall(
          context,
          vnodeTag,
          vnodeProps,
          vnodeChildren,
          vnodePatchFlag,
          vnodeDynamicProps,
          vnodeDirectives,
          !!shouldUseBlock,
          false,
          isComponent2,
          node.loc
        );
      };
    };
    function resolveComponentType(node, context, ssr = false) {
      let { tag } = node;
      const isExplicitDynamic = isComponentTag(tag);
      const isProp = findProp(
        node,
        "is",
        false,
        true
      );
      if (isProp) {
        if (isExplicitDynamic || isCompatEnabled(
          "COMPILER_IS_ON_ELEMENT",
          context
        )) {
          let exp;
          if (isProp.type === 6) {
            exp = isProp.value && createSimpleExpression(isProp.value.content, true);
          } else {
            exp = isProp.exp;
            if (!exp) {
              exp = createSimpleExpression(`is`, false, isProp.loc);
              {
                exp = isProp.exp = processExpression(exp, context);
              }
            }
          }
          if (exp) {
            return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
              exp
            ]);
          }
        } else if (isProp.type === 6 && isProp.value.content.startsWith("vue:")) {
          tag = isProp.value.content.slice(4);
        }
      }
      const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
      if (builtIn) {
        if (!ssr)
          context.helper(builtIn);
        return builtIn;
      }
      {
        const fromSetup = resolveSetupReference(tag, context);
        if (fromSetup) {
          return fromSetup;
        }
        const dotIndex = tag.indexOf(".");
        if (dotIndex > 0) {
          const ns = resolveSetupReference(tag.slice(0, dotIndex), context);
          if (ns) {
            return ns + tag.slice(dotIndex);
          }
        }
      }
      if (context.selfName && shared.capitalize(shared.camelize(tag)) === context.selfName) {
        context.helper(RESOLVE_COMPONENT);
        context.components.add(tag + `__self`);
        return toValidAssetId(tag, `component`);
      }
      context.helper(RESOLVE_COMPONENT);
      context.components.add(tag);
      return toValidAssetId(tag, `component`);
    }
    function resolveSetupReference(name, context) {
      const bindings = context.bindingMetadata;
      if (!bindings || bindings.__isScriptSetup === false) {
        return;
      }
      const camelName = shared.camelize(name);
      const PascalName = shared.capitalize(camelName);
      const checkType = (type) => {
        if (bindings[name] === type) {
          return name;
        }
        if (bindings[camelName] === type) {
          return camelName;
        }
        if (bindings[PascalName] === type) {
          return PascalName;
        }
      };
      const fromConst = checkType("setup-const") || checkType("setup-reactive-const") || checkType("literal-const");
      if (fromConst) {
        return context.inline ? fromConst : `$setup[${JSON.stringify(fromConst)}]`;
      }
      const fromMaybeRef = checkType("setup-let") || checkType("setup-ref") || checkType("setup-maybe-ref");
      if (fromMaybeRef) {
        return context.inline ? `${context.helperString(UNREF)}(${fromMaybeRef})` : `$setup[${JSON.stringify(fromMaybeRef)}]`;
      }
      const fromProps = checkType("props");
      if (fromProps) {
        return `${context.helperString(UNREF)}(${context.inline ? "__props" : "$props"}[${JSON.stringify(fromProps)}])`;
      }
    }
    function buildProps(node, context, props = node.props, isComponent2, isDynamicComponent, ssr = false) {
      const { tag, loc: elementLoc, children } = node;
      let properties = [];
      const mergeArgs = [];
      const runtimeDirectives = [];
      const hasChildren = children.length > 0;
      let shouldUseBlock = false;
      let patchFlag = 0;
      let hasRef = false;
      let hasClassBinding = false;
      let hasStyleBinding = false;
      let hasHydrationEventBinding = false;
      let hasDynamicKeys = false;
      let hasVnodeHook = false;
      const dynamicPropNames = [];
      const pushMergeArg = (arg) => {
        if (properties.length) {
          mergeArgs.push(
            createObjectExpression(dedupeProperties(properties), elementLoc)
          );
          properties = [];
        }
        if (arg)
          mergeArgs.push(arg);
      };
      const pushRefVForMarker = () => {
        if (context.scopes.vFor > 0) {
          properties.push(
            createObjectProperty(
              createSimpleExpression("ref_for", true),
              createSimpleExpression("true")
            )
          );
        }
      };
      const analyzePatchFlag = ({ key, value }) => {
        if (isStaticExp(key)) {
          const name = key.content;
          const isEventHandler = shared.isOn(name);
          if (isEventHandler && (!isComponent2 || isDynamicComponent) && name.toLowerCase() !== "onclick" && name !== "onUpdate:modelValue" && !shared.isReservedProp(name)) {
            hasHydrationEventBinding = true;
          }
          if (isEventHandler && shared.isReservedProp(name)) {
            hasVnodeHook = true;
          }
          if (isEventHandler && value.type === 14) {
            value = value.arguments[0];
          }
          if (value.type === 20 || (value.type === 4 || value.type === 8) && getConstantType(value, context) > 0) {
            return;
          }
          if (name === "ref") {
            hasRef = true;
          } else if (name === "class") {
            hasClassBinding = true;
          } else if (name === "style") {
            hasStyleBinding = true;
          } else if (name !== "key" && !dynamicPropNames.includes(name)) {
            dynamicPropNames.push(name);
          }
          if (isComponent2 && (name === "class" || name === "style") && !dynamicPropNames.includes(name)) {
            dynamicPropNames.push(name);
          }
        } else {
          hasDynamicKeys = true;
        }
      };
      for (let i = 0; i < props.length; i++) {
        const prop = props[i];
        if (prop.type === 6) {
          const { loc, name, nameLoc, value } = prop;
          let isStatic = true;
          if (name === "ref") {
            hasRef = true;
            pushRefVForMarker();
            if (value && context.inline) {
              const binding = context.bindingMetadata[value.content];
              if (binding === "setup-let" || binding === "setup-ref" || binding === "setup-maybe-ref") {
                isStatic = false;
                properties.push(
                  createObjectProperty(
                    createSimpleExpression("ref_key", true),
                    createSimpleExpression(value.content, true, value.loc)
                  )
                );
              }
            }
          }
          if (name === "is" && (isComponentTag(tag) || value && value.content.startsWith("vue:") || isCompatEnabled(
            "COMPILER_IS_ON_ELEMENT",
            context
          ))) {
            continue;
          }
          properties.push(
            createObjectProperty(
              createSimpleExpression(name, true, nameLoc),
              createSimpleExpression(
                value ? value.content : "",
                isStatic,
                value ? value.loc : loc
              )
            )
          );
        } else {
          const { name, arg, exp, loc, modifiers } = prop;
          const isVBind = name === "bind";
          const isVOn = name === "on";
          if (name === "slot") {
            if (!isComponent2) {
              context.onError(
                createCompilerError(40, loc)
              );
            }
            continue;
          }
          if (name === "once" || name === "memo") {
            continue;
          }
          if (name === "is" || isVBind && isStaticArgOf(arg, "is") && (isComponentTag(tag) || isCompatEnabled(
            "COMPILER_IS_ON_ELEMENT",
            context
          ))) {
            continue;
          }
          if (isVOn && ssr) {
            continue;
          }
          if (isVBind && isStaticArgOf(arg, "key") || isVOn && hasChildren && isStaticArgOf(arg, "vue:before-update")) {
            shouldUseBlock = true;
          }
          if (isVBind && isStaticArgOf(arg, "ref")) {
            pushRefVForMarker();
          }
          if (!arg && (isVBind || isVOn)) {
            hasDynamicKeys = true;
            if (exp) {
              if (isVBind) {
                pushRefVForMarker();
                pushMergeArg();
                {
                  {
                    const hasOverridableKeys = mergeArgs.some((arg2) => {
                      if (arg2.type === 15) {
                        return arg2.properties.some(({ key }) => {
                          if (key.type !== 4 || !key.isStatic) {
                            return true;
                          }
                          return key.content !== "class" && key.content !== "style" && !shared.isOn(key.content);
                        });
                      } else {
                        return true;
                      }
                    });
                    if (hasOverridableKeys) {
                      checkCompatEnabled(
                        "COMPILER_V_BIND_OBJECT_ORDER",
                        context,
                        loc
                      );
                    }
                  }
                  if (isCompatEnabled(
                    "COMPILER_V_BIND_OBJECT_ORDER",
                    context
                  )) {
                    mergeArgs.unshift(exp);
                    continue;
                  }
                }
                mergeArgs.push(exp);
              } else {
                pushMergeArg({
                  type: 14,
                  loc,
                  callee: context.helper(TO_HANDLERS),
                  arguments: isComponent2 ? [exp] : [exp, `true`]
                });
              }
            } else {
              context.onError(
                createCompilerError(
                  isVBind ? 34 : 35,
                  loc
                )
              );
            }
            continue;
          }
          if (isVBind && modifiers.includes("prop")) {
            patchFlag |= 32;
          }
          const directiveTransform = context.directiveTransforms[name];
          if (directiveTransform) {
            const { props: props2, needRuntime } = directiveTransform(prop, node, context);
            !ssr && props2.forEach(analyzePatchFlag);
            if (isVOn && arg && !isStaticExp(arg)) {
              pushMergeArg(createObjectExpression(props2, elementLoc));
            } else {
              properties.push(...props2);
            }
            if (needRuntime) {
              runtimeDirectives.push(prop);
              if (shared.isSymbol(needRuntime)) {
                directiveImportMap.set(prop, needRuntime);
              }
            }
          } else if (!shared.isBuiltInDirective(name)) {
            runtimeDirectives.push(prop);
            if (hasChildren) {
              shouldUseBlock = true;
            }
          }
        }
      }
      let propsExpression = void 0;
      if (mergeArgs.length) {
        pushMergeArg();
        if (mergeArgs.length > 1) {
          propsExpression = createCallExpression(
            context.helper(MERGE_PROPS),
            mergeArgs,
            elementLoc
          );
        } else {
          propsExpression = mergeArgs[0];
        }
      } else if (properties.length) {
        propsExpression = createObjectExpression(
          dedupeProperties(properties),
          elementLoc
        );
      }
      if (hasDynamicKeys) {
        patchFlag |= 16;
      } else {
        if (hasClassBinding && !isComponent2) {
          patchFlag |= 2;
        }
        if (hasStyleBinding && !isComponent2) {
          patchFlag |= 4;
        }
        if (dynamicPropNames.length) {
          patchFlag |= 8;
        }
        if (hasHydrationEventBinding) {
          patchFlag |= 32;
        }
      }
      if (!shouldUseBlock && (patchFlag === 0 || patchFlag === 32) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
        patchFlag |= 512;
      }
      if (!context.inSSR && propsExpression) {
        switch (propsExpression.type) {
          case 15:
            let classKeyIndex = -1;
            let styleKeyIndex = -1;
            let hasDynamicKey = false;
            for (let i = 0; i < propsExpression.properties.length; i++) {
              const key = propsExpression.properties[i].key;
              if (isStaticExp(key)) {
                if (key.content === "class") {
                  classKeyIndex = i;
                } else if (key.content === "style") {
                  styleKeyIndex = i;
                }
              } else if (!key.isHandlerKey) {
                hasDynamicKey = true;
              }
            }
            const classProp = propsExpression.properties[classKeyIndex];
            const styleProp = propsExpression.properties[styleKeyIndex];
            if (!hasDynamicKey) {
              if (classProp && !isStaticExp(classProp.value)) {
                classProp.value = createCallExpression(
                  context.helper(NORMALIZE_CLASS),
                  [classProp.value]
                );
              }
              if (styleProp && (hasStyleBinding || styleProp.value.type === 4 && styleProp.value.content.trim()[0] === `[` || styleProp.value.type === 17)) {
                styleProp.value = createCallExpression(
                  context.helper(NORMALIZE_STYLE),
                  [styleProp.value]
                );
              }
            } else {
              propsExpression = createCallExpression(
                context.helper(NORMALIZE_PROPS),
                [propsExpression]
              );
            }
            break;
          case 14:
            break;
          default:
            propsExpression = createCallExpression(
              context.helper(NORMALIZE_PROPS),
              [
                createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
                  propsExpression
                ])
              ]
            );
            break;
        }
      }
      return {
        props: propsExpression,
        directives: runtimeDirectives,
        patchFlag,
        dynamicPropNames,
        shouldUseBlock
      };
    }
    function dedupeProperties(properties) {
      const knownProps = /* @__PURE__ */ new Map();
      const deduped = [];
      for (let i = 0; i < properties.length; i++) {
        const prop = properties[i];
        if (prop.key.type === 8 || !prop.key.isStatic) {
          deduped.push(prop);
          continue;
        }
        const name = prop.key.content;
        const existing = knownProps.get(name);
        if (existing) {
          if (name === "style" || name === "class" || shared.isOn(name)) {
            mergeAsArray(existing, prop);
          }
        } else {
          knownProps.set(name, prop);
          deduped.push(prop);
        }
      }
      return deduped;
    }
    function mergeAsArray(existing, incoming) {
      if (existing.value.type === 17) {
        existing.value.elements.push(incoming.value);
      } else {
        existing.value = createArrayExpression(
          [existing.value, incoming.value],
          existing.loc
        );
      }
    }
    function buildDirectiveArgs(dir, context) {
      const dirArgs = [];
      const runtime = directiveImportMap.get(dir);
      if (runtime) {
        dirArgs.push(context.helperString(runtime));
      } else {
        const fromSetup = resolveSetupReference("v-" + dir.name, context);
        if (fromSetup) {
          dirArgs.push(fromSetup);
        } else {
          context.helper(RESOLVE_DIRECTIVE);
          context.directives.add(dir.name);
          dirArgs.push(toValidAssetId(dir.name, `directive`));
        }
      }
      const { loc } = dir;
      if (dir.exp)
        dirArgs.push(dir.exp);
      if (dir.arg) {
        if (!dir.exp) {
          dirArgs.push(`void 0`);
        }
        dirArgs.push(dir.arg);
      }
      if (Object.keys(dir.modifiers).length) {
        if (!dir.arg) {
          if (!dir.exp) {
            dirArgs.push(`void 0`);
          }
          dirArgs.push(`void 0`);
        }
        const trueExpression = createSimpleExpression(`true`, false, loc);
        dirArgs.push(
          createObjectExpression(
            dir.modifiers.map(
              (modifier) => createObjectProperty(modifier, trueExpression)
            ),
            loc
          )
        );
      }
      return createArrayExpression(dirArgs, dir.loc);
    }
    function stringifyDynamicPropNames(props) {
      let propsNamesString = `[`;
      for (let i = 0, l = props.length; i < l; i++) {
        propsNamesString += JSON.stringify(props[i]);
        if (i < l - 1)
          propsNamesString += ", ";
      }
      return propsNamesString + `]`;
    }
    function isComponentTag(tag) {
      return tag === "component" || tag === "Component";
    }
    var transformSlotOutlet = (node, context) => {
      if (isSlotOutlet(node)) {
        const { children, loc } = node;
        const { slotName, slotProps } = processSlotOutlet(node, context);
        const slotArgs = [
          context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
          slotName,
          "{}",
          "undefined",
          "true"
        ];
        let expectedLen = 2;
        if (slotProps) {
          slotArgs[2] = slotProps;
          expectedLen = 3;
        }
        if (children.length) {
          slotArgs[3] = createFunctionExpression([], children, false, false, loc);
          expectedLen = 4;
        }
        if (context.scopeId && !context.slotted) {
          expectedLen = 5;
        }
        slotArgs.splice(expectedLen);
        node.codegenNode = createCallExpression(
          context.helper(RENDER_SLOT),
          slotArgs,
          loc
        );
      }
    };
    function processSlotOutlet(node, context) {
      let slotName = `"default"`;
      let slotProps = void 0;
      const nonNameProps = [];
      for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 6) {
          if (p.value) {
            if (p.name === "name") {
              slotName = JSON.stringify(p.value.content);
            } else {
              p.name = shared.camelize(p.name);
              nonNameProps.push(p);
            }
          }
        } else {
          if (p.name === "bind" && isStaticArgOf(p.arg, "name")) {
            if (p.exp) {
              slotName = p.exp;
            } else if (p.arg && p.arg.type === 4) {
              const name = shared.camelize(p.arg.content);
              slotName = p.exp = createSimpleExpression(name, false, p.arg.loc);
              {
                slotName = p.exp = processExpression(p.exp, context);
              }
            }
          } else {
            if (p.name === "bind" && p.arg && isStaticExp(p.arg)) {
              p.arg.content = shared.camelize(p.arg.content);
            }
            nonNameProps.push(p);
          }
        }
      }
      if (nonNameProps.length > 0) {
        const { props, directives } = buildProps(
          node,
          context,
          nonNameProps,
          false,
          false
        );
        slotProps = props;
        if (directives.length) {
          context.onError(
            createCompilerError(
              36,
              directives[0].loc
            )
          );
        }
      }
      return {
        slotName,
        slotProps
      };
    }
    var fnExpRE = /^\s*(async\s*)?(\([^)]*?\)|[\w$_]+)\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;
    var transformOn = (dir, node, context, augmentor) => {
      const { loc, modifiers, arg } = dir;
      if (!dir.exp && !modifiers.length) {
        context.onError(createCompilerError(35, loc));
      }
      let eventName;
      if (arg.type === 4) {
        if (arg.isStatic) {
          let rawName = arg.content;
          if (rawName.startsWith("vnode")) {
            context.onError(createCompilerError(51, arg.loc));
          }
          if (rawName.startsWith("vue:")) {
            rawName = `vnode-${rawName.slice(4)}`;
          }
          const eventString = node.tagType !== 0 || rawName.startsWith("vnode") || !/[A-Z]/.test(rawName) ? shared.toHandlerKey(shared.camelize(rawName)) : `on:${rawName}`;
          eventName = createSimpleExpression(eventString, true, arg.loc);
        } else {
          eventName = createCompoundExpression([
            `${context.helperString(TO_HANDLER_KEY)}(`,
            arg,
            `)`
          ]);
        }
      } else {
        eventName = arg;
        eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
        eventName.children.push(`)`);
      }
      let exp = dir.exp;
      if (exp && !exp.content.trim()) {
        exp = void 0;
      }
      let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
      if (exp) {
        const isMemberExp = isMemberExpression(exp.content, context);
        const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));
        const hasMultipleStatements = exp.content.includes(`;`);
        if (context.prefixIdentifiers) {
          isInlineStatement && context.addIdentifiers(`$event`);
          exp = dir.exp = processExpression(
            exp,
            context,
            false,
            hasMultipleStatements
          );
          isInlineStatement && context.removeIdentifiers(`$event`);
          shouldCache = context.cacheHandlers && !context.inVOnce && !(exp.type === 4 && exp.constType > 0) && !(isMemberExp && node.tagType === 1) && !hasScopeRef(exp, context.identifiers);
          if (shouldCache && isMemberExp) {
            if (exp.type === 4) {
              exp.content = `${exp.content} && ${exp.content}(...args)`;
            } else {
              exp.children = [...exp.children, ` && `, ...exp.children, `(...args)`];
            }
          }
        }
        if (isInlineStatement || shouldCache && isMemberExp) {
          exp = createCompoundExpression([
            `${isInlineStatement ? context.isTS ? `($event: any)` : `$event` : `${context.isTS ? `
//@ts-ignore
` : ``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
            exp,
            hasMultipleStatements ? `}` : `)`
          ]);
        }
      }
      let ret = {
        props: [
          createObjectProperty(
            eventName,
            exp || createSimpleExpression(`() => {}`, false, loc)
          )
        ]
      };
      if (augmentor) {
        ret = augmentor(ret);
      }
      if (shouldCache) {
        ret.props[0].value = context.cache(ret.props[0].value);
      }
      ret.props.forEach((p) => p.key.isHandlerKey = true);
      return ret;
    };
    var transformText = (node, context) => {
      if (node.type === 0 || node.type === 1 || node.type === 11 || node.type === 10) {
        return () => {
          const children = node.children;
          let currentContainer = void 0;
          let hasText = false;
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (isText$1(child)) {
              hasText = true;
              for (let j = i + 1; j < children.length; j++) {
                const next = children[j];
                if (isText$1(next)) {
                  if (!currentContainer) {
                    currentContainer = children[i] = createCompoundExpression(
                      [child],
                      child.loc
                    );
                  }
                  currentContainer.children.push(` + `, next);
                  children.splice(j, 1);
                  j--;
                } else {
                  currentContainer = void 0;
                  break;
                }
              }
            }
          }
          if (!hasText || children.length === 1 && (node.type === 0 || node.type === 1 && node.tagType === 0 && !node.props.find(
            (p) => p.type === 7 && !context.directiveTransforms[p.name]
          ) && !(node.tag === "template"))) {
            return;
          }
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (isText$1(child) || child.type === 8) {
              const callArgs = [];
              if (child.type !== 2 || child.content !== " ") {
                callArgs.push(child);
              }
              if (!context.ssr && getConstantType(child, context) === 0) {
                callArgs.push(
                  1 + ` /* ${shared.PatchFlagNames[1]} */`
                );
              }
              children[i] = {
                type: 12,
                content: child,
                loc: child.loc,
                codegenNode: createCallExpression(
                  context.helper(CREATE_TEXT),
                  callArgs
                )
              };
            }
          }
        };
      }
    };
    var seen$1 = /* @__PURE__ */ new WeakSet();
    var transformOnce = (node, context) => {
      if (node.type === 1 && findDir(node, "once", true)) {
        if (seen$1.has(node) || context.inVOnce || context.inSSR) {
          return;
        }
        seen$1.add(node);
        context.inVOnce = true;
        context.helper(SET_BLOCK_TRACKING);
        return () => {
          context.inVOnce = false;
          const cur = context.currentNode;
          if (cur.codegenNode) {
            cur.codegenNode = context.cache(
              cur.codegenNode,
              true
            );
          }
        };
      }
    };
    var transformModel = (dir, node, context) => {
      const { exp, arg } = dir;
      if (!exp) {
        context.onError(
          createCompilerError(41, dir.loc)
        );
        return createTransformProps();
      }
      const rawExp = exp.loc.source;
      const expString = exp.type === 4 ? exp.content : rawExp;
      const bindingType = context.bindingMetadata[rawExp];
      if (bindingType === "props" || bindingType === "props-aliased") {
        context.onError(createCompilerError(44, exp.loc));
        return createTransformProps();
      }
      const maybeRef = context.inline && (bindingType === "setup-let" || bindingType === "setup-ref" || bindingType === "setup-maybe-ref");
      if (!expString.trim() || !isMemberExpression(expString, context) && !maybeRef) {
        context.onError(
          createCompilerError(42, exp.loc)
        );
        return createTransformProps();
      }
      if (context.prefixIdentifiers && isSimpleIdentifier(expString) && context.identifiers[expString]) {
        context.onError(
          createCompilerError(43, exp.loc)
        );
        return createTransformProps();
      }
      const propName = arg ? arg : createSimpleExpression("modelValue", true);
      const eventName = arg ? isStaticExp(arg) ? `onUpdate:${shared.camelize(arg.content)}` : createCompoundExpression(['"onUpdate:" + ', arg]) : `onUpdate:modelValue`;
      let assignmentExp;
      const eventArg = context.isTS ? `($event: any)` : `$event`;
      if (maybeRef) {
        if (bindingType === "setup-ref") {
          assignmentExp = createCompoundExpression([
            `${eventArg} => ((`,
            createSimpleExpression(rawExp, false, exp.loc),
            `).value = $event)`
          ]);
        } else {
          const altAssignment = bindingType === "setup-let" ? `${rawExp} = $event` : `null`;
          assignmentExp = createCompoundExpression([
            `${eventArg} => (${context.helperString(IS_REF)}(${rawExp}) ? (`,
            createSimpleExpression(rawExp, false, exp.loc),
            `).value = $event : ${altAssignment})`
          ]);
        }
      } else {
        assignmentExp = createCompoundExpression([
          `${eventArg} => ((`,
          exp,
          `) = $event)`
        ]);
      }
      const props = [
        createObjectProperty(propName, dir.exp),
        createObjectProperty(eventName, assignmentExp)
      ];
      if (context.prefixIdentifiers && !context.inVOnce && context.cacheHandlers && !hasScopeRef(exp, context.identifiers)) {
        props[1].value = context.cache(props[1].value);
      }
      if (dir.modifiers.length && node.tagType === 1) {
        const modifiers = dir.modifiers.map((m) => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`).join(`, `);
        const modifiersKey = arg ? isStaticExp(arg) ? `${arg.content}Modifiers` : createCompoundExpression([arg, ' + "Modifiers"']) : `modelModifiers`;
        props.push(
          createObjectProperty(
            modifiersKey,
            createSimpleExpression(
              `{ ${modifiers} }`,
              false,
              dir.loc,
              2
            )
          )
        );
      }
      return createTransformProps(props);
    };
    function createTransformProps(props = []) {
      return { props };
    }
    var validDivisionCharRE = /[\w).+\-_$\]]/;
    var transformFilter = (node, context) => {
      if (!isCompatEnabled("COMPILER_FILTERS", context)) {
        return;
      }
      if (node.type === 5) {
        rewriteFilter(node.content, context);
      }
      if (node.type === 1) {
        node.props.forEach((prop) => {
          if (prop.type === 7 && prop.name !== "for" && prop.exp) {
            rewriteFilter(prop.exp, context);
          }
        });
      }
    };
    function rewriteFilter(node, context) {
      if (node.type === 4) {
        parseFilter(node, context);
      } else {
        for (let i = 0; i < node.children.length; i++) {
          const child = node.children[i];
          if (typeof child !== "object")
            continue;
          if (child.type === 4) {
            parseFilter(child, context);
          } else if (child.type === 8) {
            rewriteFilter(node, context);
          } else if (child.type === 5) {
            rewriteFilter(child.content, context);
          }
        }
      }
    }
    function parseFilter(node, context) {
      const exp = node.content;
      let inSingle = false;
      let inDouble = false;
      let inTemplateString = false;
      let inRegex = false;
      let curly = 0;
      let square = 0;
      let paren = 0;
      let lastFilterIndex = 0;
      let c, prev, i, expression, filters = [];
      for (i = 0; i < exp.length; i++) {
        prev = c;
        c = exp.charCodeAt(i);
        if (inSingle) {
          if (c === 39 && prev !== 92)
            inSingle = false;
        } else if (inDouble) {
          if (c === 34 && prev !== 92)
            inDouble = false;
        } else if (inTemplateString) {
          if (c === 96 && prev !== 92)
            inTemplateString = false;
        } else if (inRegex) {
          if (c === 47 && prev !== 92)
            inRegex = false;
        } else if (c === 124 && exp.charCodeAt(i + 1) !== 124 && exp.charCodeAt(i - 1) !== 124 && !curly && !square && !paren) {
          if (expression === void 0) {
            lastFilterIndex = i + 1;
            expression = exp.slice(0, i).trim();
          } else {
            pushFilter();
          }
        } else {
          switch (c) {
            case 34:
              inDouble = true;
              break;
            case 39:
              inSingle = true;
              break;
            case 96:
              inTemplateString = true;
              break;
            case 40:
              paren++;
              break;
            case 41:
              paren--;
              break;
            case 91:
              square++;
              break;
            case 93:
              square--;
              break;
            case 123:
              curly++;
              break;
            case 125:
              curly--;
              break;
          }
          if (c === 47) {
            let j = i - 1;
            let p;
            for (; j >= 0; j--) {
              p = exp.charAt(j);
              if (p !== " ")
                break;
            }
            if (!p || !validDivisionCharRE.test(p)) {
              inRegex = true;
            }
          }
        }
      }
      if (expression === void 0) {
        expression = exp.slice(0, i).trim();
      } else if (lastFilterIndex !== 0) {
        pushFilter();
      }
      function pushFilter() {
        filters.push(exp.slice(lastFilterIndex, i).trim());
        lastFilterIndex = i + 1;
      }
      if (filters.length) {
        warnDeprecation(
          "COMPILER_FILTERS",
          context,
          node.loc
        );
        for (i = 0; i < filters.length; i++) {
          expression = wrapFilter(expression, filters[i], context);
        }
        node.content = expression;
        node.ast = void 0;
      }
    }
    function wrapFilter(exp, filter, context) {
      context.helper(RESOLVE_FILTER);
      const i = filter.indexOf("(");
      if (i < 0) {
        context.filters.add(filter);
        return `${toValidAssetId(filter, "filter")}(${exp})`;
      } else {
        const name = filter.slice(0, i);
        const args = filter.slice(i + 1);
        context.filters.add(name);
        return `${toValidAssetId(name, "filter")}(${exp}${args !== ")" ? "," + args : args}`;
      }
    }
    var seen = /* @__PURE__ */ new WeakSet();
    var transformMemo = (node, context) => {
      if (node.type === 1) {
        const dir = findDir(node, "memo");
        if (!dir || seen.has(node)) {
          return;
        }
        seen.add(node);
        return () => {
          const codegenNode = node.codegenNode || context.currentNode.codegenNode;
          if (codegenNode && codegenNode.type === 13) {
            if (node.tagType !== 1) {
              convertToBlock(codegenNode, context);
            }
            node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
              dir.exp,
              createFunctionExpression(void 0, codegenNode),
              `_cache`,
              String(context.cached++)
            ]);
          }
        };
      }
    };
    function getBaseTransformPreset(prefixIdentifiers) {
      return [
        [
          transformOnce,
          transformIf,
          transformMemo,
          transformFor,
          ...[transformFilter],
          ...prefixIdentifiers ? [
            trackVForSlotScopes,
            transformExpression
          ] : [],
          transformSlotOutlet,
          transformElement,
          trackSlotScopes,
          transformText
        ],
        {
          on: transformOn,
          bind: transformBind,
          model: transformModel
        }
      ];
    }
    function baseCompile(source, options = {}) {
      const onError = options.onError || defaultOnError;
      const isModuleMode = options.mode === "module";
      const prefixIdentifiers = options.prefixIdentifiers === true || isModuleMode;
      if (!prefixIdentifiers && options.cacheHandlers) {
        onError(createCompilerError(49));
      }
      if (options.scopeId && !isModuleMode) {
        onError(createCompilerError(50));
      }
      const resolvedOptions = shared.extend({}, options, {
        prefixIdentifiers
      });
      const ast = shared.isString(source) ? baseParse(source, resolvedOptions) : source;
      const [nodeTransforms, directiveTransforms] = getBaseTransformPreset(prefixIdentifiers);
      if (options.isTS) {
        const { expressionPlugins } = options;
        if (!expressionPlugins || !expressionPlugins.includes("typescript")) {
          options.expressionPlugins = [...expressionPlugins || [], "typescript"];
        }
      }
      transform(
        ast,
        shared.extend({}, resolvedOptions, {
          nodeTransforms: [
            ...nodeTransforms,
            ...options.nodeTransforms || []
          ],
          directiveTransforms: shared.extend(
            {},
            directiveTransforms,
            options.directiveTransforms || {}
          )
        })
      );
      return generate(ast, resolvedOptions);
    }
    var BindingTypes = {
      "DATA": "data",
      "PROPS": "props",
      "PROPS_ALIASED": "props-aliased",
      "SETUP_LET": "setup-let",
      "SETUP_CONST": "setup-const",
      "SETUP_REACTIVE_CONST": "setup-reactive-const",
      "SETUP_MAYBE_REF": "setup-maybe-ref",
      "SETUP_REF": "setup-ref",
      "OPTIONS": "options",
      "LITERAL_CONST": "literal-const"
    };
    var noopDirectiveTransform = () => ({ props: [] });
    exports.generateCodeFrame = shared.generateCodeFrame;
    exports.BASE_TRANSITION = BASE_TRANSITION;
    exports.BindingTypes = BindingTypes;
    exports.CAMELIZE = CAMELIZE;
    exports.CAPITALIZE = CAPITALIZE;
    exports.CREATE_BLOCK = CREATE_BLOCK;
    exports.CREATE_COMMENT = CREATE_COMMENT;
    exports.CREATE_ELEMENT_BLOCK = CREATE_ELEMENT_BLOCK;
    exports.CREATE_ELEMENT_VNODE = CREATE_ELEMENT_VNODE;
    exports.CREATE_SLOTS = CREATE_SLOTS;
    exports.CREATE_STATIC = CREATE_STATIC;
    exports.CREATE_TEXT = CREATE_TEXT;
    exports.CREATE_VNODE = CREATE_VNODE;
    exports.CompilerDeprecationTypes = CompilerDeprecationTypes;
    exports.ConstantTypes = ConstantTypes;
    exports.ElementTypes = ElementTypes;
    exports.ErrorCodes = ErrorCodes;
    exports.FRAGMENT = FRAGMENT;
    exports.GUARD_REACTIVE_PROPS = GUARD_REACTIVE_PROPS;
    exports.IS_MEMO_SAME = IS_MEMO_SAME;
    exports.IS_REF = IS_REF;
    exports.KEEP_ALIVE = KEEP_ALIVE;
    exports.MERGE_PROPS = MERGE_PROPS;
    exports.NORMALIZE_CLASS = NORMALIZE_CLASS;
    exports.NORMALIZE_PROPS = NORMALIZE_PROPS;
    exports.NORMALIZE_STYLE = NORMALIZE_STYLE;
    exports.Namespaces = Namespaces;
    exports.NodeTypes = NodeTypes;
    exports.OPEN_BLOCK = OPEN_BLOCK;
    exports.POP_SCOPE_ID = POP_SCOPE_ID;
    exports.PUSH_SCOPE_ID = PUSH_SCOPE_ID;
    exports.RENDER_LIST = RENDER_LIST;
    exports.RENDER_SLOT = RENDER_SLOT;
    exports.RESOLVE_COMPONENT = RESOLVE_COMPONENT;
    exports.RESOLVE_DIRECTIVE = RESOLVE_DIRECTIVE;
    exports.RESOLVE_DYNAMIC_COMPONENT = RESOLVE_DYNAMIC_COMPONENT;
    exports.RESOLVE_FILTER = RESOLVE_FILTER;
    exports.SET_BLOCK_TRACKING = SET_BLOCK_TRACKING;
    exports.SUSPENSE = SUSPENSE;
    exports.TELEPORT = TELEPORT;
    exports.TO_DISPLAY_STRING = TO_DISPLAY_STRING;
    exports.TO_HANDLERS = TO_HANDLERS;
    exports.TO_HANDLER_KEY = TO_HANDLER_KEY;
    exports.TS_NODE_TYPES = TS_NODE_TYPES;
    exports.UNREF = UNREF;
    exports.WITH_CTX = WITH_CTX;
    exports.WITH_DIRECTIVES = WITH_DIRECTIVES;
    exports.WITH_MEMO = WITH_MEMO;
    exports.advancePositionWithClone = advancePositionWithClone;
    exports.advancePositionWithMutation = advancePositionWithMutation;
    exports.assert = assert;
    exports.baseCompile = baseCompile;
    exports.baseParse = baseParse;
    exports.buildDirectiveArgs = buildDirectiveArgs;
    exports.buildProps = buildProps;
    exports.buildSlots = buildSlots;
    exports.checkCompatEnabled = checkCompatEnabled;
    exports.convertToBlock = convertToBlock;
    exports.createArrayExpression = createArrayExpression;
    exports.createAssignmentExpression = createAssignmentExpression;
    exports.createBlockStatement = createBlockStatement;
    exports.createCacheExpression = createCacheExpression;
    exports.createCallExpression = createCallExpression;
    exports.createCompilerError = createCompilerError;
    exports.createCompoundExpression = createCompoundExpression;
    exports.createConditionalExpression = createConditionalExpression;
    exports.createForLoopParams = createForLoopParams;
    exports.createFunctionExpression = createFunctionExpression;
    exports.createIfStatement = createIfStatement;
    exports.createInterpolation = createInterpolation;
    exports.createObjectExpression = createObjectExpression;
    exports.createObjectProperty = createObjectProperty;
    exports.createReturnStatement = createReturnStatement;
    exports.createRoot = createRoot;
    exports.createSequenceExpression = createSequenceExpression;
    exports.createSimpleExpression = createSimpleExpression;
    exports.createStructuralDirectiveTransform = createStructuralDirectiveTransform;
    exports.createTemplateLiteral = createTemplateLiteral;
    exports.createTransformContext = createTransformContext;
    exports.createVNodeCall = createVNodeCall;
    exports.errorMessages = errorMessages;
    exports.extractIdentifiers = extractIdentifiers;
    exports.findDir = findDir;
    exports.findProp = findProp;
    exports.forAliasRE = forAliasRE;
    exports.generate = generate;
    exports.getBaseTransformPreset = getBaseTransformPreset;
    exports.getConstantType = getConstantType;
    exports.getMemoedVNodeCall = getMemoedVNodeCall;
    exports.getVNodeBlockHelper = getVNodeBlockHelper;
    exports.getVNodeHelper = getVNodeHelper;
    exports.hasDynamicKeyVBind = hasDynamicKeyVBind;
    exports.hasScopeRef = hasScopeRef;
    exports.helperNameMap = helperNameMap;
    exports.injectProp = injectProp;
    exports.isCoreComponent = isCoreComponent;
    exports.isFunctionType = isFunctionType;
    exports.isInDestructureAssignment = isInDestructureAssignment;
    exports.isInNewExpression = isInNewExpression;
    exports.isMemberExpression = isMemberExpression;
    exports.isMemberExpressionBrowser = isMemberExpressionBrowser;
    exports.isMemberExpressionNode = isMemberExpressionNode;
    exports.isReferencedIdentifier = isReferencedIdentifier;
    exports.isSimpleIdentifier = isSimpleIdentifier;
    exports.isSlotOutlet = isSlotOutlet;
    exports.isStaticArgOf = isStaticArgOf;
    exports.isStaticExp = isStaticExp;
    exports.isStaticProperty = isStaticProperty;
    exports.isStaticPropertyKey = isStaticPropertyKey;
    exports.isTemplateNode = isTemplateNode;
    exports.isText = isText$1;
    exports.isVSlot = isVSlot;
    exports.locStub = locStub;
    exports.noopDirectiveTransform = noopDirectiveTransform;
    exports.processExpression = processExpression;
    exports.processFor = processFor;
    exports.processIf = processIf;
    exports.processSlotOutlet = processSlotOutlet;
    exports.registerRuntimeHelpers = registerRuntimeHelpers;
    exports.resolveComponentType = resolveComponentType;
    exports.stringifyExpression = stringifyExpression;
    exports.toValidAssetId = toValidAssetId;
    exports.trackSlotScopes = trackSlotScopes;
    exports.trackVForSlotScopes = trackVForSlotScopes;
    exports.transform = transform;
    exports.transformBind = transformBind;
    exports.transformElement = transformElement;
    exports.transformExpression = transformExpression;
    exports.transformModel = transformModel;
    exports.transformOn = transformOn;
    exports.traverseNode = traverseNode;
    exports.unwrapTSNode = unwrapTSNode;
    exports.walkBlockDeclarations = walkBlockDeclarations;
    exports.walkFunctionParams = walkFunctionParams;
    exports.walkIdentifiers = walkIdentifiers;
    exports.warnDeprecation = warnDeprecation;
  }
});

// node_modules/@vue/compiler-core/index.js
var require_compiler_core = __commonJS({
  "node_modules/@vue/compiler-core/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_compiler_core_cjs();
    }
  }
});

// node_modules/@vue/compiler-dom/dist/compiler-dom.cjs.js
var require_compiler_dom_cjs = __commonJS({
  "node_modules/@vue/compiler-dom/dist/compiler-dom.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var compilerCore = require_compiler_core();
    var shared = require_shared();
    var V_MODEL_RADIO = Symbol(`vModelRadio`);
    var V_MODEL_CHECKBOX = Symbol(`vModelCheckbox`);
    var V_MODEL_TEXT = Symbol(`vModelText`);
    var V_MODEL_SELECT = Symbol(`vModelSelect`);
    var V_MODEL_DYNAMIC = Symbol(`vModelDynamic`);
    var V_ON_WITH_MODIFIERS = Symbol(`vOnModifiersGuard`);
    var V_ON_WITH_KEYS = Symbol(`vOnKeysGuard`);
    var V_SHOW = Symbol(`vShow`);
    var TRANSITION = Symbol(`Transition`);
    var TRANSITION_GROUP = Symbol(`TransitionGroup`);
    compilerCore.registerRuntimeHelpers({
      [V_MODEL_RADIO]: `vModelRadio`,
      [V_MODEL_CHECKBOX]: `vModelCheckbox`,
      [V_MODEL_TEXT]: `vModelText`,
      [V_MODEL_SELECT]: `vModelSelect`,
      [V_MODEL_DYNAMIC]: `vModelDynamic`,
      [V_ON_WITH_MODIFIERS]: `withModifiers`,
      [V_ON_WITH_KEYS]: `withKeys`,
      [V_SHOW]: `vShow`,
      [TRANSITION]: `Transition`,
      [TRANSITION_GROUP]: `TransitionGroup`
    });
    var parserOptions = {
      parseMode: "html",
      isVoidTag: shared.isVoidTag,
      isNativeTag: (tag) => shared.isHTMLTag(tag) || shared.isSVGTag(tag) || shared.isMathMLTag(tag),
      isPreTag: (tag) => tag === "pre",
      decodeEntities: void 0,
      isBuiltInComponent: (tag) => {
        if (tag === "Transition" || tag === "transition") {
          return TRANSITION;
        } else if (tag === "TransitionGroup" || tag === "transition-group") {
          return TRANSITION_GROUP;
        }
      },
      getNamespace(tag, parent, rootNamespace) {
        let ns = parent ? parent.ns : rootNamespace;
        if (parent && ns === 2) {
          if (parent.tag === "annotation-xml") {
            if (tag === "svg") {
              return 1;
            }
            if (parent.props.some(
              (a) => a.type === 6 && a.name === "encoding" && a.value != null && (a.value.content === "text/html" || a.value.content === "application/xhtml+xml")
            )) {
              ns = 0;
            }
          } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== "mglyph" && tag !== "malignmark") {
            ns = 0;
          }
        } else if (parent && ns === 1) {
          if (parent.tag === "foreignObject" || parent.tag === "desc" || parent.tag === "title") {
            ns = 0;
          }
        }
        if (ns === 0) {
          if (tag === "svg") {
            return 1;
          }
          if (tag === "math") {
            return 2;
          }
        }
        return ns;
      }
    };
    var transformStyle = (node) => {
      if (node.type === 1) {
        node.props.forEach((p, i) => {
          if (p.type === 6 && p.name === "style" && p.value) {
            node.props[i] = {
              type: 7,
              name: `bind`,
              arg: compilerCore.createSimpleExpression(`style`, true, p.loc),
              exp: parseInlineCSS(p.value.content, p.loc),
              modifiers: [],
              loc: p.loc
            };
          }
        });
      }
    };
    var parseInlineCSS = (cssText, loc) => {
      const normalized = shared.parseStringStyle(cssText);
      return compilerCore.createSimpleExpression(
        JSON.stringify(normalized),
        false,
        loc,
        3
      );
    };
    function createDOMCompilerError(code, loc) {
      return compilerCore.createCompilerError(
        code,
        loc,
        DOMErrorMessages
      );
    }
    var DOMErrorCodes = {
      "X_V_HTML_NO_EXPRESSION": 53,
      "53": "X_V_HTML_NO_EXPRESSION",
      "X_V_HTML_WITH_CHILDREN": 54,
      "54": "X_V_HTML_WITH_CHILDREN",
      "X_V_TEXT_NO_EXPRESSION": 55,
      "55": "X_V_TEXT_NO_EXPRESSION",
      "X_V_TEXT_WITH_CHILDREN": 56,
      "56": "X_V_TEXT_WITH_CHILDREN",
      "X_V_MODEL_ON_INVALID_ELEMENT": 57,
      "57": "X_V_MODEL_ON_INVALID_ELEMENT",
      "X_V_MODEL_ARG_ON_ELEMENT": 58,
      "58": "X_V_MODEL_ARG_ON_ELEMENT",
      "X_V_MODEL_ON_FILE_INPUT_ELEMENT": 59,
      "59": "X_V_MODEL_ON_FILE_INPUT_ELEMENT",
      "X_V_MODEL_UNNECESSARY_VALUE": 60,
      "60": "X_V_MODEL_UNNECESSARY_VALUE",
      "X_V_SHOW_NO_EXPRESSION": 61,
      "61": "X_V_SHOW_NO_EXPRESSION",
      "X_TRANSITION_INVALID_CHILDREN": 62,
      "62": "X_TRANSITION_INVALID_CHILDREN",
      "X_IGNORED_SIDE_EFFECT_TAG": 63,
      "63": "X_IGNORED_SIDE_EFFECT_TAG",
      "__EXTEND_POINT__": 64,
      "64": "__EXTEND_POINT__"
    };
    var DOMErrorMessages = {
      [53]: `v-html is missing expression.`,
      [54]: `v-html will override element children.`,
      [55]: `v-text is missing expression.`,
      [56]: `v-text will override element children.`,
      [57]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
      [58]: `v-model argument is not supported on plain elements.`,
      [59]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
      [60]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
      [61]: `v-show is missing expression.`,
      [62]: `<Transition> expects exactly one child element or component.`,
      [63]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
    };
    var transformVHtml = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
        context.onError(
          createDOMCompilerError(53, loc)
        );
      }
      if (node.children.length) {
        context.onError(
          createDOMCompilerError(54, loc)
        );
        node.children.length = 0;
      }
      return {
        props: [
          compilerCore.createObjectProperty(
            compilerCore.createSimpleExpression(`innerHTML`, true, loc),
            exp || compilerCore.createSimpleExpression("", true)
          )
        ]
      };
    };
    var transformVText = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
        context.onError(
          createDOMCompilerError(55, loc)
        );
      }
      if (node.children.length) {
        context.onError(
          createDOMCompilerError(56, loc)
        );
        node.children.length = 0;
      }
      return {
        props: [
          compilerCore.createObjectProperty(
            compilerCore.createSimpleExpression(`textContent`, true),
            exp ? compilerCore.getConstantType(exp, context) > 0 ? exp : compilerCore.createCallExpression(
              context.helperString(compilerCore.TO_DISPLAY_STRING),
              [exp],
              loc
            ) : compilerCore.createSimpleExpression("", true)
          )
        ]
      };
    };
    var transformModel = (dir, node, context) => {
      const baseResult = compilerCore.transformModel(dir, node, context);
      if (!baseResult.props.length || node.tagType === 1) {
        return baseResult;
      }
      if (dir.arg) {
        context.onError(
          createDOMCompilerError(
            58,
            dir.arg.loc
          )
        );
      }
      function checkDuplicatedValue() {
        const value = compilerCore.findDir(node, "bind");
        if (value && compilerCore.isStaticArgOf(value.arg, "value")) {
          context.onError(
            createDOMCompilerError(
              60,
              value.loc
            )
          );
        }
      }
      const { tag } = node;
      const isCustomElement = context.isCustomElement(tag);
      if (tag === "input" || tag === "textarea" || tag === "select" || isCustomElement) {
        let directiveToUse = V_MODEL_TEXT;
        let isInvalidType = false;
        if (tag === "input" || isCustomElement) {
          const type = compilerCore.findProp(node, `type`);
          if (type) {
            if (type.type === 7) {
              directiveToUse = V_MODEL_DYNAMIC;
            } else if (type.value) {
              switch (type.value.content) {
                case "radio":
                  directiveToUse = V_MODEL_RADIO;
                  break;
                case "checkbox":
                  directiveToUse = V_MODEL_CHECKBOX;
                  break;
                case "file":
                  isInvalidType = true;
                  context.onError(
                    createDOMCompilerError(
                      59,
                      dir.loc
                    )
                  );
                  break;
                default:
                  checkDuplicatedValue();
                  break;
              }
            }
          } else if (compilerCore.hasDynamicKeyVBind(node)) {
            directiveToUse = V_MODEL_DYNAMIC;
          } else {
            checkDuplicatedValue();
          }
        } else if (tag === "select") {
          directiveToUse = V_MODEL_SELECT;
        } else {
          checkDuplicatedValue();
        }
        if (!isInvalidType) {
          baseResult.needRuntime = context.helper(directiveToUse);
        }
      } else {
        context.onError(
          createDOMCompilerError(
            57,
            dir.loc
          )
        );
      }
      baseResult.props = baseResult.props.filter(
        (p) => !(p.key.type === 4 && p.key.content === "modelValue")
      );
      return baseResult;
    };
    var isEventOptionModifier = shared.makeMap(`passive,once,capture`);
    var isNonKeyModifier = shared.makeMap(
      `stop,prevent,self,ctrl,shift,alt,meta,exact,middle`
    );
    var maybeKeyModifier = shared.makeMap("left,right");
    var isKeyboardEvent = shared.makeMap(
      `onkeyup,onkeydown,onkeypress`,
      true
    );
    var resolveModifiers = (key, modifiers, context, loc) => {
      const keyModifiers = [];
      const nonKeyModifiers = [];
      const eventOptionModifiers = [];
      for (let i = 0; i < modifiers.length; i++) {
        const modifier = modifiers[i];
        if (modifier === "native" && compilerCore.checkCompatEnabled(
          "COMPILER_V_ON_NATIVE",
          context,
          loc
        )) {
          eventOptionModifiers.push(modifier);
        } else if (isEventOptionModifier(modifier)) {
          eventOptionModifiers.push(modifier);
        } else {
          if (maybeKeyModifier(modifier)) {
            if (compilerCore.isStaticExp(key)) {
              if (isKeyboardEvent(key.content)) {
                keyModifiers.push(modifier);
              } else {
                nonKeyModifiers.push(modifier);
              }
            } else {
              keyModifiers.push(modifier);
              nonKeyModifiers.push(modifier);
            }
          } else {
            if (isNonKeyModifier(modifier)) {
              nonKeyModifiers.push(modifier);
            } else {
              keyModifiers.push(modifier);
            }
          }
        }
      }
      return {
        keyModifiers,
        nonKeyModifiers,
        eventOptionModifiers
      };
    };
    var transformClick = (key, event) => {
      const isStaticClick = compilerCore.isStaticExp(key) && key.content.toLowerCase() === "onclick";
      return isStaticClick ? compilerCore.createSimpleExpression(event, true) : key.type !== 4 ? compilerCore.createCompoundExpression([
        `(`,
        key,
        `) === "onClick" ? "${event}" : (`,
        key,
        `)`
      ]) : key;
    };
    var transformOn = (dir, node, context) => {
      return compilerCore.transformOn(dir, node, context, (baseResult) => {
        const { modifiers } = dir;
        if (!modifiers.length)
          return baseResult;
        let { key, value: handlerExp } = baseResult.props[0];
        const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);
        if (nonKeyModifiers.includes("right")) {
          key = transformClick(key, `onContextmenu`);
        }
        if (nonKeyModifiers.includes("middle")) {
          key = transformClick(key, `onMouseup`);
        }
        if (nonKeyModifiers.length) {
          handlerExp = compilerCore.createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
            handlerExp,
            JSON.stringify(nonKeyModifiers)
          ]);
        }
        if (keyModifiers.length && (!compilerCore.isStaticExp(key) || isKeyboardEvent(key.content))) {
          handlerExp = compilerCore.createCallExpression(context.helper(V_ON_WITH_KEYS), [
            handlerExp,
            JSON.stringify(keyModifiers)
          ]);
        }
        if (eventOptionModifiers.length) {
          const modifierPostfix = eventOptionModifiers.map(shared.capitalize).join("");
          key = compilerCore.isStaticExp(key) ? compilerCore.createSimpleExpression(`${key.content}${modifierPostfix}`, true) : compilerCore.createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);
        }
        return {
          props: [compilerCore.createObjectProperty(key, handlerExp)]
        };
      });
    };
    var transformShow = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
        context.onError(
          createDOMCompilerError(61, loc)
        );
      }
      return {
        props: [],
        needRuntime: context.helper(V_SHOW)
      };
    };
    var transformTransition = (node, context) => {
      if (node.type === 1 && node.tagType === 1) {
        const component = context.isBuiltInComponent(node.tag);
        if (component === TRANSITION) {
          return () => {
            if (!node.children.length) {
              return;
            }
            if (hasMultipleChildren(node)) {
              context.onError(
                createDOMCompilerError(
                  62,
                  {
                    start: node.children[0].loc.start,
                    end: node.children[node.children.length - 1].loc.end,
                    source: ""
                  }
                )
              );
            }
            const child = node.children[0];
            if (child.type === 1) {
              for (const p of child.props) {
                if (p.type === 7 && p.name === "show") {
                  node.props.push({
                    type: 6,
                    name: "persisted",
                    nameLoc: node.loc,
                    value: void 0,
                    loc: node.loc
                  });
                }
              }
            }
          };
        }
      }
    };
    function hasMultipleChildren(node) {
      const children = node.children = node.children.filter(
        (c) => c.type !== 3 && !(c.type === 2 && !c.content.trim())
      );
      const child = children[0];
      return children.length !== 1 || child.type === 11 || child.type === 9 && child.branches.some(hasMultipleChildren);
    }
    var expReplaceRE = /__VUE_EXP_START__(.*?)__VUE_EXP_END__/g;
    var stringifyStatic = (children, context, parent) => {
      if (context.scopes.vSlot > 0) {
        return;
      }
      let nc = 0;
      let ec = 0;
      const currentChunk = [];
      const stringifyCurrentChunk = (currentIndex) => {
        if (nc >= 20 || ec >= 5) {
          const staticCall = compilerCore.createCallExpression(context.helper(compilerCore.CREATE_STATIC), [
            JSON.stringify(
              currentChunk.map((node) => stringifyNode(node, context)).join("")
            ).replace(expReplaceRE, `" + $1 + "`),
            String(currentChunk.length)
          ]);
          replaceHoist(currentChunk[0], staticCall, context);
          if (currentChunk.length > 1) {
            for (let i2 = 1; i2 < currentChunk.length; i2++) {
              replaceHoist(currentChunk[i2], null, context);
            }
            const deleteCount = currentChunk.length - 1;
            children.splice(currentIndex - currentChunk.length + 1, deleteCount);
            return deleteCount;
          }
        }
        return 0;
      };
      let i = 0;
      for (; i < children.length; i++) {
        const child = children[i];
        const hoisted = getHoistedNode(child);
        if (hoisted) {
          const node = child;
          const result = analyzeNode(node);
          if (result) {
            nc += result[0];
            ec += result[1];
            currentChunk.push(node);
            continue;
          }
        }
        i -= stringifyCurrentChunk(i);
        nc = 0;
        ec = 0;
        currentChunk.length = 0;
      }
      stringifyCurrentChunk(i);
    };
    var getHoistedNode = (node) => (node.type === 1 && node.tagType === 0 || node.type == 12) && node.codegenNode && node.codegenNode.type === 4 && node.codegenNode.hoisted;
    var dataAriaRE = /^(data|aria)-/;
    var isStringifiableAttr = (name, ns) => {
      return (ns === 0 ? shared.isKnownHtmlAttr(name) : ns === 1 ? shared.isKnownSvgAttr(name) : false) || dataAriaRE.test(name);
    };
    var replaceHoist = (node, replacement, context) => {
      const hoistToReplace = node.codegenNode.hoisted;
      context.hoists[context.hoists.indexOf(hoistToReplace)] = replacement;
    };
    var isNonStringifiable = shared.makeMap(
      `caption,thead,tr,th,tbody,td,tfoot,colgroup,col`
    );
    function analyzeNode(node) {
      if (node.type === 1 && isNonStringifiable(node.tag)) {
        return false;
      }
      if (node.type === 12) {
        return [1, 0];
      }
      let nc = 1;
      let ec = node.props.length > 0 ? 1 : 0;
      let bailed = false;
      const bail = () => {
        bailed = true;
        return false;
      };
      function walk(node2) {
        const isOptionTag = node2.tag === "option" && node2.ns === 0;
        for (let i = 0; i < node2.props.length; i++) {
          const p = node2.props[i];
          if (p.type === 6 && !isStringifiableAttr(p.name, node2.ns)) {
            return bail();
          }
          if (p.type === 7 && p.name === "bind") {
            if (p.arg && (p.arg.type === 8 || p.arg.isStatic && !isStringifiableAttr(p.arg.content, node2.ns))) {
              return bail();
            }
            if (p.exp && (p.exp.type === 8 || p.exp.constType < 3)) {
              return bail();
            }
            if (isOptionTag && compilerCore.isStaticArgOf(p.arg, "value") && p.exp && p.exp.ast && p.exp.ast.type !== "StringLiteral") {
              return bail();
            }
          }
        }
        for (let i = 0; i < node2.children.length; i++) {
          nc++;
          const child = node2.children[i];
          if (child.type === 1) {
            if (child.props.length > 0) {
              ec++;
            }
            walk(child);
            if (bailed) {
              return false;
            }
          }
        }
        return true;
      }
      return walk(node) ? [nc, ec] : false;
    }
    function stringifyNode(node, context) {
      if (shared.isString(node)) {
        return node;
      }
      if (shared.isSymbol(node)) {
        return ``;
      }
      switch (node.type) {
        case 1:
          return stringifyElement(node, context);
        case 2:
          return shared.escapeHtml(node.content);
        case 3:
          return `<!--${shared.escapeHtml(node.content)}-->`;
        case 5:
          return shared.escapeHtml(shared.toDisplayString(evaluateConstant(node.content)));
        case 8:
          return shared.escapeHtml(evaluateConstant(node));
        case 12:
          return stringifyNode(node.content, context);
        default:
          return "";
      }
    }
    function stringifyElement(node, context) {
      let res = `<${node.tag}`;
      let innerHTML = "";
      for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 6) {
          res += ` ${p.name}`;
          if (p.value) {
            res += `="${shared.escapeHtml(p.value.content)}"`;
          }
        } else if (p.type === 7) {
          if (p.name === "bind") {
            const exp = p.exp;
            if (exp.content[0] === "_") {
              res += ` ${p.arg.content}="__VUE_EXP_START__${exp.content}__VUE_EXP_END__"`;
              continue;
            }
            if (shared.isBooleanAttr(p.arg.content) && exp.content === "false") {
              continue;
            }
            let evaluated = evaluateConstant(exp);
            if (evaluated != null) {
              const arg = p.arg && p.arg.content;
              if (arg === "class") {
                evaluated = shared.normalizeClass(evaluated);
              } else if (arg === "style") {
                evaluated = shared.stringifyStyle(shared.normalizeStyle(evaluated));
              }
              res += ` ${p.arg.content}="${shared.escapeHtml(
                evaluated
              )}"`;
            }
          } else if (p.name === "html") {
            innerHTML = evaluateConstant(p.exp);
          } else if (p.name === "text") {
            innerHTML = shared.escapeHtml(
              shared.toDisplayString(evaluateConstant(p.exp))
            );
          }
        }
      }
      if (context.scopeId) {
        res += ` ${context.scopeId}`;
      }
      res += `>`;
      if (innerHTML) {
        res += innerHTML;
      } else {
        for (let i = 0; i < node.children.length; i++) {
          res += stringifyNode(node.children[i], context);
        }
      }
      if (!shared.isVoidTag(node.tag)) {
        res += `</${node.tag}>`;
      }
      return res;
    }
    function evaluateConstant(exp) {
      if (exp.type === 4) {
        return new Function(`return (${exp.content})`)();
      } else {
        let res = ``;
        exp.children.forEach((c) => {
          if (shared.isString(c) || shared.isSymbol(c)) {
            return;
          }
          if (c.type === 2) {
            res += c.content;
          } else if (c.type === 5) {
            res += shared.toDisplayString(evaluateConstant(c.content));
          } else {
            res += evaluateConstant(c);
          }
        });
        return res;
      }
    }
    var ignoreSideEffectTags = (node, context) => {
      if (node.type === 1 && node.tagType === 0 && (node.tag === "script" || node.tag === "style")) {
        context.onError(
          createDOMCompilerError(
            63,
            node.loc
          )
        );
        context.removeNode();
      }
    };
    var DOMNodeTransforms = [
      transformStyle,
      ...[transformTransition]
    ];
    var DOMDirectiveTransforms = {
      cloak: compilerCore.noopDirectiveTransform,
      html: transformVHtml,
      text: transformVText,
      model: transformModel,
      on: transformOn,
      show: transformShow
    };
    function compile(src, options = {}) {
      return compilerCore.baseCompile(
        src,
        shared.extend({}, parserOptions, options, {
          nodeTransforms: [
            ignoreSideEffectTags,
            ...DOMNodeTransforms,
            ...options.nodeTransforms || []
          ],
          directiveTransforms: shared.extend(
            {},
            DOMDirectiveTransforms,
            options.directiveTransforms || {}
          ),
          transformHoist: stringifyStatic
        })
      );
    }
    function parse(template, options = {}) {
      return compilerCore.baseParse(template, shared.extend({}, parserOptions, options));
    }
    exports.DOMDirectiveTransforms = DOMDirectiveTransforms;
    exports.DOMErrorCodes = DOMErrorCodes;
    exports.DOMErrorMessages = DOMErrorMessages;
    exports.DOMNodeTransforms = DOMNodeTransforms;
    exports.TRANSITION = TRANSITION;
    exports.TRANSITION_GROUP = TRANSITION_GROUP;
    exports.V_MODEL_CHECKBOX = V_MODEL_CHECKBOX;
    exports.V_MODEL_DYNAMIC = V_MODEL_DYNAMIC;
    exports.V_MODEL_RADIO = V_MODEL_RADIO;
    exports.V_MODEL_SELECT = V_MODEL_SELECT;
    exports.V_MODEL_TEXT = V_MODEL_TEXT;
    exports.V_ON_WITH_KEYS = V_ON_WITH_KEYS;
    exports.V_ON_WITH_MODIFIERS = V_ON_WITH_MODIFIERS;
    exports.V_SHOW = V_SHOW;
    exports.compile = compile;
    exports.createDOMCompilerError = createDOMCompilerError;
    exports.parse = parse;
    exports.parserOptions = parserOptions;
    exports.transformStyle = transformStyle;
    Object.keys(compilerCore).forEach(function(k) {
      if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k))
        exports[k] = compilerCore[k];
    });
  }
});

// node_modules/@vue/compiler-dom/index.js
var require_compiler_dom = __commonJS({
  "node_modules/@vue/compiler-dom/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_compiler_dom_cjs();
    }
  }
});

// node_modules/@vue/reactivity/dist/reactivity.cjs.js
var require_reactivity_cjs = __commonJS({
  "node_modules/@vue/reactivity/dist/reactivity.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var shared = require_shared();
    function warn(msg, ...args) {
      console.warn(`[Vue warn] ${msg}`, ...args);
    }
    var activeEffectScope;
    var EffectScope = class {
      constructor(detached = false) {
        this.detached = detached;
        this._active = true;
        this.effects = [];
        this.cleanups = [];
        this.parent = activeEffectScope;
        if (!detached && activeEffectScope) {
          this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
            this
          ) - 1;
        }
      }
      get active() {
        return this._active;
      }
      run(fn) {
        if (this._active) {
          const currentEffectScope = activeEffectScope;
          try {
            activeEffectScope = this;
            return fn();
          } finally {
            activeEffectScope = currentEffectScope;
          }
        } else {
          warn(`cannot run an inactive effect scope.`);
        }
      }
      on() {
        activeEffectScope = this;
      }
      off() {
        activeEffectScope = this.parent;
      }
      stop(fromParent) {
        if (this._active) {
          let i, l;
          for (i = 0, l = this.effects.length; i < l; i++) {
            this.effects[i].stop();
          }
          for (i = 0, l = this.cleanups.length; i < l; i++) {
            this.cleanups[i]();
          }
          if (this.scopes) {
            for (i = 0, l = this.scopes.length; i < l; i++) {
              this.scopes[i].stop(true);
            }
          }
          if (!this.detached && this.parent && !fromParent) {
            const last = this.parent.scopes.pop();
            if (last && last !== this) {
              this.parent.scopes[this.index] = last;
              last.index = this.index;
            }
          }
          this.parent = void 0;
          this._active = false;
        }
      }
    };
    function effectScope(detached) {
      return new EffectScope(detached);
    }
    function recordEffectScope(effect2, scope = activeEffectScope) {
      if (scope && scope.active) {
        scope.effects.push(effect2);
      }
    }
    function getCurrentScope() {
      return activeEffectScope;
    }
    function onScopeDispose(fn) {
      if (activeEffectScope) {
        activeEffectScope.cleanups.push(fn);
      } else {
        warn(
          `onScopeDispose() is called when there is no active effect scope to be associated with.`
        );
      }
    }
    var activeEffect;
    var ReactiveEffect = class {
      constructor(fn, trigger2, scheduler, scope) {
        this.fn = fn;
        this.trigger = trigger2;
        this.scheduler = scheduler;
        this.active = true;
        this.deps = [];
        this._dirtyLevel = 5;
        this._trackId = 0;
        this._runnings = 0;
        this._shouldSchedule = false;
        this._depsLength = 0;
        recordEffectScope(this, scope);
      }
      get dirty() {
        if (this._dirtyLevel === 2)
          return false;
        if (this._dirtyLevel === 3 || this._dirtyLevel === 4) {
          this._dirtyLevel = 1;
          pauseTracking();
          for (let i = 0; i < this._depsLength; i++) {
            const dep = this.deps[i];
            if (dep.computed) {
              if (dep.computed.effect._dirtyLevel === 2)
                return true;
              triggerComputed(dep.computed);
              if (this._dirtyLevel >= 5) {
                break;
              }
            }
          }
          if (this._dirtyLevel === 1) {
            this._dirtyLevel = 0;
          }
          resetTracking();
        }
        return this._dirtyLevel >= 5;
      }
      set dirty(v) {
        this._dirtyLevel = v ? 5 : 0;
      }
      run() {
        this._dirtyLevel = 0;
        if (!this.active) {
          return this.fn();
        }
        let lastShouldTrack = shouldTrack;
        let lastEffect = activeEffect;
        try {
          shouldTrack = true;
          activeEffect = this;
          this._runnings++;
          preCleanupEffect(this);
          return this.fn();
        } finally {
          postCleanupEffect(this);
          this._runnings--;
          activeEffect = lastEffect;
          shouldTrack = lastShouldTrack;
        }
      }
      stop() {
        if (this.active) {
          preCleanupEffect(this);
          postCleanupEffect(this);
          this.onStop && this.onStop();
          this.active = false;
        }
      }
    };
    function triggerComputed(computed2) {
      return computed2.value;
    }
    function preCleanupEffect(effect2) {
      effect2._trackId++;
      effect2._depsLength = 0;
    }
    function postCleanupEffect(effect2) {
      if (effect2.deps.length > effect2._depsLength) {
        for (let i = effect2._depsLength; i < effect2.deps.length; i++) {
          cleanupDepEffect(effect2.deps[i], effect2);
        }
        effect2.deps.length = effect2._depsLength;
      }
    }
    function cleanupDepEffect(dep, effect2) {
      const trackId = dep.get(effect2);
      if (trackId !== void 0 && effect2._trackId !== trackId) {
        dep.delete(effect2);
        if (dep.size === 0) {
          dep.cleanup();
        }
      }
    }
    function effect(fn, options) {
      if (fn.effect instanceof ReactiveEffect) {
        fn = fn.effect.fn;
      }
      const _effect = new ReactiveEffect(fn, shared.NOOP, () => {
        if (_effect.dirty) {
          _effect.run();
        }
      });
      if (options) {
        shared.extend(_effect, options);
        if (options.scope)
          recordEffectScope(_effect, options.scope);
      }
      if (!options || !options.lazy) {
        _effect.run();
      }
      const runner = _effect.run.bind(_effect);
      runner.effect = _effect;
      return runner;
    }
    function stop(runner) {
      runner.effect.stop();
    }
    var shouldTrack = true;
    var pauseScheduleStack = 0;
    var trackStack = [];
    function pauseTracking() {
      trackStack.push(shouldTrack);
      shouldTrack = false;
    }
    function enableTracking() {
      trackStack.push(shouldTrack);
      shouldTrack = true;
    }
    function resetTracking() {
      const last = trackStack.pop();
      shouldTrack = last === void 0 ? true : last;
    }
    function pauseScheduling() {
      pauseScheduleStack++;
    }
    function resetScheduling() {
      pauseScheduleStack--;
      while (!pauseScheduleStack && queueEffectSchedulers.length) {
        queueEffectSchedulers.shift()();
      }
    }
    function trackEffect(effect2, dep, debuggerEventExtraInfo) {
      var _a;
      if (dep.get(effect2) !== effect2._trackId) {
        dep.set(effect2, effect2._trackId);
        const oldDep = effect2.deps[effect2._depsLength];
        if (oldDep !== dep) {
          if (oldDep) {
            cleanupDepEffect(oldDep, effect2);
          }
          effect2.deps[effect2._depsLength++] = dep;
        } else {
          effect2._depsLength++;
        }
        {
          (_a = effect2.onTrack) == null ? void 0 : _a.call(effect2, shared.extend({ effect: effect2 }, debuggerEventExtraInfo));
        }
      }
    }
    var queueEffectSchedulers = [];
    function triggerEffects(dep, dirtyLevel, debuggerEventExtraInfo) {
      var _a;
      pauseScheduling();
      for (const effect2 of dep.keys()) {
        if (!dep.computed && effect2.computed) {
          if (dep.get(effect2) === effect2._trackId && effect2._runnings > 0) {
            effect2._dirtyLevel = 2;
            continue;
          }
        }
        let tracking;
        if (effect2._dirtyLevel < dirtyLevel && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
          effect2._shouldSchedule || (effect2._shouldSchedule = effect2._dirtyLevel === 0);
          if (effect2.computed && effect2._dirtyLevel === 2) {
            effect2._shouldSchedule = true;
          }
          effect2._dirtyLevel = dirtyLevel;
        }
        if (effect2._shouldSchedule && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
          {
            (_a = effect2.onTrigger) == null ? void 0 : _a.call(effect2, shared.extend({ effect: effect2 }, debuggerEventExtraInfo));
          }
          effect2.trigger();
          if ((!effect2._runnings || effect2.allowRecurse) && effect2._dirtyLevel !== 3) {
            effect2._shouldSchedule = false;
            if (effect2.scheduler) {
              queueEffectSchedulers.push(effect2.scheduler);
            }
          }
        }
      }
      resetScheduling();
    }
    var createDep = (cleanup, computed2) => {
      const dep = /* @__PURE__ */ new Map();
      dep.cleanup = cleanup;
      dep.computed = computed2;
      return dep;
    };
    var targetMap = /* @__PURE__ */ new WeakMap();
    var ITERATE_KEY = Symbol("iterate");
    var MAP_KEY_ITERATE_KEY = Symbol("Map key iterate");
    function track(target, type, key) {
      if (shouldTrack && activeEffect) {
        let depsMap = targetMap.get(target);
        if (!depsMap) {
          targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
        }
        let dep = depsMap.get(key);
        if (!dep) {
          depsMap.set(key, dep = createDep(() => depsMap.delete(key)));
        }
        trackEffect(
          activeEffect,
          dep,
          {
            target,
            type,
            key
          }
        );
      }
    }
    function trigger(target, type, key, newValue, oldValue, oldTarget) {
      const depsMap = targetMap.get(target);
      if (!depsMap) {
        return;
      }
      let deps = [];
      if (type === "clear") {
        deps = [...depsMap.values()];
      } else if (key === "length" && shared.isArray(target)) {
        const newLength = Number(newValue);
        depsMap.forEach((dep, key2) => {
          if (key2 === "length" || !shared.isSymbol(key2) && key2 >= newLength) {
            deps.push(dep);
          }
        });
      } else {
        if (key !== void 0) {
          deps.push(depsMap.get(key));
        }
        switch (type) {
          case "add":
            if (!shared.isArray(target)) {
              deps.push(depsMap.get(ITERATE_KEY));
              if (shared.isMap(target)) {
                deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            } else if (shared.isIntegerKey(key)) {
              deps.push(depsMap.get("length"));
            }
            break;
          case "delete":
            if (!shared.isArray(target)) {
              deps.push(depsMap.get(ITERATE_KEY));
              if (shared.isMap(target)) {
                deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            }
            break;
          case "set":
            if (shared.isMap(target)) {
              deps.push(depsMap.get(ITERATE_KEY));
            }
            break;
        }
      }
      pauseScheduling();
      for (const dep of deps) {
        if (dep) {
          triggerEffects(
            dep,
            5,
            {
              target,
              type,
              key,
              newValue,
              oldValue,
              oldTarget
            }
          );
        }
      }
      resetScheduling();
    }
    function getDepFromReactive(object, key) {
      const depsMap = targetMap.get(object);
      return depsMap && depsMap.get(key);
    }
    var isNonTrackableKeys = shared.makeMap(`__proto__,__v_isRef,__isVue`);
    var builtInSymbols = new Set(
      Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(shared.isSymbol)
    );
    var arrayInstrumentations = createArrayInstrumentations();
    function createArrayInstrumentations() {
      const instrumentations = {};
      ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
        instrumentations[key] = function(...args) {
          const arr = toRaw(this);
          for (let i = 0, l = this.length; i < l; i++) {
            track(arr, "get", i + "");
          }
          const res = arr[key](...args);
          if (res === -1 || res === false) {
            return arr[key](...args.map(toRaw));
          } else {
            return res;
          }
        };
      });
      ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
        instrumentations[key] = function(...args) {
          pauseTracking();
          pauseScheduling();
          const res = toRaw(this)[key].apply(this, args);
          resetScheduling();
          resetTracking();
          return res;
        };
      });
      return instrumentations;
    }
    function hasOwnProperty2(key) {
      if (!shared.isSymbol(key))
        key = String(key);
      const obj = toRaw(this);
      track(obj, "has", key);
      return obj.hasOwnProperty(key);
    }
    var BaseReactiveHandler = class {
      constructor(_isReadonly = false, _isShallow = false) {
        this._isReadonly = _isReadonly;
        this._isShallow = _isShallow;
      }
      get(target, key, receiver) {
        const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_isShallow") {
          return isShallow2;
        } else if (key === "__v_raw") {
          if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
            return target;
          }
          return;
        }
        const targetIsArray = shared.isArray(target);
        if (!isReadonly2) {
          if (targetIsArray && shared.hasOwn(arrayInstrumentations, key)) {
            return Reflect.get(arrayInstrumentations, key, receiver);
          }
          if (key === "hasOwnProperty") {
            return hasOwnProperty2;
          }
        }
        const res = Reflect.get(target, key, receiver);
        if (shared.isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
          return res;
        }
        if (!isReadonly2) {
          track(target, "get", key);
        }
        if (isShallow2) {
          return res;
        }
        if (isRef(res)) {
          return targetIsArray && shared.isIntegerKey(key) ? res : res.value;
        }
        if (shared.isObject(res)) {
          return isReadonly2 ? readonly(res) : reactive(res);
        }
        return res;
      }
    };
    var MutableReactiveHandler = class extends BaseReactiveHandler {
      constructor(isShallow2 = false) {
        super(false, isShallow2);
      }
      set(target, key, value, receiver) {
        let oldValue = target[key];
        if (!this._isShallow) {
          const isOldValueReadonly = isReadonly(oldValue);
          if (!isShallow(value) && !isReadonly(value)) {
            oldValue = toRaw(oldValue);
            value = toRaw(value);
          }
          if (!shared.isArray(target) && isRef(oldValue) && !isRef(value)) {
            if (isOldValueReadonly) {
              return false;
            } else {
              oldValue.value = value;
              return true;
            }
          }
        }
        const hadKey = shared.isArray(target) && shared.isIntegerKey(key) ? Number(key) < target.length : shared.hasOwn(target, key);
        const result = Reflect.set(target, key, value, receiver);
        if (target === toRaw(receiver)) {
          if (!hadKey) {
            trigger(target, "add", key, value);
          } else if (shared.hasChanged(value, oldValue)) {
            trigger(target, "set", key, value, oldValue);
          }
        }
        return result;
      }
      deleteProperty(target, key) {
        const hadKey = shared.hasOwn(target, key);
        const oldValue = target[key];
        const result = Reflect.deleteProperty(target, key);
        if (result && hadKey) {
          trigger(target, "delete", key, void 0, oldValue);
        }
        return result;
      }
      has(target, key) {
        const result = Reflect.has(target, key);
        if (!shared.isSymbol(key) || !builtInSymbols.has(key)) {
          track(target, "has", key);
        }
        return result;
      }
      ownKeys(target) {
        track(
          target,
          "iterate",
          shared.isArray(target) ? "length" : ITERATE_KEY
        );
        return Reflect.ownKeys(target);
      }
    };
    var ReadonlyReactiveHandler = class extends BaseReactiveHandler {
      constructor(isShallow2 = false) {
        super(true, isShallow2);
      }
      set(target, key) {
        {
          warn(
            `Set operation on key "${String(key)}" failed: target is readonly.`,
            target
          );
        }
        return true;
      }
      deleteProperty(target, key) {
        {
          warn(
            `Delete operation on key "${String(key)}" failed: target is readonly.`,
            target
          );
        }
        return true;
      }
    };
    var mutableHandlers = new MutableReactiveHandler();
    var readonlyHandlers = new ReadonlyReactiveHandler();
    var shallowReactiveHandlers = new MutableReactiveHandler(
      true
    );
    var shallowReadonlyHandlers = new ReadonlyReactiveHandler(true);
    var toShallow = (value) => value;
    var getProto = (v) => Reflect.getPrototypeOf(v);
    function get(target, key, isReadonly2 = false, isShallow2 = false) {
      target = target["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!isReadonly2) {
        if (shared.hasChanged(key, rawKey)) {
          track(rawTarget, "get", key);
        }
        track(rawTarget, "get", rawKey);
      }
      const { has: has2 } = getProto(rawTarget);
      const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      if (has2.call(rawTarget, key)) {
        return wrap(target.get(key));
      } else if (has2.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
      } else if (target !== rawTarget) {
        target.get(key);
      }
    }
    function has(key, isReadonly2 = false) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!isReadonly2) {
        if (shared.hasChanged(key, rawKey)) {
          track(rawTarget, "has", key);
        }
        track(rawTarget, "has", rawKey);
      }
      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
    }
    function size(target, isReadonly2 = false) {
      target = target["__v_raw"];
      !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
      return Reflect.get(target, "size", target);
    }
    function add(value) {
      value = toRaw(value);
      const target = toRaw(this);
      const proto = getProto(target);
      const hadKey = proto.has.call(target, value);
      if (!hadKey) {
        target.add(value);
        trigger(target, "add", value, value);
      }
      return this;
    }
    function set(key, value) {
      value = toRaw(value);
      const target = toRaw(this);
      const { has: has2, get: get2 } = getProto(target);
      let hadKey = has2.call(target, key);
      if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target, key);
      } else {
        checkIdentityKeys(target, has2, key);
      }
      const oldValue = get2.call(target, key);
      target.set(key, value);
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (shared.hasChanged(value, oldValue)) {
        trigger(target, "set", key, value, oldValue);
      }
      return this;
    }
    function deleteEntry(key) {
      const target = toRaw(this);
      const { has: has2, get: get2 } = getProto(target);
      let hadKey = has2.call(target, key);
      if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target, key);
      } else {
        checkIdentityKeys(target, has2, key);
      }
      const oldValue = get2 ? get2.call(target, key) : void 0;
      const result = target.delete(key);
      if (hadKey) {
        trigger(target, "delete", key, void 0, oldValue);
      }
      return result;
    }
    function clear() {
      const target = toRaw(this);
      const hadItems = target.size !== 0;
      const oldTarget = shared.isMap(target) ? new Map(target) : new Set(target);
      const result = target.clear();
      if (hadItems) {
        trigger(target, "clear", void 0, void 0, oldTarget);
      }
      return result;
    }
    function createForEach(isReadonly2, isShallow2) {
      return function forEach(callback, thisArg) {
        const observed = this;
        const target = observed["__v_raw"];
        const rawTarget = toRaw(target);
        const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
        return target.forEach((value, key) => {
          return callback.call(thisArg, wrap(value), wrap(key), observed);
        });
      };
    }
    function createIterableMethod(method, isReadonly2, isShallow2) {
      return function(...args) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const targetIsMap = shared.isMap(rawTarget);
        const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
        const isKeyOnly = method === "keys" && targetIsMap;
        const innerIterator = target[method](...args);
        const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(
          rawTarget,
          "iterate",
          isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
        );
        return {
          next() {
            const { value, done } = innerIterator.next();
            return done ? { value, done } : {
              value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
              done
            };
          },
          [Symbol.iterator]() {
            return this;
          }
        };
      };
    }
    function createReadonlyMethod(type) {
      return function(...args) {
        {
          const key = args[0] ? `on key "${args[0]}" ` : ``;
          warn(
            `${shared.capitalize(type)} operation ${key}failed: target is readonly.`,
            toRaw(this)
          );
        }
        return type === "delete" ? false : type === "clear" ? void 0 : this;
      };
    }
    function createInstrumentations() {
      const mutableInstrumentations2 = {
        get(key) {
          return get(this, key);
        },
        get size() {
          return size(this);
        },
        has,
        add,
        set,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, false)
      };
      const shallowInstrumentations2 = {
        get(key) {
          return get(this, key, false, true);
        },
        get size() {
          return size(this);
        },
        has,
        add,
        set,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, true)
      };
      const readonlyInstrumentations2 = {
        get(key) {
          return get(this, key, true);
        },
        get size() {
          return size(this, true);
        },
        has(key) {
          return has.call(this, key, true);
        },
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear"),
        forEach: createForEach(true, false)
      };
      const shallowReadonlyInstrumentations2 = {
        get(key) {
          return get(this, key, true, true);
        },
        get size() {
          return size(this, true);
        },
        has(key) {
          return has.call(this, key, true);
        },
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear"),
        forEach: createForEach(true, true)
      };
      const iteratorMethods = [
        "keys",
        "values",
        "entries",
        Symbol.iterator
      ];
      iteratorMethods.forEach((method) => {
        mutableInstrumentations2[method] = createIterableMethod(method, false, false);
        readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
        shallowInstrumentations2[method] = createIterableMethod(method, false, true);
        shallowReadonlyInstrumentations2[method] = createIterableMethod(
          method,
          true,
          true
        );
      });
      return [
        mutableInstrumentations2,
        readonlyInstrumentations2,
        shallowInstrumentations2,
        shallowReadonlyInstrumentations2
      ];
    }
    var [
      mutableInstrumentations,
      readonlyInstrumentations,
      shallowInstrumentations,
      shallowReadonlyInstrumentations
    ] = createInstrumentations();
    function createInstrumentationGetter(isReadonly2, shallow) {
      const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
      return (target, key, receiver) => {
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_raw") {
          return target;
        }
        return Reflect.get(
          shared.hasOwn(instrumentations, key) && key in target ? instrumentations : target,
          key,
          receiver
        );
      };
    }
    var mutableCollectionHandlers = {
      get: createInstrumentationGetter(false, false)
    };
    var shallowCollectionHandlers = {
      get: createInstrumentationGetter(false, true)
    };
    var readonlyCollectionHandlers = {
      get: createInstrumentationGetter(true, false)
    };
    var shallowReadonlyCollectionHandlers = {
      get: createInstrumentationGetter(true, true)
    };
    function checkIdentityKeys(target, has2, key) {
      const rawKey = toRaw(key);
      if (rawKey !== key && has2.call(target, rawKey)) {
        const type = shared.toRawType(target);
        warn(
          `Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
        );
      }
    }
    var reactiveMap = /* @__PURE__ */ new WeakMap();
    var shallowReactiveMap = /* @__PURE__ */ new WeakMap();
    var readonlyMap = /* @__PURE__ */ new WeakMap();
    var shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
    function targetTypeMap(rawType) {
      switch (rawType) {
        case "Object":
        case "Array":
          return 1;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
          return 2;
        default:
          return 0;
      }
    }
    function getTargetType(value) {
      return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(shared.toRawType(value));
    }
    function reactive(target) {
      if (isReadonly(target)) {
        return target;
      }
      return createReactiveObject(
        target,
        false,
        mutableHandlers,
        mutableCollectionHandlers,
        reactiveMap
      );
    }
    function shallowReactive(target) {
      return createReactiveObject(
        target,
        false,
        shallowReactiveHandlers,
        shallowCollectionHandlers,
        shallowReactiveMap
      );
    }
    function readonly(target) {
      return createReactiveObject(
        target,
        true,
        readonlyHandlers,
        readonlyCollectionHandlers,
        readonlyMap
      );
    }
    function shallowReadonly(target) {
      return createReactiveObject(
        target,
        true,
        shallowReadonlyHandlers,
        shallowReadonlyCollectionHandlers,
        shallowReadonlyMap
      );
    }
    function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
      if (!shared.isObject(target)) {
        {
          warn(
            `value cannot be made ${isReadonly2 ? "readonly" : "reactive"}: ${String(
              target
            )}`
          );
        }
        return target;
      }
      if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
        return target;
      }
      const existingProxy = proxyMap.get(target);
      if (existingProxy) {
        return existingProxy;
      }
      const targetType = getTargetType(target);
      if (targetType === 0) {
        return target;
      }
      const proxy = new Proxy(
        target,
        targetType === 2 ? collectionHandlers : baseHandlers
      );
      proxyMap.set(target, proxy);
      return proxy;
    }
    function isReactive(value) {
      if (isReadonly(value)) {
        return isReactive(value["__v_raw"]);
      }
      return !!(value && value["__v_isReactive"]);
    }
    function isReadonly(value) {
      return !!(value && value["__v_isReadonly"]);
    }
    function isShallow(value) {
      return !!(value && value["__v_isShallow"]);
    }
    function isProxy(value) {
      return value ? !!value["__v_raw"] : false;
    }
    function toRaw(observed) {
      const raw = observed && observed["__v_raw"];
      return raw ? toRaw(raw) : observed;
    }
    function markRaw(value) {
      if (Object.isExtensible(value)) {
        shared.def(value, "__v_skip", true);
      }
      return value;
    }
    var toReactive = (value) => shared.isObject(value) ? reactive(value) : value;
    var toReadonly = (value) => shared.isObject(value) ? readonly(value) : value;
    var COMPUTED_SIDE_EFFECT_WARN = `Computed is still dirty after getter evaluation, likely because a computed is mutating its own dependency in its getter. State mutations in computed getters should be avoided.  Check the docs for more details: https://vuejs.org/guide/essentials/computed.html#getters-should-be-side-effect-free`;
    var ComputedRefImpl = class {
      constructor(getter, _setter, isReadonly2, isSSR) {
        this.getter = getter;
        this._setter = _setter;
        this.dep = void 0;
        this.__v_isRef = true;
        this["__v_isReadonly"] = false;
        this.effect = new ReactiveEffect(
          () => getter(this._value),
          () => triggerRefValue(
            this,
            this.effect._dirtyLevel === 3 ? 3 : 4
          )
        );
        this.effect.computed = this;
        this.effect.active = this._cacheable = !isSSR;
        this["__v_isReadonly"] = isReadonly2;
      }
      get value() {
        const self2 = toRaw(this);
        if ((!self2._cacheable || self2.effect.dirty) && shared.hasChanged(self2._value, self2._value = self2.effect.run())) {
          triggerRefValue(self2, 5);
        }
        trackRefValue(self2);
        if (self2.effect._dirtyLevel >= 2) {
          if (this._warnRecursive) {
            warn(COMPUTED_SIDE_EFFECT_WARN, `

getter: `, this.getter);
          }
          triggerRefValue(self2, 3);
        }
        return self2._value;
      }
      set value(newValue) {
        this._setter(newValue);
      }
      get _dirty() {
        return this.effect.dirty;
      }
      set _dirty(v) {
        this.effect.dirty = v;
      }
    };
    function computed(getterOrOptions, debugOptions, isSSR = false) {
      let getter;
      let setter;
      const onlyGetter = shared.isFunction(getterOrOptions);
      if (onlyGetter) {
        getter = getterOrOptions;
        setter = () => {
          warn("Write operation failed: computed value is readonly");
        };
      } else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
      }
      const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
      if (debugOptions && !isSSR) {
        cRef.effect.onTrack = debugOptions.onTrack;
        cRef.effect.onTrigger = debugOptions.onTrigger;
      }
      return cRef;
    }
    function trackRefValue(ref2) {
      var _a;
      if (shouldTrack && activeEffect) {
        ref2 = toRaw(ref2);
        trackEffect(
          activeEffect,
          (_a = ref2.dep) != null ? _a : ref2.dep = createDep(
            () => ref2.dep = void 0,
            ref2 instanceof ComputedRefImpl ? ref2 : void 0
          ),
          {
            target: ref2,
            type: "get",
            key: "value"
          }
        );
      }
    }
    function triggerRefValue(ref2, dirtyLevel = 5, newVal, oldVal) {
      ref2 = toRaw(ref2);
      const dep = ref2.dep;
      if (dep) {
        triggerEffects(
          dep,
          dirtyLevel,
          {
            target: ref2,
            type: "set",
            key: "value",
            newValue: newVal,
            oldValue: oldVal
          }
        );
      }
    }
    function isRef(r) {
      return !!(r && r.__v_isRef === true);
    }
    function ref(value) {
      return createRef(value, false);
    }
    function shallowRef(value) {
      return createRef(value, true);
    }
    function createRef(rawValue, shallow) {
      if (isRef(rawValue)) {
        return rawValue;
      }
      return new RefImpl(rawValue, shallow);
    }
    var RefImpl = class {
      constructor(value, __v_isShallow) {
        this.__v_isShallow = __v_isShallow;
        this.dep = void 0;
        this.__v_isRef = true;
        this._rawValue = __v_isShallow ? value : toRaw(value);
        this._value = __v_isShallow ? value : toReactive(value);
      }
      get value() {
        trackRefValue(this);
        return this._value;
      }
      set value(newVal) {
        const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
        newVal = useDirectValue ? newVal : toRaw(newVal);
        if (shared.hasChanged(newVal, this._rawValue)) {
          const oldVal = this._rawValue;
          this._rawValue = newVal;
          this._value = useDirectValue ? newVal : toReactive(newVal);
          triggerRefValue(this, 5, newVal, oldVal);
        }
      }
    };
    function triggerRef(ref2) {
      triggerRefValue(ref2, 5, ref2.value);
    }
    function unref(ref2) {
      return isRef(ref2) ? ref2.value : ref2;
    }
    function toValue(source) {
      return shared.isFunction(source) ? source() : unref(source);
    }
    var shallowUnwrapHandlers = {
      get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
      set: (target, key, value, receiver) => {
        const oldValue = target[key];
        if (isRef(oldValue) && !isRef(value)) {
          oldValue.value = value;
          return true;
        } else {
          return Reflect.set(target, key, value, receiver);
        }
      }
    };
    function proxyRefs(objectWithRefs) {
      return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
    }
    var CustomRefImpl = class {
      constructor(factory) {
        this.dep = void 0;
        this.__v_isRef = true;
        const { get: get2, set: set2 } = factory(
          () => trackRefValue(this),
          () => triggerRefValue(this)
        );
        this._get = get2;
        this._set = set2;
      }
      get value() {
        return this._get();
      }
      set value(newVal) {
        this._set(newVal);
      }
    };
    function customRef(factory) {
      return new CustomRefImpl(factory);
    }
    function toRefs(object) {
      if (!isProxy(object)) {
        warn(`toRefs() expects a reactive object but received a plain one.`);
      }
      const ret = shared.isArray(object) ? new Array(object.length) : {};
      for (const key in object) {
        ret[key] = propertyToRef(object, key);
      }
      return ret;
    }
    var ObjectRefImpl = class {
      constructor(_object, _key, _defaultValue) {
        this._object = _object;
        this._key = _key;
        this._defaultValue = _defaultValue;
        this.__v_isRef = true;
      }
      get value() {
        const val = this._object[this._key];
        return val === void 0 ? this._defaultValue : val;
      }
      set value(newVal) {
        this._object[this._key] = newVal;
      }
      get dep() {
        return getDepFromReactive(toRaw(this._object), this._key);
      }
    };
    var GetterRefImpl = class {
      constructor(_getter) {
        this._getter = _getter;
        this.__v_isRef = true;
        this.__v_isReadonly = true;
      }
      get value() {
        return this._getter();
      }
    };
    function toRef(source, key, defaultValue) {
      if (isRef(source)) {
        return source;
      } else if (shared.isFunction(source)) {
        return new GetterRefImpl(source);
      } else if (shared.isObject(source) && arguments.length > 1) {
        return propertyToRef(source, key, defaultValue);
      } else {
        return ref(source);
      }
    }
    function propertyToRef(source, key, defaultValue) {
      const val = source[key];
      return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
    }
    var deferredComputed = computed;
    var TrackOpTypes = {
      "GET": "get",
      "HAS": "has",
      "ITERATE": "iterate"
    };
    var TriggerOpTypes = {
      "SET": "set",
      "ADD": "add",
      "DELETE": "delete",
      "CLEAR": "clear"
    };
    var ReactiveFlags = {
      "SKIP": "__v_skip",
      "IS_REACTIVE": "__v_isReactive",
      "IS_READONLY": "__v_isReadonly",
      "IS_SHALLOW": "__v_isShallow",
      "RAW": "__v_raw"
    };
    exports.EffectScope = EffectScope;
    exports.ITERATE_KEY = ITERATE_KEY;
    exports.ReactiveEffect = ReactiveEffect;
    exports.ReactiveFlags = ReactiveFlags;
    exports.TrackOpTypes = TrackOpTypes;
    exports.TriggerOpTypes = TriggerOpTypes;
    exports.computed = computed;
    exports.customRef = customRef;
    exports.deferredComputed = deferredComputed;
    exports.effect = effect;
    exports.effectScope = effectScope;
    exports.enableTracking = enableTracking;
    exports.getCurrentScope = getCurrentScope;
    exports.isProxy = isProxy;
    exports.isReactive = isReactive;
    exports.isReadonly = isReadonly;
    exports.isRef = isRef;
    exports.isShallow = isShallow;
    exports.markRaw = markRaw;
    exports.onScopeDispose = onScopeDispose;
    exports.pauseScheduling = pauseScheduling;
    exports.pauseTracking = pauseTracking;
    exports.proxyRefs = proxyRefs;
    exports.reactive = reactive;
    exports.readonly = readonly;
    exports.ref = ref;
    exports.resetScheduling = resetScheduling;
    exports.resetTracking = resetTracking;
    exports.shallowReactive = shallowReactive;
    exports.shallowReadonly = shallowReadonly;
    exports.shallowRef = shallowRef;
    exports.stop = stop;
    exports.toRaw = toRaw;
    exports.toRef = toRef;
    exports.toRefs = toRefs;
    exports.toValue = toValue;
    exports.track = track;
    exports.trigger = trigger;
    exports.triggerRef = triggerRef;
    exports.unref = unref;
  }
});

// node_modules/@vue/reactivity/index.js
var require_reactivity = __commonJS({
  "node_modules/@vue/reactivity/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_reactivity_cjs();
    }
  }
});

// node_modules/@vue/runtime-core/dist/runtime-core.cjs.js
var require_runtime_core_cjs = __commonJS({
  "node_modules/@vue/runtime-core/dist/runtime-core.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var reactivity = require_reactivity();
    var shared = require_shared();
    var stack = [];
    function pushWarningContext(vnode) {
      stack.push(vnode);
    }
    function popWarningContext() {
      stack.pop();
    }
    function warn$1(msg, ...args) {
      reactivity.pauseTracking();
      const instance = stack.length ? stack[stack.length - 1].component : null;
      const appWarnHandler = instance && instance.appContext.config.warnHandler;
      const trace = getComponentTrace();
      if (appWarnHandler) {
        callWithErrorHandling(
          appWarnHandler,
          instance,
          11,
          [
            msg + args.map((a) => {
              var _a, _b;
              return (_b = (_a = a.toString) == null ? void 0 : _a.call(a)) != null ? _b : JSON.stringify(a);
            }).join(""),
            instance && instance.proxy,
            trace.map(
              ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
            ).join("\n"),
            trace
          ]
        );
      } else {
        const warnArgs = [`[Vue warn]: ${msg}`, ...args];
        if (trace.length && true) {
          warnArgs.push(`
`, ...formatTrace(trace));
        }
        console.warn(...warnArgs);
      }
      reactivity.resetTracking();
    }
    function getComponentTrace() {
      let currentVNode = stack[stack.length - 1];
      if (!currentVNode) {
        return [];
      }
      const normalizedStack = [];
      while (currentVNode) {
        const last = normalizedStack[0];
        if (last && last.vnode === currentVNode) {
          last.recurseCount++;
        } else {
          normalizedStack.push({
            vnode: currentVNode,
            recurseCount: 0
          });
        }
        const parentInstance = currentVNode.component && currentVNode.component.parent;
        currentVNode = parentInstance && parentInstance.vnode;
      }
      return normalizedStack;
    }
    function formatTrace(trace) {
      const logs = [];
      trace.forEach((entry, i) => {
        logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
      });
      return logs;
    }
    function formatTraceEntry({ vnode, recurseCount }) {
      const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
      const isRoot = vnode.component ? vnode.component.parent == null : false;
      const open = ` at <${formatComponentName(
        vnode.component,
        vnode.type,
        isRoot
      )}`;
      const close = `>` + postfix;
      return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
    }
    function formatProps(props) {
      const res = [];
      const keys = Object.keys(props);
      keys.slice(0, 3).forEach((key) => {
        res.push(...formatProp(key, props[key]));
      });
      if (keys.length > 3) {
        res.push(` ...`);
      }
      return res;
    }
    function formatProp(key, value, raw) {
      if (shared.isString(value)) {
        value = JSON.stringify(value);
        return raw ? value : [`${key}=${value}`];
      } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
        return raw ? value : [`${key}=${value}`];
      } else if (reactivity.isRef(value)) {
        value = formatProp(key, reactivity.toRaw(value.value), true);
        return raw ? value : [`${key}=Ref<`, value, `>`];
      } else if (shared.isFunction(value)) {
        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
      } else {
        value = reactivity.toRaw(value);
        return raw ? value : [`${key}=`, value];
      }
    }
    function assertNumber(val, type) {
      if (val === void 0) {
        return;
      } else if (typeof val !== "number") {
        warn$1(`${type} is not a valid number - got ${JSON.stringify(val)}.`);
      } else if (isNaN(val)) {
        warn$1(`${type} is NaN - the duration expression might be incorrect.`);
      }
    }
    var ErrorCodes = {
      "SETUP_FUNCTION": 0,
      "0": "SETUP_FUNCTION",
      "RENDER_FUNCTION": 1,
      "1": "RENDER_FUNCTION",
      "WATCH_GETTER": 2,
      "2": "WATCH_GETTER",
      "WATCH_CALLBACK": 3,
      "3": "WATCH_CALLBACK",
      "WATCH_CLEANUP": 4,
      "4": "WATCH_CLEANUP",
      "NATIVE_EVENT_HANDLER": 5,
      "5": "NATIVE_EVENT_HANDLER",
      "COMPONENT_EVENT_HANDLER": 6,
      "6": "COMPONENT_EVENT_HANDLER",
      "VNODE_HOOK": 7,
      "7": "VNODE_HOOK",
      "DIRECTIVE_HOOK": 8,
      "8": "DIRECTIVE_HOOK",
      "TRANSITION_HOOK": 9,
      "9": "TRANSITION_HOOK",
      "APP_ERROR_HANDLER": 10,
      "10": "APP_ERROR_HANDLER",
      "APP_WARN_HANDLER": 11,
      "11": "APP_WARN_HANDLER",
      "FUNCTION_REF": 12,
      "12": "FUNCTION_REF",
      "ASYNC_COMPONENT_LOADER": 13,
      "13": "ASYNC_COMPONENT_LOADER",
      "SCHEDULER": 14,
      "14": "SCHEDULER"
    };
    var ErrorTypeStrings$1 = {
      ["sp"]: "serverPrefetch hook",
      ["bc"]: "beforeCreate hook",
      ["c"]: "created hook",
      ["bm"]: "beforeMount hook",
      ["m"]: "mounted hook",
      ["bu"]: "beforeUpdate hook",
      ["u"]: "updated",
      ["bum"]: "beforeUnmount hook",
      ["um"]: "unmounted hook",
      ["a"]: "activated hook",
      ["da"]: "deactivated hook",
      ["ec"]: "errorCaptured hook",
      ["rtc"]: "renderTracked hook",
      ["rtg"]: "renderTriggered hook",
      [0]: "setup function",
      [1]: "render function",
      [2]: "watcher getter",
      [3]: "watcher callback",
      [4]: "watcher cleanup function",
      [5]: "native event handler",
      [6]: "component event handler",
      [7]: "vnode hook",
      [8]: "directive hook",
      [9]: "transition hook",
      [10]: "app errorHandler",
      [11]: "app warnHandler",
      [12]: "ref function",
      [13]: "async component loader",
      [14]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://github.com/vuejs/core ."
    };
    function callWithErrorHandling(fn, instance, type, args) {
      try {
        return args ? fn(...args) : fn();
      } catch (err) {
        handleError(err, instance, type);
      }
    }
    function callWithAsyncErrorHandling(fn, instance, type, args) {
      if (shared.isFunction(fn)) {
        const res = callWithErrorHandling(fn, instance, type, args);
        if (res && shared.isPromise(res)) {
          res.catch((err) => {
            handleError(err, instance, type);
          });
        }
        return res;
      }
      if (shared.isArray(fn)) {
        const values = [];
        for (let i = 0; i < fn.length; i++) {
          values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
        }
        return values;
      } else {
        warn$1(
          `Invalid value type passed to callWithAsyncErrorHandling(): ${typeof fn}`
        );
      }
    }
    function handleError(err, instance, type, throwInDev = true) {
      const contextVNode = instance ? instance.vnode : null;
      if (instance) {
        let cur = instance.parent;
        const exposedInstance = instance.proxy;
        const errorInfo = ErrorTypeStrings$1[type];
        while (cur) {
          const errorCapturedHooks = cur.ec;
          if (errorCapturedHooks) {
            for (let i = 0; i < errorCapturedHooks.length; i++) {
              if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
                return;
              }
            }
          }
          cur = cur.parent;
        }
        const appErrorHandler = instance.appContext.config.errorHandler;
        if (appErrorHandler) {
          reactivity.pauseTracking();
          callWithErrorHandling(
            appErrorHandler,
            null,
            10,
            [err, exposedInstance, errorInfo]
          );
          reactivity.resetTracking();
          return;
        }
      }
      logError(err, type, contextVNode, throwInDev);
    }
    function logError(err, type, contextVNode, throwInDev = true) {
      {
        const info = ErrorTypeStrings$1[type];
        if (contextVNode) {
          pushWarningContext(contextVNode);
        }
        warn$1(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
        if (contextVNode) {
          popWarningContext();
        }
        if (throwInDev) {
          throw err;
        } else {
          console.error(err);
        }
      }
    }
    var isFlushing = false;
    var isFlushPending = false;
    var queue = [];
    var flushIndex = 0;
    var pendingPostFlushCbs = [];
    var activePostFlushCbs = null;
    var postFlushIndex = 0;
    var resolvedPromise = Promise.resolve();
    var currentFlushPromise = null;
    var RECURSION_LIMIT = 100;
    function nextTick(fn) {
      const p = currentFlushPromise || resolvedPromise;
      return fn ? p.then(this ? fn.bind(this) : fn) : p;
    }
    function findInsertionIndex(id) {
      let start = flushIndex + 1;
      let end = queue.length;
      while (start < end) {
        const middle = start + end >>> 1;
        const middleJob = queue[middle];
        const middleJobId = getId(middleJob);
        if (middleJobId < id || middleJobId === id && middleJob.pre) {
          start = middle + 1;
        } else {
          end = middle;
        }
      }
      return start;
    }
    function queueJob(job) {
      if (!queue.length || !queue.includes(
        job,
        isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
      )) {
        if (job.id == null) {
          queue.push(job);
        } else {
          queue.splice(findInsertionIndex(job.id), 0, job);
        }
        queueFlush();
      }
    }
    function queueFlush() {
      if (!isFlushing && !isFlushPending) {
        isFlushPending = true;
        currentFlushPromise = resolvedPromise.then(flushJobs);
      }
    }
    function invalidateJob(job) {
      const i = queue.indexOf(job);
      if (i > flushIndex) {
        queue.splice(i, 1);
      }
    }
    function queuePostFlushCb(cb) {
      if (!shared.isArray(cb)) {
        if (!activePostFlushCbs || !activePostFlushCbs.includes(
          cb,
          cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
        )) {
          pendingPostFlushCbs.push(cb);
        }
      } else {
        pendingPostFlushCbs.push(...cb);
      }
      queueFlush();
    }
    function flushPreFlushCbs(instance, seen, i = isFlushing ? flushIndex + 1 : 0) {
      {
        seen = seen || /* @__PURE__ */ new Map();
      }
      for (; i < queue.length; i++) {
        const cb = queue[i];
        if (cb && cb.pre) {
          if (instance && cb.id !== instance.uid) {
            continue;
          }
          if (checkRecursiveUpdates(seen, cb)) {
            continue;
          }
          queue.splice(i, 1);
          i--;
          cb();
        }
      }
    }
    function flushPostFlushCbs(seen) {
      if (pendingPostFlushCbs.length) {
        const deduped = [...new Set(pendingPostFlushCbs)].sort(
          (a, b) => getId(a) - getId(b)
        );
        pendingPostFlushCbs.length = 0;
        if (activePostFlushCbs) {
          activePostFlushCbs.push(...deduped);
          return;
        }
        activePostFlushCbs = deduped;
        {
          seen = seen || /* @__PURE__ */ new Map();
        }
        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
          const cb = activePostFlushCbs[postFlushIndex];
          if (checkRecursiveUpdates(seen, cb)) {
            continue;
          }
          if (cb.active !== false)
            cb();
        }
        activePostFlushCbs = null;
        postFlushIndex = 0;
      }
    }
    var getId = (job) => job.id == null ? Infinity : job.id;
    var comparator = (a, b) => {
      const diff = getId(a) - getId(b);
      if (diff === 0) {
        if (a.pre && !b.pre)
          return -1;
        if (b.pre && !a.pre)
          return 1;
      }
      return diff;
    };
    function flushJobs(seen) {
      isFlushPending = false;
      isFlushing = true;
      {
        seen = seen || /* @__PURE__ */ new Map();
      }
      queue.sort(comparator);
      const check = (job) => checkRecursiveUpdates(seen, job);
      try {
        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
          const job = queue[flushIndex];
          if (job && job.active !== false) {
            if (check(job)) {
              continue;
            }
            callWithErrorHandling(job, null, 14);
          }
        }
      } finally {
        flushIndex = 0;
        queue.length = 0;
        flushPostFlushCbs(seen);
        isFlushing = false;
        currentFlushPromise = null;
        if (queue.length || pendingPostFlushCbs.length) {
          flushJobs(seen);
        }
      }
    }
    function checkRecursiveUpdates(seen, fn) {
      if (!seen.has(fn)) {
        seen.set(fn, 1);
      } else {
        const count = seen.get(fn);
        if (count > RECURSION_LIMIT) {
          const instance = fn.ownerInstance;
          const componentName = instance && getComponentName(instance.type);
          handleError(
            `Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,
            null,
            10
          );
          return true;
        } else {
          seen.set(fn, count + 1);
        }
      }
    }
    var isHmrUpdating = false;
    var hmrDirtyComponents = /* @__PURE__ */ new Set();
    {
      shared.getGlobalThis().__VUE_HMR_RUNTIME__ = {
        createRecord: tryWrap(createRecord),
        rerender: tryWrap(rerender),
        reload: tryWrap(reload)
      };
    }
    var map = /* @__PURE__ */ new Map();
    function registerHMR(instance) {
      const id = instance.type.__hmrId;
      let record = map.get(id);
      if (!record) {
        createRecord(id, instance.type);
        record = map.get(id);
      }
      record.instances.add(instance);
    }
    function unregisterHMR(instance) {
      map.get(instance.type.__hmrId).instances.delete(instance);
    }
    function createRecord(id, initialDef) {
      if (map.has(id)) {
        return false;
      }
      map.set(id, {
        initialDef: normalizeClassComponent(initialDef),
        instances: /* @__PURE__ */ new Set()
      });
      return true;
    }
    function normalizeClassComponent(component) {
      return isClassComponent(component) ? component.__vccOpts : component;
    }
    function rerender(id, newRender) {
      const record = map.get(id);
      if (!record) {
        return;
      }
      record.initialDef.render = newRender;
      [...record.instances].forEach((instance) => {
        if (newRender) {
          instance.render = newRender;
          normalizeClassComponent(instance.type).render = newRender;
        }
        instance.renderCache = [];
        isHmrUpdating = true;
        instance.effect.dirty = true;
        instance.update();
        isHmrUpdating = false;
      });
    }
    function reload(id, newComp) {
      const record = map.get(id);
      if (!record)
        return;
      newComp = normalizeClassComponent(newComp);
      updateComponentDef(record.initialDef, newComp);
      const instances = [...record.instances];
      for (const instance of instances) {
        const oldComp = normalizeClassComponent(instance.type);
        if (!hmrDirtyComponents.has(oldComp)) {
          if (oldComp !== record.initialDef) {
            updateComponentDef(oldComp, newComp);
          }
          hmrDirtyComponents.add(oldComp);
        }
        instance.appContext.propsCache.delete(instance.type);
        instance.appContext.emitsCache.delete(instance.type);
        instance.appContext.optionsCache.delete(instance.type);
        if (instance.ceReload) {
          hmrDirtyComponents.add(oldComp);
          instance.ceReload(newComp.styles);
          hmrDirtyComponents.delete(oldComp);
        } else if (instance.parent) {
          instance.parent.effect.dirty = true;
          queueJob(() => {
            instance.parent.update();
            hmrDirtyComponents.delete(oldComp);
          });
        } else if (instance.appContext.reload) {
          instance.appContext.reload();
        } else if (typeof window !== "undefined") {
          window.location.reload();
        } else {
          console.warn(
            "[HMR] Root or manually mounted instance modified. Full reload required."
          );
        }
      }
      queuePostFlushCb(() => {
        for (const instance of instances) {
          hmrDirtyComponents.delete(
            normalizeClassComponent(instance.type)
          );
        }
      });
    }
    function updateComponentDef(oldComp, newComp) {
      shared.extend(oldComp, newComp);
      for (const key in oldComp) {
        if (key !== "__file" && !(key in newComp)) {
          delete oldComp[key];
        }
      }
    }
    function tryWrap(fn) {
      return (id, arg) => {
        try {
          return fn(id, arg);
        } catch (e) {
          console.error(e);
          console.warn(
            `[HMR] Something went wrong during Vue component hot-reload. Full reload required.`
          );
        }
      };
    }
    var devtools$1;
    var buffer = [];
    var devtoolsNotInstalled = false;
    function emit$1(event, ...args) {
      if (devtools$1) {
        devtools$1.emit(event, ...args);
      } else if (!devtoolsNotInstalled) {
        buffer.push({ event, args });
      }
    }
    function setDevtoolsHook$1(hook, target) {
      var _a, _b;
      devtools$1 = hook;
      if (devtools$1) {
        devtools$1.enabled = true;
        buffer.forEach(({ event, args }) => devtools$1.emit(event, ...args));
        buffer = [];
      } else if (typeof window !== "undefined" && window.HTMLElement && !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes("jsdom"))) {
        const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
        replay.push((newHook) => {
          setDevtoolsHook$1(newHook, target);
        });
        setTimeout(() => {
          if (!devtools$1) {
            target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
            devtoolsNotInstalled = true;
            buffer = [];
          }
        }, 3e3);
      } else {
        devtoolsNotInstalled = true;
        buffer = [];
      }
    }
    function devtoolsInitApp(app, version2) {
      emit$1("app:init", app, version2, {
        Fragment,
        Text,
        Comment,
        Static
      });
    }
    function devtoolsUnmountApp(app) {
      emit$1("app:unmount", app);
    }
    var devtoolsComponentAdded = createDevtoolsComponentHook(
      "component:added"
    );
    var devtoolsComponentUpdated = createDevtoolsComponentHook("component:updated");
    var _devtoolsComponentRemoved = createDevtoolsComponentHook(
      "component:removed"
    );
    var devtoolsComponentRemoved = (component) => {
      if (devtools$1 && typeof devtools$1.cleanupBuffer === "function" && !devtools$1.cleanupBuffer(component)) {
        _devtoolsComponentRemoved(component);
      }
    };
    function createDevtoolsComponentHook(hook) {
      return (component) => {
        emit$1(
          hook,
          component.appContext.app,
          component.uid,
          component.parent ? component.parent.uid : void 0,
          component
        );
      };
    }
    var devtoolsPerfStart = createDevtoolsPerformanceHook(
      "perf:start"
    );
    var devtoolsPerfEnd = createDevtoolsPerformanceHook(
      "perf:end"
    );
    function createDevtoolsPerformanceHook(hook) {
      return (component, type, time) => {
        emit$1(hook, component.appContext.app, component.uid, component, type, time);
      };
    }
    function devtoolsComponentEmit(component, event, params) {
      emit$1(
        "component:emit",
        component.appContext.app,
        component,
        event,
        params
      );
    }
    function emit(instance, event, ...rawArgs) {
      if (instance.isUnmounted)
        return;
      const props = instance.vnode.props || shared.EMPTY_OBJ;
      {
        const {
          emitsOptions,
          propsOptions: [propsOptions]
        } = instance;
        if (emitsOptions) {
          if (!(event in emitsOptions) && true) {
            if (!propsOptions || !(shared.toHandlerKey(event) in propsOptions)) {
              warn$1(
                `Component emitted event "${event}" but it is neither declared in the emits option nor as an "${shared.toHandlerKey(event)}" prop.`
              );
            }
          } else {
            const validator = emitsOptions[event];
            if (shared.isFunction(validator)) {
              const isValid = validator(...rawArgs);
              if (!isValid) {
                warn$1(
                  `Invalid event arguments: event validation failed for event "${event}".`
                );
              }
            }
          }
        }
      }
      let args = rawArgs;
      const isModelListener = event.startsWith("update:");
      const modelArg = isModelListener && event.slice(7);
      if (modelArg && modelArg in props) {
        const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
        const { number, trim } = props[modifiersKey] || shared.EMPTY_OBJ;
        if (trim) {
          args = rawArgs.map((a) => shared.isString(a) ? a.trim() : a);
        }
        if (number) {
          args = rawArgs.map(shared.looseToNumber);
        }
      }
      {
        devtoolsComponentEmit(instance, event, args);
      }
      {
        const lowerCaseEvent = event.toLowerCase();
        if (lowerCaseEvent !== event && props[shared.toHandlerKey(lowerCaseEvent)]) {
          warn$1(
            `Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(
              instance,
              instance.type
            )} but the handler is registered for "${event}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${shared.hyphenate(
              event
            )}" instead of "${event}".`
          );
        }
      }
      let handlerName;
      let handler = props[handlerName = shared.toHandlerKey(event)] || props[handlerName = shared.toHandlerKey(shared.camelize(event))];
      if (!handler && isModelListener) {
        handler = props[handlerName = shared.toHandlerKey(shared.hyphenate(event))];
      }
      if (handler) {
        callWithAsyncErrorHandling(
          handler,
          instance,
          6,
          args
        );
      }
      const onceHandler = props[handlerName + `Once`];
      if (onceHandler) {
        if (!instance.emitted) {
          instance.emitted = {};
        } else if (instance.emitted[handlerName]) {
          return;
        }
        instance.emitted[handlerName] = true;
        callWithAsyncErrorHandling(
          onceHandler,
          instance,
          6,
          args
        );
      }
    }
    function normalizeEmitsOptions(comp, appContext, asMixin = false) {
      const cache = appContext.emitsCache;
      const cached = cache.get(comp);
      if (cached !== void 0) {
        return cached;
      }
      const raw = comp.emits;
      let normalized = {};
      let hasExtends = false;
      if (!shared.isFunction(comp)) {
        const extendEmits = (raw2) => {
          const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
          if (normalizedFromExtend) {
            hasExtends = true;
            shared.extend(normalized, normalizedFromExtend);
          }
        };
        if (!asMixin && appContext.mixins.length) {
          appContext.mixins.forEach(extendEmits);
        }
        if (comp.extends) {
          extendEmits(comp.extends);
        }
        if (comp.mixins) {
          comp.mixins.forEach(extendEmits);
        }
      }
      if (!raw && !hasExtends) {
        if (shared.isObject(comp)) {
          cache.set(comp, null);
        }
        return null;
      }
      if (shared.isArray(raw)) {
        raw.forEach((key) => normalized[key] = null);
      } else {
        shared.extend(normalized, raw);
      }
      if (shared.isObject(comp)) {
        cache.set(comp, normalized);
      }
      return normalized;
    }
    function isEmitListener(options, key) {
      if (!options || !shared.isOn(key)) {
        return false;
      }
      key = key.slice(2).replace(/Once$/, "");
      return shared.hasOwn(options, key[0].toLowerCase() + key.slice(1)) || shared.hasOwn(options, shared.hyphenate(key)) || shared.hasOwn(options, key);
    }
    var currentRenderingInstance = null;
    var currentScopeId = null;
    function setCurrentRenderingInstance(instance) {
      const prev = currentRenderingInstance;
      currentRenderingInstance = instance;
      currentScopeId = instance && instance.type.__scopeId || null;
      return prev;
    }
    function pushScopeId(id) {
      currentScopeId = id;
    }
    function popScopeId() {
      currentScopeId = null;
    }
    var withScopeId = (_id) => withCtx;
    function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
      if (!ctx)
        return fn;
      if (fn._n) {
        return fn;
      }
      const renderFnWithContext = (...args) => {
        if (renderFnWithContext._d) {
          setBlockTracking(-1);
        }
        const prevInstance = setCurrentRenderingInstance(ctx);
        let res;
        try {
          res = fn(...args);
        } finally {
          setCurrentRenderingInstance(prevInstance);
          if (renderFnWithContext._d) {
            setBlockTracking(1);
          }
        }
        {
          devtoolsComponentUpdated(ctx);
        }
        return res;
      };
      renderFnWithContext._n = true;
      renderFnWithContext._c = true;
      renderFnWithContext._d = true;
      return renderFnWithContext;
    }
    var accessedAttrs = false;
    function markAttrsAccessed() {
      accessedAttrs = true;
    }
    function renderComponentRoot(instance) {
      const {
        type: Component,
        vnode,
        proxy,
        withProxy,
        propsOptions: [propsOptions],
        slots,
        attrs,
        emit: emit2,
        render,
        renderCache,
        props,
        data,
        setupState,
        ctx,
        inheritAttrs
      } = instance;
      const prev = setCurrentRenderingInstance(instance);
      let result;
      let fallthroughAttrs;
      {
        accessedAttrs = false;
      }
      try {
        if (vnode.shapeFlag & 4) {
          const proxyToUse = withProxy || proxy;
          const thisProxy = setupState.__isScriptSetup ? new Proxy(proxyToUse, {
            get(target, key, receiver) {
              warn$1(
                `Property '${String(
                  key
                )}' was accessed via 'this'. Avoid using 'this' in templates.`
              );
              return Reflect.get(target, key, receiver);
            }
          }) : proxyToUse;
          result = normalizeVNode(
            render.call(
              thisProxy,
              proxyToUse,
              renderCache,
              true ? reactivity.shallowReadonly(props) : props,
              setupState,
              data,
              ctx
            )
          );
          fallthroughAttrs = attrs;
        } else {
          const render2 = Component;
          if (attrs === props) {
            markAttrsAccessed();
          }
          result = normalizeVNode(
            render2.length > 1 ? render2(
              true ? reactivity.shallowReadonly(props) : props,
              true ? {
                get attrs() {
                  markAttrsAccessed();
                  return reactivity.shallowReadonly(attrs);
                },
                slots,
                emit: emit2
              } : { attrs, slots, emit: emit2 }
            ) : render2(
              true ? reactivity.shallowReadonly(props) : props,
              null
            )
          );
          fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
        }
      } catch (err) {
        blockStack.length = 0;
        handleError(err, instance, 1);
        result = createVNode(Comment);
      }
      let root = result;
      let setRoot = void 0;
      if (result.patchFlag > 0 && result.patchFlag & 2048) {
        [root, setRoot] = getChildRoot(result);
      }
      if (fallthroughAttrs && inheritAttrs !== false) {
        const keys = Object.keys(fallthroughAttrs);
        const { shapeFlag } = root;
        if (keys.length) {
          if (shapeFlag & (1 | 6)) {
            if (propsOptions && keys.some(shared.isModelListener)) {
              fallthroughAttrs = filterModelListeners(
                fallthroughAttrs,
                propsOptions
              );
            }
            root = cloneVNode(root, fallthroughAttrs, false, true);
          } else if (!accessedAttrs && root.type !== Comment) {
            const allAttrs = Object.keys(attrs);
            const eventAttrs = [];
            const extraAttrs = [];
            for (let i = 0, l = allAttrs.length; i < l; i++) {
              const key = allAttrs[i];
              if (shared.isOn(key)) {
                if (!shared.isModelListener(key)) {
                  eventAttrs.push(key[2].toLowerCase() + key.slice(3));
                }
              } else {
                extraAttrs.push(key);
              }
            }
            if (extraAttrs.length) {
              warn$1(
                `Extraneous non-props attributes (${extraAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`
              );
            }
            if (eventAttrs.length) {
              warn$1(
                `Extraneous non-emits event listeners (${eventAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`
              );
            }
          }
        }
      }
      if (vnode.dirs) {
        if (!isElementRoot(root)) {
          warn$1(
            `Runtime directive used on component with non-element root node. The directives will not function as intended.`
          );
        }
        root = cloneVNode(root, null, false, true);
        root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
      }
      if (vnode.transition) {
        if (!isElementRoot(root)) {
          warn$1(
            `Component inside <Transition> renders non-element root node that cannot be animated.`
          );
        }
        root.transition = vnode.transition;
      }
      if (setRoot) {
        setRoot(root);
      } else {
        result = root;
      }
      setCurrentRenderingInstance(prev);
      return result;
    }
    var getChildRoot = (vnode) => {
      const rawChildren = vnode.children;
      const dynamicChildren = vnode.dynamicChildren;
      const childRoot = filterSingleRoot(rawChildren, false);
      if (!childRoot) {
        return [vnode, void 0];
      } else if (childRoot.patchFlag > 0 && childRoot.patchFlag & 2048) {
        return getChildRoot(childRoot);
      }
      const index = rawChildren.indexOf(childRoot);
      const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
      const setRoot = (updatedRoot) => {
        rawChildren[index] = updatedRoot;
        if (dynamicChildren) {
          if (dynamicIndex > -1) {
            dynamicChildren[dynamicIndex] = updatedRoot;
          } else if (updatedRoot.patchFlag > 0) {
            vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
          }
        }
      };
      return [normalizeVNode(childRoot), setRoot];
    };
    function filterSingleRoot(children, recurse = true) {
      let singleRoot;
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (isVNode(child)) {
          if (child.type !== Comment || child.children === "v-if") {
            if (singleRoot) {
              return;
            } else {
              singleRoot = child;
              if (recurse && singleRoot.patchFlag > 0 && singleRoot.patchFlag & 2048) {
                return filterSingleRoot(singleRoot.children);
              }
            }
          }
        } else {
          return;
        }
      }
      return singleRoot;
    }
    var getFunctionalFallthrough = (attrs) => {
      let res;
      for (const key in attrs) {
        if (key === "class" || key === "style" || shared.isOn(key)) {
          (res || (res = {}))[key] = attrs[key];
        }
      }
      return res;
    };
    var filterModelListeners = (attrs, props) => {
      const res = {};
      for (const key in attrs) {
        if (!shared.isModelListener(key) || !(key.slice(9) in props)) {
          res[key] = attrs[key];
        }
      }
      return res;
    };
    var isElementRoot = (vnode) => {
      return vnode.shapeFlag & (6 | 1) || vnode.type === Comment;
    };
    function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
      const { props: prevProps, children: prevChildren, component } = prevVNode;
      const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
      const emits = component.emitsOptions;
      if ((prevChildren || nextChildren) && isHmrUpdating) {
        return true;
      }
      if (nextVNode.dirs || nextVNode.transition) {
        return true;
      }
      if (optimized && patchFlag >= 0) {
        if (patchFlag & 1024) {
          return true;
        }
        if (patchFlag & 16) {
          if (!prevProps) {
            return !!nextProps;
          }
          return hasPropsChanged(prevProps, nextProps, emits);
        } else if (patchFlag & 8) {
          const dynamicProps = nextVNode.dynamicProps;
          for (let i = 0; i < dynamicProps.length; i++) {
            const key = dynamicProps[i];
            if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
              return true;
            }
          }
        }
      } else {
        if (prevChildren || nextChildren) {
          if (!nextChildren || !nextChildren.$stable) {
            return true;
          }
        }
        if (prevProps === nextProps) {
          return false;
        }
        if (!prevProps) {
          return !!nextProps;
        }
        if (!nextProps) {
          return true;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
      }
      return false;
    }
    function hasPropsChanged(prevProps, nextProps, emitsOptions) {
      const nextKeys = Object.keys(nextProps);
      if (nextKeys.length !== Object.keys(prevProps).length) {
        return true;
      }
      for (let i = 0; i < nextKeys.length; i++) {
        const key = nextKeys[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
          return true;
        }
      }
      return false;
    }
    function updateHOCHostEl({ vnode, parent }, el) {
      while (parent) {
        const root = parent.subTree;
        if (root.suspense && root.suspense.activeBranch === vnode) {
          root.el = vnode.el;
        }
        if (root === vnode) {
          (vnode = parent.vnode).el = el;
          parent = parent.parent;
        } else {
          break;
        }
      }
    }
    var COMPONENTS = "components";
    var DIRECTIVES = "directives";
    function resolveComponent(name, maybeSelfReference) {
      return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
    }
    var NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
    function resolveDynamicComponent(component) {
      if (shared.isString(component)) {
        return resolveAsset(COMPONENTS, component, false) || component;
      } else {
        return component || NULL_DYNAMIC_COMPONENT;
      }
    }
    function resolveDirective(name) {
      return resolveAsset(DIRECTIVES, name);
    }
    function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
      const instance = currentRenderingInstance || currentInstance;
      if (instance) {
        const Component = instance.type;
        if (type === COMPONENTS) {
          const selfName = getComponentName(
            Component,
            false
          );
          if (selfName && (selfName === name || selfName === shared.camelize(name) || selfName === shared.capitalize(shared.camelize(name)))) {
            return Component;
          }
        }
        const res = resolve(instance[type] || Component[type], name) || resolve(instance.appContext[type], name);
        if (!res && maybeSelfReference) {
          return Component;
        }
        if (warnMissing && !res) {
          const extra = type === COMPONENTS ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : ``;
          warn$1(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);
        }
        return res;
      } else {
        warn$1(
          `resolve${shared.capitalize(type.slice(0, -1))} can only be used in render() or setup().`
        );
      }
    }
    function resolve(registry, name) {
      return registry && (registry[name] || registry[shared.camelize(name)] || registry[shared.capitalize(shared.camelize(name))]);
    }
    var isSuspense = (type) => type.__isSuspense;
    var suspenseId = 0;
    var SuspenseImpl = {
      name: "Suspense",
      __isSuspense: true,
      process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
        if (n1 == null) {
          mountSuspense(
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            rendererInternals
          );
        } else {
          if (parentSuspense && parentSuspense.deps > 0 && !n1.suspense.isInFallback) {
            n2.suspense = n1.suspense;
            n2.suspense.vnode = n2;
            n2.el = n1.el;
            return;
          }
          patchSuspense(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            namespace,
            slotScopeIds,
            optimized,
            rendererInternals
          );
        }
      },
      hydrate: hydrateSuspense,
      create: createSuspenseBoundary,
      normalize: normalizeSuspenseChildren
    };
    var Suspense = SuspenseImpl;
    function triggerEvent(vnode, name) {
      const eventListener = vnode.props && vnode.props[name];
      if (shared.isFunction(eventListener)) {
        eventListener();
      }
    }
    function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
      const {
        p: patch,
        o: { createElement }
      } = rendererInternals;
      const hiddenContainer = createElement("div");
      const suspense = vnode.suspense = createSuspenseBoundary(
        vnode,
        parentSuspense,
        parentComponent,
        container,
        hiddenContainer,
        anchor,
        namespace,
        slotScopeIds,
        optimized,
        rendererInternals
      );
      patch(
        null,
        suspense.pendingBranch = vnode.ssContent,
        hiddenContainer,
        null,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds
      );
      if (suspense.deps > 0) {
        triggerEvent(vnode, "onPending");
        triggerEvent(vnode, "onFallback");
        patch(
          null,
          vnode.ssFallback,
          container,
          anchor,
          parentComponent,
          null,
          namespace,
          slotScopeIds
        );
        setActiveBranch(suspense, vnode.ssFallback);
      } else {
        suspense.resolve(false, true);
      }
    }
    function patchSuspense(n1, n2, container, anchor, parentComponent, namespace, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
      const suspense = n2.suspense = n1.suspense;
      suspense.vnode = n2;
      n2.el = n1.el;
      const newBranch = n2.ssContent;
      const newFallback = n2.ssFallback;
      const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
      if (pendingBranch) {
        suspense.pendingBranch = newBranch;
        if (isSameVNodeType(newBranch, pendingBranch)) {
          patch(
            pendingBranch,
            newBranch,
            suspense.hiddenContainer,
            null,
            parentComponent,
            suspense,
            namespace,
            slotScopeIds,
            optimized
          );
          if (suspense.deps <= 0) {
            suspense.resolve();
          } else if (isInFallback) {
            if (!isHydrating) {
              patch(
                activeBranch,
                newFallback,
                container,
                anchor,
                parentComponent,
                null,
                namespace,
                slotScopeIds,
                optimized
              );
              setActiveBranch(suspense, newFallback);
            }
          }
        } else {
          suspense.pendingId = suspenseId++;
          if (isHydrating) {
            suspense.isHydrating = false;
            suspense.activeBranch = pendingBranch;
          } else {
            unmount(pendingBranch, parentComponent, suspense);
          }
          suspense.deps = 0;
          suspense.effects.length = 0;
          suspense.hiddenContainer = createElement("div");
          if (isInFallback) {
            patch(
              null,
              newBranch,
              suspense.hiddenContainer,
              null,
              parentComponent,
              suspense,
              namespace,
              slotScopeIds,
              optimized
            );
            if (suspense.deps <= 0) {
              suspense.resolve();
            } else {
              patch(
                activeBranch,
                newFallback,
                container,
                anchor,
                parentComponent,
                null,
                namespace,
                slotScopeIds,
                optimized
              );
              setActiveBranch(suspense, newFallback);
            }
          } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
            patch(
              activeBranch,
              newBranch,
              container,
              anchor,
              parentComponent,
              suspense,
              namespace,
              slotScopeIds,
              optimized
            );
            suspense.resolve(true);
          } else {
            patch(
              null,
              newBranch,
              suspense.hiddenContainer,
              null,
              parentComponent,
              suspense,
              namespace,
              slotScopeIds,
              optimized
            );
            if (suspense.deps <= 0) {
              suspense.resolve();
            }
          }
        }
      } else {
        if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
          patch(
            activeBranch,
            newBranch,
            container,
            anchor,
            parentComponent,
            suspense,
            namespace,
            slotScopeIds,
            optimized
          );
          setActiveBranch(suspense, newBranch);
        } else {
          triggerEvent(n2, "onPending");
          suspense.pendingBranch = newBranch;
          if (newBranch.shapeFlag & 512) {
            suspense.pendingId = newBranch.component.suspenseId;
          } else {
            suspense.pendingId = suspenseId++;
          }
          patch(
            null,
            newBranch,
            suspense.hiddenContainer,
            null,
            parentComponent,
            suspense,
            namespace,
            slotScopeIds,
            optimized
          );
          if (suspense.deps <= 0) {
            suspense.resolve();
          } else {
            const { timeout, pendingId } = suspense;
            if (timeout > 0) {
              setTimeout(() => {
                if (suspense.pendingId === pendingId) {
                  suspense.fallback(newFallback);
                }
              }, timeout);
            } else if (timeout === 0) {
              suspense.fallback(newFallback);
            }
          }
        }
      }
    }
    var hasWarned = false;
    function createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, namespace, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
      if (!hasWarned) {
        hasWarned = true;
        console[console.info ? "info" : "log"](
          `<Suspense> is an experimental feature and its API will likely change.`
        );
      }
      const {
        p: patch,
        m: move,
        um: unmount,
        n: next,
        o: { parentNode, remove }
      } = rendererInternals;
      let parentSuspenseId;
      const isSuspensible = isVNodeSuspensible(vnode);
      if (isSuspensible) {
        if (parentSuspense && parentSuspense.pendingBranch) {
          parentSuspenseId = parentSuspense.pendingId;
          parentSuspense.deps++;
        }
      }
      const timeout = vnode.props ? shared.toNumber(vnode.props.timeout) : void 0;
      {
        assertNumber(timeout, `Suspense timeout`);
      }
      const initialAnchor = anchor;
      const suspense = {
        vnode,
        parent: parentSuspense,
        parentComponent,
        namespace,
        container,
        hiddenContainer,
        deps: 0,
        pendingId: suspenseId++,
        timeout: typeof timeout === "number" ? timeout : -1,
        activeBranch: null,
        pendingBranch: null,
        isInFallback: !isHydrating,
        isHydrating,
        isUnmounted: false,
        effects: [],
        resolve(resume = false, sync = false) {
          {
            if (!resume && !suspense.pendingBranch) {
              throw new Error(
                `suspense.resolve() is called without a pending branch.`
              );
            }
            if (suspense.isUnmounted) {
              throw new Error(
                `suspense.resolve() is called on an already unmounted suspense boundary.`
              );
            }
          }
          const {
            vnode: vnode2,
            activeBranch,
            pendingBranch,
            pendingId,
            effects,
            parentComponent: parentComponent2,
            container: container2
          } = suspense;
          let delayEnter = false;
          if (suspense.isHydrating) {
            suspense.isHydrating = false;
          } else if (!resume) {
            delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
            if (delayEnter) {
              activeBranch.transition.afterLeave = () => {
                if (pendingId === suspense.pendingId) {
                  move(
                    pendingBranch,
                    container2,
                    anchor === initialAnchor ? next(activeBranch) : anchor,
                    0
                  );
                  queuePostFlushCb(effects);
                }
              };
            }
            if (activeBranch) {
              if (parentNode(activeBranch.el) !== suspense.hiddenContainer) {
                anchor = next(activeBranch);
              }
              unmount(activeBranch, parentComponent2, suspense, true);
            }
            if (!delayEnter) {
              move(pendingBranch, container2, anchor, 0);
            }
          }
          setActiveBranch(suspense, pendingBranch);
          suspense.pendingBranch = null;
          suspense.isInFallback = false;
          let parent = suspense.parent;
          let hasUnresolvedAncestor = false;
          while (parent) {
            if (parent.pendingBranch) {
              parent.effects.push(...effects);
              hasUnresolvedAncestor = true;
              break;
            }
            parent = parent.parent;
          }
          if (!hasUnresolvedAncestor && !delayEnter) {
            queuePostFlushCb(effects);
          }
          suspense.effects = [];
          if (isSuspensible) {
            if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {
              parentSuspense.deps--;
              if (parentSuspense.deps === 0 && !sync) {
                parentSuspense.resolve();
              }
            }
          }
          triggerEvent(vnode2, "onResolve");
        },
        fallback(fallbackVNode) {
          if (!suspense.pendingBranch) {
            return;
          }
          const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, namespace: namespace2 } = suspense;
          triggerEvent(vnode2, "onFallback");
          const anchor2 = next(activeBranch);
          const mountFallback = () => {
            if (!suspense.isInFallback) {
              return;
            }
            patch(
              null,
              fallbackVNode,
              container2,
              anchor2,
              parentComponent2,
              null,
              namespace2,
              slotScopeIds,
              optimized
            );
            setActiveBranch(suspense, fallbackVNode);
          };
          const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
          if (delayEnter) {
            activeBranch.transition.afterLeave = mountFallback;
          }
          suspense.isInFallback = true;
          unmount(
            activeBranch,
            parentComponent2,
            null,
            true
          );
          if (!delayEnter) {
            mountFallback();
          }
        },
        move(container2, anchor2, type) {
          suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);
          suspense.container = container2;
        },
        next() {
          return suspense.activeBranch && next(suspense.activeBranch);
        },
        registerDep(instance, setupRenderEffect, optimized2) {
          const isInPendingSuspense = !!suspense.pendingBranch;
          if (isInPendingSuspense) {
            suspense.deps++;
          }
          const hydratedEl = instance.vnode.el;
          instance.asyncDep.catch((err) => {
            handleError(err, instance, 0);
          }).then((asyncSetupResult) => {
            if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
              return;
            }
            instance.asyncResolved = true;
            const { vnode: vnode2 } = instance;
            {
              pushWarningContext(vnode2);
            }
            handleSetupResult(instance, asyncSetupResult, false);
            if (hydratedEl) {
              vnode2.el = hydratedEl;
            }
            const placeholder = !hydratedEl && instance.subTree.el;
            setupRenderEffect(
              instance,
              vnode2,
              parentNode(hydratedEl || instance.subTree.el),
              hydratedEl ? null : next(instance.subTree),
              suspense,
              namespace,
              optimized2
            );
            if (placeholder) {
              remove(placeholder);
            }
            updateHOCHostEl(instance, vnode2.el);
            {
              popWarningContext();
            }
            if (isInPendingSuspense && --suspense.deps === 0) {
              suspense.resolve();
            }
          });
        },
        unmount(parentSuspense2, doRemove) {
          suspense.isUnmounted = true;
          if (suspense.activeBranch) {
            unmount(
              suspense.activeBranch,
              parentComponent,
              parentSuspense2,
              doRemove
            );
          }
          if (suspense.pendingBranch) {
            unmount(
              suspense.pendingBranch,
              parentComponent,
              parentSuspense2,
              doRemove
            );
          }
        }
      };
      return suspense;
    }
    function hydrateSuspense(node, vnode, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals, hydrateNode) {
      const suspense = vnode.suspense = createSuspenseBoundary(
        vnode,
        parentSuspense,
        parentComponent,
        node.parentNode,
        document.createElement("div"),
        null,
        namespace,
        slotScopeIds,
        optimized,
        rendererInternals,
        true
      );
      const result = hydrateNode(
        node,
        suspense.pendingBranch = vnode.ssContent,
        parentComponent,
        suspense,
        slotScopeIds,
        optimized
      );
      if (suspense.deps === 0) {
        suspense.resolve(false, true);
      }
      return result;
    }
    function normalizeSuspenseChildren(vnode) {
      const { shapeFlag, children } = vnode;
      const isSlotChildren = shapeFlag & 32;
      vnode.ssContent = normalizeSuspenseSlot(
        isSlotChildren ? children.default : children
      );
      vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
    }
    function normalizeSuspenseSlot(s) {
      let block;
      if (shared.isFunction(s)) {
        const trackBlock = isBlockTreeEnabled && s._c;
        if (trackBlock) {
          s._d = false;
          openBlock();
        }
        s = s();
        if (trackBlock) {
          s._d = true;
          block = currentBlock;
          closeBlock();
        }
      }
      if (shared.isArray(s)) {
        const singleChild = filterSingleRoot(s);
        if (!singleChild && s.filter((child) => child !== NULL_DYNAMIC_COMPONENT).length > 0) {
          warn$1(`<Suspense> slots expect a single root node.`);
        }
        s = singleChild;
      }
      s = normalizeVNode(s);
      if (block && !s.dynamicChildren) {
        s.dynamicChildren = block.filter((c) => c !== s);
      }
      return s;
    }
    function queueEffectWithSuspense(fn, suspense) {
      if (suspense && suspense.pendingBranch) {
        if (shared.isArray(fn)) {
          suspense.effects.push(...fn);
        } else {
          suspense.effects.push(fn);
        }
      } else {
        queuePostFlushCb(fn);
      }
    }
    function setActiveBranch(suspense, branch) {
      suspense.activeBranch = branch;
      const { vnode, parentComponent } = suspense;
      let el = branch.el;
      while (!el && branch.component) {
        branch = branch.component.subTree;
        el = branch.el;
      }
      vnode.el = el;
      if (parentComponent && parentComponent.subTree === vnode) {
        parentComponent.vnode.el = el;
        updateHOCHostEl(parentComponent, el);
      }
    }
    function isVNodeSuspensible(vnode) {
      const suspensible = vnode.props && vnode.props.suspensible;
      return suspensible != null && suspensible !== false;
    }
    function injectHook(type, hook, target = currentInstance, prepend = false) {
      if (target) {
        const hooks = target[type] || (target[type] = []);
        const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
          reactivity.pauseTracking();
          const reset = setCurrentInstance(target);
          const res = callWithAsyncErrorHandling(hook, target, type, args);
          reset();
          reactivity.resetTracking();
          return res;
        });
        if (prepend) {
          hooks.unshift(wrappedHook);
        } else {
          hooks.push(wrappedHook);
        }
        return wrappedHook;
      } else {
        const apiName = shared.toHandlerKey(ErrorTypeStrings$1[type].replace(/ hook$/, ""));
        warn$1(
          `${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`
        );
      }
    }
    var createHook = (lifecycle) => (hook, target = currentInstance) => {
      if (!isInSSRComponentSetup || lifecycle === "sp") {
        injectHook(lifecycle, (...args) => hook(...args), target);
      }
    };
    var onBeforeMount = createHook("bm");
    var onMounted = createHook("m");
    var onBeforeUpdate = createHook("bu");
    var onUpdated = createHook("u");
    var onBeforeUnmount = createHook("bum");
    var onUnmounted = createHook("um");
    var onServerPrefetch = createHook("sp");
    var onRenderTriggered = createHook(
      "rtg"
    );
    var onRenderTracked = createHook(
      "rtc"
    );
    function onErrorCaptured(hook, target = currentInstance) {
      injectHook("ec", hook, target);
    }
    function validateDirectiveName(name) {
      if (shared.isBuiltInDirective(name)) {
        warn$1("Do not use built-in directive ids as custom directive id: " + name);
      }
    }
    function withDirectives(vnode, directives) {
      if (currentRenderingInstance === null) {
        warn$1(`withDirectives can only be used inside render functions.`);
        return vnode;
      }
      const instance = getComponentPublicInstance(currentRenderingInstance);
      const bindings = vnode.dirs || (vnode.dirs = []);
      for (let i = 0; i < directives.length; i++) {
        let [dir, value, arg, modifiers = shared.EMPTY_OBJ] = directives[i];
        if (dir) {
          if (shared.isFunction(dir)) {
            dir = {
              mounted: dir,
              updated: dir
            };
          }
          if (dir.deep) {
            traverse(value);
          }
          bindings.push({
            dir,
            instance,
            value,
            oldValue: void 0,
            arg,
            modifiers
          });
        }
      }
      return vnode;
    }
    function invokeDirectiveHook(vnode, prevVNode, instance, name) {
      const bindings = vnode.dirs;
      const oldBindings = prevVNode && prevVNode.dirs;
      for (let i = 0; i < bindings.length; i++) {
        const binding = bindings[i];
        if (oldBindings) {
          binding.oldValue = oldBindings[i].value;
        }
        let hook = binding.dir[name];
        if (hook) {
          reactivity.pauseTracking();
          callWithAsyncErrorHandling(hook, instance, 8, [
            vnode.el,
            binding,
            vnode,
            prevVNode
          ]);
          reactivity.resetTracking();
        }
      }
    }
    function renderList(source, renderItem, cache, index) {
      let ret;
      const cached = cache && cache[index];
      if (shared.isArray(source) || shared.isString(source)) {
        ret = new Array(source.length);
        for (let i = 0, l = source.length; i < l; i++) {
          ret[i] = renderItem(source[i], i, void 0, cached && cached[i]);
        }
      } else if (typeof source === "number") {
        if (!Number.isInteger(source)) {
          warn$1(`The v-for range expect an integer value but got ${source}.`);
        }
        ret = new Array(source);
        for (let i = 0; i < source; i++) {
          ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
        }
      } else if (shared.isObject(source)) {
        if (source[Symbol.iterator]) {
          ret = Array.from(
            source,
            (item, i) => renderItem(item, i, void 0, cached && cached[i])
          );
        } else {
          const keys = Object.keys(source);
          ret = new Array(keys.length);
          for (let i = 0, l = keys.length; i < l; i++) {
            const key = keys[i];
            ret[i] = renderItem(source[key], key, i, cached && cached[i]);
          }
        }
      } else {
        ret = [];
      }
      if (cache) {
        cache[index] = ret;
      }
      return ret;
    }
    function createSlots(slots, dynamicSlots) {
      for (let i = 0; i < dynamicSlots.length; i++) {
        const slot = dynamicSlots[i];
        if (shared.isArray(slot)) {
          for (let j = 0; j < slot.length; j++) {
            slots[slot[j].name] = slot[j].fn;
          }
        } else if (slot) {
          slots[slot.name] = slot.key ? (...args) => {
            const res = slot.fn(...args);
            if (res)
              res.key = slot.key;
            return res;
          } : slot.fn;
        }
      }
      return slots;
    }
    function defineComponent(options, extraOptions) {
      return shared.isFunction(options) ? (() => shared.extend({ name: options.name }, extraOptions, { setup: options }))() : options;
    }
    var isAsyncWrapper = (i) => !!i.type.__asyncLoader;
    function defineAsyncComponent(source) {
      if (shared.isFunction(source)) {
        source = { loader: source };
      }
      const {
        loader,
        loadingComponent,
        errorComponent,
        delay = 200,
        timeout,
        suspensible = true,
        onError: userOnError
      } = source;
      let pendingRequest = null;
      let resolvedComp;
      let retries = 0;
      const retry = () => {
        retries++;
        pendingRequest = null;
        return load();
      };
      const load = () => {
        let thisRequest;
        return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {
          err = err instanceof Error ? err : new Error(String(err));
          if (userOnError) {
            return new Promise((resolve2, reject) => {
              const userRetry = () => resolve2(retry());
              const userFail = () => reject(err);
              userOnError(err, userRetry, userFail, retries + 1);
            });
          } else {
            throw err;
          }
        }).then((comp) => {
          if (thisRequest !== pendingRequest && pendingRequest) {
            return pendingRequest;
          }
          if (!comp) {
            warn$1(
              `Async component loader resolved to undefined. If you are using retry(), make sure to return its return value.`
            );
          }
          if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
            comp = comp.default;
          }
          if (comp && !shared.isObject(comp) && !shared.isFunction(comp)) {
            throw new Error(`Invalid async component load result: ${comp}`);
          }
          resolvedComp = comp;
          return comp;
        }));
      };
      return defineComponent({
        name: "AsyncComponentWrapper",
        __asyncLoader: load,
        get __asyncResolved() {
          return resolvedComp;
        },
        setup() {
          const instance = currentInstance;
          if (resolvedComp) {
            return () => createInnerComp(resolvedComp, instance);
          }
          const onError = (err) => {
            pendingRequest = null;
            handleError(
              err,
              instance,
              13,
              !errorComponent
            );
          };
          if (suspensible && instance.suspense || isInSSRComponentSetup) {
            return load().then((comp) => {
              return () => createInnerComp(comp, instance);
            }).catch((err) => {
              onError(err);
              return () => errorComponent ? createVNode(errorComponent, {
                error: err
              }) : null;
            });
          }
          const loaded = reactivity.ref(false);
          const error = reactivity.ref();
          const delayed = reactivity.ref(!!delay);
          if (delay) {
            setTimeout(() => {
              delayed.value = false;
            }, delay);
          }
          if (timeout != null) {
            setTimeout(() => {
              if (!loaded.value && !error.value) {
                const err = new Error(
                  `Async component timed out after ${timeout}ms.`
                );
                onError(err);
                error.value = err;
              }
            }, timeout);
          }
          load().then(() => {
            loaded.value = true;
            if (instance.parent && isKeepAlive(instance.parent.vnode)) {
              instance.parent.effect.dirty = true;
              queueJob(instance.parent.update);
            }
          }).catch((err) => {
            onError(err);
            error.value = err;
          });
          return () => {
            if (loaded.value && resolvedComp) {
              return createInnerComp(resolvedComp, instance);
            } else if (error.value && errorComponent) {
              return createVNode(errorComponent, {
                error: error.value
              });
            } else if (loadingComponent && !delayed.value) {
              return createVNode(loadingComponent);
            }
          };
        }
      });
    }
    function createInnerComp(comp, parent) {
      const { ref: ref2, props, children, ce } = parent.vnode;
      const vnode = createVNode(comp, props, children);
      vnode.ref = ref2;
      vnode.ce = ce;
      delete parent.vnode.ce;
      return vnode;
    }
    function renderSlot(slots, name, props = {}, fallback, noSlotted) {
      if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
        if (name !== "default")
          props.name = name;
        return createVNode("slot", props, fallback && fallback());
      }
      let slot = slots[name];
      if (slot && slot.length > 1) {
        warn$1(
          `SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template.`
        );
        slot = () => [];
      }
      if (slot && slot._c) {
        slot._d = false;
      }
      openBlock();
      const validSlotContent = slot && ensureValidVNode(slot(props));
      const rendered = createBlock(
        Fragment,
        {
          key: props.key || validSlotContent && validSlotContent.key || `_${name}`
        },
        validSlotContent || (fallback ? fallback() : []),
        validSlotContent && slots._ === 1 ? 64 : -2
      );
      if (!noSlotted && rendered.scopeId) {
        rendered.slotScopeIds = [rendered.scopeId + "-s"];
      }
      if (slot && slot._c) {
        slot._d = true;
      }
      return rendered;
    }
    function ensureValidVNode(vnodes) {
      return vnodes.some((child) => {
        if (!isVNode(child))
          return true;
        if (child.type === Comment)
          return false;
        if (child.type === Fragment && !ensureValidVNode(child.children))
          return false;
        return true;
      }) ? vnodes : null;
    }
    function toHandlers(obj, preserveCaseIfNecessary) {
      const ret = {};
      if (!shared.isObject(obj)) {
        warn$1(`v-on with no argument expects an object value.`);
        return ret;
      }
      for (const key in obj) {
        ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : shared.toHandlerKey(key)] = obj[key];
      }
      return ret;
    }
    var getPublicInstance = (i) => {
      if (!i)
        return null;
      if (isStatefulComponent(i))
        return getComponentPublicInstance(i);
      return getPublicInstance(i.parent);
    };
    var publicPropertiesMap = shared.extend(/* @__PURE__ */ Object.create(null), {
      $: (i) => i,
      $el: (i) => i.vnode.el,
      $data: (i) => i.data,
      $props: (i) => reactivity.shallowReadonly(i.props),
      $attrs: (i) => reactivity.shallowReadonly(i.attrs),
      $slots: (i) => reactivity.shallowReadonly(i.slots),
      $refs: (i) => reactivity.shallowReadonly(i.refs),
      $parent: (i) => getPublicInstance(i.parent),
      $root: (i) => getPublicInstance(i.root),
      $emit: (i) => i.emit,
      $options: (i) => resolveMergedOptions(i),
      $forceUpdate: (i) => i.f || (i.f = () => {
        i.effect.dirty = true;
        queueJob(i.update);
      }),
      $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
      $watch: (i) => instanceWatch.bind(i)
    });
    var isReservedPrefix = (key) => key === "_" || key === "$";
    var hasSetupBinding = (state, key) => state !== shared.EMPTY_OBJ && !state.__isScriptSetup && shared.hasOwn(state, key);
    var PublicInstanceProxyHandlers = {
      get({ _: instance }, key) {
        if (key === "__v_skip") {
          return true;
        }
        const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
        if (key === "__isVue") {
          return true;
        }
        let normalizedProps;
        if (key[0] !== "$") {
          const n = accessCache[key];
          if (n !== void 0) {
            switch (n) {
              case 1:
                return setupState[key];
              case 2:
                return data[key];
              case 4:
                return ctx[key];
              case 3:
                return props[key];
            }
          } else if (hasSetupBinding(setupState, key)) {
            accessCache[key] = 1;
            return setupState[key];
          } else if (data !== shared.EMPTY_OBJ && shared.hasOwn(data, key)) {
            accessCache[key] = 2;
            return data[key];
          } else if ((normalizedProps = instance.propsOptions[0]) && shared.hasOwn(normalizedProps, key)) {
            accessCache[key] = 3;
            return props[key];
          } else if (ctx !== shared.EMPTY_OBJ && shared.hasOwn(ctx, key)) {
            accessCache[key] = 4;
            return ctx[key];
          } else if (shouldCacheAccess) {
            accessCache[key] = 0;
          }
        }
        const publicGetter = publicPropertiesMap[key];
        let cssModule, globalProperties;
        if (publicGetter) {
          if (key === "$attrs") {
            reactivity.track(instance.attrs, "get", "");
            markAttrsAccessed();
          } else if (key === "$slots") {
            reactivity.track(instance, "get", key);
          }
          return publicGetter(instance);
        } else if ((cssModule = type.__cssModules) && (cssModule = cssModule[key])) {
          return cssModule;
        } else if (ctx !== shared.EMPTY_OBJ && shared.hasOwn(ctx, key)) {
          accessCache[key] = 4;
          return ctx[key];
        } else if (globalProperties = appContext.config.globalProperties, shared.hasOwn(globalProperties, key)) {
          {
            return globalProperties[key];
          }
        } else if (currentRenderingInstance && (!shared.isString(key) || key.indexOf("__v") !== 0)) {
          if (data !== shared.EMPTY_OBJ && isReservedPrefix(key[0]) && shared.hasOwn(data, key)) {
            warn$1(
              `Property ${JSON.stringify(
                key
              )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
            );
          } else if (instance === currentRenderingInstance) {
            warn$1(
              `Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`
            );
          }
        }
      },
      set({ _: instance }, key, value) {
        const { data, setupState, ctx } = instance;
        if (hasSetupBinding(setupState, key)) {
          setupState[key] = value;
          return true;
        } else if (setupState.__isScriptSetup && shared.hasOwn(setupState, key)) {
          warn$1(`Cannot mutate <script setup> binding "${key}" from Options API.`);
          return false;
        } else if (data !== shared.EMPTY_OBJ && shared.hasOwn(data, key)) {
          data[key] = value;
          return true;
        } else if (shared.hasOwn(instance.props, key)) {
          warn$1(`Attempting to mutate prop "${key}". Props are readonly.`);
          return false;
        }
        if (key[0] === "$" && key.slice(1) in instance) {
          warn$1(
            `Attempting to mutate public property "${key}". Properties starting with $ are reserved and readonly.`
          );
          return false;
        } else {
          if (key in instance.appContext.config.globalProperties) {
            Object.defineProperty(ctx, key, {
              enumerable: true,
              configurable: true,
              value
            });
          } else {
            ctx[key] = value;
          }
        }
        return true;
      },
      has({
        _: { data, setupState, accessCache, ctx, appContext, propsOptions }
      }, key) {
        let normalizedProps;
        return !!accessCache[key] || data !== shared.EMPTY_OBJ && shared.hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && shared.hasOwn(normalizedProps, key) || shared.hasOwn(ctx, key) || shared.hasOwn(publicPropertiesMap, key) || shared.hasOwn(appContext.config.globalProperties, key);
      },
      defineProperty(target, key, descriptor) {
        if (descriptor.get != null) {
          target._.accessCache[key] = 0;
        } else if (shared.hasOwn(descriptor, "value")) {
          this.set(target, key, descriptor.value, null);
        }
        return Reflect.defineProperty(target, key, descriptor);
      }
    };
    {
      PublicInstanceProxyHandlers.ownKeys = (target) => {
        warn$1(
          `Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`
        );
        return Reflect.ownKeys(target);
      };
    }
    var RuntimeCompiledPublicInstanceProxyHandlers = shared.extend(
      {},
      PublicInstanceProxyHandlers,
      {
        get(target, key) {
          if (key === Symbol.unscopables) {
            return;
          }
          return PublicInstanceProxyHandlers.get(target, key, target);
        },
        has(_, key) {
          const has = key[0] !== "_" && !shared.isGloballyAllowed(key);
          if (!has && PublicInstanceProxyHandlers.has(_, key)) {
            warn$1(
              `Property ${JSON.stringify(
                key
              )} should not start with _ which is a reserved prefix for Vue internals.`
            );
          }
          return has;
        }
      }
    );
    function createDevRenderContext(instance) {
      const target = {};
      Object.defineProperty(target, `_`, {
        configurable: true,
        enumerable: false,
        get: () => instance
      });
      Object.keys(publicPropertiesMap).forEach((key) => {
        Object.defineProperty(target, key, {
          configurable: true,
          enumerable: false,
          get: () => publicPropertiesMap[key](instance),
          set: shared.NOOP
        });
      });
      return target;
    }
    function exposePropsOnRenderContext(instance) {
      const {
        ctx,
        propsOptions: [propsOptions]
      } = instance;
      if (propsOptions) {
        Object.keys(propsOptions).forEach((key) => {
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: () => instance.props[key],
            set: shared.NOOP
          });
        });
      }
    }
    function exposeSetupStateOnRenderContext(instance) {
      const { ctx, setupState } = instance;
      Object.keys(reactivity.toRaw(setupState)).forEach((key) => {
        if (!setupState.__isScriptSetup) {
          if (isReservedPrefix(key[0])) {
            warn$1(
              `setup() return property ${JSON.stringify(
                key
              )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
            );
            return;
          }
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: () => setupState[key],
            set: shared.NOOP
          });
        }
      });
    }
    var warnRuntimeUsage = (method) => warn$1(
      `${method}() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`
    );
    function defineProps() {
      {
        warnRuntimeUsage(`defineProps`);
      }
      return null;
    }
    function defineEmits() {
      {
        warnRuntimeUsage(`defineEmits`);
      }
      return null;
    }
    function defineExpose(exposed) {
      {
        warnRuntimeUsage(`defineExpose`);
      }
    }
    function defineOptions(options) {
      {
        warnRuntimeUsage(`defineOptions`);
      }
    }
    function defineSlots() {
      {
        warnRuntimeUsage(`defineSlots`);
      }
      return null;
    }
    function defineModel() {
      {
        warnRuntimeUsage("defineModel");
      }
    }
    function withDefaults(props, defaults) {
      {
        warnRuntimeUsage(`withDefaults`);
      }
      return null;
    }
    function useSlots() {
      return getContext().slots;
    }
    function useAttrs() {
      return getContext().attrs;
    }
    function getContext() {
      const i = getCurrentInstance();
      if (!i) {
        warn$1(`useContext() called without active instance.`);
      }
      return i.setupContext || (i.setupContext = createSetupContext(i));
    }
    function normalizePropsOrEmits(props) {
      return shared.isArray(props) ? props.reduce(
        (normalized, p) => (normalized[p] = null, normalized),
        {}
      ) : props;
    }
    function mergeDefaults(raw, defaults) {
      const props = normalizePropsOrEmits(raw);
      for (const key in defaults) {
        if (key.startsWith("__skip"))
          continue;
        let opt = props[key];
        if (opt) {
          if (shared.isArray(opt) || shared.isFunction(opt)) {
            opt = props[key] = { type: opt, default: defaults[key] };
          } else {
            opt.default = defaults[key];
          }
        } else if (opt === null) {
          opt = props[key] = { default: defaults[key] };
        } else {
          warn$1(`props default key "${key}" has no corresponding declaration.`);
        }
        if (opt && defaults[`__skip_${key}`]) {
          opt.skipFactory = true;
        }
      }
      return props;
    }
    function mergeModels(a, b) {
      if (!a || !b)
        return a || b;
      if (shared.isArray(a) && shared.isArray(b))
        return a.concat(b);
      return shared.extend({}, normalizePropsOrEmits(a), normalizePropsOrEmits(b));
    }
    function createPropsRestProxy(props, excludedKeys) {
      const ret = {};
      for (const key in props) {
        if (!excludedKeys.includes(key)) {
          Object.defineProperty(ret, key, {
            enumerable: true,
            get: () => props[key]
          });
        }
      }
      return ret;
    }
    function withAsyncContext(getAwaitable) {
      const ctx = getCurrentInstance();
      if (!ctx) {
        warn$1(
          `withAsyncContext called without active current instance. This is likely a bug.`
        );
      }
      let awaitable = getAwaitable();
      unsetCurrentInstance();
      if (shared.isPromise(awaitable)) {
        awaitable = awaitable.catch((e) => {
          setCurrentInstance(ctx);
          throw e;
        });
      }
      return [awaitable, () => setCurrentInstance(ctx)];
    }
    function createDuplicateChecker() {
      const cache = /* @__PURE__ */ Object.create(null);
      return (type, key) => {
        if (cache[key]) {
          warn$1(`${type} property "${key}" is already defined in ${cache[key]}.`);
        } else {
          cache[key] = type;
        }
      };
    }
    var shouldCacheAccess = true;
    function applyOptions(instance) {
      const options = resolveMergedOptions(instance);
      const publicThis = instance.proxy;
      const ctx = instance.ctx;
      shouldCacheAccess = false;
      if (options.beforeCreate) {
        callHook(options.beforeCreate, instance, "bc");
      }
      const {
        data: dataOptions,
        computed: computedOptions,
        methods,
        watch: watchOptions,
        provide: provideOptions,
        inject: injectOptions,
        created,
        beforeMount,
        mounted,
        beforeUpdate,
        updated,
        activated,
        deactivated,
        beforeDestroy,
        beforeUnmount,
        destroyed,
        unmounted,
        render,
        renderTracked,
        renderTriggered,
        errorCaptured,
        serverPrefetch,
        expose,
        inheritAttrs,
        components,
        directives,
        filters
      } = options;
      const checkDuplicateProperties = createDuplicateChecker();
      {
        const [propsOptions] = instance.propsOptions;
        if (propsOptions) {
          for (const key in propsOptions) {
            checkDuplicateProperties("Props", key);
          }
        }
      }
      if (injectOptions) {
        resolveInjections(injectOptions, ctx, checkDuplicateProperties);
      }
      if (methods) {
        for (const key in methods) {
          const methodHandler = methods[key];
          if (shared.isFunction(methodHandler)) {
            {
              Object.defineProperty(ctx, key, {
                value: methodHandler.bind(publicThis),
                configurable: true,
                enumerable: true,
                writable: true
              });
            }
            {
              checkDuplicateProperties("Methods", key);
            }
          } else {
            warn$1(
              `Method "${key}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`
            );
          }
        }
      }
      if (dataOptions) {
        if (!shared.isFunction(dataOptions)) {
          warn$1(
            `The data option must be a function. Plain object usage is no longer supported.`
          );
        }
        const data = dataOptions.call(publicThis, publicThis);
        if (shared.isPromise(data)) {
          warn$1(
            `data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`
          );
        }
        if (!shared.isObject(data)) {
          warn$1(`data() should return an object.`);
        } else {
          instance.data = reactivity.reactive(data);
          {
            for (const key in data) {
              checkDuplicateProperties("Data", key);
              if (!isReservedPrefix(key[0])) {
                Object.defineProperty(ctx, key, {
                  configurable: true,
                  enumerable: true,
                  get: () => data[key],
                  set: shared.NOOP
                });
              }
            }
          }
        }
      }
      shouldCacheAccess = true;
      if (computedOptions) {
        for (const key in computedOptions) {
          const opt = computedOptions[key];
          const get = shared.isFunction(opt) ? opt.bind(publicThis, publicThis) : shared.isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : shared.NOOP;
          if (get === shared.NOOP) {
            warn$1(`Computed property "${key}" has no getter.`);
          }
          const set = !shared.isFunction(opt) && shared.isFunction(opt.set) ? opt.set.bind(publicThis) : () => {
            warn$1(
              `Write operation failed: computed property "${key}" is readonly.`
            );
          };
          const c = computed({
            get,
            set
          });
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: () => c.value,
            set: (v) => c.value = v
          });
          {
            checkDuplicateProperties("Computed", key);
          }
        }
      }
      if (watchOptions) {
        for (const key in watchOptions) {
          createWatcher(watchOptions[key], ctx, publicThis, key);
        }
      }
      if (provideOptions) {
        const provides = shared.isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
        Reflect.ownKeys(provides).forEach((key) => {
          provide(key, provides[key]);
        });
      }
      if (created) {
        callHook(created, instance, "c");
      }
      function registerLifecycleHook(register, hook) {
        if (shared.isArray(hook)) {
          hook.forEach((_hook) => register(_hook.bind(publicThis)));
        } else if (hook) {
          register(hook.bind(publicThis));
        }
      }
      registerLifecycleHook(onBeforeMount, beforeMount);
      registerLifecycleHook(onMounted, mounted);
      registerLifecycleHook(onBeforeUpdate, beforeUpdate);
      registerLifecycleHook(onUpdated, updated);
      registerLifecycleHook(onActivated, activated);
      registerLifecycleHook(onDeactivated, deactivated);
      registerLifecycleHook(onErrorCaptured, errorCaptured);
      registerLifecycleHook(onRenderTracked, renderTracked);
      registerLifecycleHook(onRenderTriggered, renderTriggered);
      registerLifecycleHook(onBeforeUnmount, beforeUnmount);
      registerLifecycleHook(onUnmounted, unmounted);
      registerLifecycleHook(onServerPrefetch, serverPrefetch);
      if (shared.isArray(expose)) {
        if (expose.length) {
          const exposed = instance.exposed || (instance.exposed = {});
          expose.forEach((key) => {
            Object.defineProperty(exposed, key, {
              get: () => publicThis[key],
              set: (val) => publicThis[key] = val
            });
          });
        } else if (!instance.exposed) {
          instance.exposed = {};
        }
      }
      if (render && instance.render === shared.NOOP) {
        instance.render = render;
      }
      if (inheritAttrs != null) {
        instance.inheritAttrs = inheritAttrs;
      }
      if (components)
        instance.components = components;
      if (directives)
        instance.directives = directives;
    }
    function resolveInjections(injectOptions, ctx, checkDuplicateProperties = shared.NOOP) {
      if (shared.isArray(injectOptions)) {
        injectOptions = normalizeInject(injectOptions);
      }
      for (const key in injectOptions) {
        const opt = injectOptions[key];
        let injected;
        if (shared.isObject(opt)) {
          if ("default" in opt) {
            injected = inject(
              opt.from || key,
              opt.default,
              true
            );
          } else {
            injected = inject(opt.from || key);
          }
        } else {
          injected = inject(opt);
        }
        if (reactivity.isRef(injected)) {
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: () => injected.value,
            set: (v) => injected.value = v
          });
        } else {
          ctx[key] = injected;
        }
        {
          checkDuplicateProperties("Inject", key);
        }
      }
    }
    function callHook(hook, instance, type) {
      callWithAsyncErrorHandling(
        shared.isArray(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
        instance,
        type
      );
    }
    function createWatcher(raw, ctx, publicThis, key) {
      const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
      if (shared.isString(raw)) {
        const handler = ctx[raw];
        if (shared.isFunction(handler)) {
          watch(getter, handler);
        } else {
          warn$1(`Invalid watch handler specified by key "${raw}"`, handler);
        }
      } else if (shared.isFunction(raw)) {
        watch(getter, raw.bind(publicThis));
      } else if (shared.isObject(raw)) {
        if (shared.isArray(raw)) {
          raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
        } else {
          const handler = shared.isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
          if (shared.isFunction(handler)) {
            watch(getter, handler, raw);
          } else {
            warn$1(`Invalid watch handler specified by key "${raw.handler}"`, handler);
          }
        }
      } else {
        warn$1(`Invalid watch option: "${key}"`, raw);
      }
    }
    function resolveMergedOptions(instance) {
      const base = instance.type;
      const { mixins, extends: extendsOptions } = base;
      const {
        mixins: globalMixins,
        optionsCache: cache,
        config: { optionMergeStrategies }
      } = instance.appContext;
      const cached = cache.get(base);
      let resolved;
      if (cached) {
        resolved = cached;
      } else if (!globalMixins.length && !mixins && !extendsOptions) {
        {
          resolved = base;
        }
      } else {
        resolved = {};
        if (globalMixins.length) {
          globalMixins.forEach(
            (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
          );
        }
        mergeOptions(resolved, base, optionMergeStrategies);
      }
      if (shared.isObject(base)) {
        cache.set(base, resolved);
      }
      return resolved;
    }
    function mergeOptions(to, from, strats, asMixin = false) {
      const { mixins, extends: extendsOptions } = from;
      if (extendsOptions) {
        mergeOptions(to, extendsOptions, strats, true);
      }
      if (mixins) {
        mixins.forEach(
          (m) => mergeOptions(to, m, strats, true)
        );
      }
      for (const key in from) {
        if (asMixin && key === "expose") {
          warn$1(
            `"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`
          );
        } else {
          const strat = internalOptionMergeStrats[key] || strats && strats[key];
          to[key] = strat ? strat(to[key], from[key]) : from[key];
        }
      }
      return to;
    }
    var internalOptionMergeStrats = {
      data: mergeDataFn,
      props: mergeEmitsOrPropsOptions,
      emits: mergeEmitsOrPropsOptions,
      methods: mergeObjectOptions,
      computed: mergeObjectOptions,
      beforeCreate: mergeAsArray,
      created: mergeAsArray,
      beforeMount: mergeAsArray,
      mounted: mergeAsArray,
      beforeUpdate: mergeAsArray,
      updated: mergeAsArray,
      beforeDestroy: mergeAsArray,
      beforeUnmount: mergeAsArray,
      destroyed: mergeAsArray,
      unmounted: mergeAsArray,
      activated: mergeAsArray,
      deactivated: mergeAsArray,
      errorCaptured: mergeAsArray,
      serverPrefetch: mergeAsArray,
      components: mergeObjectOptions,
      directives: mergeObjectOptions,
      watch: mergeWatchOptions,
      provide: mergeDataFn,
      inject: mergeInject
    };
    function mergeDataFn(to, from) {
      if (!from) {
        return to;
      }
      if (!to) {
        return from;
      }
      return function mergedDataFn() {
        return shared.extend(
          shared.isFunction(to) ? to.call(this, this) : to,
          shared.isFunction(from) ? from.call(this, this) : from
        );
      };
    }
    function mergeInject(to, from) {
      return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
    }
    function normalizeInject(raw) {
      if (shared.isArray(raw)) {
        const res = {};
        for (let i = 0; i < raw.length; i++) {
          res[raw[i]] = raw[i];
        }
        return res;
      }
      return raw;
    }
    function mergeAsArray(to, from) {
      return to ? [...new Set([].concat(to, from))] : from;
    }
    function mergeObjectOptions(to, from) {
      return to ? shared.extend(/* @__PURE__ */ Object.create(null), to, from) : from;
    }
    function mergeEmitsOrPropsOptions(to, from) {
      if (to) {
        if (shared.isArray(to) && shared.isArray(from)) {
          return [.../* @__PURE__ */ new Set([...to, ...from])];
        }
        return shared.extend(
          /* @__PURE__ */ Object.create(null),
          normalizePropsOrEmits(to),
          normalizePropsOrEmits(from != null ? from : {})
        );
      } else {
        return from;
      }
    }
    function mergeWatchOptions(to, from) {
      if (!to)
        return from;
      if (!from)
        return to;
      const merged = shared.extend(/* @__PURE__ */ Object.create(null), to);
      for (const key in from) {
        merged[key] = mergeAsArray(to[key], from[key]);
      }
      return merged;
    }
    function createAppContext() {
      return {
        app: null,
        config: {
          isNativeTag: shared.NO,
          performance: false,
          globalProperties: {},
          optionMergeStrategies: {},
          errorHandler: void 0,
          warnHandler: void 0,
          compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: /* @__PURE__ */ Object.create(null),
        optionsCache: /* @__PURE__ */ new WeakMap(),
        propsCache: /* @__PURE__ */ new WeakMap(),
        emitsCache: /* @__PURE__ */ new WeakMap()
      };
    }
    var uid$1 = 0;
    function createAppAPI(render, hydrate) {
      return function createApp(rootComponent, rootProps = null) {
        if (!shared.isFunction(rootComponent)) {
          rootComponent = shared.extend({}, rootComponent);
        }
        if (rootProps != null && !shared.isObject(rootProps)) {
          warn$1(`root props passed to app.mount() must be an object.`);
          rootProps = null;
        }
        const context = createAppContext();
        const installedPlugins = /* @__PURE__ */ new WeakSet();
        let isMounted = false;
        const app = context.app = {
          _uid: uid$1++,
          _component: rootComponent,
          _props: rootProps,
          _container: null,
          _context: context,
          _instance: null,
          version,
          get config() {
            return context.config;
          },
          set config(v) {
            {
              warn$1(
                `app.config cannot be replaced. Modify individual options instead.`
              );
            }
          },
          use(plugin, ...options) {
            if (installedPlugins.has(plugin)) {
              warn$1(`Plugin has already been applied to target app.`);
            } else if (plugin && shared.isFunction(plugin.install)) {
              installedPlugins.add(plugin);
              plugin.install(app, ...options);
            } else if (shared.isFunction(plugin)) {
              installedPlugins.add(plugin);
              plugin(app, ...options);
            } else {
              warn$1(
                `A plugin must either be a function or an object with an "install" function.`
              );
            }
            return app;
          },
          mixin(mixin) {
            {
              if (!context.mixins.includes(mixin)) {
                context.mixins.push(mixin);
              } else {
                warn$1(
                  "Mixin has already been applied to target app" + (mixin.name ? `: ${mixin.name}` : "")
                );
              }
            }
            return app;
          },
          component(name, component) {
            {
              validateComponentName(name, context.config);
            }
            if (!component) {
              return context.components[name];
            }
            if (context.components[name]) {
              warn$1(`Component "${name}" has already been registered in target app.`);
            }
            context.components[name] = component;
            return app;
          },
          directive(name, directive) {
            {
              validateDirectiveName(name);
            }
            if (!directive) {
              return context.directives[name];
            }
            if (context.directives[name]) {
              warn$1(`Directive "${name}" has already been registered in target app.`);
            }
            context.directives[name] = directive;
            return app;
          },
          mount(rootContainer, isHydrate, namespace) {
            if (!isMounted) {
              if (rootContainer.__vue_app__) {
                warn$1(
                  `There is already an app instance mounted on the host container.
 If you want to mount another app on the same host container, you need to unmount the previous app by calling \`app.unmount()\` first.`
                );
              }
              const vnode = createVNode(rootComponent, rootProps);
              vnode.appContext = context;
              if (namespace === true) {
                namespace = "svg";
              } else if (namespace === false) {
                namespace = void 0;
              }
              {
                context.reload = () => {
                  render(
                    cloneVNode(vnode),
                    rootContainer,
                    namespace
                  );
                };
              }
              if (isHydrate && hydrate) {
                hydrate(vnode, rootContainer);
              } else {
                render(vnode, rootContainer, namespace);
              }
              isMounted = true;
              app._container = rootContainer;
              rootContainer.__vue_app__ = app;
              {
                app._instance = vnode.component;
                devtoolsInitApp(app, version);
              }
              return getComponentPublicInstance(vnode.component);
            } else {
              warn$1(
                `App has already been mounted.
If you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \`const createMyApp = () => createApp(App)\``
              );
            }
          },
          unmount() {
            if (isMounted) {
              render(null, app._container);
              {
                app._instance = null;
                devtoolsUnmountApp(app);
              }
              delete app._container.__vue_app__;
            } else {
              warn$1(`Cannot unmount an app that is not mounted.`);
            }
          },
          provide(key, value) {
            if (key in context.provides) {
              warn$1(
                `App already provides property with key "${String(key)}". It will be overwritten with the new value.`
              );
            }
            context.provides[key] = value;
            return app;
          },
          runWithContext(fn) {
            const lastApp = currentApp;
            currentApp = app;
            try {
              return fn();
            } finally {
              currentApp = lastApp;
            }
          }
        };
        return app;
      };
    }
    var currentApp = null;
    function provide(key, value) {
      if (!currentInstance) {
        {
          warn$1(`provide() can only be used inside setup().`);
        }
      } else {
        let provides = currentInstance.provides;
        const parentProvides = currentInstance.parent && currentInstance.parent.provides;
        if (parentProvides === provides) {
          provides = currentInstance.provides = Object.create(parentProvides);
        }
        provides[key] = value;
      }
    }
    function inject(key, defaultValue, treatDefaultAsFactory = false) {
      const instance = currentInstance || currentRenderingInstance;
      if (instance || currentApp) {
        const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
        if (provides && key in provides) {
          return provides[key];
        } else if (arguments.length > 1) {
          return treatDefaultAsFactory && shared.isFunction(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
        } else {
          warn$1(`injection "${String(key)}" not found.`);
        }
      } else {
        warn$1(`inject() can only be used inside setup() or functional components.`);
      }
    }
    function hasInjectionContext() {
      return !!(currentInstance || currentRenderingInstance || currentApp);
    }
    var internalObjectProto = {};
    var createInternalObject = () => Object.create(internalObjectProto);
    var isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
    function initProps(instance, rawProps, isStateful, isSSR = false) {
      const props = {};
      const attrs = createInternalObject();
      instance.propsDefaults = /* @__PURE__ */ Object.create(null);
      setFullProps(instance, rawProps, props, attrs);
      for (const key in instance.propsOptions[0]) {
        if (!(key in props)) {
          props[key] = void 0;
        }
      }
      {
        validateProps(rawProps || {}, props, instance);
      }
      if (isStateful) {
        instance.props = isSSR ? props : reactivity.shallowReactive(props);
      } else {
        if (!instance.type.props) {
          instance.props = attrs;
        } else {
          instance.props = props;
        }
      }
      instance.attrs = attrs;
    }
    function isInHmrContext(instance) {
      while (instance) {
        if (instance.type.__hmrId)
          return true;
        instance = instance.parent;
      }
    }
    function updateProps(instance, rawProps, rawPrevProps, optimized) {
      const {
        props,
        attrs,
        vnode: { patchFlag }
      } = instance;
      const rawCurrentProps = reactivity.toRaw(props);
      const [options] = instance.propsOptions;
      let hasAttrsChanged = false;
      if (!isInHmrContext(instance) && (optimized || patchFlag > 0) && !(patchFlag & 16)) {
        if (patchFlag & 8) {
          const propsToUpdate = instance.vnode.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            let key = propsToUpdate[i];
            if (isEmitListener(instance.emitsOptions, key)) {
              continue;
            }
            const value = rawProps[key];
            if (options) {
              if (shared.hasOwn(attrs, key)) {
                if (value !== attrs[key]) {
                  attrs[key] = value;
                  hasAttrsChanged = true;
                }
              } else {
                const camelizedKey = shared.camelize(key);
                props[camelizedKey] = resolvePropValue(
                  options,
                  rawCurrentProps,
                  camelizedKey,
                  value,
                  instance,
                  false
                );
              }
            } else {
              if (value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            }
          }
        }
      } else {
        if (setFullProps(instance, rawProps, props, attrs)) {
          hasAttrsChanged = true;
        }
        let kebabKey;
        for (const key in rawCurrentProps) {
          if (!rawProps || !shared.hasOwn(rawProps, key) && ((kebabKey = shared.hyphenate(key)) === key || !shared.hasOwn(rawProps, kebabKey))) {
            if (options) {
              if (rawPrevProps && (rawPrevProps[key] !== void 0 || rawPrevProps[kebabKey] !== void 0)) {
                props[key] = resolvePropValue(
                  options,
                  rawCurrentProps,
                  key,
                  void 0,
                  instance,
                  true
                );
              }
            } else {
              delete props[key];
            }
          }
        }
        if (attrs !== rawCurrentProps) {
          for (const key in attrs) {
            if (!rawProps || !shared.hasOwn(rawProps, key) && true) {
              delete attrs[key];
              hasAttrsChanged = true;
            }
          }
        }
      }
      if (hasAttrsChanged) {
        reactivity.trigger(instance.attrs, "set", "");
      }
      {
        validateProps(rawProps || {}, props, instance);
      }
    }
    function setFullProps(instance, rawProps, props, attrs) {
      const [options, needCastKeys] = instance.propsOptions;
      let hasAttrsChanged = false;
      let rawCastValues;
      if (rawProps) {
        for (let key in rawProps) {
          if (shared.isReservedProp(key)) {
            continue;
          }
          const value = rawProps[key];
          let camelKey;
          if (options && shared.hasOwn(options, camelKey = shared.camelize(key))) {
            if (!needCastKeys || !needCastKeys.includes(camelKey)) {
              props[camelKey] = value;
            } else {
              (rawCastValues || (rawCastValues = {}))[camelKey] = value;
            }
          } else if (!isEmitListener(instance.emitsOptions, key)) {
            if (!(key in attrs) || value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
      if (needCastKeys) {
        const rawCurrentProps = reactivity.toRaw(props);
        const castValues = rawCastValues || shared.EMPTY_OBJ;
        for (let i = 0; i < needCastKeys.length; i++) {
          const key = needCastKeys[i];
          props[key] = resolvePropValue(
            options,
            rawCurrentProps,
            key,
            castValues[key],
            instance,
            !shared.hasOwn(castValues, key)
          );
        }
      }
      return hasAttrsChanged;
    }
    function resolvePropValue(options, props, key, value, instance, isAbsent) {
      const opt = options[key];
      if (opt != null) {
        const hasDefault = shared.hasOwn(opt, "default");
        if (hasDefault && value === void 0) {
          const defaultValue = opt.default;
          if (opt.type !== Function && !opt.skipFactory && shared.isFunction(defaultValue)) {
            const { propsDefaults } = instance;
            if (key in propsDefaults) {
              value = propsDefaults[key];
            } else {
              const reset = setCurrentInstance(instance);
              value = propsDefaults[key] = defaultValue.call(
                null,
                props
              );
              reset();
            }
          } else {
            value = defaultValue;
          }
        }
        if (opt[0]) {
          if (isAbsent && !hasDefault) {
            value = false;
          } else if (opt[1] && (value === "" || value === shared.hyphenate(key))) {
            value = true;
          }
        }
      }
      return value;
    }
    function normalizePropsOptions(comp, appContext, asMixin = false) {
      const cache = appContext.propsCache;
      const cached = cache.get(comp);
      if (cached) {
        return cached;
      }
      const raw = comp.props;
      const normalized = {};
      const needCastKeys = [];
      let hasExtends = false;
      if (!shared.isFunction(comp)) {
        const extendProps = (raw2) => {
          hasExtends = true;
          const [props, keys] = normalizePropsOptions(raw2, appContext, true);
          shared.extend(normalized, props);
          if (keys)
            needCastKeys.push(...keys);
        };
        if (!asMixin && appContext.mixins.length) {
          appContext.mixins.forEach(extendProps);
        }
        if (comp.extends) {
          extendProps(comp.extends);
        }
        if (comp.mixins) {
          comp.mixins.forEach(extendProps);
        }
      }
      if (!raw && !hasExtends) {
        if (shared.isObject(comp)) {
          cache.set(comp, shared.EMPTY_ARR);
        }
        return shared.EMPTY_ARR;
      }
      if (shared.isArray(raw)) {
        for (let i = 0; i < raw.length; i++) {
          if (!shared.isString(raw[i])) {
            warn$1(`props must be strings when using array syntax.`, raw[i]);
          }
          const normalizedKey = shared.camelize(raw[i]);
          if (validatePropName(normalizedKey)) {
            normalized[normalizedKey] = shared.EMPTY_OBJ;
          }
        }
      } else if (raw) {
        if (!shared.isObject(raw)) {
          warn$1(`invalid props options`, raw);
        }
        for (const key in raw) {
          const normalizedKey = shared.camelize(key);
          if (validatePropName(normalizedKey)) {
            const opt = raw[key];
            const prop = normalized[normalizedKey] = shared.isArray(opt) || shared.isFunction(opt) ? { type: opt } : shared.extend({}, opt);
            if (prop) {
              const booleanIndex = getTypeIndex(Boolean, prop.type);
              const stringIndex = getTypeIndex(String, prop.type);
              prop[0] = booleanIndex > -1;
              prop[1] = stringIndex < 0 || booleanIndex < stringIndex;
              if (booleanIndex > -1 || shared.hasOwn(prop, "default")) {
                needCastKeys.push(normalizedKey);
              }
            }
          }
        }
      }
      const res = [normalized, needCastKeys];
      if (shared.isObject(comp)) {
        cache.set(comp, res);
      }
      return res;
    }
    function validatePropName(key) {
      if (key[0] !== "$" && !shared.isReservedProp(key)) {
        return true;
      } else {
        warn$1(`Invalid prop name: "${key}" is a reserved property.`);
      }
      return false;
    }
    function getType(ctor) {
      if (ctor === null) {
        return "null";
      }
      if (typeof ctor === "function") {
        return ctor.name || "";
      } else if (typeof ctor === "object") {
        const name = ctor.constructor && ctor.constructor.name;
        return name || "";
      }
      return "";
    }
    function isSameType(a, b) {
      return getType(a) === getType(b);
    }
    function getTypeIndex(type, expectedTypes) {
      if (shared.isArray(expectedTypes)) {
        return expectedTypes.findIndex((t) => isSameType(t, type));
      } else if (shared.isFunction(expectedTypes)) {
        return isSameType(expectedTypes, type) ? 0 : -1;
      }
      return -1;
    }
    function validateProps(rawProps, props, instance) {
      const resolvedValues = reactivity.toRaw(props);
      const options = instance.propsOptions[0];
      for (const key in options) {
        let opt = options[key];
        if (opt == null)
          continue;
        validateProp(
          key,
          resolvedValues[key],
          opt,
          reactivity.shallowReadonly(resolvedValues),
          !shared.hasOwn(rawProps, key) && !shared.hasOwn(rawProps, shared.hyphenate(key))
        );
      }
    }
    function validateProp(name, value, prop, props, isAbsent) {
      const { type, required, validator, skipCheck } = prop;
      if (required && isAbsent) {
        warn$1('Missing required prop: "' + name + '"');
        return;
      }
      if (value == null && !required) {
        return;
      }
      if (type != null && type !== true && !skipCheck) {
        let isValid = false;
        const types = shared.isArray(type) ? type : [type];
        const expectedTypes = [];
        for (let i = 0; i < types.length && !isValid; i++) {
          const { valid, expectedType } = assertType(value, types[i]);
          expectedTypes.push(expectedType || "");
          isValid = valid;
        }
        if (!isValid) {
          warn$1(getInvalidTypeMessage(name, value, expectedTypes));
          return;
        }
      }
      if (validator && !validator(value, props)) {
        warn$1('Invalid prop: custom validator check failed for prop "' + name + '".');
      }
    }
    var isSimpleType = shared.makeMap(
      "String,Number,Boolean,Function,Symbol,BigInt"
    );
    function assertType(value, type) {
      let valid;
      const expectedType = getType(type);
      if (isSimpleType(expectedType)) {
        const t = typeof value;
        valid = t === expectedType.toLowerCase();
        if (!valid && t === "object") {
          valid = value instanceof type;
        }
      } else if (expectedType === "Object") {
        valid = shared.isObject(value);
      } else if (expectedType === "Array") {
        valid = shared.isArray(value);
      } else if (expectedType === "null") {
        valid = value === null;
      } else {
        valid = value instanceof type;
      }
      return {
        valid,
        expectedType
      };
    }
    function getInvalidTypeMessage(name, value, expectedTypes) {
      if (expectedTypes.length === 0) {
        return `Prop type [] for prop "${name}" won't match anything. Did you mean to use type Array instead?`;
      }
      let message = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map(shared.capitalize).join(" | ")}`;
      const expectedType = expectedTypes[0];
      const receivedType = shared.toRawType(value);
      const expectedValue = styleValue(value, expectedType);
      const receivedValue = styleValue(value, receivedType);
      if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
        message += ` with value ${expectedValue}`;
      }
      message += `, got ${receivedType} `;
      if (isExplicable(receivedType)) {
        message += `with value ${receivedValue}.`;
      }
      return message;
    }
    function styleValue(value, type) {
      if (type === "String") {
        return `"${value}"`;
      } else if (type === "Number") {
        return `${Number(value)}`;
      } else {
        return `${value}`;
      }
    }
    function isExplicable(type) {
      const explicitTypes = ["string", "number", "boolean"];
      return explicitTypes.some((elem) => type.toLowerCase() === elem);
    }
    function isBoolean(...args) {
      return args.some((elem) => elem.toLowerCase() === "boolean");
    }
    var isInternalKey = (key) => key[0] === "_" || key === "$stable";
    var normalizeSlotValue = (value) => shared.isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
    var normalizeSlot = (key, rawSlot, ctx) => {
      if (rawSlot._n) {
        return rawSlot;
      }
      const normalized = withCtx((...args) => {
        if (currentInstance && (!ctx || ctx.root === currentInstance.root)) {
          warn$1(
            `Slot "${key}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`
          );
        }
        return normalizeSlotValue(rawSlot(...args));
      }, ctx);
      normalized._c = false;
      return normalized;
    };
    var normalizeObjectSlots = (rawSlots, slots, instance) => {
      const ctx = rawSlots._ctx;
      for (const key in rawSlots) {
        if (isInternalKey(key))
          continue;
        const value = rawSlots[key];
        if (shared.isFunction(value)) {
          slots[key] = normalizeSlot(key, value, ctx);
        } else if (value != null) {
          {
            warn$1(
              `Non-function value encountered for slot "${key}". Prefer function slots for better performance.`
            );
          }
          const normalized = normalizeSlotValue(value);
          slots[key] = () => normalized;
        }
      }
    };
    var normalizeVNodeSlots = (instance, children) => {
      if (!isKeepAlive(instance.vnode) && true) {
        warn$1(
          `Non-function value encountered for default slot. Prefer function slots for better performance.`
        );
      }
      const normalized = normalizeSlotValue(children);
      instance.slots.default = () => normalized;
    };
    var initSlots = (instance, children) => {
      const slots = instance.slots = createInternalObject();
      if (instance.vnode.shapeFlag & 32) {
        const type = children._;
        if (type) {
          shared.extend(slots, children);
          shared.def(slots, "_", type, true);
        } else {
          normalizeObjectSlots(children, slots);
        }
      } else if (children) {
        normalizeVNodeSlots(instance, children);
      }
    };
    var updateSlots = (instance, children, optimized) => {
      const { vnode, slots } = instance;
      let needDeletionCheck = true;
      let deletionComparisonTarget = shared.EMPTY_OBJ;
      if (vnode.shapeFlag & 32) {
        const type = children._;
        if (type) {
          if (isHmrUpdating) {
            shared.extend(slots, children);
            reactivity.trigger(instance, "set", "$slots");
          } else if (optimized && type === 1) {
            needDeletionCheck = false;
          } else {
            shared.extend(slots, children);
            if (!optimized && type === 1) {
              delete slots._;
            }
          }
        } else {
          needDeletionCheck = !children.$stable;
          normalizeObjectSlots(children, slots);
        }
        deletionComparisonTarget = children;
      } else if (children) {
        normalizeVNodeSlots(instance, children);
        deletionComparisonTarget = { default: 1 };
      }
      if (needDeletionCheck) {
        for (const key in slots) {
          if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
            delete slots[key];
          }
        }
      }
    };
    function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
      if (shared.isArray(rawRef)) {
        rawRef.forEach(
          (r, i) => setRef(
            r,
            oldRawRef && (shared.isArray(oldRawRef) ? oldRawRef[i] : oldRawRef),
            parentSuspense,
            vnode,
            isUnmount
          )
        );
        return;
      }
      if (isAsyncWrapper(vnode) && !isUnmount) {
        return;
      }
      const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
      const value = isUnmount ? null : refValue;
      const { i: owner, r: ref } = rawRef;
      if (!owner) {
        warn$1(
          `Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`
        );
        return;
      }
      const oldRef = oldRawRef && oldRawRef.r;
      const refs = owner.refs === shared.EMPTY_OBJ ? owner.refs = {} : owner.refs;
      const setupState = owner.setupState;
      if (oldRef != null && oldRef !== ref) {
        if (shared.isString(oldRef)) {
          refs[oldRef] = null;
          if (shared.hasOwn(setupState, oldRef)) {
            setupState[oldRef] = null;
          }
        } else if (reactivity.isRef(oldRef)) {
          oldRef.value = null;
        }
      }
      if (shared.isFunction(ref)) {
        callWithErrorHandling(ref, owner, 12, [value, refs]);
      } else {
        const _isString = shared.isString(ref);
        const _isRef = reactivity.isRef(ref);
        if (_isString || _isRef) {
          const doSet = () => {
            if (rawRef.f) {
              const existing = _isString ? shared.hasOwn(setupState, ref) ? setupState[ref] : refs[ref] : ref.value;
              if (isUnmount) {
                shared.isArray(existing) && shared.remove(existing, refValue);
              } else {
                if (!shared.isArray(existing)) {
                  if (_isString) {
                    refs[ref] = [refValue];
                    if (shared.hasOwn(setupState, ref)) {
                      setupState[ref] = refs[ref];
                    }
                  } else {
                    ref.value = [refValue];
                    if (rawRef.k)
                      refs[rawRef.k] = ref.value;
                  }
                } else if (!existing.includes(refValue)) {
                  existing.push(refValue);
                }
              }
            } else if (_isString) {
              refs[ref] = value;
              if (shared.hasOwn(setupState, ref)) {
                setupState[ref] = value;
              }
            } else if (_isRef) {
              ref.value = value;
              if (rawRef.k)
                refs[rawRef.k] = value;
            } else {
              warn$1("Invalid template ref type:", ref, `(${typeof ref})`);
            }
          };
          if (value) {
            doSet.id = -1;
            queuePostRenderEffect(doSet, parentSuspense);
          } else {
            doSet();
          }
        } else {
          warn$1("Invalid template ref type:", ref, `(${typeof ref})`);
        }
      }
    }
    var hasLoggedMismatchError = false;
    var logMismatchError = () => {
      if (hasLoggedMismatchError) {
        return;
      }
      console.error("Hydration completed but contains mismatches.");
      hasLoggedMismatchError = true;
    };
    var isSVGContainer = (container) => container.namespaceURI.includes("svg") && container.tagName !== "foreignObject";
    var isMathMLContainer = (container) => container.namespaceURI.includes("MathML");
    var getContainerType = (container) => {
      if (isSVGContainer(container))
        return "svg";
      if (isMathMLContainer(container))
        return "mathml";
      return void 0;
    };
    var isComment = (node) => node.nodeType === 8;
    function createHydrationFunctions(rendererInternals) {
      const {
        mt: mountComponent,
        p: patch,
        o: {
          patchProp,
          createText,
          nextSibling,
          parentNode,
          remove,
          insert,
          createComment
        }
      } = rendererInternals;
      const hydrate = (vnode, container) => {
        if (!container.hasChildNodes()) {
          warn$1(
            `Attempting to hydrate existing markup but container is empty. Performing full mount instead.`
          );
          patch(null, vnode, container);
          flushPostFlushCbs();
          container._vnode = vnode;
          return;
        }
        hydrateNode(container.firstChild, vnode, null, null, null);
        flushPostFlushCbs();
        container._vnode = vnode;
      };
      const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
        optimized = optimized || !!vnode.dynamicChildren;
        const isFragmentStart = isComment(node) && node.data === "[";
        const onMismatch = () => handleMismatch(
          node,
          vnode,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          isFragmentStart
        );
        const { type, ref, shapeFlag, patchFlag } = vnode;
        let domType = node.nodeType;
        vnode.el = node;
        {
          if (!("__vnode" in node)) {
            Object.defineProperty(node, "__vnode", {
              value: vnode,
              enumerable: false
            });
          }
          if (!("__vueParentComponent" in node)) {
            Object.defineProperty(node, "__vueParentComponent", {
              value: parentComponent,
              enumerable: false
            });
          }
        }
        if (patchFlag === -2) {
          optimized = false;
          vnode.dynamicChildren = null;
        }
        let nextNode = null;
        switch (type) {
          case Text:
            if (domType !== 3) {
              if (vnode.children === "") {
                insert(vnode.el = createText(""), parentNode(node), node);
                nextNode = node;
              } else {
                nextNode = onMismatch();
              }
            } else {
              if (node.data !== vnode.children) {
                warn$1(
                  `Hydration text mismatch in`,
                  node.parentNode,
                  `
  - rendered on server: ${JSON.stringify(
                    node.data
                  )}
  - expected on client: ${JSON.stringify(vnode.children)}`
                );
                logMismatchError();
                node.data = vnode.children;
              }
              nextNode = nextSibling(node);
            }
            break;
          case Comment:
            if (isTemplateNode(node)) {
              nextNode = nextSibling(node);
              replaceNode(
                vnode.el = node.content.firstChild,
                node,
                parentComponent
              );
            } else if (domType !== 8 || isFragmentStart) {
              nextNode = onMismatch();
            } else {
              nextNode = nextSibling(node);
            }
            break;
          case Static:
            if (isFragmentStart) {
              node = nextSibling(node);
              domType = node.nodeType;
            }
            if (domType === 1 || domType === 3) {
              nextNode = node;
              const needToAdoptContent = !vnode.children.length;
              for (let i = 0; i < vnode.staticCount; i++) {
                if (needToAdoptContent)
                  vnode.children += nextNode.nodeType === 1 ? nextNode.outerHTML : nextNode.data;
                if (i === vnode.staticCount - 1) {
                  vnode.anchor = nextNode;
                }
                nextNode = nextSibling(nextNode);
              }
              return isFragmentStart ? nextSibling(nextNode) : nextNode;
            } else {
              onMismatch();
            }
            break;
          case Fragment:
            if (!isFragmentStart) {
              nextNode = onMismatch();
            } else {
              nextNode = hydrateFragment(
                node,
                vnode,
                parentComponent,
                parentSuspense,
                slotScopeIds,
                optimized
              );
            }
            break;
          default:
            if (shapeFlag & 1) {
              if ((domType !== 1 || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) && !isTemplateNode(node)) {
                nextNode = onMismatch();
              } else {
                nextNode = hydrateElement(
                  node,
                  vnode,
                  parentComponent,
                  parentSuspense,
                  slotScopeIds,
                  optimized
                );
              }
            } else if (shapeFlag & 6) {
              vnode.slotScopeIds = slotScopeIds;
              const container = parentNode(node);
              if (isFragmentStart) {
                nextNode = locateClosingAnchor(node);
              } else if (isComment(node) && node.data === "teleport start") {
                nextNode = locateClosingAnchor(node, node.data, "teleport end");
              } else {
                nextNode = nextSibling(node);
              }
              mountComponent(
                vnode,
                container,
                null,
                parentComponent,
                parentSuspense,
                getContainerType(container),
                optimized
              );
              if (isAsyncWrapper(vnode)) {
                let subTree;
                if (isFragmentStart) {
                  subTree = createVNode(Fragment);
                  subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
                } else {
                  subTree = node.nodeType === 3 ? createTextVNode("") : createVNode("div");
                }
                subTree.el = node;
                vnode.component.subTree = subTree;
              }
            } else if (shapeFlag & 64) {
              if (domType !== 8) {
                nextNode = onMismatch();
              } else {
                nextNode = vnode.type.hydrate(
                  node,
                  vnode,
                  parentComponent,
                  parentSuspense,
                  slotScopeIds,
                  optimized,
                  rendererInternals,
                  hydrateChildren
                );
              }
            } else if (shapeFlag & 128) {
              nextNode = vnode.type.hydrate(
                node,
                vnode,
                parentComponent,
                parentSuspense,
                getContainerType(parentNode(node)),
                slotScopeIds,
                optimized,
                rendererInternals,
                hydrateNode
              );
            } else {
              warn$1("Invalid HostVNode type:", type, `(${typeof type})`);
            }
        }
        if (ref != null) {
          setRef(ref, null, parentSuspense, vnode);
        }
        return nextNode;
      };
      const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
        optimized = optimized || !!vnode.dynamicChildren;
        const { type, props, patchFlag, shapeFlag, dirs, transition } = vnode;
        const forcePatch = type === "input" || type === "option";
        {
          if (dirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "created");
          }
          let needCallTransitionHooks = false;
          if (isTemplateNode(el)) {
            needCallTransitionHooks = needTransition(parentSuspense, transition) && parentComponent && parentComponent.vnode.props && parentComponent.vnode.props.appear;
            const content = el.content.firstChild;
            if (needCallTransitionHooks) {
              transition.beforeEnter(content);
            }
            replaceNode(content, el, parentComponent);
            vnode.el = el = content;
          }
          if (shapeFlag & 16 && !(props && (props.innerHTML || props.textContent))) {
            let next = hydrateChildren(
              el.firstChild,
              vnode,
              el,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
            let hasWarned2 = false;
            while (next) {
              if (!hasWarned2) {
                warn$1(
                  `Hydration children mismatch on`,
                  el,
                  `
Server rendered element contains more child nodes than client vdom.`
                );
                hasWarned2 = true;
              }
              logMismatchError();
              const cur = next;
              next = next.nextSibling;
              remove(cur);
            }
          } else if (shapeFlag & 8) {
            if (el.textContent !== vnode.children) {
              warn$1(
                `Hydration text content mismatch on`,
                el,
                `
  - rendered on server: ${el.textContent}
  - expected on client: ${vnode.children}`
              );
              logMismatchError();
              el.textContent = vnode.children;
            }
          }
          if (props) {
            {
              for (const key in props) {
                if (propHasMismatch(el, key, props[key], vnode, parentComponent)) {
                  logMismatchError();
                }
                if (forcePatch && (key.endsWith("value") || key === "indeterminate") || shared.isOn(key) && !shared.isReservedProp(key) || key[0] === ".") {
                  patchProp(
                    el,
                    key,
                    null,
                    props[key],
                    void 0,
                    void 0,
                    parentComponent
                  );
                }
              }
            }
          }
          let vnodeHooks;
          if (vnodeHooks = props && props.onVnodeBeforeMount) {
            invokeVNodeHook(vnodeHooks, parentComponent, vnode);
          }
          if (dirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
          }
          if ((vnodeHooks = props && props.onVnodeMounted) || dirs || needCallTransitionHooks) {
            queueEffectWithSuspense(() => {
              vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
              needCallTransitionHooks && transition.enter(el);
              dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
            }, parentSuspense);
          }
        }
        return el.nextSibling;
      };
      const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
        optimized = optimized || !!parentVNode.dynamicChildren;
        const children = parentVNode.children;
        const l = children.length;
        let hasWarned2 = false;
        for (let i = 0; i < l; i++) {
          const vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i]);
          if (node) {
            node = hydrateNode(
              node,
              vnode,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
          } else if (vnode.type === Text && !vnode.children) {
            insert(vnode.el = createText(""), container);
          } else {
            if (!hasWarned2) {
              warn$1(
                `Hydration children mismatch on`,
                container,
                `
Server rendered element contains fewer child nodes than client vdom.`
              );
              hasWarned2 = true;
            }
            logMismatchError();
            patch(
              null,
              vnode,
              container,
              null,
              parentComponent,
              parentSuspense,
              getContainerType(container),
              slotScopeIds
            );
          }
        }
        return node;
      };
      const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
        const { slotScopeIds: fragmentSlotScopeIds } = vnode;
        if (fragmentSlotScopeIds) {
          slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
        }
        const container = parentNode(node);
        const next = hydrateChildren(
          nextSibling(node),
          vnode,
          container,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        if (next && isComment(next) && next.data === "]") {
          return nextSibling(vnode.anchor = next);
        } else {
          logMismatchError();
          insert(vnode.anchor = createComment(`]`), container, next);
          return next;
        }
      };
      const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
        warn$1(
          `Hydration node mismatch:
- rendered on server:`,
          node,
          node.nodeType === 3 ? `(text)` : isComment(node) && node.data === "[" ? `(start of fragment)` : ``,
          `
- expected on client:`,
          vnode.type
        );
        logMismatchError();
        vnode.el = null;
        if (isFragment) {
          const end = locateClosingAnchor(node);
          while (true) {
            const next2 = nextSibling(node);
            if (next2 && next2 !== end) {
              remove(next2);
            } else {
              break;
            }
          }
        }
        const next = nextSibling(node);
        const container = parentNode(node);
        remove(node);
        patch(
          null,
          vnode,
          container,
          next,
          parentComponent,
          parentSuspense,
          getContainerType(container),
          slotScopeIds
        );
        return next;
      };
      const locateClosingAnchor = (node, open = "[", close = "]") => {
        let match = 0;
        while (node) {
          node = nextSibling(node);
          if (node && isComment(node)) {
            if (node.data === open)
              match++;
            if (node.data === close) {
              if (match === 0) {
                return nextSibling(node);
              } else {
                match--;
              }
            }
          }
        }
        return node;
      };
      const replaceNode = (newNode, oldNode, parentComponent) => {
        const parentNode2 = oldNode.parentNode;
        if (parentNode2) {
          parentNode2.replaceChild(newNode, oldNode);
        }
        let parent = parentComponent;
        while (parent) {
          if (parent.vnode.el === oldNode) {
            parent.vnode.el = parent.subTree.el = newNode;
          }
          parent = parent.parent;
        }
      };
      const isTemplateNode = (node) => {
        return node.nodeType === 1 && node.tagName.toLowerCase() === "template";
      };
      return [hydrate, hydrateNode];
    }
    function propHasMismatch(el, key, clientValue, vnode, instance) {
      var _a;
      let mismatchType;
      let mismatchKey;
      let actual;
      let expected;
      if (key === "class") {
        actual = el.getAttribute("class");
        expected = shared.normalizeClass(clientValue);
        if (!isSetEqual(toClassSet(actual || ""), toClassSet(expected))) {
          mismatchType = mismatchKey = `class`;
        }
      } else if (key === "style") {
        actual = el.getAttribute("style") || "";
        expected = shared.isString(clientValue) ? clientValue : shared.stringifyStyle(shared.normalizeStyle(clientValue));
        const actualMap = toStyleMap(actual);
        const expectedMap = toStyleMap(expected);
        if (vnode.dirs) {
          for (const { dir, value } of vnode.dirs) {
            if (dir.name === "show" && !value) {
              expectedMap.set("display", "none");
            }
          }
        }
        const root = instance == null ? void 0 : instance.subTree;
        if (vnode === root || (root == null ? void 0 : root.type) === Fragment && root.children.includes(vnode)) {
          const cssVars = (_a = instance == null ? void 0 : instance.getCssVars) == null ? void 0 : _a.call(instance);
          for (const key2 in cssVars) {
            expectedMap.set(`--${key2}`, String(cssVars[key2]));
          }
        }
        if (!isMapEqual(actualMap, expectedMap)) {
          mismatchType = mismatchKey = "style";
        }
      } else if (el instanceof SVGElement && shared.isKnownSvgAttr(key) || el instanceof HTMLElement && (shared.isBooleanAttr(key) || shared.isKnownHtmlAttr(key))) {
        if (shared.isBooleanAttr(key)) {
          actual = el.hasAttribute(key);
          expected = shared.includeBooleanAttr(clientValue);
        } else if (clientValue == null) {
          actual = el.hasAttribute(key);
          expected = false;
        } else {
          if (el.hasAttribute(key)) {
            actual = el.getAttribute(key);
          } else if (key === "value" && el.tagName === "TEXTAREA") {
            actual = el.value;
          } else {
            actual = false;
          }
          expected = shared.isRenderableAttrValue(clientValue) ? String(clientValue) : false;
        }
        if (actual !== expected) {
          mismatchType = `attribute`;
          mismatchKey = key;
        }
      }
      if (mismatchType) {
        const format = (v) => v === false ? `(not rendered)` : `${mismatchKey}="${v}"`;
        const preSegment = `Hydration ${mismatchType} mismatch on`;
        const postSegment = `
  - rendered on server: ${format(actual)}
  - expected on client: ${format(expected)}
  Note: this mismatch is check-only. The DOM will not be rectified in production due to performance overhead.
  You should fix the source of the mismatch.`;
        {
          warn$1(preSegment, el, postSegment);
        }
        return true;
      }
      return false;
    }
    function toClassSet(str) {
      return new Set(str.trim().split(/\s+/));
    }
    function isSetEqual(a, b) {
      if (a.size !== b.size) {
        return false;
      }
      for (const s of a) {
        if (!b.has(s)) {
          return false;
        }
      }
      return true;
    }
    function toStyleMap(str) {
      const styleMap = /* @__PURE__ */ new Map();
      for (const item of str.split(";")) {
        let [key, value] = item.split(":");
        key = key == null ? void 0 : key.trim();
        value = value == null ? void 0 : value.trim();
        if (key && value) {
          styleMap.set(key, value);
        }
      }
      return styleMap;
    }
    function isMapEqual(a, b) {
      if (a.size !== b.size) {
        return false;
      }
      for (const [key, value] of a) {
        if (value !== b.get(key)) {
          return false;
        }
      }
      return true;
    }
    var supported;
    var perf;
    function startMeasure(instance, type) {
      if (instance.appContext.config.performance && isSupported()) {
        perf.mark(`vue-${type}-${instance.uid}`);
      }
      {
        devtoolsPerfStart(instance, type, isSupported() ? perf.now() : Date.now());
      }
    }
    function endMeasure(instance, type) {
      if (instance.appContext.config.performance && isSupported()) {
        const startTag = `vue-${type}-${instance.uid}`;
        const endTag = startTag + `:end`;
        perf.mark(endTag);
        perf.measure(
          `<${formatComponentName(instance, instance.type)}> ${type}`,
          startTag,
          endTag
        );
        perf.clearMarks(startTag);
        perf.clearMarks(endTag);
      }
      {
        devtoolsPerfEnd(instance, type, isSupported() ? perf.now() : Date.now());
      }
    }
    function isSupported() {
      if (supported !== void 0) {
        return supported;
      }
      if (typeof window !== "undefined" && window.performance) {
        supported = true;
        perf = window.performance;
      } else {
        supported = false;
      }
      return supported;
    }
    var queuePostRenderEffect = queueEffectWithSuspense;
    function createRenderer(options) {
      return baseCreateRenderer(options);
    }
    function createHydrationRenderer(options) {
      return baseCreateRenderer(options, createHydrationFunctions);
    }
    function baseCreateRenderer(options, createHydrationFns) {
      const target = shared.getGlobalThis();
      target.__VUE__ = true;
      {
        setDevtoolsHook$1(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
      }
      const {
        insert: hostInsert,
        remove: hostRemove,
        patchProp: hostPatchProp,
        createElement: hostCreateElement,
        createText: hostCreateText,
        createComment: hostCreateComment,
        setText: hostSetText,
        setElementText: hostSetElementText,
        parentNode: hostParentNode,
        nextSibling: hostNextSibling,
        setScopeId: hostSetScopeId = shared.NOOP,
        insertStaticContent: hostInsertStaticContent
      } = options;
      const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = isHmrUpdating ? false : !!n2.dynamicChildren) => {
        if (n1 === n2) {
          return;
        }
        if (n1 && !isSameVNodeType(n1, n2)) {
          anchor = getNextHostNode(n1);
          unmount(n1, parentComponent, parentSuspense, true);
          n1 = null;
        }
        if (n2.patchFlag === -2) {
          optimized = false;
          n2.dynamicChildren = null;
        }
        const { type, ref, shapeFlag } = n2;
        switch (type) {
          case Text:
            processText(n1, n2, container, anchor);
            break;
          case Comment:
            processCommentNode(n1, n2, container, anchor);
            break;
          case Static:
            if (n1 == null) {
              mountStaticNode(n2, container, anchor, namespace);
            } else {
              patchStaticNode(n1, n2, container, namespace);
            }
            break;
          case Fragment:
            processFragment(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            break;
          default:
            if (shapeFlag & 1) {
              processElement(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else if (shapeFlag & 6) {
              processComponent(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else if (shapeFlag & 64) {
              type.process(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized,
                internals
              );
            } else if (shapeFlag & 128) {
              type.process(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized,
                internals
              );
            } else {
              warn$1("Invalid VNode type:", type, `(${typeof type})`);
            }
        }
        if (ref != null && parentComponent) {
          setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
        }
      };
      const processText = (n1, n2, container, anchor) => {
        if (n1 == null) {
          hostInsert(
            n2.el = hostCreateText(n2.children),
            container,
            anchor
          );
        } else {
          const el = n2.el = n1.el;
          if (n2.children !== n1.children) {
            hostSetText(el, n2.children);
          }
        }
      };
      const processCommentNode = (n1, n2, container, anchor) => {
        if (n1 == null) {
          hostInsert(
            n2.el = hostCreateComment(n2.children || ""),
            container,
            anchor
          );
        } else {
          n2.el = n1.el;
        }
      };
      const mountStaticNode = (n2, container, anchor, namespace) => {
        [n2.el, n2.anchor] = hostInsertStaticContent(
          n2.children,
          container,
          anchor,
          namespace,
          n2.el,
          n2.anchor
        );
      };
      const patchStaticNode = (n1, n2, container, namespace) => {
        if (n2.children !== n1.children) {
          const anchor = hostNextSibling(n1.anchor);
          removeStaticNode(n1);
          [n2.el, n2.anchor] = hostInsertStaticContent(
            n2.children,
            container,
            anchor,
            namespace
          );
        } else {
          n2.el = n1.el;
          n2.anchor = n1.anchor;
        }
      };
      const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
        let next;
        while (el && el !== anchor) {
          next = hostNextSibling(el);
          hostInsert(el, container, nextSibling);
          el = next;
        }
        hostInsert(anchor, container, nextSibling);
      };
      const removeStaticNode = ({ el, anchor }) => {
        let next;
        while (el && el !== anchor) {
          next = hostNextSibling(el);
          hostRemove(el);
          el = next;
        }
        hostRemove(anchor);
      };
      const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        if (n2.type === "svg") {
          namespace = "svg";
        } else if (n2.type === "math") {
          namespace = "mathml";
        }
        if (n1 == null) {
          mountElement(
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          patchElement(
            n1,
            n2,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      };
      const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        let el;
        let vnodeHook;
        const { props, shapeFlag, transition, dirs } = vnode;
        el = vnode.el = hostCreateElement(
          vnode.type,
          namespace,
          props && props.is,
          props
        );
        if (shapeFlag & 8) {
          hostSetElementText(el, vnode.children);
        } else if (shapeFlag & 16) {
          mountChildren(
            vnode.children,
            el,
            null,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(vnode, namespace),
            slotScopeIds,
            optimized
          );
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "created");
        }
        setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
        if (props) {
          for (const key in props) {
            if (key !== "value" && !shared.isReservedProp(key)) {
              hostPatchProp(
                el,
                key,
                null,
                props[key],
                namespace,
                vnode.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
          if ("value" in props) {
            hostPatchProp(el, "value", null, props.value, namespace);
          }
          if (vnodeHook = props.onVnodeBeforeMount) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
          }
        }
        {
          Object.defineProperty(el, "__vnode", {
            value: vnode,
            enumerable: false
          });
          Object.defineProperty(el, "__vueParentComponent", {
            value: parentComponent,
            enumerable: false
          });
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
        }
        const needCallTransitionHooks = needTransition(parentSuspense, transition);
        if (needCallTransitionHooks) {
          transition.beforeEnter(el);
        }
        hostInsert(el, container, anchor);
        if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            needCallTransitionHooks && transition.enter(el);
            dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
          }, parentSuspense);
        }
      };
      const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
        if (scopeId) {
          hostSetScopeId(el, scopeId);
        }
        if (slotScopeIds) {
          for (let i = 0; i < slotScopeIds.length; i++) {
            hostSetScopeId(el, slotScopeIds[i]);
          }
        }
        if (parentComponent) {
          let subTree = parentComponent.subTree;
          if (subTree.patchFlag > 0 && subTree.patchFlag & 2048) {
            subTree = filterSingleRoot(subTree.children) || subTree;
          }
          if (vnode === subTree) {
            const parentVNode = parentComponent.vnode;
            setScopeId(
              el,
              parentVNode,
              parentVNode.scopeId,
              parentVNode.slotScopeIds,
              parentComponent.parent
            );
          }
        }
      };
      const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
        for (let i = start; i < children.length; i++) {
          const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
          patch(
            null,
            child,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      };
      const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        const el = n2.el = n1.el;
        let { patchFlag, dynamicChildren, dirs } = n2;
        patchFlag |= n1.patchFlag & 16;
        const oldProps = n1.props || shared.EMPTY_OBJ;
        const newProps = n2.props || shared.EMPTY_OBJ;
        let vnodeHook;
        parentComponent && toggleRecurse(parentComponent, false);
        if (vnodeHook = newProps.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        }
        if (dirs) {
          invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
        }
        parentComponent && toggleRecurse(parentComponent, true);
        if (isHmrUpdating) {
          patchFlag = 0;
          optimized = false;
          dynamicChildren = null;
        }
        if (dynamicChildren) {
          patchBlockChildren(
            n1.dynamicChildren,
            dynamicChildren,
            el,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(n2, namespace),
            slotScopeIds
          );
          {
            traverseStaticChildren(n1, n2);
          }
        } else if (!optimized) {
          patchChildren(
            n1,
            n2,
            el,
            null,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(n2, namespace),
            slotScopeIds,
            false
          );
        }
        if (patchFlag > 0) {
          if (patchFlag & 16) {
            patchProps(
              el,
              n2,
              oldProps,
              newProps,
              parentComponent,
              parentSuspense,
              namespace
            );
          } else {
            if (patchFlag & 2) {
              if (oldProps.class !== newProps.class) {
                hostPatchProp(el, "class", null, newProps.class, namespace);
              }
            }
            if (patchFlag & 4) {
              hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
            }
            if (patchFlag & 8) {
              const propsToUpdate = n2.dynamicProps;
              for (let i = 0; i < propsToUpdate.length; i++) {
                const key = propsToUpdate[i];
                const prev = oldProps[key];
                const next = newProps[key];
                if (next !== prev || key === "value") {
                  hostPatchProp(
                    el,
                    key,
                    prev,
                    next,
                    namespace,
                    n1.children,
                    parentComponent,
                    parentSuspense,
                    unmountChildren
                  );
                }
              }
            }
          }
          if (patchFlag & 1) {
            if (n1.children !== n2.children) {
              hostSetElementText(el, n2.children);
            }
          }
        } else if (!optimized && dynamicChildren == null) {
          patchProps(
            el,
            n2,
            oldProps,
            newProps,
            parentComponent,
            parentSuspense,
            namespace
          );
        }
        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
            dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
          }, parentSuspense);
        }
      };
      const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
        for (let i = 0; i < newChildren.length; i++) {
          const oldVNode = oldChildren[i];
          const newVNode = newChildren[i];
          const container = oldVNode.el && (oldVNode.type === Fragment || !isSameVNodeType(oldVNode, newVNode) || oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : fallbackContainer;
          patch(
            oldVNode,
            newVNode,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            true
          );
        }
      };
      const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, namespace) => {
        if (oldProps !== newProps) {
          if (oldProps !== shared.EMPTY_OBJ) {
            for (const key in oldProps) {
              if (!shared.isReservedProp(key) && !(key in newProps)) {
                hostPatchProp(
                  el,
                  key,
                  oldProps[key],
                  null,
                  namespace,
                  vnode.children,
                  parentComponent,
                  parentSuspense,
                  unmountChildren
                );
              }
            }
          }
          for (const key in newProps) {
            if (shared.isReservedProp(key))
              continue;
            const next = newProps[key];
            const prev = oldProps[key];
            if (next !== prev && key !== "value") {
              hostPatchProp(
                el,
                key,
                prev,
                next,
                namespace,
                vnode.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
          if ("value" in newProps) {
            hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
          }
        }
      };
      const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
        const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
        let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
        if (isHmrUpdating || patchFlag & 2048) {
          patchFlag = 0;
          optimized = false;
          dynamicChildren = null;
        }
        if (fragmentSlotScopeIds) {
          slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
        }
        if (n1 == null) {
          hostInsert(fragmentStartAnchor, container, anchor);
          hostInsert(fragmentEndAnchor, container, anchor);
          mountChildren(
            n2.children || [],
            container,
            fragmentEndAnchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && n1.dynamicChildren) {
            patchBlockChildren(
              n1.dynamicChildren,
              dynamicChildren,
              container,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds
            );
            {
              traverseStaticChildren(n1, n2);
            }
          } else {
            patchChildren(
              n1,
              n2,
              container,
              fragmentEndAnchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        }
      };
      const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        n2.slotScopeIds = slotScopeIds;
        if (n1 == null) {
          if (n2.shapeFlag & 512) {
            parentComponent.ctx.activate(
              n2,
              container,
              anchor,
              namespace,
              optimized
            );
          } else {
            mountComponent(
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              optimized
            );
          }
        } else {
          updateComponent(n1, n2, optimized);
        }
      };
      const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
        const instance = initialVNode.component = createComponentInstance(
          initialVNode,
          parentComponent,
          parentSuspense
        );
        if (instance.type.__hmrId) {
          registerHMR(instance);
        }
        {
          pushWarningContext(initialVNode);
          startMeasure(instance, `mount`);
        }
        if (isKeepAlive(initialVNode)) {
          instance.ctx.renderer = internals;
        }
        {
          {
            startMeasure(instance, `init`);
          }
          setupComponent(instance);
          {
            endMeasure(instance, `init`);
          }
        }
        if (instance.asyncDep) {
          parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
          if (!initialVNode.el) {
            const placeholder = instance.subTree = createVNode(Comment);
            processCommentNode(null, placeholder, container, anchor);
          }
        } else {
          setupRenderEffect(
            instance,
            initialVNode,
            container,
            anchor,
            parentSuspense,
            namespace,
            optimized
          );
        }
        {
          popWarningContext();
          endMeasure(instance, `mount`);
        }
      };
      const updateComponent = (n1, n2, optimized) => {
        const instance = n2.component = n1.component;
        if (shouldUpdateComponent(n1, n2, optimized)) {
          if (instance.asyncDep && !instance.asyncResolved) {
            {
              pushWarningContext(n2);
            }
            updateComponentPreRender(instance, n2, optimized);
            {
              popWarningContext();
            }
            return;
          } else {
            instance.next = n2;
            invalidateJob(instance.update);
            instance.effect.dirty = true;
            instance.update();
          }
        } else {
          n2.el = n1.el;
          instance.vnode = n2;
        }
      };
      const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
        const componentUpdateFn = () => {
          if (!instance.isMounted) {
            let vnodeHook;
            const { el, props } = initialVNode;
            const { bm, m, parent } = instance;
            const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
            toggleRecurse(instance, false);
            if (bm) {
              shared.invokeArrayFns(bm);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
              invokeVNodeHook(vnodeHook, parent, initialVNode);
            }
            toggleRecurse(instance, true);
            if (el && hydrateNode) {
              const hydrateSubTree = () => {
                {
                  startMeasure(instance, `render`);
                }
                instance.subTree = renderComponentRoot(instance);
                {
                  endMeasure(instance, `render`);
                }
                {
                  startMeasure(instance, `hydrate`);
                }
                hydrateNode(
                  el,
                  instance.subTree,
                  instance,
                  parentSuspense,
                  null
                );
                {
                  endMeasure(instance, `hydrate`);
                }
              };
              if (isAsyncWrapperVNode) {
                initialVNode.type.__asyncLoader().then(
                  () => !instance.isUnmounted && hydrateSubTree()
                );
              } else {
                hydrateSubTree();
              }
            } else {
              {
                startMeasure(instance, `render`);
              }
              const subTree = instance.subTree = renderComponentRoot(instance);
              {
                endMeasure(instance, `render`);
              }
              {
                startMeasure(instance, `patch`);
              }
              patch(
                null,
                subTree,
                container,
                anchor,
                instance,
                parentSuspense,
                namespace
              );
              {
                endMeasure(instance, `patch`);
              }
              initialVNode.el = subTree.el;
            }
            if (m) {
              queuePostRenderEffect(m, parentSuspense);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
              const scopedInitialVNode = initialVNode;
              queuePostRenderEffect(
                () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
                parentSuspense
              );
            }
            if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
              instance.a && queuePostRenderEffect(instance.a, parentSuspense);
            }
            instance.isMounted = true;
            {
              devtoolsComponentAdded(instance);
            }
            initialVNode = container = anchor = null;
          } else {
            let { next, bu, u, parent, vnode } = instance;
            {
              const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
              if (nonHydratedAsyncRoot) {
                if (next) {
                  next.el = vnode.el;
                  updateComponentPreRender(instance, next, optimized);
                }
                nonHydratedAsyncRoot.asyncDep.then(() => {
                  if (!instance.isUnmounted) {
                    componentUpdateFn();
                  }
                });
                return;
              }
            }
            let originNext = next;
            let vnodeHook;
            {
              pushWarningContext(next || instance.vnode);
            }
            toggleRecurse(instance, false);
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance, next, optimized);
            } else {
              next = vnode;
            }
            if (bu) {
              shared.invokeArrayFns(bu);
            }
            if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
              invokeVNodeHook(vnodeHook, parent, next, vnode);
            }
            toggleRecurse(instance, true);
            {
              startMeasure(instance, `render`);
            }
            const nextTree = renderComponentRoot(instance);
            {
              endMeasure(instance, `render`);
            }
            const prevTree = instance.subTree;
            instance.subTree = nextTree;
            {
              startMeasure(instance, `patch`);
            }
            patch(
              prevTree,
              nextTree,
              hostParentNode(prevTree.el),
              getNextHostNode(prevTree),
              instance,
              parentSuspense,
              namespace
            );
            {
              endMeasure(instance, `patch`);
            }
            next.el = nextTree.el;
            if (originNext === null) {
              updateHOCHostEl(instance, nextTree.el);
            }
            if (u) {
              queuePostRenderEffect(u, parentSuspense);
            }
            if (vnodeHook = next.props && next.props.onVnodeUpdated) {
              queuePostRenderEffect(
                () => invokeVNodeHook(vnodeHook, parent, next, vnode),
                parentSuspense
              );
            }
            {
              devtoolsComponentUpdated(instance);
            }
            {
              popWarningContext();
            }
          }
        };
        const effect = instance.effect = new reactivity.ReactiveEffect(
          componentUpdateFn,
          shared.NOOP,
          () => queueJob(update),
          instance.scope
        );
        const update = instance.update = () => {
          if (effect.dirty) {
            effect.run();
          }
        };
        update.id = instance.uid;
        toggleRecurse(instance, true);
        {
          effect.onTrack = instance.rtc ? (e) => shared.invokeArrayFns(instance.rtc, e) : void 0;
          effect.onTrigger = instance.rtg ? (e) => shared.invokeArrayFns(instance.rtg, e) : void 0;
          update.ownerInstance = instance;
        }
        update();
      };
      const updateComponentPreRender = (instance, nextVNode, optimized) => {
        nextVNode.component = instance;
        const prevProps = instance.vnode.props;
        instance.vnode = nextVNode;
        instance.next = null;
        updateProps(instance, nextVNode.props, prevProps, optimized);
        updateSlots(instance, nextVNode.children, optimized);
        reactivity.pauseTracking();
        flushPreFlushCbs(instance);
        reactivity.resetTracking();
      };
      const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
        const c1 = n1 && n1.children;
        const prevShapeFlag = n1 ? n1.shapeFlag : 0;
        const c2 = n2.children;
        const { patchFlag, shapeFlag } = n2;
        if (patchFlag > 0) {
          if (patchFlag & 128) {
            patchKeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            return;
          } else if (patchFlag & 256) {
            patchUnkeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            return;
          }
        }
        if (shapeFlag & 8) {
          if (prevShapeFlag & 16) {
            unmountChildren(c1, parentComponent, parentSuspense);
          }
          if (c2 !== c1) {
            hostSetElementText(container, c2);
          }
        } else {
          if (prevShapeFlag & 16) {
            if (shapeFlag & 16) {
              patchKeyedChildren(
                c1,
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else {
              unmountChildren(c1, parentComponent, parentSuspense, true);
            }
          } else {
            if (prevShapeFlag & 8) {
              hostSetElementText(container, "");
            }
            if (shapeFlag & 16) {
              mountChildren(
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            }
          }
        }
      };
      const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        c1 = c1 || shared.EMPTY_ARR;
        c2 = c2 || shared.EMPTY_ARR;
        const oldLength = c1.length;
        const newLength = c2.length;
        const commonLength = Math.min(oldLength, newLength);
        let i;
        for (i = 0; i < commonLength; i++) {
          const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
          patch(
            c1[i],
            nextChild,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
        if (oldLength > newLength) {
          unmountChildren(
            c1,
            parentComponent,
            parentSuspense,
            true,
            false,
            commonLength
          );
        } else {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            commonLength
          );
        }
      };
      const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        let i = 0;
        const l2 = c2.length;
        let e1 = c1.length - 1;
        let e2 = l2 - 1;
        while (i <= e1 && i <= e2) {
          const n1 = c1[i];
          const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
          if (isSameVNodeType(n1, n2)) {
            patch(
              n1,
              n2,
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            break;
          }
          i++;
        }
        while (i <= e1 && i <= e2) {
          const n1 = c1[e1];
          const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
          if (isSameVNodeType(n1, n2)) {
            patch(
              n1,
              n2,
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            break;
          }
          e1--;
          e2--;
        }
        if (i > e1) {
          if (i <= e2) {
            const nextPos = e2 + 1;
            const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
            while (i <= e2) {
              patch(
                null,
                c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
              i++;
            }
          }
        } else if (i > e2) {
          while (i <= e1) {
            unmount(c1[i], parentComponent, parentSuspense, true);
            i++;
          }
        } else {
          const s1 = i;
          const s2 = i;
          const keyToNewIndexMap = /* @__PURE__ */ new Map();
          for (i = s2; i <= e2; i++) {
            const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
            if (nextChild.key != null) {
              if (keyToNewIndexMap.has(nextChild.key)) {
                warn$1(
                  `Duplicate keys found during update:`,
                  JSON.stringify(nextChild.key),
                  `Make sure keys are unique.`
                );
              }
              keyToNewIndexMap.set(nextChild.key, i);
            }
          }
          let j;
          let patched = 0;
          const toBePatched = e2 - s2 + 1;
          let moved = false;
          let maxNewIndexSoFar = 0;
          const newIndexToOldIndexMap = new Array(toBePatched);
          for (i = 0; i < toBePatched; i++)
            newIndexToOldIndexMap[i] = 0;
          for (i = s1; i <= e1; i++) {
            const prevChild = c1[i];
            if (patched >= toBePatched) {
              unmount(prevChild, parentComponent, parentSuspense, true);
              continue;
            }
            let newIndex;
            if (prevChild.key != null) {
              newIndex = keyToNewIndexMap.get(prevChild.key);
            } else {
              for (j = s2; j <= e2; j++) {
                if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                  newIndex = j;
                  break;
                }
              }
            }
            if (newIndex === void 0) {
              unmount(prevChild, parentComponent, parentSuspense, true);
            } else {
              newIndexToOldIndexMap[newIndex - s2] = i + 1;
              if (newIndex >= maxNewIndexSoFar) {
                maxNewIndexSoFar = newIndex;
              } else {
                moved = true;
              }
              patch(
                prevChild,
                c2[newIndex],
                container,
                null,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
              patched++;
            }
          }
          const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : shared.EMPTY_ARR;
          j = increasingNewIndexSequence.length - 1;
          for (i = toBePatched - 1; i >= 0; i--) {
            const nextIndex = s2 + i;
            const nextChild = c2[nextIndex];
            const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
            if (newIndexToOldIndexMap[i] === 0) {
              patch(
                null,
                nextChild,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else if (moved) {
              if (j < 0 || i !== increasingNewIndexSequence[j]) {
                move(nextChild, container, anchor, 2);
              } else {
                j--;
              }
            }
          }
        }
      };
      const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
        const { el, type, transition, children, shapeFlag } = vnode;
        if (shapeFlag & 6) {
          move(vnode.component.subTree, container, anchor, moveType);
          return;
        }
        if (shapeFlag & 128) {
          vnode.suspense.move(container, anchor, moveType);
          return;
        }
        if (shapeFlag & 64) {
          type.move(vnode, container, anchor, internals);
          return;
        }
        if (type === Fragment) {
          hostInsert(el, container, anchor);
          for (let i = 0; i < children.length; i++) {
            move(children[i], container, anchor, moveType);
          }
          hostInsert(vnode.anchor, container, anchor);
          return;
        }
        if (type === Static) {
          moveStaticNode(vnode, container, anchor);
          return;
        }
        const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
        if (needTransition2) {
          if (moveType === 0) {
            transition.beforeEnter(el);
            hostInsert(el, container, anchor);
            queuePostRenderEffect(() => transition.enter(el), parentSuspense);
          } else {
            const { leave, delayLeave, afterLeave } = transition;
            const remove2 = () => hostInsert(el, container, anchor);
            const performLeave = () => {
              leave(el, () => {
                remove2();
                afterLeave && afterLeave();
              });
            };
            if (delayLeave) {
              delayLeave(el, remove2, performLeave);
            } else {
              performLeave();
            }
          }
        } else {
          hostInsert(el, container, anchor);
        }
      };
      const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
        const {
          type,
          props,
          ref,
          children,
          dynamicChildren,
          shapeFlag,
          patchFlag,
          dirs,
          memoIndex
        } = vnode;
        if (ref != null) {
          setRef(ref, null, parentSuspense, vnode, true);
        }
        if (memoIndex != null) {
          parentComponent.renderCache[memoIndex] = void 0;
        }
        if (shapeFlag & 256) {
          parentComponent.ctx.deactivate(vnode);
          return;
        }
        const shouldInvokeDirs = shapeFlag & 1 && dirs;
        const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
        let vnodeHook;
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
        if (shapeFlag & 6) {
          unmountComponent(vnode.component, parentSuspense, doRemove);
        } else {
          if (shapeFlag & 128) {
            vnode.suspense.unmount(parentSuspense, doRemove);
            return;
          }
          if (shouldInvokeDirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
          }
          if (shapeFlag & 64) {
            vnode.type.remove(
              vnode,
              parentComponent,
              parentSuspense,
              optimized,
              internals,
              doRemove
            );
          } else if (dynamicChildren && (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
            unmountChildren(
              dynamicChildren,
              parentComponent,
              parentSuspense,
              false,
              true
            );
          } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
            unmountChildren(children, parentComponent, parentSuspense);
          }
          if (doRemove) {
            remove(vnode);
          }
        }
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
          }, parentSuspense);
        }
      };
      const remove = (vnode) => {
        const { type, el, anchor, transition } = vnode;
        if (type === Fragment) {
          if (vnode.patchFlag > 0 && vnode.patchFlag & 2048 && transition && !transition.persisted) {
            vnode.children.forEach((child) => {
              if (child.type === Comment) {
                hostRemove(child.el);
              } else {
                remove(child);
              }
            });
          } else {
            removeFragment(el, anchor);
          }
          return;
        }
        if (type === Static) {
          removeStaticNode(vnode);
          return;
        }
        const performRemove = () => {
          hostRemove(el);
          if (transition && !transition.persisted && transition.afterLeave) {
            transition.afterLeave();
          }
        };
        if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
          const { leave, delayLeave } = transition;
          const performLeave = () => leave(el, performRemove);
          if (delayLeave) {
            delayLeave(vnode.el, performRemove, performLeave);
          } else {
            performLeave();
          }
        } else {
          performRemove();
        }
      };
      const removeFragment = (cur, end) => {
        let next;
        while (cur !== end) {
          next = hostNextSibling(cur);
          hostRemove(cur);
          cur = next;
        }
        hostRemove(end);
      };
      const unmountComponent = (instance, parentSuspense, doRemove) => {
        if (instance.type.__hmrId) {
          unregisterHMR(instance);
        }
        const { bum, scope, update, subTree, um, m, a } = instance;
        invalidateMount(m);
        invalidateMount(a);
        if (bum) {
          shared.invokeArrayFns(bum);
        }
        scope.stop();
        if (update) {
          update.active = false;
          unmount(subTree, instance, parentSuspense, doRemove);
        }
        if (um) {
          queuePostRenderEffect(um, parentSuspense);
        }
        queuePostRenderEffect(() => {
          instance.isUnmounted = true;
        }, parentSuspense);
        if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
          parentSuspense.deps--;
          if (parentSuspense.deps === 0) {
            parentSuspense.resolve();
          }
        }
        {
          devtoolsComponentRemoved(instance);
        }
      };
      const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
        for (let i = start; i < children.length; i++) {
          unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
        }
      };
      const getNextHostNode = (vnode) => {
        if (vnode.shapeFlag & 6) {
          return getNextHostNode(vnode.component.subTree);
        }
        if (vnode.shapeFlag & 128) {
          return vnode.suspense.next();
        }
        return hostNextSibling(vnode.anchor || vnode.el);
      };
      let isFlushing2 = false;
      const render = (vnode, container, namespace) => {
        if (vnode == null) {
          if (container._vnode) {
            unmount(container._vnode, null, null, true);
          }
        } else {
          patch(
            container._vnode || null,
            vnode,
            container,
            null,
            null,
            null,
            namespace
          );
        }
        if (!isFlushing2) {
          isFlushing2 = true;
          flushPreFlushCbs();
          flushPostFlushCbs();
          isFlushing2 = false;
        }
        container._vnode = vnode;
      };
      const internals = {
        p: patch,
        um: unmount,
        m: move,
        r: remove,
        mt: mountComponent,
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        n: getNextHostNode,
        o: options
      };
      let hydrate;
      let hydrateNode;
      if (createHydrationFns) {
        [hydrate, hydrateNode] = createHydrationFns(
          internals
        );
      }
      return {
        render,
        hydrate,
        createApp: createAppAPI(render, hydrate)
      };
    }
    function resolveChildrenNamespace({ type, props }, currentNamespace) {
      return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
    }
    function toggleRecurse({ effect, update }, allowed) {
      effect.allowRecurse = update.allowRecurse = allowed;
    }
    function needTransition(parentSuspense, transition) {
      return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    }
    function traverseStaticChildren(n1, n2, shallow = false) {
      const ch1 = n1.children;
      const ch2 = n2.children;
      if (shared.isArray(ch1) && shared.isArray(ch2)) {
        for (let i = 0; i < ch1.length; i++) {
          const c1 = ch1[i];
          let c2 = ch2[i];
          if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
            if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
              c2 = ch2[i] = cloneIfMounted(ch2[i]);
              c2.el = c1.el;
            }
            if (!shallow && c2.patchFlag !== -2)
              traverseStaticChildren(c1, c2);
          }
          if (c2.type === Text) {
            c2.el = c1.el;
          }
          if (c2.type === Comment && !c2.el) {
            c2.el = c1.el;
          }
        }
      }
    }
    function getSequence(arr) {
      const p = arr.slice();
      const result = [0];
      let i, j, u, v, c;
      const len = arr.length;
      for (i = 0; i < len; i++) {
        const arrI = arr[i];
        if (arrI !== 0) {
          j = result[result.length - 1];
          if (arr[j] < arrI) {
            p[i] = j;
            result.push(i);
            continue;
          }
          u = 0;
          v = result.length - 1;
          while (u < v) {
            c = u + v >> 1;
            if (arr[result[c]] < arrI) {
              u = c + 1;
            } else {
              v = c;
            }
          }
          if (arrI < arr[result[u]]) {
            if (u > 0) {
              p[i] = result[u - 1];
            }
            result[u] = i;
          }
        }
      }
      u = result.length;
      v = result[u - 1];
      while (u-- > 0) {
        result[u] = v;
        v = p[v];
      }
      return result;
    }
    function locateNonHydratedAsyncRoot(instance) {
      const subComponent = instance.subTree.component;
      if (subComponent) {
        if (subComponent.asyncDep && !subComponent.asyncResolved) {
          return subComponent;
        } else {
          return locateNonHydratedAsyncRoot(subComponent);
        }
      }
    }
    function invalidateMount(hooks) {
      if (hooks) {
        for (let i = 0; i < hooks.length; i++)
          hooks[i].active = false;
      }
    }
    var ssrContextKey = Symbol.for("v-scx");
    var useSSRContext = () => {
      {
        const ctx = inject(ssrContextKey);
        if (!ctx) {
          warn$1(
            `Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`
          );
        }
        return ctx;
      }
    };
    function watchEffect(effect, options) {
      return doWatch(effect, null, options);
    }
    function watchPostEffect(effect, options) {
      return doWatch(
        effect,
        null,
        shared.extend({}, options, { flush: "post" })
      );
    }
    function watchSyncEffect(effect, options) {
      return doWatch(
        effect,
        null,
        shared.extend({}, options, { flush: "sync" })
      );
    }
    var INITIAL_WATCHER_VALUE = {};
    function watch(source, cb, options) {
      if (!shared.isFunction(cb)) {
        warn$1(
          `\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`
        );
      }
      return doWatch(source, cb, options);
    }
    function doWatch(source, cb, {
      immediate,
      deep,
      flush,
      once,
      onTrack,
      onTrigger
    } = shared.EMPTY_OBJ) {
      if (cb && once) {
        const _cb = cb;
        cb = (...args) => {
          _cb(...args);
          unwatch();
        };
      }
      if (deep !== void 0 && typeof deep === "number") {
        warn$1(
          `watch() "deep" option with number value will be used as watch depth in future versions. Please use a boolean instead to avoid potential breakage.`
        );
      }
      if (!cb) {
        if (immediate !== void 0) {
          warn$1(
            `watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`
          );
        }
        if (deep !== void 0) {
          warn$1(
            `watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`
          );
        }
        if (once !== void 0) {
          warn$1(
            `watch() "once" option is only respected when using the watch(source, callback, options?) signature.`
          );
        }
      }
      const warnInvalidSource = (s) => {
        warn$1(
          `Invalid watch source: `,
          s,
          `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`
        );
      };
      const instance = currentInstance;
      const reactiveGetter = (source2) => deep === true ? source2 : traverse(source2, deep === false ? 1 : void 0);
      let getter;
      let forceTrigger = false;
      let isMultiSource = false;
      if (reactivity.isRef(source)) {
        getter = () => source.value;
        forceTrigger = reactivity.isShallow(source);
      } else if (reactivity.isReactive(source)) {
        getter = () => reactiveGetter(source);
        forceTrigger = true;
      } else if (shared.isArray(source)) {
        isMultiSource = true;
        forceTrigger = source.some((s) => reactivity.isReactive(s) || reactivity.isShallow(s));
        getter = () => source.map((s) => {
          if (reactivity.isRef(s)) {
            return s.value;
          } else if (reactivity.isReactive(s)) {
            return reactiveGetter(s);
          } else if (shared.isFunction(s)) {
            return callWithErrorHandling(s, instance, 2);
          } else {
            warnInvalidSource(s);
          }
        });
      } else if (shared.isFunction(source)) {
        if (cb) {
          getter = () => callWithErrorHandling(source, instance, 2);
        } else {
          getter = () => {
            if (cleanup) {
              cleanup();
            }
            return callWithAsyncErrorHandling(
              source,
              instance,
              3,
              [onCleanup]
            );
          };
        }
      } else {
        getter = shared.NOOP;
        warnInvalidSource(source);
      }
      if (cb && deep) {
        const baseGetter = getter;
        getter = () => traverse(baseGetter());
      }
      let cleanup;
      let onCleanup = (fn) => {
        cleanup = effect.onStop = () => {
          callWithErrorHandling(fn, instance, 4);
          cleanup = effect.onStop = void 0;
        };
      };
      let ssrCleanup;
      if (isInSSRComponentSetup) {
        onCleanup = shared.NOOP;
        if (!cb) {
          getter();
        } else if (immediate) {
          callWithAsyncErrorHandling(cb, instance, 3, [
            getter(),
            isMultiSource ? [] : void 0,
            onCleanup
          ]);
        }
        if (flush === "sync") {
          const ctx = useSSRContext();
          ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
        } else {
          return shared.NOOP;
        }
      }
      let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
      const job = () => {
        if (!effect.active || !effect.dirty) {
          return;
        }
        if (cb) {
          const newValue = effect.run();
          if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => shared.hasChanged(v, oldValue[i])) : shared.hasChanged(newValue, oldValue)) || false) {
            if (cleanup) {
              cleanup();
            }
            callWithAsyncErrorHandling(cb, instance, 3, [
              newValue,
              oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
              onCleanup
            ]);
            oldValue = newValue;
          }
        } else {
          effect.run();
        }
      };
      job.allowRecurse = !!cb;
      let scheduler;
      if (flush === "sync") {
        scheduler = job;
      } else if (flush === "post") {
        scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
      } else {
        job.pre = true;
        if (instance)
          job.id = instance.uid;
        scheduler = () => queueJob(job);
      }
      const effect = new reactivity.ReactiveEffect(getter, shared.NOOP, scheduler);
      const scope = reactivity.getCurrentScope();
      const unwatch = () => {
        effect.stop();
        if (scope) {
          shared.remove(scope.effects, effect);
        }
      };
      {
        effect.onTrack = onTrack;
        effect.onTrigger = onTrigger;
      }
      if (cb) {
        if (immediate) {
          job();
        } else {
          oldValue = effect.run();
        }
      } else if (flush === "post") {
        queuePostRenderEffect(
          effect.run.bind(effect),
          instance && instance.suspense
        );
      } else {
        effect.run();
      }
      if (ssrCleanup)
        ssrCleanup.push(unwatch);
      return unwatch;
    }
    function instanceWatch(source, value, options) {
      const publicThis = this.proxy;
      const getter = shared.isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
      let cb;
      if (shared.isFunction(value)) {
        cb = value;
      } else {
        cb = value.handler;
        options = value;
      }
      const reset = setCurrentInstance(this);
      const res = doWatch(getter, cb.bind(publicThis), options);
      reset();
      return res;
    }
    function createPathGetter(ctx, path) {
      const segments = path.split(".");
      return () => {
        let cur = ctx;
        for (let i = 0; i < segments.length && cur; i++) {
          cur = cur[segments[i]];
        }
        return cur;
      };
    }
    function traverse(value, depth = Infinity, seen) {
      if (depth <= 0 || !shared.isObject(value) || value["__v_skip"]) {
        return value;
      }
      seen = seen || /* @__PURE__ */ new Set();
      if (seen.has(value)) {
        return value;
      }
      seen.add(value);
      depth--;
      if (reactivity.isRef(value)) {
        traverse(value.value, depth, seen);
      } else if (shared.isArray(value)) {
        for (let i = 0; i < value.length; i++) {
          traverse(value[i], depth, seen);
        }
      } else if (shared.isSet(value) || shared.isMap(value)) {
        value.forEach((v) => {
          traverse(v, depth, seen);
        });
      } else if (shared.isPlainObject(value)) {
        for (const key in value) {
          traverse(value[key], depth, seen);
        }
        for (const key of Object.getOwnPropertySymbols(value)) {
          if (Object.prototype.propertyIsEnumerable.call(value, key)) {
            traverse(value[key], depth, seen);
          }
        }
      }
      return value;
    }
    var isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
    var KeepAliveImpl = {
      name: `KeepAlive`,
      __isKeepAlive: true,
      props: {
        include: [String, RegExp, Array],
        exclude: [String, RegExp, Array],
        max: [String, Number]
      },
      setup(props, { slots }) {
        const instance = getCurrentInstance();
        const sharedContext = instance.ctx;
        if (!sharedContext.renderer) {
          return () => {
            const children = slots.default && slots.default();
            return children && children.length === 1 ? children[0] : children;
          };
        }
        const cache = /* @__PURE__ */ new Map();
        const keys = /* @__PURE__ */ new Set();
        let current = null;
        {
          instance.__v_cache = cache;
        }
        const parentSuspense = instance.suspense;
        const {
          renderer: {
            p: patch,
            m: move,
            um: _unmount,
            o: { createElement }
          }
        } = sharedContext;
        const storageContainer = createElement("div");
        sharedContext.activate = (vnode, container, anchor, namespace, optimized) => {
          const instance2 = vnode.component;
          move(vnode, container, anchor, 0, parentSuspense);
          patch(
            instance2.vnode,
            vnode,
            container,
            anchor,
            instance2,
            parentSuspense,
            namespace,
            vnode.slotScopeIds,
            optimized
          );
          queuePostRenderEffect(() => {
            instance2.isDeactivated = false;
            if (instance2.a) {
              shared.invokeArrayFns(instance2.a);
            }
            const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
            if (vnodeHook) {
              invokeVNodeHook(vnodeHook, instance2.parent, vnode);
            }
          }, parentSuspense);
          {
            devtoolsComponentAdded(instance2);
          }
        };
        sharedContext.deactivate = (vnode) => {
          const instance2 = vnode.component;
          invalidateMount(instance2.m);
          invalidateMount(instance2.a);
          move(vnode, storageContainer, null, 1, parentSuspense);
          queuePostRenderEffect(() => {
            if (instance2.da) {
              shared.invokeArrayFns(instance2.da);
            }
            const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
            if (vnodeHook) {
              invokeVNodeHook(vnodeHook, instance2.parent, vnode);
            }
            instance2.isDeactivated = true;
          }, parentSuspense);
          {
            devtoolsComponentAdded(instance2);
          }
        };
        function unmount(vnode) {
          resetShapeFlag(vnode);
          _unmount(vnode, instance, parentSuspense, true);
        }
        function pruneCache(filter) {
          cache.forEach((vnode, key) => {
            const name = getComponentName(vnode.type);
            if (name && (!filter || !filter(name))) {
              pruneCacheEntry(key);
            }
          });
        }
        function pruneCacheEntry(key) {
          const cached = cache.get(key);
          if (!current || !isSameVNodeType(cached, current)) {
            unmount(cached);
          } else if (current) {
            resetShapeFlag(current);
          }
          cache.delete(key);
          keys.delete(key);
        }
        watch(
          () => [props.include, props.exclude],
          ([include, exclude]) => {
            include && pruneCache((name) => matches(include, name));
            exclude && pruneCache((name) => !matches(exclude, name));
          },
          { flush: "post", deep: true }
        );
        let pendingCacheKey = null;
        const cacheSubtree = () => {
          if (pendingCacheKey != null) {
            if (isSuspense(instance.subTree.type)) {
              queuePostRenderEffect(() => {
                cache.set(pendingCacheKey, getInnerChild(instance.subTree));
              }, instance.subTree.suspense);
            } else {
              cache.set(pendingCacheKey, getInnerChild(instance.subTree));
            }
          }
        };
        onMounted(cacheSubtree);
        onUpdated(cacheSubtree);
        onBeforeUnmount(() => {
          cache.forEach((cached) => {
            const { subTree, suspense } = instance;
            const vnode = getInnerChild(subTree);
            if (cached.type === vnode.type && cached.key === vnode.key) {
              resetShapeFlag(vnode);
              const da = vnode.component.da;
              da && queuePostRenderEffect(da, suspense);
              return;
            }
            unmount(cached);
          });
        });
        return () => {
          pendingCacheKey = null;
          if (!slots.default) {
            return null;
          }
          const children = slots.default();
          const rawVNode = children[0];
          if (children.length > 1) {
            {
              warn$1(`KeepAlive should contain exactly one component child.`);
            }
            current = null;
            return children;
          } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
            current = null;
            return rawVNode;
          }
          let vnode = getInnerChild(rawVNode);
          const comp = vnode.type;
          const name = getComponentName(
            isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp
          );
          const { include, exclude, max } = props;
          if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
            current = vnode;
            return rawVNode;
          }
          const key = vnode.key == null ? comp : vnode.key;
          const cachedVNode = cache.get(key);
          if (vnode.el) {
            vnode = cloneVNode(vnode);
            if (rawVNode.shapeFlag & 128) {
              rawVNode.ssContent = vnode;
            }
          }
          pendingCacheKey = key;
          if (cachedVNode) {
            vnode.el = cachedVNode.el;
            vnode.component = cachedVNode.component;
            if (vnode.transition) {
              setTransitionHooks(vnode, vnode.transition);
            }
            vnode.shapeFlag |= 512;
            keys.delete(key);
            keys.add(key);
          } else {
            keys.add(key);
            if (max && keys.size > parseInt(max, 10)) {
              pruneCacheEntry(keys.values().next().value);
            }
          }
          vnode.shapeFlag |= 256;
          current = vnode;
          return isSuspense(rawVNode.type) ? rawVNode : vnode;
        };
      }
    };
    var KeepAlive = KeepAliveImpl;
    function matches(pattern, name) {
      if (shared.isArray(pattern)) {
        return pattern.some((p) => matches(p, name));
      } else if (shared.isString(pattern)) {
        return pattern.split(",").includes(name);
      } else if (shared.isRegExp(pattern)) {
        return pattern.test(name);
      }
      return false;
    }
    function onActivated(hook, target) {
      registerKeepAliveHook(hook, "a", target);
    }
    function onDeactivated(hook, target) {
      registerKeepAliveHook(hook, "da", target);
    }
    function registerKeepAliveHook(hook, type, target = currentInstance) {
      const wrappedHook = hook.__wdc || (hook.__wdc = () => {
        let current = target;
        while (current) {
          if (current.isDeactivated) {
            return;
          }
          current = current.parent;
        }
        return hook();
      });
      injectHook(type, wrappedHook, target);
      if (target) {
        let current = target.parent;
        while (current && current.parent) {
          if (isKeepAlive(current.parent.vnode)) {
            injectToKeepAliveRoot(wrappedHook, type, target, current);
          }
          current = current.parent;
        }
      }
    }
    function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
      const injected = injectHook(
        type,
        hook,
        keepAliveRoot,
        true
      );
      onUnmounted(() => {
        shared.remove(keepAliveRoot[type], injected);
      }, target);
    }
    function resetShapeFlag(vnode) {
      vnode.shapeFlag &= ~256;
      vnode.shapeFlag &= ~512;
    }
    function getInnerChild(vnode) {
      return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
    }
    var leaveCbKey = Symbol("_leaveCb");
    var enterCbKey = Symbol("_enterCb");
    function useTransitionState() {
      const state = {
        isMounted: false,
        isLeaving: false,
        isUnmounting: false,
        leavingVNodes: /* @__PURE__ */ new Map()
      };
      onMounted(() => {
        state.isMounted = true;
      });
      onBeforeUnmount(() => {
        state.isUnmounting = true;
      });
      return state;
    }
    var TransitionHookValidator = [Function, Array];
    var BaseTransitionPropsValidators = {
      mode: String,
      appear: Boolean,
      persisted: Boolean,
      onBeforeEnter: TransitionHookValidator,
      onEnter: TransitionHookValidator,
      onAfterEnter: TransitionHookValidator,
      onEnterCancelled: TransitionHookValidator,
      onBeforeLeave: TransitionHookValidator,
      onLeave: TransitionHookValidator,
      onAfterLeave: TransitionHookValidator,
      onLeaveCancelled: TransitionHookValidator,
      onBeforeAppear: TransitionHookValidator,
      onAppear: TransitionHookValidator,
      onAfterAppear: TransitionHookValidator,
      onAppearCancelled: TransitionHookValidator
    };
    var recursiveGetSubtree = (instance) => {
      const subTree = instance.subTree;
      return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
    };
    var BaseTransitionImpl = {
      name: `BaseTransition`,
      props: BaseTransitionPropsValidators,
      setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        return () => {
          const children = slots.default && getTransitionRawChildren(slots.default(), true);
          if (!children || !children.length) {
            return;
          }
          let child = children[0];
          if (children.length > 1) {
            let hasFound = false;
            for (const c of children) {
              if (c.type !== Comment) {
                if (hasFound) {
                  warn$1(
                    "<transition> can only be used on a single element or component. Use <transition-group> for lists."
                  );
                  break;
                }
                child = c;
                hasFound = true;
              }
            }
          }
          const rawProps = reactivity.toRaw(props);
          const { mode } = rawProps;
          if (mode && mode !== "in-out" && mode !== "out-in" && mode !== "default") {
            warn$1(`invalid <transition> mode: ${mode}`);
          }
          if (state.isLeaving) {
            return emptyPlaceholder(child);
          }
          const innerChild = getKeepAliveChild(child);
          if (!innerChild) {
            return emptyPlaceholder(child);
          }
          let enterHooks = resolveTransitionHooks(
            innerChild,
            rawProps,
            state,
            instance,
            (hooks) => enterHooks = hooks
          );
          setTransitionHooks(innerChild, enterHooks);
          const oldChild = instance.subTree;
          const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
          if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild) && recursiveGetSubtree(instance).type !== Comment) {
            const leavingHooks = resolveTransitionHooks(
              oldInnerChild,
              rawProps,
              state,
              instance
            );
            setTransitionHooks(oldInnerChild, leavingHooks);
            if (mode === "out-in" && innerChild.type !== Comment) {
              state.isLeaving = true;
              leavingHooks.afterLeave = () => {
                state.isLeaving = false;
                if (instance.update.active !== false) {
                  instance.effect.dirty = true;
                  instance.update();
                }
              };
              return emptyPlaceholder(child);
            } else if (mode === "in-out" && innerChild.type !== Comment) {
              leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
                const leavingVNodesCache = getLeavingNodesForType(
                  state,
                  oldInnerChild
                );
                leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                el[leaveCbKey] = () => {
                  earlyRemove();
                  el[leaveCbKey] = void 0;
                  delete enterHooks.delayedLeave;
                };
                enterHooks.delayedLeave = delayedLeave;
              };
            }
          }
          return child;
        };
      }
    };
    var BaseTransition = BaseTransitionImpl;
    function getLeavingNodesForType(state, vnode) {
      const { leavingVNodes } = state;
      let leavingVNodesCache = leavingVNodes.get(vnode.type);
      if (!leavingVNodesCache) {
        leavingVNodesCache = /* @__PURE__ */ Object.create(null);
        leavingVNodes.set(vnode.type, leavingVNodesCache);
      }
      return leavingVNodesCache;
    }
    function resolveTransitionHooks(vnode, props, state, instance, postClone) {
      const {
        appear,
        mode,
        persisted = false,
        onBeforeEnter,
        onEnter,
        onAfterEnter,
        onEnterCancelled,
        onBeforeLeave,
        onLeave,
        onAfterLeave,
        onLeaveCancelled,
        onBeforeAppear,
        onAppear,
        onAfterAppear,
        onAppearCancelled
      } = props;
      const key = String(vnode.key);
      const leavingVNodesCache = getLeavingNodesForType(state, vnode);
      const callHook2 = (hook, args) => {
        hook && callWithAsyncErrorHandling(
          hook,
          instance,
          9,
          args
        );
      };
      const callAsyncHook = (hook, args) => {
        const done = args[1];
        callHook2(hook, args);
        if (shared.isArray(hook)) {
          if (hook.every((hook2) => hook2.length <= 1))
            done();
        } else if (hook.length <= 1) {
          done();
        }
      };
      const hooks = {
        mode,
        persisted,
        beforeEnter(el) {
          let hook = onBeforeEnter;
          if (!state.isMounted) {
            if (appear) {
              hook = onBeforeAppear || onBeforeEnter;
            } else {
              return;
            }
          }
          if (el[leaveCbKey]) {
            el[leaveCbKey](
              true
            );
          }
          const leavingVNode = leavingVNodesCache[key];
          if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
            leavingVNode.el[leaveCbKey]();
          }
          callHook2(hook, [el]);
        },
        enter(el) {
          let hook = onEnter;
          let afterHook = onAfterEnter;
          let cancelHook = onEnterCancelled;
          if (!state.isMounted) {
            if (appear) {
              hook = onAppear || onEnter;
              afterHook = onAfterAppear || onAfterEnter;
              cancelHook = onAppearCancelled || onEnterCancelled;
            } else {
              return;
            }
          }
          let called = false;
          const done = el[enterCbKey] = (cancelled) => {
            if (called)
              return;
            called = true;
            if (cancelled) {
              callHook2(cancelHook, [el]);
            } else {
              callHook2(afterHook, [el]);
            }
            if (hooks.delayedLeave) {
              hooks.delayedLeave();
            }
            el[enterCbKey] = void 0;
          };
          if (hook) {
            callAsyncHook(hook, [el, done]);
          } else {
            done();
          }
        },
        leave(el, remove) {
          const key2 = String(vnode.key);
          if (el[enterCbKey]) {
            el[enterCbKey](
              true
            );
          }
          if (state.isUnmounting) {
            return remove();
          }
          callHook2(onBeforeLeave, [el]);
          let called = false;
          const done = el[leaveCbKey] = (cancelled) => {
            if (called)
              return;
            called = true;
            remove();
            if (cancelled) {
              callHook2(onLeaveCancelled, [el]);
            } else {
              callHook2(onAfterLeave, [el]);
            }
            el[leaveCbKey] = void 0;
            if (leavingVNodesCache[key2] === vnode) {
              delete leavingVNodesCache[key2];
            }
          };
          leavingVNodesCache[key2] = vnode;
          if (onLeave) {
            callAsyncHook(onLeave, [el, done]);
          } else {
            done();
          }
        },
        clone(vnode2) {
          const hooks2 = resolveTransitionHooks(
            vnode2,
            props,
            state,
            instance,
            postClone
          );
          if (postClone)
            postClone(hooks2);
          return hooks2;
        }
      };
      return hooks;
    }
    function emptyPlaceholder(vnode) {
      if (isKeepAlive(vnode)) {
        vnode = cloneVNode(vnode);
        vnode.children = null;
        return vnode;
      }
    }
    function getKeepAliveChild(vnode) {
      if (!isKeepAlive(vnode)) {
        return vnode;
      }
      if (vnode.component) {
        return vnode.component.subTree;
      }
      const { shapeFlag, children } = vnode;
      if (children) {
        if (shapeFlag & 16) {
          return children[0];
        }
        if (shapeFlag & 32 && shared.isFunction(children.default)) {
          return children.default();
        }
      }
    }
    function setTransitionHooks(vnode, hooks) {
      if (vnode.shapeFlag & 6 && vnode.component) {
        setTransitionHooks(vnode.component.subTree, hooks);
      } else if (vnode.shapeFlag & 128) {
        vnode.ssContent.transition = hooks.clone(vnode.ssContent);
        vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
      } else {
        vnode.transition = hooks;
      }
    }
    function getTransitionRawChildren(children, keepComment = false, parentKey) {
      let ret = [];
      let keyedFragmentCount = 0;
      for (let i = 0; i < children.length; i++) {
        let child = children[i];
        const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
        if (child.type === Fragment) {
          if (child.patchFlag & 128)
            keyedFragmentCount++;
          ret = ret.concat(
            getTransitionRawChildren(child.children, keepComment, key)
          );
        } else if (keepComment || child.type !== Comment) {
          ret.push(key != null ? cloneVNode(child, { key }) : child);
        }
      }
      if (keyedFragmentCount > 1) {
        for (let i = 0; i < ret.length; i++) {
          ret[i].patchFlag = -2;
        }
      }
      return ret;
    }
    var isTeleport = (type) => type.__isTeleport;
    var isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
    var isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
    var isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
    var resolveTarget = (props, select) => {
      const targetSelector = props && props.to;
      if (shared.isString(targetSelector)) {
        if (!select) {
          warn$1(
            `Current renderer does not support string target for Teleports. (missing querySelector renderer option)`
          );
          return null;
        } else {
          const target = select(targetSelector);
          if (!target && !isTeleportDisabled(props)) {
            warn$1(
              `Failed to locate Teleport target with selector "${targetSelector}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`
            );
          }
          return target;
        }
      } else {
        if (!targetSelector && !isTeleportDisabled(props)) {
          warn$1(`Invalid Teleport target: ${targetSelector}`);
        }
        return targetSelector;
      }
    };
    var TeleportImpl = {
      name: "Teleport",
      __isTeleport: true,
      process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
        const {
          mc: mountChildren,
          pc: patchChildren,
          pbc: patchBlockChildren,
          o: { insert, querySelector, createText, createComment }
        } = internals;
        const disabled = isTeleportDisabled(n2.props);
        let { shapeFlag, children, dynamicChildren } = n2;
        if (isHmrUpdating) {
          optimized = false;
          dynamicChildren = null;
        }
        if (n1 == null) {
          const placeholder = n2.el = createComment("teleport start");
          const mainAnchor = n2.anchor = createComment("teleport end");
          insert(placeholder, container, anchor);
          insert(mainAnchor, container, anchor);
          const target = n2.target = resolveTarget(n2.props, querySelector);
          const targetAnchor = n2.targetAnchor = createText("");
          if (target) {
            insert(targetAnchor, target);
            if (namespace === "svg" || isTargetSVG(target)) {
              namespace = "svg";
            } else if (namespace === "mathml" || isTargetMathML(target)) {
              namespace = "mathml";
            }
          } else if (!disabled) {
            warn$1("Invalid Teleport target on mount:", target, `(${typeof target})`);
          }
          const mount = (container2, anchor2) => {
            if (shapeFlag & 16) {
              mountChildren(
                children,
                container2,
                anchor2,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            }
          };
          if (disabled) {
            mount(container, mainAnchor);
          } else if (target) {
            mount(target, targetAnchor);
          }
        } else {
          n2.el = n1.el;
          const mainAnchor = n2.anchor = n1.anchor;
          const target = n2.target = n1.target;
          const targetAnchor = n2.targetAnchor = n1.targetAnchor;
          const wasDisabled = isTeleportDisabled(n1.props);
          const currentContainer = wasDisabled ? container : target;
          const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
          if (namespace === "svg" || isTargetSVG(target)) {
            namespace = "svg";
          } else if (namespace === "mathml" || isTargetMathML(target)) {
            namespace = "mathml";
          }
          if (dynamicChildren) {
            patchBlockChildren(
              n1.dynamicChildren,
              dynamicChildren,
              currentContainer,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds
            );
            traverseStaticChildren(n1, n2, true);
          } else if (!optimized) {
            patchChildren(
              n1,
              n2,
              currentContainer,
              currentAnchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              false
            );
          }
          if (disabled) {
            if (!wasDisabled) {
              moveTeleport(
                n2,
                container,
                mainAnchor,
                internals,
                1
              );
            } else {
              if (n2.props && n1.props && n2.props.to !== n1.props.to) {
                n2.props.to = n1.props.to;
              }
            }
          } else {
            if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
              const nextTarget = n2.target = resolveTarget(
                n2.props,
                querySelector
              );
              if (nextTarget) {
                moveTeleport(
                  n2,
                  nextTarget,
                  null,
                  internals,
                  0
                );
              } else {
                warn$1(
                  "Invalid Teleport target on update:",
                  target,
                  `(${typeof target})`
                );
              }
            } else if (wasDisabled) {
              moveTeleport(
                n2,
                target,
                targetAnchor,
                internals,
                1
              );
            }
          }
        }
        updateCssVars(n2);
      },
      remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
        const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
        if (target) {
          hostRemove(targetAnchor);
        }
        doRemove && hostRemove(anchor);
        if (shapeFlag & 16) {
          const shouldRemove = doRemove || !isTeleportDisabled(props);
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            unmount(
              child,
              parentComponent,
              parentSuspense,
              shouldRemove,
              !!child.dynamicChildren
            );
          }
        }
      },
      move: moveTeleport,
      hydrate: hydrateTeleport
    };
    function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
      if (moveType === 0) {
        insert(vnode.targetAnchor, container, parentAnchor);
      }
      const { el, anchor, shapeFlag, children, props } = vnode;
      const isReorder = moveType === 2;
      if (isReorder) {
        insert(el, container, parentAnchor);
      }
      if (!isReorder || isTeleportDisabled(props)) {
        if (shapeFlag & 16) {
          for (let i = 0; i < children.length; i++) {
            move(
              children[i],
              container,
              parentAnchor,
              2
            );
          }
        }
      }
      if (isReorder) {
        insert(anchor, container, parentAnchor);
      }
    }
    function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
      o: { nextSibling, parentNode, querySelector }
    }, hydrateChildren) {
      const target = vnode.target = resolveTarget(
        vnode.props,
        querySelector
      );
      if (target) {
        const targetNode = target._lpa || target.firstChild;
        if (vnode.shapeFlag & 16) {
          if (isTeleportDisabled(vnode.props)) {
            vnode.anchor = hydrateChildren(
              nextSibling(node),
              vnode,
              parentNode(node),
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
            vnode.targetAnchor = targetNode;
          } else {
            vnode.anchor = nextSibling(node);
            let targetAnchor = targetNode;
            while (targetAnchor) {
              targetAnchor = nextSibling(targetAnchor);
              if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
                vnode.targetAnchor = targetAnchor;
                target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                break;
              }
            }
            hydrateChildren(
              targetNode,
              vnode,
              target,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
          }
        }
        updateCssVars(vnode);
      }
      return vnode.anchor && nextSibling(vnode.anchor);
    }
    var Teleport = TeleportImpl;
    function updateCssVars(vnode) {
      const ctx = vnode.ctx;
      if (ctx && ctx.ut) {
        let node = vnode.children[0].el;
        while (node && node !== vnode.targetAnchor) {
          if (node.nodeType === 1)
            node.setAttribute("data-v-owner", ctx.uid);
          node = node.nextSibling;
        }
        ctx.ut();
      }
    }
    var Fragment = Symbol.for("v-fgt");
    var Text = Symbol.for("v-txt");
    var Comment = Symbol.for("v-cmt");
    var Static = Symbol.for("v-stc");
    var blockStack = [];
    var currentBlock = null;
    function openBlock(disableTracking = false) {
      blockStack.push(currentBlock = disableTracking ? null : []);
    }
    function closeBlock() {
      blockStack.pop();
      currentBlock = blockStack[blockStack.length - 1] || null;
    }
    var isBlockTreeEnabled = 1;
    function setBlockTracking(value) {
      isBlockTreeEnabled += value;
    }
    function setupBlock(vnode) {
      vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || shared.EMPTY_ARR : null;
      closeBlock();
      if (isBlockTreeEnabled > 0 && currentBlock) {
        currentBlock.push(vnode);
      }
      return vnode;
    }
    function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
      return setupBlock(
        createBaseVNode(
          type,
          props,
          children,
          patchFlag,
          dynamicProps,
          shapeFlag,
          true
        )
      );
    }
    function createBlock(type, props, children, patchFlag, dynamicProps) {
      return setupBlock(
        createVNode(
          type,
          props,
          children,
          patchFlag,
          dynamicProps,
          true
        )
      );
    }
    function isVNode(value) {
      return value ? value.__v_isVNode === true : false;
    }
    function isSameVNodeType(n1, n2) {
      if (n2.shapeFlag & 6 && hmrDirtyComponents.has(n2.type)) {
        n1.shapeFlag &= ~256;
        n2.shapeFlag &= ~512;
        return false;
      }
      return n1.type === n2.type && n1.key === n2.key;
    }
    var vnodeArgsTransformer;
    function transformVNodeArgs(transformer) {
      vnodeArgsTransformer = transformer;
    }
    var createVNodeWithArgsTransform = (...args) => {
      return _createVNode(
        ...vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args
      );
    };
    var normalizeKey = ({ key }) => key != null ? key : null;
    var normalizeRef = ({
      ref,
      ref_key,
      ref_for
    }) => {
      if (typeof ref === "number") {
        ref = "" + ref;
      }
      return ref != null ? shared.isString(ref) || reactivity.isRef(ref) || shared.isFunction(ref) ? { i: currentRenderingInstance, r: ref, k: ref_key, f: !!ref_for } : ref : null;
    };
    function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
      const vnode = {
        __v_isVNode: true,
        __v_skip: true,
        type,
        props,
        key: props && normalizeKey(props),
        ref: props && normalizeRef(props),
        scopeId: currentScopeId,
        slotScopeIds: null,
        children,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag,
        patchFlag,
        dynamicProps,
        dynamicChildren: null,
        appContext: null,
        ctx: currentRenderingInstance
      };
      if (needFullChildrenNormalization) {
        normalizeChildren(vnode, children);
        if (shapeFlag & 128) {
          type.normalize(vnode);
        }
      } else if (children) {
        vnode.shapeFlag |= shared.isString(children) ? 8 : 16;
      }
      if (vnode.key !== vnode.key) {
        warn$1(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
      }
      if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock && (vnode.patchFlag > 0 || shapeFlag & 6) && vnode.patchFlag !== 32) {
        currentBlock.push(vnode);
      }
      return vnode;
    }
    var createVNode = createVNodeWithArgsTransform;
    function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
      if (!type || type === NULL_DYNAMIC_COMPONENT) {
        if (!type) {
          warn$1(`Invalid vnode type when creating vnode: ${type}.`);
        }
        type = Comment;
      }
      if (isVNode(type)) {
        const cloned = cloneVNode(
          type,
          props,
          true
        );
        if (children) {
          normalizeChildren(cloned, children);
        }
        if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
          if (cloned.shapeFlag & 6) {
            currentBlock[currentBlock.indexOf(type)] = cloned;
          } else {
            currentBlock.push(cloned);
          }
        }
        cloned.patchFlag = -2;
        return cloned;
      }
      if (isClassComponent(type)) {
        type = type.__vccOpts;
      }
      if (props) {
        props = guardReactiveProps(props);
        let { class: klass, style } = props;
        if (klass && !shared.isString(klass)) {
          props.class = shared.normalizeClass(klass);
        }
        if (shared.isObject(style)) {
          if (reactivity.isProxy(style) && !shared.isArray(style)) {
            style = shared.extend({}, style);
          }
          props.style = shared.normalizeStyle(style);
        }
      }
      const shapeFlag = shared.isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : shared.isObject(type) ? 4 : shared.isFunction(type) ? 2 : 0;
      if (shapeFlag & 4 && reactivity.isProxy(type)) {
        type = reactivity.toRaw(type);
        warn$1(
          `Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with \`markRaw\` or using \`shallowRef\` instead of \`ref\`.`,
          `
Component that was made reactive: `,
          type
        );
      }
      return createBaseVNode(
        type,
        props,
        children,
        patchFlag,
        dynamicProps,
        shapeFlag,
        isBlockNode,
        true
      );
    }
    function guardReactiveProps(props) {
      if (!props)
        return null;
      return reactivity.isProxy(props) || isInternalObject(props) ? shared.extend({}, props) : props;
    }
    function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
      const { props, ref, patchFlag, children, transition } = vnode;
      const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
      const cloned = {
        __v_isVNode: true,
        __v_skip: true,
        type: vnode.type,
        props: mergedProps,
        key: mergedProps && normalizeKey(mergedProps),
        ref: extraProps && extraProps.ref ? mergeRef && ref ? shared.isArray(ref) ? ref.concat(normalizeRef(extraProps)) : [ref, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref,
        scopeId: vnode.scopeId,
        slotScopeIds: vnode.slotScopeIds,
        children: patchFlag === -1 && shared.isArray(children) ? children.map(deepCloneVNode) : children,
        target: vnode.target,
        targetAnchor: vnode.targetAnchor,
        staticCount: vnode.staticCount,
        shapeFlag: vnode.shapeFlag,
        patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
        dynamicProps: vnode.dynamicProps,
        dynamicChildren: vnode.dynamicChildren,
        appContext: vnode.appContext,
        dirs: vnode.dirs,
        transition,
        component: vnode.component,
        suspense: vnode.suspense,
        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
        el: vnode.el,
        anchor: vnode.anchor,
        ctx: vnode.ctx,
        ce: vnode.ce
      };
      if (transition && cloneTransition) {
        setTransitionHooks(
          cloned,
          transition.clone(cloned)
        );
      }
      return cloned;
    }
    function deepCloneVNode(vnode) {
      const cloned = cloneVNode(vnode);
      if (shared.isArray(vnode.children)) {
        cloned.children = vnode.children.map(deepCloneVNode);
      }
      return cloned;
    }
    function createTextVNode(text = " ", flag = 0) {
      return createVNode(Text, null, text, flag);
    }
    function createStaticVNode(content, numberOfNodes) {
      const vnode = createVNode(Static, null, content);
      vnode.staticCount = numberOfNodes;
      return vnode;
    }
    function createCommentVNode(text = "", asBlock = false) {
      return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
    }
    function normalizeVNode(child) {
      if (child == null || typeof child === "boolean") {
        return createVNode(Comment);
      } else if (shared.isArray(child)) {
        return createVNode(
          Fragment,
          null,
          child.slice()
        );
      } else if (typeof child === "object") {
        return cloneIfMounted(child);
      } else {
        return createVNode(Text, null, String(child));
      }
    }
    function cloneIfMounted(child) {
      return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
    }
    function normalizeChildren(vnode, children) {
      let type = 0;
      const { shapeFlag } = vnode;
      if (children == null) {
        children = null;
      } else if (shared.isArray(children)) {
        type = 16;
      } else if (typeof children === "object") {
        if (shapeFlag & (1 | 64)) {
          const slot = children.default;
          if (slot) {
            slot._c && (slot._d = false);
            normalizeChildren(vnode, slot());
            slot._c && (slot._d = true);
          }
          return;
        } else {
          type = 32;
          const slotFlag = children._;
          if (!slotFlag && !isInternalObject(children)) {
            children._ctx = currentRenderingInstance;
          } else if (slotFlag === 3 && currentRenderingInstance) {
            if (currentRenderingInstance.slots._ === 1) {
              children._ = 1;
            } else {
              children._ = 2;
              vnode.patchFlag |= 1024;
            }
          }
        }
      } else if (shared.isFunction(children)) {
        children = { default: children, _ctx: currentRenderingInstance };
        type = 32;
      } else {
        children = String(children);
        if (shapeFlag & 64) {
          type = 16;
          children = [createTextVNode(children)];
        } else {
          type = 8;
        }
      }
      vnode.children = children;
      vnode.shapeFlag |= type;
    }
    function mergeProps(...args) {
      const ret = {};
      for (let i = 0; i < args.length; i++) {
        const toMerge = args[i];
        for (const key in toMerge) {
          if (key === "class") {
            if (ret.class !== toMerge.class) {
              ret.class = shared.normalizeClass([ret.class, toMerge.class]);
            }
          } else if (key === "style") {
            ret.style = shared.normalizeStyle([ret.style, toMerge.style]);
          } else if (shared.isOn(key)) {
            const existing = ret[key];
            const incoming = toMerge[key];
            if (incoming && existing !== incoming && !(shared.isArray(existing) && existing.includes(incoming))) {
              ret[key] = existing ? [].concat(existing, incoming) : incoming;
            }
          } else if (key !== "") {
            ret[key] = toMerge[key];
          }
        }
      }
      return ret;
    }
    function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
      callWithAsyncErrorHandling(hook, instance, 7, [
        vnode,
        prevVNode
      ]);
    }
    var emptyAppContext = createAppContext();
    var uid = 0;
    function createComponentInstance(vnode, parent, suspense) {
      const type = vnode.type;
      const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
      const instance = {
        uid: uid++,
        vnode,
        type,
        parent,
        appContext,
        root: null,
        next: null,
        subTree: null,
        effect: null,
        update: null,
        scope: new reactivity.EffectScope(
          true
        ),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: parent ? parent.provides : Object.create(appContext.provides),
        accessCache: null,
        renderCache: [],
        components: null,
        directives: null,
        propsOptions: normalizePropsOptions(type, appContext),
        emitsOptions: normalizeEmitsOptions(type, appContext),
        emit: null,
        emitted: null,
        propsDefaults: shared.EMPTY_OBJ,
        inheritAttrs: type.inheritAttrs,
        ctx: shared.EMPTY_OBJ,
        data: shared.EMPTY_OBJ,
        props: shared.EMPTY_OBJ,
        attrs: shared.EMPTY_OBJ,
        slots: shared.EMPTY_OBJ,
        refs: shared.EMPTY_OBJ,
        setupState: shared.EMPTY_OBJ,
        setupContext: null,
        attrsProxy: null,
        slotsProxy: null,
        suspense,
        suspenseId: suspense ? suspense.pendingId : 0,
        asyncDep: null,
        asyncResolved: false,
        isMounted: false,
        isUnmounted: false,
        isDeactivated: false,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
      };
      {
        instance.ctx = createDevRenderContext(instance);
      }
      instance.root = parent ? parent.root : instance;
      instance.emit = emit.bind(null, instance);
      if (vnode.ce) {
        vnode.ce(instance);
      }
      return instance;
    }
    var currentInstance = null;
    var getCurrentInstance = () => currentInstance || currentRenderingInstance;
    var internalSetCurrentInstance;
    var setInSSRSetupState;
    {
      const g = shared.getGlobalThis();
      const registerGlobalSetter = (key, setter) => {
        let setters;
        if (!(setters = g[key]))
          setters = g[key] = [];
        setters.push(setter);
        return (v) => {
          if (setters.length > 1)
            setters.forEach((set) => set(v));
          else
            setters[0](v);
        };
      };
      internalSetCurrentInstance = registerGlobalSetter(
        `__VUE_INSTANCE_SETTERS__`,
        (v) => currentInstance = v
      );
      setInSSRSetupState = registerGlobalSetter(
        `__VUE_SSR_SETTERS__`,
        (v) => isInSSRComponentSetup = v
      );
    }
    var setCurrentInstance = (instance) => {
      const prev = currentInstance;
      internalSetCurrentInstance(instance);
      instance.scope.on();
      return () => {
        instance.scope.off();
        internalSetCurrentInstance(prev);
      };
    };
    var unsetCurrentInstance = () => {
      currentInstance && currentInstance.scope.off();
      internalSetCurrentInstance(null);
    };
    var isBuiltInTag = shared.makeMap("slot,component");
    function validateComponentName(name, { isNativeTag }) {
      if (isBuiltInTag(name) || isNativeTag(name)) {
        warn$1(
          "Do not use built-in or reserved HTML elements as component id: " + name
        );
      }
    }
    function isStatefulComponent(instance) {
      return instance.vnode.shapeFlag & 4;
    }
    var isInSSRComponentSetup = false;
    function setupComponent(instance, isSSR = false) {
      isSSR && setInSSRSetupState(isSSR);
      const { props, children } = instance.vnode;
      const isStateful = isStatefulComponent(instance);
      initProps(instance, props, isStateful, isSSR);
      initSlots(instance, children);
      const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
      isSSR && setInSSRSetupState(false);
      return setupResult;
    }
    function setupStatefulComponent(instance, isSSR) {
      var _a;
      const Component = instance.type;
      {
        if (Component.name) {
          validateComponentName(Component.name, instance.appContext.config);
        }
        if (Component.components) {
          const names = Object.keys(Component.components);
          for (let i = 0; i < names.length; i++) {
            validateComponentName(names[i], instance.appContext.config);
          }
        }
        if (Component.directives) {
          const names = Object.keys(Component.directives);
          for (let i = 0; i < names.length; i++) {
            validateDirectiveName(names[i]);
          }
        }
        if (Component.compilerOptions && isRuntimeOnly()) {
          warn$1(
            `"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`
          );
        }
      }
      instance.accessCache = /* @__PURE__ */ Object.create(null);
      instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
      {
        exposePropsOnRenderContext(instance);
      }
      const { setup } = Component;
      if (setup) {
        const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
        const reset = setCurrentInstance(instance);
        reactivity.pauseTracking();
        const setupResult = callWithErrorHandling(
          setup,
          instance,
          0,
          [
            reactivity.shallowReadonly(instance.props),
            setupContext
          ]
        );
        reactivity.resetTracking();
        reset();
        if (shared.isPromise(setupResult)) {
          setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
          if (isSSR) {
            return setupResult.then((resolvedResult) => {
              handleSetupResult(instance, resolvedResult, isSSR);
            }).catch((e) => {
              handleError(e, instance, 0);
            });
          } else {
            instance.asyncDep = setupResult;
            if (!instance.suspense) {
              const name = (_a = Component.name) != null ? _a : "Anonymous";
              warn$1(
                `Component <${name}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`
              );
            }
          }
        } else {
          handleSetupResult(instance, setupResult, isSSR);
        }
      } else {
        finishComponentSetup(instance, isSSR);
      }
    }
    function handleSetupResult(instance, setupResult, isSSR) {
      if (shared.isFunction(setupResult)) {
        if (instance.type.__ssrInlineRender) {
          instance.ssrRender = setupResult;
        } else {
          instance.render = setupResult;
        }
      } else if (shared.isObject(setupResult)) {
        if (isVNode(setupResult)) {
          warn$1(
            `setup() should not return VNodes directly - return a render function instead.`
          );
        }
        {
          instance.devtoolsRawSetupState = setupResult;
        }
        instance.setupState = reactivity.proxyRefs(setupResult);
        {
          exposeSetupStateOnRenderContext(instance);
        }
      } else if (setupResult !== void 0) {
        warn$1(
          `setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`
        );
      }
      finishComponentSetup(instance, isSSR);
    }
    var compile;
    var installWithProxy;
    function registerRuntimeCompiler(_compile) {
      compile = _compile;
      installWithProxy = (i) => {
        if (i.render._rc) {
          i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
        }
      };
    }
    var isRuntimeOnly = () => !compile;
    function finishComponentSetup(instance, isSSR, skipOptions) {
      const Component = instance.type;
      if (!instance.render) {
        if (!isSSR && compile && !Component.render) {
          const template = Component.template || resolveMergedOptions(instance).template;
          if (template) {
            {
              startMeasure(instance, `compile`);
            }
            const { isCustomElement, compilerOptions } = instance.appContext.config;
            const { delimiters, compilerOptions: componentCompilerOptions } = Component;
            const finalCompilerOptions = shared.extend(
              shared.extend(
                {
                  isCustomElement,
                  delimiters
                },
                compilerOptions
              ),
              componentCompilerOptions
            );
            Component.render = compile(template, finalCompilerOptions);
            {
              endMeasure(instance, `compile`);
            }
          }
        }
        instance.render = Component.render || shared.NOOP;
        if (installWithProxy) {
          installWithProxy(instance);
        }
      }
      {
        const reset = setCurrentInstance(instance);
        reactivity.pauseTracking();
        try {
          applyOptions(instance);
        } finally {
          reactivity.resetTracking();
          reset();
        }
      }
      if (!Component.render && instance.render === shared.NOOP && !isSSR) {
        if (!compile && Component.template) {
          warn$1(
            `Component provided template option but runtime compilation is not supported in this build of Vue.`
          );
        } else {
          warn$1(`Component is missing template or render function: `, Component);
        }
      }
    }
    var attrsProxyHandlers = {
      get(target, key) {
        markAttrsAccessed();
        reactivity.track(target, "get", "");
        return target[key];
      },
      set() {
        warn$1(`setupContext.attrs is readonly.`);
        return false;
      },
      deleteProperty() {
        warn$1(`setupContext.attrs is readonly.`);
        return false;
      }
    };
    function getSlotsProxy(instance) {
      return instance.slotsProxy || (instance.slotsProxy = new Proxy(instance.slots, {
        get(target, key) {
          reactivity.track(instance, "get", "$slots");
          return target[key];
        }
      }));
    }
    function createSetupContext(instance) {
      const expose = (exposed) => {
        {
          if (instance.exposed) {
            warn$1(`expose() should be called only once per setup().`);
          }
          if (exposed != null) {
            let exposedType = typeof exposed;
            if (exposedType === "object") {
              if (shared.isArray(exposed)) {
                exposedType = "array";
              } else if (reactivity.isRef(exposed)) {
                exposedType = "ref";
              }
            }
            if (exposedType !== "object") {
              warn$1(
                `expose() should be passed a plain object, received ${exposedType}.`
              );
            }
          }
        }
        instance.exposed = exposed || {};
      };
      {
        let attrsProxy;
        return Object.freeze({
          get attrs() {
            return attrsProxy || (attrsProxy = new Proxy(instance.attrs, attrsProxyHandlers));
          },
          get slots() {
            return getSlotsProxy(instance);
          },
          get emit() {
            return (event, ...args) => instance.emit(event, ...args);
          },
          expose
        });
      }
    }
    function getComponentPublicInstance(instance) {
      if (instance.exposed) {
        return instance.exposeProxy || (instance.exposeProxy = new Proxy(reactivity.proxyRefs(reactivity.markRaw(instance.exposed)), {
          get(target, key) {
            if (key in target) {
              return target[key];
            } else if (key in publicPropertiesMap) {
              return publicPropertiesMap[key](instance);
            }
          },
          has(target, key) {
            return key in target || key in publicPropertiesMap;
          }
        }));
      } else {
        return instance.proxy;
      }
    }
    var classifyRE = /(?:^|[-_])(\w)/g;
    var classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
    function getComponentName(Component, includeInferred = true) {
      return shared.isFunction(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
    }
    function formatComponentName(instance, Component, isRoot = false) {
      let name = getComponentName(Component);
      if (!name && Component.__file) {
        const match = Component.__file.match(/([^/\\]+)\.\w+$/);
        if (match) {
          name = match[1];
        }
      }
      if (!name && instance && instance.parent) {
        const inferFromRegistry = (registry) => {
          for (const key in registry) {
            if (registry[key] === Component) {
              return key;
            }
          }
        };
        name = inferFromRegistry(
          instance.components || instance.parent.type.components
        ) || inferFromRegistry(instance.appContext.components);
      }
      return name ? classify(name) : isRoot ? `App` : `Anonymous`;
    }
    function isClassComponent(value) {
      return shared.isFunction(value) && "__vccOpts" in value;
    }
    var computed = (getterOrOptions, debugOptions) => {
      const c = reactivity.computed(getterOrOptions, debugOptions, isInSSRComponentSetup);
      {
        const i = getCurrentInstance();
        if (i && i.appContext.config.warnRecursiveComputed) {
          c._warnRecursive = true;
        }
      }
      return c;
    };
    function useModel(props, name, options = shared.EMPTY_OBJ) {
      const i = getCurrentInstance();
      if (!i) {
        warn$1(`useModel() called without active instance.`);
        return reactivity.ref();
      }
      if (!i.propsOptions[0][name]) {
        warn$1(`useModel() called with prop "${name}" which is not declared.`);
        return reactivity.ref();
      }
      const camelizedName = shared.camelize(name);
      const hyphenatedName = shared.hyphenate(name);
      const res = reactivity.customRef((track, trigger) => {
        let localValue;
        watchSyncEffect(() => {
          const propValue = props[name];
          if (shared.hasChanged(localValue, propValue)) {
            localValue = propValue;
            trigger();
          }
        });
        return {
          get() {
            track();
            return options.get ? options.get(localValue) : localValue;
          },
          set(value) {
            const rawProps = i.vnode.props;
            if (!(rawProps && (name in rawProps || camelizedName in rawProps || hyphenatedName in rawProps) && (`onUpdate:${name}` in rawProps || `onUpdate:${camelizedName}` in rawProps || `onUpdate:${hyphenatedName}` in rawProps)) && shared.hasChanged(value, localValue)) {
              localValue = value;
              trigger();
            }
            i.emit(`update:${name}`, options.set ? options.set(value) : value);
          }
        };
      });
      const modifierKey = name === "modelValue" ? "modelModifiers" : `${name}Modifiers`;
      res[Symbol.iterator] = () => {
        let i2 = 0;
        return {
          next() {
            if (i2 < 2) {
              return { value: i2++ ? props[modifierKey] || {} : res, done: false };
            } else {
              return { done: true };
            }
          }
        };
      };
      return res;
    }
    function h(type, propsOrChildren, children) {
      const l = arguments.length;
      if (l === 2) {
        if (shared.isObject(propsOrChildren) && !shared.isArray(propsOrChildren)) {
          if (isVNode(propsOrChildren)) {
            return createVNode(type, null, [propsOrChildren]);
          }
          return createVNode(type, propsOrChildren);
        } else {
          return createVNode(type, null, propsOrChildren);
        }
      } else {
        if (l > 3) {
          children = Array.prototype.slice.call(arguments, 2);
        } else if (l === 3 && isVNode(children)) {
          children = [children];
        }
        return createVNode(type, propsOrChildren, children);
      }
    }
    function initCustomFormatter() {
      if (typeof window === "undefined") {
        return;
      }
      const vueStyle = { style: "color:#3ba776" };
      const numberStyle = { style: "color:#1677ff" };
      const stringStyle = { style: "color:#f5222d" };
      const keywordStyle = { style: "color:#eb2f96" };
      const formatter = {
        header(obj) {
          if (!shared.isObject(obj)) {
            return null;
          }
          if (obj.__isVue) {
            return ["div", vueStyle, `VueInstance`];
          } else if (reactivity.isRef(obj)) {
            return [
              "div",
              {},
              ["span", vueStyle, genRefFlag(obj)],
              "<",
              formatValue(obj.value),
              `>`
            ];
          } else if (reactivity.isReactive(obj)) {
            return [
              "div",
              {},
              ["span", vueStyle, reactivity.isShallow(obj) ? "ShallowReactive" : "Reactive"],
              "<",
              formatValue(obj),
              `>${reactivity.isReadonly(obj) ? ` (readonly)` : ``}`
            ];
          } else if (reactivity.isReadonly(obj)) {
            return [
              "div",
              {},
              ["span", vueStyle, reactivity.isShallow(obj) ? "ShallowReadonly" : "Readonly"],
              "<",
              formatValue(obj),
              ">"
            ];
          }
          return null;
        },
        hasBody(obj) {
          return obj && obj.__isVue;
        },
        body(obj) {
          if (obj && obj.__isVue) {
            return [
              "div",
              {},
              ...formatInstance(obj.$)
            ];
          }
        }
      };
      function formatInstance(instance) {
        const blocks = [];
        if (instance.type.props && instance.props) {
          blocks.push(createInstanceBlock("props", reactivity.toRaw(instance.props)));
        }
        if (instance.setupState !== shared.EMPTY_OBJ) {
          blocks.push(createInstanceBlock("setup", instance.setupState));
        }
        if (instance.data !== shared.EMPTY_OBJ) {
          blocks.push(createInstanceBlock("data", reactivity.toRaw(instance.data)));
        }
        const computed2 = extractKeys(instance, "computed");
        if (computed2) {
          blocks.push(createInstanceBlock("computed", computed2));
        }
        const injected = extractKeys(instance, "inject");
        if (injected) {
          blocks.push(createInstanceBlock("injected", injected));
        }
        blocks.push([
          "div",
          {},
          [
            "span",
            {
              style: keywordStyle.style + ";opacity:0.66"
            },
            "$ (internal): "
          ],
          ["object", { object: instance }]
        ]);
        return blocks;
      }
      function createInstanceBlock(type, target) {
        target = shared.extend({}, target);
        if (!Object.keys(target).length) {
          return ["span", {}];
        }
        return [
          "div",
          { style: "line-height:1.25em;margin-bottom:0.6em" },
          [
            "div",
            {
              style: "color:#476582"
            },
            type
          ],
          [
            "div",
            {
              style: "padding-left:1.25em"
            },
            ...Object.keys(target).map((key) => {
              return [
                "div",
                {},
                ["span", keywordStyle, key + ": "],
                formatValue(target[key], false)
              ];
            })
          ]
        ];
      }
      function formatValue(v, asRaw = true) {
        if (typeof v === "number") {
          return ["span", numberStyle, v];
        } else if (typeof v === "string") {
          return ["span", stringStyle, JSON.stringify(v)];
        } else if (typeof v === "boolean") {
          return ["span", keywordStyle, v];
        } else if (shared.isObject(v)) {
          return ["object", { object: asRaw ? reactivity.toRaw(v) : v }];
        } else {
          return ["span", stringStyle, String(v)];
        }
      }
      function extractKeys(instance, type) {
        const Comp = instance.type;
        if (shared.isFunction(Comp)) {
          return;
        }
        const extracted = {};
        for (const key in instance.ctx) {
          if (isKeyOfType(Comp, key, type)) {
            extracted[key] = instance.ctx[key];
          }
        }
        return extracted;
      }
      function isKeyOfType(Comp, key, type) {
        const opts = Comp[type];
        if (shared.isArray(opts) && opts.includes(key) || shared.isObject(opts) && key in opts) {
          return true;
        }
        if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
          return true;
        }
        if (Comp.mixins && Comp.mixins.some((m) => isKeyOfType(m, key, type))) {
          return true;
        }
      }
      function genRefFlag(v) {
        if (reactivity.isShallow(v)) {
          return `ShallowRef`;
        }
        if (v.effect) {
          return `ComputedRef`;
        }
        return `Ref`;
      }
      if (window.devtoolsFormatters) {
        window.devtoolsFormatters.push(formatter);
      } else {
        window.devtoolsFormatters = [formatter];
      }
    }
    function withMemo(memo, render, cache, index) {
      const cached = cache[index];
      if (cached && isMemoSame(cached, memo)) {
        return cached;
      }
      const ret = render();
      ret.memo = memo.slice();
      ret.memoIndex = index;
      return cache[index] = ret;
    }
    function isMemoSame(cached, memo) {
      const prev = cached.memo;
      if (prev.length != memo.length) {
        return false;
      }
      for (let i = 0; i < prev.length; i++) {
        if (shared.hasChanged(prev[i], memo[i])) {
          return false;
        }
      }
      if (isBlockTreeEnabled > 0 && currentBlock) {
        currentBlock.push(cached);
      }
      return true;
    }
    var version = "3.4.29";
    var warn = warn$1;
    var ErrorTypeStrings = ErrorTypeStrings$1;
    var devtools = devtools$1;
    var setDevtoolsHook = setDevtoolsHook$1;
    var _ssrUtils = {
      createComponentInstance,
      setupComponent,
      renderComponentRoot,
      setCurrentRenderingInstance,
      isVNode,
      normalizeVNode,
      getComponentPublicInstance
    };
    var ssrUtils = _ssrUtils;
    var resolveFilter = null;
    var compatUtils = null;
    var DeprecationTypes = null;
    exports.EffectScope = reactivity.EffectScope;
    exports.ReactiveEffect = reactivity.ReactiveEffect;
    exports.TrackOpTypes = reactivity.TrackOpTypes;
    exports.TriggerOpTypes = reactivity.TriggerOpTypes;
    exports.customRef = reactivity.customRef;
    exports.effect = reactivity.effect;
    exports.effectScope = reactivity.effectScope;
    exports.getCurrentScope = reactivity.getCurrentScope;
    exports.isProxy = reactivity.isProxy;
    exports.isReactive = reactivity.isReactive;
    exports.isReadonly = reactivity.isReadonly;
    exports.isRef = reactivity.isRef;
    exports.isShallow = reactivity.isShallow;
    exports.markRaw = reactivity.markRaw;
    exports.onScopeDispose = reactivity.onScopeDispose;
    exports.proxyRefs = reactivity.proxyRefs;
    exports.reactive = reactivity.reactive;
    exports.readonly = reactivity.readonly;
    exports.ref = reactivity.ref;
    exports.shallowReactive = reactivity.shallowReactive;
    exports.shallowReadonly = reactivity.shallowReadonly;
    exports.shallowRef = reactivity.shallowRef;
    exports.stop = reactivity.stop;
    exports.toRaw = reactivity.toRaw;
    exports.toRef = reactivity.toRef;
    exports.toRefs = reactivity.toRefs;
    exports.toValue = reactivity.toValue;
    exports.triggerRef = reactivity.triggerRef;
    exports.unref = reactivity.unref;
    exports.camelize = shared.camelize;
    exports.capitalize = shared.capitalize;
    exports.normalizeClass = shared.normalizeClass;
    exports.normalizeProps = shared.normalizeProps;
    exports.normalizeStyle = shared.normalizeStyle;
    exports.toDisplayString = shared.toDisplayString;
    exports.toHandlerKey = shared.toHandlerKey;
    exports.BaseTransition = BaseTransition;
    exports.BaseTransitionPropsValidators = BaseTransitionPropsValidators;
    exports.Comment = Comment;
    exports.DeprecationTypes = DeprecationTypes;
    exports.ErrorCodes = ErrorCodes;
    exports.ErrorTypeStrings = ErrorTypeStrings;
    exports.Fragment = Fragment;
    exports.KeepAlive = KeepAlive;
    exports.Static = Static;
    exports.Suspense = Suspense;
    exports.Teleport = Teleport;
    exports.Text = Text;
    exports.assertNumber = assertNumber;
    exports.callWithAsyncErrorHandling = callWithAsyncErrorHandling;
    exports.callWithErrorHandling = callWithErrorHandling;
    exports.cloneVNode = cloneVNode;
    exports.compatUtils = compatUtils;
    exports.computed = computed;
    exports.createBlock = createBlock;
    exports.createCommentVNode = createCommentVNode;
    exports.createElementBlock = createElementBlock;
    exports.createElementVNode = createBaseVNode;
    exports.createHydrationRenderer = createHydrationRenderer;
    exports.createPropsRestProxy = createPropsRestProxy;
    exports.createRenderer = createRenderer;
    exports.createSlots = createSlots;
    exports.createStaticVNode = createStaticVNode;
    exports.createTextVNode = createTextVNode;
    exports.createVNode = createVNode;
    exports.defineAsyncComponent = defineAsyncComponent;
    exports.defineComponent = defineComponent;
    exports.defineEmits = defineEmits;
    exports.defineExpose = defineExpose;
    exports.defineModel = defineModel;
    exports.defineOptions = defineOptions;
    exports.defineProps = defineProps;
    exports.defineSlots = defineSlots;
    exports.devtools = devtools;
    exports.getCurrentInstance = getCurrentInstance;
    exports.getTransitionRawChildren = getTransitionRawChildren;
    exports.guardReactiveProps = guardReactiveProps;
    exports.h = h;
    exports.handleError = handleError;
    exports.hasInjectionContext = hasInjectionContext;
    exports.initCustomFormatter = initCustomFormatter;
    exports.inject = inject;
    exports.isMemoSame = isMemoSame;
    exports.isRuntimeOnly = isRuntimeOnly;
    exports.isVNode = isVNode;
    exports.mergeDefaults = mergeDefaults;
    exports.mergeModels = mergeModels;
    exports.mergeProps = mergeProps;
    exports.nextTick = nextTick;
    exports.onActivated = onActivated;
    exports.onBeforeMount = onBeforeMount;
    exports.onBeforeUnmount = onBeforeUnmount;
    exports.onBeforeUpdate = onBeforeUpdate;
    exports.onDeactivated = onDeactivated;
    exports.onErrorCaptured = onErrorCaptured;
    exports.onMounted = onMounted;
    exports.onRenderTracked = onRenderTracked;
    exports.onRenderTriggered = onRenderTriggered;
    exports.onServerPrefetch = onServerPrefetch;
    exports.onUnmounted = onUnmounted;
    exports.onUpdated = onUpdated;
    exports.openBlock = openBlock;
    exports.popScopeId = popScopeId;
    exports.provide = provide;
    exports.pushScopeId = pushScopeId;
    exports.queuePostFlushCb = queuePostFlushCb;
    exports.registerRuntimeCompiler = registerRuntimeCompiler;
    exports.renderList = renderList;
    exports.renderSlot = renderSlot;
    exports.resolveComponent = resolveComponent;
    exports.resolveDirective = resolveDirective;
    exports.resolveDynamicComponent = resolveDynamicComponent;
    exports.resolveFilter = resolveFilter;
    exports.resolveTransitionHooks = resolveTransitionHooks;
    exports.setBlockTracking = setBlockTracking;
    exports.setDevtoolsHook = setDevtoolsHook;
    exports.setTransitionHooks = setTransitionHooks;
    exports.ssrContextKey = ssrContextKey;
    exports.ssrUtils = ssrUtils;
    exports.toHandlers = toHandlers;
    exports.transformVNodeArgs = transformVNodeArgs;
    exports.useAttrs = useAttrs;
    exports.useModel = useModel;
    exports.useSSRContext = useSSRContext;
    exports.useSlots = useSlots;
    exports.useTransitionState = useTransitionState;
    exports.version = version;
    exports.warn = warn;
    exports.watch = watch;
    exports.watchEffect = watchEffect;
    exports.watchPostEffect = watchPostEffect;
    exports.watchSyncEffect = watchSyncEffect;
    exports.withAsyncContext = withAsyncContext;
    exports.withCtx = withCtx;
    exports.withDefaults = withDefaults;
    exports.withDirectives = withDirectives;
    exports.withMemo = withMemo;
    exports.withScopeId = withScopeId;
  }
});

// node_modules/@vue/runtime-core/index.js
var require_runtime_core = __commonJS({
  "node_modules/@vue/runtime-core/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_runtime_core_cjs();
    }
  }
});

// node_modules/@vue/runtime-dom/dist/runtime-dom.cjs.js
var require_runtime_dom_cjs = __commonJS({
  "node_modules/@vue/runtime-dom/dist/runtime-dom.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var runtimeCore = require_runtime_core();
    var shared = require_shared();
    var svgNS = "http://www.w3.org/2000/svg";
    var mathmlNS = "http://www.w3.org/1998/Math/MathML";
    var doc = typeof document !== "undefined" ? document : null;
    var templateContainer = doc && doc.createElement("template");
    var nodeOps = {
      insert: (child, parent, anchor) => {
        parent.insertBefore(child, anchor || null);
      },
      remove: (child) => {
        const parent = child.parentNode;
        if (parent) {
          parent.removeChild(child);
        }
      },
      createElement: (tag, namespace, is, props) => {
        const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);
        if (tag === "select" && props && props.multiple != null) {
          el.setAttribute("multiple", props.multiple);
        }
        return el;
      },
      createText: (text) => doc.createTextNode(text),
      createComment: (text) => doc.createComment(text),
      setText: (node, text) => {
        node.nodeValue = text;
      },
      setElementText: (el, text) => {
        el.textContent = text;
      },
      parentNode: (node) => node.parentNode,
      nextSibling: (node) => node.nextSibling,
      querySelector: (selector) => doc.querySelector(selector),
      setScopeId(el, id) {
        el.setAttribute(id, "");
      },
      insertStaticContent(content, parent, anchor, namespace, start, end) {
        const before = anchor ? anchor.previousSibling : parent.lastChild;
        if (start && (start === end || start.nextSibling)) {
          while (true) {
            parent.insertBefore(start.cloneNode(true), anchor);
            if (start === end || !(start = start.nextSibling))
              break;
          }
        } else {
          templateContainer.innerHTML = namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content;
          const template = templateContainer.content;
          if (namespace === "svg" || namespace === "mathml") {
            const wrapper = template.firstChild;
            while (wrapper.firstChild) {
              template.appendChild(wrapper.firstChild);
            }
            template.removeChild(wrapper);
          }
          parent.insertBefore(template, anchor);
        }
        return [
          before ? before.nextSibling : parent.firstChild,
          anchor ? anchor.previousSibling : parent.lastChild
        ];
      }
    };
    var TRANSITION = "transition";
    var ANIMATION = "animation";
    var vtcKey = Symbol("_vtc");
    var Transition = (props, { slots }) => runtimeCore.h(runtimeCore.BaseTransition, resolveTransitionProps(props), slots);
    Transition.displayName = "Transition";
    var DOMTransitionPropsValidators = {
      name: String,
      type: String,
      css: {
        type: Boolean,
        default: true
      },
      duration: [String, Number, Object],
      enterFromClass: String,
      enterActiveClass: String,
      enterToClass: String,
      appearFromClass: String,
      appearActiveClass: String,
      appearToClass: String,
      leaveFromClass: String,
      leaveActiveClass: String,
      leaveToClass: String
    };
    var TransitionPropsValidators = Transition.props = shared.extend(
      {},
      runtimeCore.BaseTransitionPropsValidators,
      DOMTransitionPropsValidators
    );
    var callHook = (hook, args = []) => {
      if (shared.isArray(hook)) {
        hook.forEach((h2) => h2(...args));
      } else if (hook) {
        hook(...args);
      }
    };
    var hasExplicitCallback = (hook) => {
      return hook ? shared.isArray(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
    };
    function resolveTransitionProps(rawProps) {
      const baseProps = {};
      for (const key in rawProps) {
        if (!(key in DOMTransitionPropsValidators)) {
          baseProps[key] = rawProps[key];
        }
      }
      if (rawProps.css === false) {
        return baseProps;
      }
      const {
        name = "v",
        type,
        duration,
        enterFromClass = `${name}-enter-from`,
        enterActiveClass = `${name}-enter-active`,
        enterToClass = `${name}-enter-to`,
        appearFromClass = enterFromClass,
        appearActiveClass = enterActiveClass,
        appearToClass = enterToClass,
        leaveFromClass = `${name}-leave-from`,
        leaveActiveClass = `${name}-leave-active`,
        leaveToClass = `${name}-leave-to`
      } = rawProps;
      const durations = normalizeDuration(duration);
      const enterDuration = durations && durations[0];
      const leaveDuration = durations && durations[1];
      const {
        onBeforeEnter,
        onEnter,
        onEnterCancelled,
        onLeave,
        onLeaveCancelled,
        onBeforeAppear = onBeforeEnter,
        onAppear = onEnter,
        onAppearCancelled = onEnterCancelled
      } = baseProps;
      const finishEnter = (el, isAppear, done) => {
        removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
        removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
        done && done();
      };
      const finishLeave = (el, done) => {
        el._isLeaving = false;
        removeTransitionClass(el, leaveFromClass);
        removeTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveActiveClass);
        done && done();
      };
      const makeEnterHook = (isAppear) => {
        return (el, done) => {
          const hook = isAppear ? onAppear : onEnter;
          const resolve = () => finishEnter(el, isAppear, done);
          callHook(hook, [el, resolve]);
          nextFrame(() => {
            removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
            addTransitionClass(el, isAppear ? appearToClass : enterToClass);
            if (!hasExplicitCallback(hook)) {
              whenTransitionEnds(el, type, enterDuration, resolve);
            }
          });
        };
      };
      return shared.extend(baseProps, {
        onBeforeEnter(el) {
          callHook(onBeforeEnter, [el]);
          addTransitionClass(el, enterFromClass);
          addTransitionClass(el, enterActiveClass);
        },
        onBeforeAppear(el) {
          callHook(onBeforeAppear, [el]);
          addTransitionClass(el, appearFromClass);
          addTransitionClass(el, appearActiveClass);
        },
        onEnter: makeEnterHook(false),
        onAppear: makeEnterHook(true),
        onLeave(el, done) {
          el._isLeaving = true;
          const resolve = () => finishLeave(el, done);
          addTransitionClass(el, leaveFromClass);
          addTransitionClass(el, leaveActiveClass);
          forceReflow();
          nextFrame(() => {
            if (!el._isLeaving) {
              return;
            }
            removeTransitionClass(el, leaveFromClass);
            addTransitionClass(el, leaveToClass);
            if (!hasExplicitCallback(onLeave)) {
              whenTransitionEnds(el, type, leaveDuration, resolve);
            }
          });
          callHook(onLeave, [el, resolve]);
        },
        onEnterCancelled(el) {
          finishEnter(el, false);
          callHook(onEnterCancelled, [el]);
        },
        onAppearCancelled(el) {
          finishEnter(el, true);
          callHook(onAppearCancelled, [el]);
        },
        onLeaveCancelled(el) {
          finishLeave(el);
          callHook(onLeaveCancelled, [el]);
        }
      });
    }
    function normalizeDuration(duration) {
      if (duration == null) {
        return null;
      } else if (shared.isObject(duration)) {
        return [NumberOf(duration.enter), NumberOf(duration.leave)];
      } else {
        const n = NumberOf(duration);
        return [n, n];
      }
    }
    function NumberOf(val) {
      const res = shared.toNumber(val);
      {
        runtimeCore.assertNumber(res, "<transition> explicit duration");
      }
      return res;
    }
    function addTransitionClass(el, cls) {
      cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
      (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
    }
    function removeTransitionClass(el, cls) {
      cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
      const _vtc = el[vtcKey];
      if (_vtc) {
        _vtc.delete(cls);
        if (!_vtc.size) {
          el[vtcKey] = void 0;
        }
      }
    }
    function nextFrame(cb) {
      requestAnimationFrame(() => {
        requestAnimationFrame(cb);
      });
    }
    var endId = 0;
    function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
      const id = el._endId = ++endId;
      const resolveIfNotStale = () => {
        if (id === el._endId) {
          resolve();
        }
      };
      if (explicitTimeout) {
        return setTimeout(resolveIfNotStale, explicitTimeout);
      }
      const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
      if (!type) {
        return resolve();
      }
      const endEvent = type + "end";
      let ended = 0;
      const end = () => {
        el.removeEventListener(endEvent, onEnd);
        resolveIfNotStale();
      };
      const onEnd = (e) => {
        if (e.target === el && ++ended >= propCount) {
          end();
        }
      };
      setTimeout(() => {
        if (ended < propCount) {
          end();
        }
      }, timeout + 1);
      el.addEventListener(endEvent, onEnd);
    }
    function getTransitionInfo(el, expectedType) {
      const styles = window.getComputedStyle(el);
      const getStyleProperties = (key) => (styles[key] || "").split(", ");
      const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
      const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
      const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
      const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
      const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
      const animationTimeout = getTimeout(animationDelays, animationDurations);
      let type = null;
      let timeout = 0;
      let propCount = 0;
      if (expectedType === TRANSITION) {
        if (transitionTimeout > 0) {
          type = TRANSITION;
          timeout = transitionTimeout;
          propCount = transitionDurations.length;
        }
      } else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
          type = ANIMATION;
          timeout = animationTimeout;
          propCount = animationDurations.length;
        }
      } else {
        timeout = Math.max(transitionTimeout, animationTimeout);
        type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
        propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
      }
      const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
        getStyleProperties(`${TRANSITION}Property`).toString()
      );
      return {
        type,
        timeout,
        propCount,
        hasTransform
      };
    }
    function getTimeout(delays, durations) {
      while (delays.length < durations.length) {
        delays = delays.concat(delays);
      }
      return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
    }
    function toMs(s) {
      if (s === "auto")
        return 0;
      return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
    }
    function forceReflow() {
      return document.body.offsetHeight;
    }
    function patchClass(el, value, isSVG) {
      const transitionClasses = el[vtcKey];
      if (transitionClasses) {
        value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
      }
      if (value == null) {
        el.removeAttribute("class");
      } else if (isSVG) {
        el.setAttribute("class", value);
      } else {
        el.className = value;
      }
    }
    var vShowOriginalDisplay = Symbol("_vod");
    var vShowHidden = Symbol("_vsh");
    var vShow = {
      beforeMount(el, { value }, { transition }) {
        el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
        if (transition && value) {
          transition.beforeEnter(el);
        } else {
          setDisplay(el, value);
        }
      },
      mounted(el, { value }, { transition }) {
        if (transition && value) {
          transition.enter(el);
        }
      },
      updated(el, { value, oldValue }, { transition }) {
        if (!value === !oldValue)
          return;
        if (transition) {
          if (value) {
            transition.beforeEnter(el);
            setDisplay(el, true);
            transition.enter(el);
          } else {
            transition.leave(el, () => {
              setDisplay(el, false);
            });
          }
        } else {
          setDisplay(el, value);
        }
      },
      beforeUnmount(el, { value }) {
        setDisplay(el, value);
      }
    };
    {
      vShow.name = "show";
    }
    function setDisplay(el, value) {
      el.style.display = value ? el[vShowOriginalDisplay] : "none";
      el[vShowHidden] = !value;
    }
    function initVShowForSSR() {
      vShow.getSSRProps = ({ value }) => {
        if (!value) {
          return { style: { display: "none" } };
        }
      };
    }
    var CSS_VAR_TEXT = Symbol("CSS_VAR_TEXT");
    function useCssVars(getter) {
      return;
    }
    var displayRE = /(^|;)\s*display\s*:/;
    function patchStyle(el, prev, next) {
      const style = el.style;
      const isCssString = shared.isString(next);
      let hasControlledDisplay = false;
      if (next && !isCssString) {
        if (prev) {
          if (!shared.isString(prev)) {
            for (const key in prev) {
              if (next[key] == null) {
                setStyle(style, key, "");
              }
            }
          } else {
            for (const prevStyle of prev.split(";")) {
              const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
              if (next[key] == null) {
                setStyle(style, key, "");
              }
            }
          }
        }
        for (const key in next) {
          if (key === "display") {
            hasControlledDisplay = true;
          }
          setStyle(style, key, next[key]);
        }
      } else {
        if (isCssString) {
          if (prev !== next) {
            const cssVarText = style[CSS_VAR_TEXT];
            if (cssVarText) {
              next += ";" + cssVarText;
            }
            style.cssText = next;
            hasControlledDisplay = displayRE.test(next);
          }
        } else if (prev) {
          el.removeAttribute("style");
        }
      }
      if (vShowOriginalDisplay in el) {
        el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
        if (el[vShowHidden]) {
          style.display = "none";
        }
      }
    }
    var semicolonRE = /[^\\];\s*$/;
    var importantRE = /\s*!important$/;
    function setStyle(style, name, val) {
      if (shared.isArray(val)) {
        val.forEach((v) => setStyle(style, name, v));
      } else {
        if (val == null)
          val = "";
        {
          if (semicolonRE.test(val)) {
            runtimeCore.warn(
              `Unexpected semicolon at the end of '${name}' style value: '${val}'`
            );
          }
        }
        if (name.startsWith("--")) {
          style.setProperty(name, val);
        } else {
          const prefixed = autoPrefix(style, name);
          if (importantRE.test(val)) {
            style.setProperty(
              shared.hyphenate(prefixed),
              val.replace(importantRE, ""),
              "important"
            );
          } else {
            style[prefixed] = val;
          }
        }
      }
    }
    var prefixes = ["Webkit", "Moz", "ms"];
    var prefixCache = {};
    function autoPrefix(style, rawName) {
      const cached = prefixCache[rawName];
      if (cached) {
        return cached;
      }
      let name = runtimeCore.camelize(rawName);
      if (name !== "filter" && name in style) {
        return prefixCache[rawName] = name;
      }
      name = shared.capitalize(name);
      for (let i = 0; i < prefixes.length; i++) {
        const prefixed = prefixes[i] + name;
        if (prefixed in style) {
          return prefixCache[rawName] = prefixed;
        }
      }
      return rawName;
    }
    var xlinkNS = "http://www.w3.org/1999/xlink";
    function patchAttr(el, key, value, isSVG, instance, isBoolean = shared.isSpecialBooleanAttr(key)) {
      if (isSVG && key.startsWith("xlink:")) {
        if (value == null) {
          el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
        } else {
          el.setAttributeNS(xlinkNS, key, value);
        }
      } else {
        if (value == null || isBoolean && !shared.includeBooleanAttr(value)) {
          el.removeAttribute(key);
        } else {
          el.setAttribute(key, isBoolean ? "" : String(value));
        }
      }
    }
    function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
      if (key === "innerHTML" || key === "textContent") {
        if (prevChildren) {
          unmountChildren(prevChildren, parentComponent, parentSuspense);
        }
        el[key] = value == null ? "" : value;
        return;
      }
      const tag = el.tagName;
      if (key === "value" && tag !== "PROGRESS" && !tag.includes("-")) {
        const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
        const newValue = value == null ? "" : String(value);
        if (oldValue !== newValue || !("_value" in el)) {
          el.value = newValue;
        }
        if (value == null) {
          el.removeAttribute(key);
        }
        el._value = value;
        return;
      }
      let needRemove = false;
      if (value === "" || value == null) {
        const type = typeof el[key];
        if (type === "boolean") {
          value = shared.includeBooleanAttr(value);
        } else if (value == null && type === "string") {
          value = "";
          needRemove = true;
        } else if (type === "number") {
          value = 0;
          needRemove = true;
        }
      }
      try {
        el[key] = value;
      } catch (e) {
        if (!needRemove) {
          runtimeCore.warn(
            `Failed setting prop "${key}" on <${tag.toLowerCase()}>: value ${value} is invalid.`,
            e
          );
        }
      }
      needRemove && el.removeAttribute(key);
    }
    function addEventListener(el, event, handler, options) {
      el.addEventListener(event, handler, options);
    }
    function removeEventListener(el, event, handler, options) {
      el.removeEventListener(event, handler, options);
    }
    var veiKey = Symbol("_vei");
    function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
      const invokers = el[veiKey] || (el[veiKey] = {});
      const existingInvoker = invokers[rawName];
      if (nextValue && existingInvoker) {
        existingInvoker.value = sanitizeEventValue(nextValue, rawName);
      } else {
        const [name, options] = parseName(rawName);
        if (nextValue) {
          const invoker = invokers[rawName] = createInvoker(
            sanitizeEventValue(nextValue, rawName),
            instance
          );
          addEventListener(el, name, invoker, options);
        } else if (existingInvoker) {
          removeEventListener(el, name, existingInvoker, options);
          invokers[rawName] = void 0;
        }
      }
    }
    var optionsModifierRE = /(?:Once|Passive|Capture)$/;
    function parseName(name) {
      let options;
      if (optionsModifierRE.test(name)) {
        options = {};
        let m;
        while (m = name.match(optionsModifierRE)) {
          name = name.slice(0, name.length - m[0].length);
          options[m[0].toLowerCase()] = true;
        }
      }
      const event = name[2] === ":" ? name.slice(3) : shared.hyphenate(name.slice(2));
      return [event, options];
    }
    var cachedNow = 0;
    var p = Promise.resolve();
    var getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
    function createInvoker(initialValue, instance) {
      const invoker = (e) => {
        if (!e._vts) {
          e._vts = Date.now();
        } else if (e._vts <= invoker.attached) {
          return;
        }
        runtimeCore.callWithAsyncErrorHandling(
          patchStopImmediatePropagation(e, invoker.value),
          instance,
          5,
          [e]
        );
      };
      invoker.value = initialValue;
      invoker.attached = getNow();
      return invoker;
    }
    function sanitizeEventValue(value, propName) {
      if (shared.isFunction(value) || shared.isArray(value)) {
        return value;
      }
      runtimeCore.warn(
        `Wrong type passed as event handler to ${propName} - did you forget @ or : in front of your prop?
Expected function or array of functions, received type ${typeof value}.`
      );
      return shared.NOOP;
    }
    function patchStopImmediatePropagation(e, value) {
      if (shared.isArray(value)) {
        const originalStop = e.stopImmediatePropagation;
        e.stopImmediatePropagation = () => {
          originalStop.call(e);
          e._stopped = true;
        };
        return value.map(
          (fn) => (e2) => !e2._stopped && fn && fn(e2)
        );
      } else {
        return value;
      }
    }
    var isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
    var patchProp = (el, key, prevValue, nextValue, namespace, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
      const isSVG = namespace === "svg";
      if (key === "class") {
        patchClass(el, nextValue, isSVG);
      } else if (key === "style") {
        patchStyle(el, prevValue, nextValue);
      } else if (shared.isOn(key)) {
        if (!shared.isModelListener(key)) {
          patchEvent(el, key, prevValue, nextValue, parentComponent);
        }
      } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
        patchDOMProp(
          el,
          key,
          nextValue,
          prevChildren,
          parentComponent,
          parentSuspense,
          unmountChildren
        );
        if (key === "value" || key === "checked" || key === "selected") {
          patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
        }
      } else {
        if (key === "true-value") {
          el._trueValue = nextValue;
        } else if (key === "false-value") {
          el._falseValue = nextValue;
        }
        patchAttr(el, key, nextValue, isSVG);
      }
    };
    function shouldSetAsProp(el, key, value, isSVG) {
      if (isSVG) {
        if (key === "innerHTML" || key === "textContent") {
          return true;
        }
        if (key in el && isNativeOn(key) && shared.isFunction(value)) {
          return true;
        }
        return false;
      }
      if (key === "spellcheck" || key === "draggable" || key === "translate") {
        return false;
      }
      if (key === "form") {
        return false;
      }
      if (key === "list" && el.tagName === "INPUT") {
        return false;
      }
      if (key === "type" && el.tagName === "TEXTAREA") {
        return false;
      }
      if (key === "width" || key === "height") {
        const tag = el.tagName;
        if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
          return false;
        }
      }
      if (isNativeOn(key) && shared.isString(value)) {
        return false;
      }
      return key in el;
    }
    function defineCustomElement(options, extraOptions, hydrate2) {
      const Comp = runtimeCore.defineComponent(options, extraOptions);
      class VueCustomElement extends VueElement {
        constructor(initialProps) {
          super(Comp, initialProps, hydrate2);
        }
      }
      VueCustomElement.def = Comp;
      return VueCustomElement;
    }
    var defineSSRCustomElement = (options, extraOptions) => {
      return defineCustomElement(options, extraOptions, hydrate);
    };
    var BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
    };
    var VueElement = class extends BaseClass {
      constructor(_def, _props = {}, hydrate2) {
        super();
        this._def = _def;
        this._props = _props;
        this._instance = null;
        this._connected = false;
        this._resolved = false;
        this._numberProps = null;
        this._ob = null;
        if (this.shadowRoot && hydrate2) {
          hydrate2(this._createVNode(), this.shadowRoot);
        } else {
          if (this.shadowRoot) {
            runtimeCore.warn(
              `Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use \`defineSSRCustomElement\`.`
            );
          }
          this.attachShadow({ mode: "open" });
          if (!this._def.__asyncLoader) {
            this._resolveProps(this._def);
          }
        }
      }
      connectedCallback() {
        this._connected = true;
        if (!this._instance) {
          if (this._resolved) {
            this._update();
          } else {
            this._resolveDef();
          }
        }
      }
      disconnectedCallback() {
        this._connected = false;
        runtimeCore.nextTick(() => {
          if (!this._connected) {
            if (this._ob) {
              this._ob.disconnect();
              this._ob = null;
            }
            render(null, this.shadowRoot);
            this._instance = null;
          }
        });
      }
      _resolveDef() {
        this._resolved = true;
        for (let i = 0; i < this.attributes.length; i++) {
          this._setAttr(this.attributes[i].name);
        }
        this._ob = new MutationObserver((mutations) => {
          for (const m of mutations) {
            this._setAttr(m.attributeName);
          }
        });
        this._ob.observe(this, { attributes: true });
        const resolve = (def, isAsync = false) => {
          const { props, styles } = def;
          let numberProps;
          if (props && !shared.isArray(props)) {
            for (const key in props) {
              const opt = props[key];
              if (opt === Number || opt && opt.type === Number) {
                if (key in this._props) {
                  this._props[key] = shared.toNumber(this._props[key]);
                }
                (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[shared.camelize(key)] = true;
              }
            }
          }
          this._numberProps = numberProps;
          if (isAsync) {
            this._resolveProps(def);
          }
          this._applyStyles(styles);
          this._update();
        };
        const asyncDef = this._def.__asyncLoader;
        if (asyncDef) {
          asyncDef().then((def) => resolve(def, true));
        } else {
          resolve(this._def);
        }
      }
      _resolveProps(def) {
        const { props } = def;
        const declaredPropKeys = shared.isArray(props) ? props : Object.keys(props || {});
        for (const key of Object.keys(this)) {
          if (key[0] !== "_" && declaredPropKeys.includes(key)) {
            this._setProp(key, this[key], true, false);
          }
        }
        for (const key of declaredPropKeys.map(shared.camelize)) {
          Object.defineProperty(this, key, {
            get() {
              return this._getProp(key);
            },
            set(val) {
              this._setProp(key, val);
            }
          });
        }
      }
      _setAttr(key) {
        let value = this.hasAttribute(key) ? this.getAttribute(key) : void 0;
        const camelKey = shared.camelize(key);
        if (this._numberProps && this._numberProps[camelKey]) {
          value = shared.toNumber(value);
        }
        this._setProp(camelKey, value, false);
      }
      _getProp(key) {
        return this._props[key];
      }
      _setProp(key, val, shouldReflect = true, shouldUpdate = true) {
        if (val !== this._props[key]) {
          this._props[key] = val;
          if (shouldUpdate && this._instance) {
            this._update();
          }
          if (shouldReflect) {
            if (val === true) {
              this.setAttribute(shared.hyphenate(key), "");
            } else if (typeof val === "string" || typeof val === "number") {
              this.setAttribute(shared.hyphenate(key), val + "");
            } else if (!val) {
              this.removeAttribute(shared.hyphenate(key));
            }
          }
        }
      }
      _update() {
        render(this._createVNode(), this.shadowRoot);
      }
      _createVNode() {
        const vnode = runtimeCore.createVNode(this._def, shared.extend({}, this._props));
        if (!this._instance) {
          vnode.ce = (instance) => {
            this._instance = instance;
            instance.isCE = true;
            {
              instance.ceReload = (newStyles) => {
                if (this._styles) {
                  this._styles.forEach((s) => this.shadowRoot.removeChild(s));
                  this._styles.length = 0;
                }
                this._applyStyles(newStyles);
                this._instance = null;
                this._update();
              };
            }
            const dispatch = (event, args) => {
              this.dispatchEvent(
                new CustomEvent(event, {
                  detail: args
                })
              );
            };
            instance.emit = (event, ...args) => {
              dispatch(event, args);
              if (shared.hyphenate(event) !== event) {
                dispatch(shared.hyphenate(event), args);
              }
            };
            let parent = this;
            while (parent = parent && (parent.parentNode || parent.host)) {
              if (parent instanceof VueElement) {
                instance.parent = parent._instance;
                instance.provides = parent._instance.provides;
                break;
              }
            }
          };
        }
        return vnode;
      }
      _applyStyles(styles) {
        if (styles) {
          styles.forEach((css) => {
            const s = document.createElement("style");
            s.textContent = css;
            this.shadowRoot.appendChild(s);
            {
              (this._styles || (this._styles = [])).push(s);
            }
          });
        }
      }
    };
    function useCssModule(name = "$style") {
      {
        const instance = runtimeCore.getCurrentInstance();
        if (!instance) {
          runtimeCore.warn(`useCssModule must be called inside setup()`);
          return shared.EMPTY_OBJ;
        }
        const modules = instance.type.__cssModules;
        if (!modules) {
          runtimeCore.warn(`Current instance does not have CSS modules injected.`);
          return shared.EMPTY_OBJ;
        }
        const mod = modules[name];
        if (!mod) {
          runtimeCore.warn(`Current instance does not have CSS module named "${name}".`);
          return shared.EMPTY_OBJ;
        }
        return mod;
      }
    }
    var positionMap = /* @__PURE__ */ new WeakMap();
    var newPositionMap = /* @__PURE__ */ new WeakMap();
    var moveCbKey = Symbol("_moveCb");
    var enterCbKey = Symbol("_enterCb");
    var TransitionGroupImpl = {
      name: "TransitionGroup",
      props: shared.extend({}, TransitionPropsValidators, {
        tag: String,
        moveClass: String
      }),
      setup(props, { slots }) {
        const instance = runtimeCore.getCurrentInstance();
        const state = runtimeCore.useTransitionState();
        let prevChildren;
        let children;
        runtimeCore.onUpdated(() => {
          if (!prevChildren.length) {
            return;
          }
          const moveClass = props.moveClass || `${props.name || "v"}-move`;
          if (!hasCSSTransform(
            prevChildren[0].el,
            instance.vnode.el,
            moveClass
          )) {
            return;
          }
          prevChildren.forEach(callPendingCbs);
          prevChildren.forEach(recordPosition);
          const movedChildren = prevChildren.filter(applyTranslation);
          forceReflow();
          movedChildren.forEach((c) => {
            const el = c.el;
            const style = el.style;
            addTransitionClass(el, moveClass);
            style.transform = style.webkitTransform = style.transitionDuration = "";
            const cb = el[moveCbKey] = (e) => {
              if (e && e.target !== el) {
                return;
              }
              if (!e || /transform$/.test(e.propertyName)) {
                el.removeEventListener("transitionend", cb);
                el[moveCbKey] = null;
                removeTransitionClass(el, moveClass);
              }
            };
            el.addEventListener("transitionend", cb);
          });
        });
        return () => {
          const rawProps = runtimeCore.toRaw(props);
          const cssTransitionProps = resolveTransitionProps(rawProps);
          let tag = rawProps.tag || runtimeCore.Fragment;
          prevChildren = [];
          if (children) {
            for (let i = 0; i < children.length; i++) {
              const child = children[i];
              if (child.el && child.el instanceof Element) {
                prevChildren.push(child);
                runtimeCore.setTransitionHooks(
                  child,
                  runtimeCore.resolveTransitionHooks(
                    child,
                    cssTransitionProps,
                    state,
                    instance
                  )
                );
                positionMap.set(
                  child,
                  child.el.getBoundingClientRect()
                );
              }
            }
          }
          children = slots.default ? runtimeCore.getTransitionRawChildren(slots.default()) : [];
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (child.key != null) {
              runtimeCore.setTransitionHooks(
                child,
                runtimeCore.resolveTransitionHooks(child, cssTransitionProps, state, instance)
              );
            } else {
              runtimeCore.warn(`<TransitionGroup> children must be keyed.`);
            }
          }
          return runtimeCore.createVNode(tag, null, children);
        };
      }
    };
    var removeMode = (props) => delete props.mode;
    removeMode(TransitionGroupImpl.props);
    var TransitionGroup = TransitionGroupImpl;
    function callPendingCbs(c) {
      const el = c.el;
      if (el[moveCbKey]) {
        el[moveCbKey]();
      }
      if (el[enterCbKey]) {
        el[enterCbKey]();
      }
    }
    function recordPosition(c) {
      newPositionMap.set(c, c.el.getBoundingClientRect());
    }
    function applyTranslation(c) {
      const oldPos = positionMap.get(c);
      const newPos = newPositionMap.get(c);
      const dx = oldPos.left - newPos.left;
      const dy = oldPos.top - newPos.top;
      if (dx || dy) {
        const s = c.el.style;
        s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
        s.transitionDuration = "0s";
        return c;
      }
    }
    function hasCSSTransform(el, root, moveClass) {
      const clone = el.cloneNode();
      const _vtc = el[vtcKey];
      if (_vtc) {
        _vtc.forEach((cls) => {
          cls.split(/\s+/).forEach((c) => c && clone.classList.remove(c));
        });
      }
      moveClass.split(/\s+/).forEach((c) => c && clone.classList.add(c));
      clone.style.display = "none";
      const container = root.nodeType === 1 ? root : root.parentNode;
      container.appendChild(clone);
      const { hasTransform } = getTransitionInfo(clone);
      container.removeChild(clone);
      return hasTransform;
    }
    var getModelAssigner = (vnode) => {
      const fn = vnode.props["onUpdate:modelValue"] || false;
      return shared.isArray(fn) ? (value) => shared.invokeArrayFns(fn, value) : fn;
    };
    function onCompositionStart(e) {
      e.target.composing = true;
    }
    function onCompositionEnd(e) {
      const target = e.target;
      if (target.composing) {
        target.composing = false;
        target.dispatchEvent(new Event("input"));
      }
    }
    var assignKey = Symbol("_assign");
    var vModelText = {
      created(el, { modifiers: { lazy, trim, number } }, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        const castToNumber = number || vnode.props && vnode.props.type === "number";
        addEventListener(el, lazy ? "change" : "input", (e) => {
          if (e.target.composing)
            return;
          let domValue = el.value;
          if (trim) {
            domValue = domValue.trim();
          }
          if (castToNumber) {
            domValue = shared.looseToNumber(domValue);
          }
          el[assignKey](domValue);
        });
        if (trim) {
          addEventListener(el, "change", () => {
            el.value = el.value.trim();
          });
        }
        if (!lazy) {
          addEventListener(el, "compositionstart", onCompositionStart);
          addEventListener(el, "compositionend", onCompositionEnd);
          addEventListener(el, "change", onCompositionEnd);
        }
      },
      mounted(el, { value }) {
        el.value = value == null ? "" : value;
      },
      beforeUpdate(el, { value, oldValue, modifiers: { lazy, trim, number } }, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        if (el.composing)
          return;
        const elValue = (number || el.type === "number") && !/^0\d/.test(el.value) ? shared.looseToNumber(el.value) : el.value;
        const newValue = value == null ? "" : value;
        if (elValue === newValue) {
          return;
        }
        if (document.activeElement === el && el.type !== "range") {
          if (lazy && value === oldValue) {
            return;
          }
          if (trim && el.value.trim() === newValue) {
            return;
          }
        }
        el.value = newValue;
      }
    };
    var vModelCheckbox = {
      deep: true,
      created(el, _, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        addEventListener(el, "change", () => {
          const modelValue = el._modelValue;
          const elementValue = getValue(el);
          const checked = el.checked;
          const assign = el[assignKey];
          if (shared.isArray(modelValue)) {
            const index = shared.looseIndexOf(modelValue, elementValue);
            const found = index !== -1;
            if (checked && !found) {
              assign(modelValue.concat(elementValue));
            } else if (!checked && found) {
              const filtered = [...modelValue];
              filtered.splice(index, 1);
              assign(filtered);
            }
          } else if (shared.isSet(modelValue)) {
            const cloned = new Set(modelValue);
            if (checked) {
              cloned.add(elementValue);
            } else {
              cloned.delete(elementValue);
            }
            assign(cloned);
          } else {
            assign(getCheckboxValue(el, checked));
          }
        });
      },
      mounted: setChecked,
      beforeUpdate(el, binding, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        setChecked(el, binding, vnode);
      }
    };
    function setChecked(el, { value, oldValue }, vnode) {
      el._modelValue = value;
      if (shared.isArray(value)) {
        el.checked = shared.looseIndexOf(value, vnode.props.value) > -1;
      } else if (shared.isSet(value)) {
        el.checked = value.has(vnode.props.value);
      } else if (value !== oldValue) {
        el.checked = shared.looseEqual(value, getCheckboxValue(el, true));
      }
    }
    var vModelRadio = {
      created(el, { value }, vnode) {
        el.checked = shared.looseEqual(value, vnode.props.value);
        el[assignKey] = getModelAssigner(vnode);
        addEventListener(el, "change", () => {
          el[assignKey](getValue(el));
        });
      },
      beforeUpdate(el, { value, oldValue }, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        if (value !== oldValue) {
          el.checked = shared.looseEqual(value, vnode.props.value);
        }
      }
    };
    var vModelSelect = {
      deep: true,
      created(el, { value, modifiers: { number } }, vnode) {
        const isSetModel = shared.isSet(value);
        addEventListener(el, "change", () => {
          const selectedVal = Array.prototype.filter.call(el.options, (o) => o.selected).map(
            (o) => number ? shared.looseToNumber(getValue(o)) : getValue(o)
          );
          el[assignKey](
            el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]
          );
          el._assigning = true;
          runtimeCore.nextTick(() => {
            el._assigning = false;
          });
        });
        el[assignKey] = getModelAssigner(vnode);
      },
      mounted(el, { value, modifiers: { number } }) {
        setSelected(el, value);
      },
      beforeUpdate(el, _binding, vnode) {
        el[assignKey] = getModelAssigner(vnode);
      },
      updated(el, { value, modifiers: { number } }) {
        if (!el._assigning) {
          setSelected(el, value);
        }
      }
    };
    function setSelected(el, value, number) {
      const isMultiple = el.multiple;
      const isArrayValue = shared.isArray(value);
      if (isMultiple && !isArrayValue && !shared.isSet(value)) {
        runtimeCore.warn(
          `<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString.call(value).slice(8, -1)}.`
        );
        return;
      }
      for (let i = 0, l = el.options.length; i < l; i++) {
        const option = el.options[i];
        const optionValue = getValue(option);
        if (isMultiple) {
          if (isArrayValue) {
            const optionType = typeof optionValue;
            if (optionType === "string" || optionType === "number") {
              option.selected = value.some((v) => String(v) === String(optionValue));
            } else {
              option.selected = shared.looseIndexOf(value, optionValue) > -1;
            }
          } else {
            option.selected = value.has(optionValue);
          }
        } else if (shared.looseEqual(getValue(option), value)) {
          if (el.selectedIndex !== i)
            el.selectedIndex = i;
          return;
        }
      }
      if (!isMultiple && el.selectedIndex !== -1) {
        el.selectedIndex = -1;
      }
    }
    function getValue(el) {
      return "_value" in el ? el._value : el.value;
    }
    function getCheckboxValue(el, checked) {
      const key = checked ? "_trueValue" : "_falseValue";
      return key in el ? el[key] : checked;
    }
    var vModelDynamic = {
      created(el, binding, vnode) {
        callModelHook(el, binding, vnode, null, "created");
      },
      mounted(el, binding, vnode) {
        callModelHook(el, binding, vnode, null, "mounted");
      },
      beforeUpdate(el, binding, vnode, prevVNode) {
        callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
      },
      updated(el, binding, vnode, prevVNode) {
        callModelHook(el, binding, vnode, prevVNode, "updated");
      }
    };
    function resolveDynamicModel(tagName, type) {
      switch (tagName) {
        case "SELECT":
          return vModelSelect;
        case "TEXTAREA":
          return vModelText;
        default:
          switch (type) {
            case "checkbox":
              return vModelCheckbox;
            case "radio":
              return vModelRadio;
            default:
              return vModelText;
          }
      }
    }
    function callModelHook(el, binding, vnode, prevVNode, hook) {
      const modelToUse = resolveDynamicModel(
        el.tagName,
        vnode.props && vnode.props.type
      );
      const fn = modelToUse[hook];
      fn && fn(el, binding, vnode, prevVNode);
    }
    function initVModelForSSR() {
      vModelText.getSSRProps = ({ value }) => ({ value });
      vModelRadio.getSSRProps = ({ value }, vnode) => {
        if (vnode.props && shared.looseEqual(vnode.props.value, value)) {
          return { checked: true };
        }
      };
      vModelCheckbox.getSSRProps = ({ value }, vnode) => {
        if (shared.isArray(value)) {
          if (vnode.props && shared.looseIndexOf(value, vnode.props.value) > -1) {
            return { checked: true };
          }
        } else if (shared.isSet(value)) {
          if (vnode.props && value.has(vnode.props.value)) {
            return { checked: true };
          }
        } else if (value) {
          return { checked: true };
        }
      };
      vModelDynamic.getSSRProps = (binding, vnode) => {
        if (typeof vnode.type !== "string") {
          return;
        }
        const modelToUse = resolveDynamicModel(
          vnode.type.toUpperCase(),
          vnode.props && vnode.props.type
        );
        if (modelToUse.getSSRProps) {
          return modelToUse.getSSRProps(binding, vnode);
        }
      };
    }
    var systemModifiers = ["ctrl", "shift", "alt", "meta"];
    var modifierGuards = {
      stop: (e) => e.stopPropagation(),
      prevent: (e) => e.preventDefault(),
      self: (e) => e.target !== e.currentTarget,
      ctrl: (e) => !e.ctrlKey,
      shift: (e) => !e.shiftKey,
      alt: (e) => !e.altKey,
      meta: (e) => !e.metaKey,
      left: (e) => "button" in e && e.button !== 0,
      middle: (e) => "button" in e && e.button !== 1,
      right: (e) => "button" in e && e.button !== 2,
      exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
    };
    var withModifiers = (fn, modifiers) => {
      const cache = fn._withMods || (fn._withMods = {});
      const cacheKey = modifiers.join(".");
      return cache[cacheKey] || (cache[cacheKey] = (event, ...args) => {
        for (let i = 0; i < modifiers.length; i++) {
          const guard = modifierGuards[modifiers[i]];
          if (guard && guard(event, modifiers))
            return;
        }
        return fn(event, ...args);
      });
    };
    var keyNames = {
      esc: "escape",
      space: " ",
      up: "arrow-up",
      left: "arrow-left",
      right: "arrow-right",
      down: "arrow-down",
      delete: "backspace"
    };
    var withKeys = (fn, modifiers) => {
      const cache = fn._withKeys || (fn._withKeys = {});
      const cacheKey = modifiers.join(".");
      return cache[cacheKey] || (cache[cacheKey] = (event) => {
        if (!("key" in event)) {
          return;
        }
        const eventKey = shared.hyphenate(event.key);
        if (modifiers.some((k) => k === eventKey || keyNames[k] === eventKey)) {
          return fn(event);
        }
      });
    };
    var rendererOptions = shared.extend({ patchProp }, nodeOps);
    var renderer;
    var enabledHydration = false;
    function ensureRenderer() {
      return renderer || (renderer = runtimeCore.createRenderer(rendererOptions));
    }
    function ensureHydrationRenderer() {
      renderer = enabledHydration ? renderer : runtimeCore.createHydrationRenderer(rendererOptions);
      enabledHydration = true;
      return renderer;
    }
    var render = (...args) => {
      ensureRenderer().render(...args);
    };
    var hydrate = (...args) => {
      ensureHydrationRenderer().hydrate(...args);
    };
    var createApp = (...args) => {
      const app = ensureRenderer().createApp(...args);
      {
        injectNativeTagCheck(app);
        injectCompilerOptionsCheck(app);
      }
      const { mount } = app;
      app.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (!container)
          return;
        const component = app._component;
        if (!shared.isFunction(component) && !component.render && !component.template) {
          component.template = container.innerHTML;
        }
        container.innerHTML = "";
        const proxy = mount(container, false, resolveRootNamespace(container));
        if (container instanceof Element) {
          container.removeAttribute("v-cloak");
          container.setAttribute("data-v-app", "");
        }
        return proxy;
      };
      return app;
    };
    var createSSRApp = (...args) => {
      const app = ensureHydrationRenderer().createApp(...args);
      {
        injectNativeTagCheck(app);
        injectCompilerOptionsCheck(app);
      }
      const { mount } = app;
      app.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (container) {
          return mount(container, true, resolveRootNamespace(container));
        }
      };
      return app;
    };
    function resolveRootNamespace(container) {
      if (container instanceof SVGElement) {
        return "svg";
      }
      if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
        return "mathml";
      }
    }
    function injectNativeTagCheck(app) {
      Object.defineProperty(app.config, "isNativeTag", {
        value: (tag) => shared.isHTMLTag(tag) || shared.isSVGTag(tag) || shared.isMathMLTag(tag),
        writable: false
      });
    }
    function injectCompilerOptionsCheck(app) {
      if (runtimeCore.isRuntimeOnly()) {
        const isCustomElement = app.config.isCustomElement;
        Object.defineProperty(app.config, "isCustomElement", {
          get() {
            return isCustomElement;
          },
          set() {
            runtimeCore.warn(
              `The \`isCustomElement\` config option is deprecated. Use \`compilerOptions.isCustomElement\` instead.`
            );
          }
        });
        const compilerOptions = app.config.compilerOptions;
        const msg = `The \`compilerOptions\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, \`compilerOptions\` must be passed to \`@vue/compiler-dom\` in the build setup instead.
- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.
- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader
- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc`;
        Object.defineProperty(app.config, "compilerOptions", {
          get() {
            runtimeCore.warn(msg);
            return compilerOptions;
          },
          set() {
            runtimeCore.warn(msg);
          }
        });
      }
    }
    function normalizeContainer(container) {
      if (shared.isString(container)) {
        const res = document.querySelector(container);
        if (!res) {
          runtimeCore.warn(
            `Failed to mount app: mount target selector "${container}" returned null.`
          );
        }
        return res;
      }
      if (window.ShadowRoot && container instanceof window.ShadowRoot && container.mode === "closed") {
        runtimeCore.warn(
          `mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`
        );
      }
      return container;
    }
    var ssrDirectiveInitialized = false;
    var initDirectivesForSSR = () => {
      if (!ssrDirectiveInitialized) {
        ssrDirectiveInitialized = true;
        initVModelForSSR();
        initVShowForSSR();
      }
    };
    exports.Transition = Transition;
    exports.TransitionGroup = TransitionGroup;
    exports.VueElement = VueElement;
    exports.createApp = createApp;
    exports.createSSRApp = createSSRApp;
    exports.defineCustomElement = defineCustomElement;
    exports.defineSSRCustomElement = defineSSRCustomElement;
    exports.hydrate = hydrate;
    exports.initDirectivesForSSR = initDirectivesForSSR;
    exports.render = render;
    exports.useCssModule = useCssModule;
    exports.useCssVars = useCssVars;
    exports.vModelCheckbox = vModelCheckbox;
    exports.vModelDynamic = vModelDynamic;
    exports.vModelRadio = vModelRadio;
    exports.vModelSelect = vModelSelect;
    exports.vModelText = vModelText;
    exports.vShow = vShow;
    exports.withKeys = withKeys;
    exports.withModifiers = withModifiers;
    Object.keys(runtimeCore).forEach(function(k) {
      if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k))
        exports[k] = runtimeCore[k];
    });
  }
});

// node_modules/@vue/runtime-dom/index.js
var require_runtime_dom = __commonJS({
  "node_modules/@vue/runtime-dom/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_runtime_dom_cjs();
    }
  }
});

// node_modules/vue/dist/vue.cjs.js
var require_vue_cjs = __commonJS({
  "node_modules/vue/dist/vue.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var compilerDom = require_compiler_dom();
    var runtimeDom = require_runtime_dom();
    var shared = require_shared();
    function _interopNamespaceDefault(e) {
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        for (var k in e) {
          n[k] = e[k];
        }
      }
      n.default = e;
      return Object.freeze(n);
    }
    var runtimeDom__namespace = _interopNamespaceDefault(runtimeDom);
    var compileCache = /* @__PURE__ */ new WeakMap();
    function getCache(options) {
      let c = compileCache.get(options != null ? options : shared.EMPTY_OBJ);
      if (!c) {
        c = /* @__PURE__ */ Object.create(null);
        compileCache.set(options != null ? options : shared.EMPTY_OBJ, c);
      }
      return c;
    }
    function compileToFunction(template, options) {
      if (!shared.isString(template)) {
        if (template.nodeType) {
          template = template.innerHTML;
        } else {
          runtimeDom.warn(`invalid template option: `, template);
          return shared.NOOP;
        }
      }
      const key = template;
      const cache = getCache(options);
      const cached = cache[key];
      if (cached) {
        return cached;
      }
      if (template[0] === "#") {
        const el = document.querySelector(template);
        if (!el) {
          runtimeDom.warn(`Template element not found or is empty: ${template}`);
        }
        template = el ? el.innerHTML : ``;
      }
      const opts = shared.extend(
        {
          hoistStatic: true,
          onError,
          onWarn: (e) => onError(e, true)
        },
        options
      );
      if (!opts.isCustomElement && typeof customElements !== "undefined") {
        opts.isCustomElement = (tag) => !!customElements.get(tag);
      }
      const { code } = compilerDom.compile(template, opts);
      function onError(err, asWarning = false) {
        const message = asWarning ? err.message : `Template compilation error: ${err.message}`;
        const codeFrame = err.loc && shared.generateCodeFrame(
          template,
          err.loc.start.offset,
          err.loc.end.offset
        );
        runtimeDom.warn(codeFrame ? `${message}
${codeFrame}` : message);
      }
      const render = new Function("Vue", code)(runtimeDom__namespace);
      render._rc = true;
      return cache[key] = render;
    }
    runtimeDom.registerRuntimeCompiler(compileToFunction);
    exports.compile = compileToFunction;
    Object.keys(runtimeDom).forEach(function(k) {
      if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k))
        exports[k] = runtimeDom[k];
    });
  }
});

// node_modules/vue/index.js
var require_vue = __commonJS({
  "node_modules/vue/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_vue_cjs();
    }
  }
});

// node_modules/apexcharts/dist/apexcharts.common.js
var require_apexcharts_common = __commonJS({
  "node_modules/apexcharts/dist/apexcharts.common.js"(exports, module) {
    "use strict";
    function t(t2, e2) {
      var i2 = Object.keys(t2);
      if (Object.getOwnPropertySymbols) {
        var a2 = Object.getOwnPropertySymbols(t2);
        e2 && (a2 = a2.filter(function(e3) {
          return Object.getOwnPropertyDescriptor(t2, e3).enumerable;
        })), i2.push.apply(i2, a2);
      }
      return i2;
    }
    function e(e2) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var a2 = null != arguments[i2] ? arguments[i2] : {};
        i2 % 2 ? t(Object(a2), true).forEach(function(t2) {
          o(e2, t2, a2[t2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(a2)) : t(Object(a2)).forEach(function(t2) {
          Object.defineProperty(e2, t2, Object.getOwnPropertyDescriptor(a2, t2));
        });
      }
      return e2;
    }
    function i(t2) {
      return i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
        return typeof t3;
      } : function(t3) {
        return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
      }, i(t2);
    }
    function a(t2, e2) {
      if (!(t2 instanceof e2))
        throw new TypeError("Cannot call a class as a function");
    }
    function s(t2, e2) {
      for (var i2 = 0; i2 < e2.length; i2++) {
        var a2 = e2[i2];
        a2.enumerable = a2.enumerable || false, a2.configurable = true, "value" in a2 && (a2.writable = true), Object.defineProperty(t2, a2.key, a2);
      }
    }
    function r(t2, e2, i2) {
      return e2 && s(t2.prototype, e2), i2 && s(t2, i2), t2;
    }
    function o(t2, e2, i2) {
      return e2 in t2 ? Object.defineProperty(t2, e2, { value: i2, enumerable: true, configurable: true, writable: true }) : t2[e2] = i2, t2;
    }
    function n(t2, e2) {
      if ("function" != typeof e2 && null !== e2)
        throw new TypeError("Super expression must either be null or a function");
      t2.prototype = Object.create(e2 && e2.prototype, { constructor: { value: t2, writable: true, configurable: true } }), e2 && h(t2, e2);
    }
    function l(t2) {
      return l = Object.setPrototypeOf ? Object.getPrototypeOf : function(t3) {
        return t3.__proto__ || Object.getPrototypeOf(t3);
      }, l(t2);
    }
    function h(t2, e2) {
      return h = Object.setPrototypeOf || function(t3, e3) {
        return t3.__proto__ = e3, t3;
      }, h(t2, e2);
    }
    function c(t2, e2) {
      if (e2 && ("object" == typeof e2 || "function" == typeof e2))
        return e2;
      if (void 0 !== e2)
        throw new TypeError("Derived constructors may only return object or undefined");
      return function(t3) {
        if (void 0 === t3)
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t3;
      }(t2);
    }
    function d(t2) {
      var e2 = function() {
        if ("undefined" == typeof Reflect || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if ("function" == typeof Proxy)
          return true;
        try {
          return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          })), true;
        } catch (t3) {
          return false;
        }
      }();
      return function() {
        var i2, a2 = l(t2);
        if (e2) {
          var s2 = l(this).constructor;
          i2 = Reflect.construct(a2, arguments, s2);
        } else
          i2 = a2.apply(this, arguments);
        return c(this, i2);
      };
    }
    function g(t2, e2) {
      return function(t3) {
        if (Array.isArray(t3))
          return t3;
      }(t2) || function(t3, e3) {
        var i2 = null == t3 ? null : "undefined" != typeof Symbol && t3[Symbol.iterator] || t3["@@iterator"];
        if (null == i2)
          return;
        var a2, s2, r2 = [], o2 = true, n2 = false;
        try {
          for (i2 = i2.call(t3); !(o2 = (a2 = i2.next()).done) && (r2.push(a2.value), !e3 || r2.length !== e3); o2 = true)
            ;
        } catch (t4) {
          n2 = true, s2 = t4;
        } finally {
          try {
            o2 || null == i2.return || i2.return();
          } finally {
            if (n2)
              throw s2;
          }
        }
        return r2;
      }(t2, e2) || p(t2, e2) || function() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }();
    }
    function u(t2) {
      return function(t3) {
        if (Array.isArray(t3))
          return f(t3);
      }(t2) || function(t3) {
        if ("undefined" != typeof Symbol && null != t3[Symbol.iterator] || null != t3["@@iterator"])
          return Array.from(t3);
      }(t2) || p(t2) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }();
    }
    function p(t2, e2) {
      if (t2) {
        if ("string" == typeof t2)
          return f(t2, e2);
        var i2 = Object.prototype.toString.call(t2).slice(8, -1);
        return "Object" === i2 && t2.constructor && (i2 = t2.constructor.name), "Map" === i2 || "Set" === i2 ? Array.from(t2) : "Arguments" === i2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i2) ? f(t2, e2) : void 0;
      }
    }
    function f(t2, e2) {
      (null == e2 || e2 > t2.length) && (e2 = t2.length);
      for (var i2 = 0, a2 = new Array(e2); i2 < e2; i2++)
        a2[i2] = t2[i2];
      return a2;
    }
    var x = function() {
      function t2() {
        a(this, t2);
      }
      return r(t2, [{ key: "shadeRGBColor", value: function(t3, e2) {
        var i2 = e2.split(","), a2 = t3 < 0 ? 0 : 255, s2 = t3 < 0 ? -1 * t3 : t3, r2 = parseInt(i2[0].slice(4), 10), o2 = parseInt(i2[1], 10), n2 = parseInt(i2[2], 10);
        return "rgb(" + (Math.round((a2 - r2) * s2) + r2) + "," + (Math.round((a2 - o2) * s2) + o2) + "," + (Math.round((a2 - n2) * s2) + n2) + ")";
      } }, { key: "shadeHexColor", value: function(t3, e2) {
        var i2 = parseInt(e2.slice(1), 16), a2 = t3 < 0 ? 0 : 255, s2 = t3 < 0 ? -1 * t3 : t3, r2 = i2 >> 16, o2 = i2 >> 8 & 255, n2 = 255 & i2;
        return "#" + (16777216 + 65536 * (Math.round((a2 - r2) * s2) + r2) + 256 * (Math.round((a2 - o2) * s2) + o2) + (Math.round((a2 - n2) * s2) + n2)).toString(16).slice(1);
      } }, { key: "shadeColor", value: function(e2, i2) {
        return t2.isColorHex(i2) ? this.shadeHexColor(e2, i2) : this.shadeRGBColor(e2, i2);
      } }], [{ key: "bind", value: function(t3, e2) {
        return function() {
          return t3.apply(e2, arguments);
        };
      } }, { key: "isObject", value: function(t3) {
        return t3 && "object" === i(t3) && !Array.isArray(t3) && null != t3;
      } }, { key: "is", value: function(t3, e2) {
        return Object.prototype.toString.call(e2) === "[object " + t3 + "]";
      } }, { key: "listToArray", value: function(t3) {
        var e2, i2 = [];
        for (e2 = 0; e2 < t3.length; e2++)
          i2[e2] = t3[e2];
        return i2;
      } }, { key: "extend", value: function(t3, e2) {
        var i2 = this;
        "function" != typeof Object.assign && (Object.assign = function(t4) {
          if (null == t4)
            throw new TypeError("Cannot convert undefined or null to object");
          for (var e3 = Object(t4), i3 = 1; i3 < arguments.length; i3++) {
            var a3 = arguments[i3];
            if (null != a3)
              for (var s2 in a3)
                a3.hasOwnProperty(s2) && (e3[s2] = a3[s2]);
          }
          return e3;
        });
        var a2 = Object.assign({}, t3);
        return this.isObject(t3) && this.isObject(e2) && Object.keys(e2).forEach(function(s2) {
          i2.isObject(e2[s2]) && s2 in t3 ? a2[s2] = i2.extend(t3[s2], e2[s2]) : Object.assign(a2, o({}, s2, e2[s2]));
        }), a2;
      } }, { key: "extendArray", value: function(e2, i2) {
        var a2 = [];
        return e2.map(function(e3) {
          a2.push(t2.extend(i2, e3));
        }), e2 = a2;
      } }, { key: "monthMod", value: function(t3) {
        return t3 % 12;
      } }, { key: "clone", value: function(e2) {
        if (t2.is("Array", e2)) {
          for (var a2 = [], s2 = 0; s2 < e2.length; s2++)
            a2[s2] = this.clone(e2[s2]);
          return a2;
        }
        if (t2.is("Null", e2))
          return null;
        if (t2.is("Date", e2))
          return e2;
        if ("object" === i(e2)) {
          var r2 = {};
          for (var o2 in e2)
            e2.hasOwnProperty(o2) && (r2[o2] = this.clone(e2[o2]));
          return r2;
        }
        return e2;
      } }, { key: "log10", value: function(t3) {
        return Math.log(t3) / Math.LN10;
      } }, { key: "roundToBase10", value: function(t3) {
        return Math.pow(10, Math.floor(Math.log10(t3)));
      } }, { key: "roundToBase", value: function(t3, e2) {
        return Math.pow(e2, Math.floor(Math.log(t3) / Math.log(e2)));
      } }, { key: "parseNumber", value: function(t3) {
        return null === t3 ? t3 : parseFloat(t3);
      } }, { key: "stripNumber", value: function(t3) {
        var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2;
        return Number.isInteger(t3) ? t3 : parseFloat(t3.toPrecision(e2));
      } }, { key: "randomId", value: function() {
        return (Math.random() + 1).toString(36).substring(4);
      } }, { key: "noExponents", value: function(t3) {
        var e2 = String(t3).split(/[eE]/);
        if (1 === e2.length)
          return e2[0];
        var i2 = "", a2 = t3 < 0 ? "-" : "", s2 = e2[0].replace(".", ""), r2 = Number(e2[1]) + 1;
        if (r2 < 0) {
          for (i2 = a2 + "0."; r2++; )
            i2 += "0";
          return i2 + s2.replace(/^-/, "");
        }
        for (r2 -= s2.length; r2--; )
          i2 += "0";
        return s2 + i2;
      } }, { key: "getDimensions", value: function(t3) {
        var e2 = getComputedStyle(t3, null), i2 = t3.clientHeight, a2 = t3.clientWidth;
        return i2 -= parseFloat(e2.paddingTop) + parseFloat(e2.paddingBottom), [a2 -= parseFloat(e2.paddingLeft) + parseFloat(e2.paddingRight), i2];
      } }, { key: "getBoundingClientRect", value: function(t3) {
        var e2 = t3.getBoundingClientRect();
        return { top: e2.top, right: e2.right, bottom: e2.bottom, left: e2.left, width: t3.clientWidth, height: t3.clientHeight, x: e2.left, y: e2.top };
      } }, { key: "getLargestStringFromArr", value: function(t3) {
        return t3.reduce(function(t4, e2) {
          return Array.isArray(e2) && (e2 = e2.reduce(function(t5, e3) {
            return t5.length > e3.length ? t5 : e3;
          })), t4.length > e2.length ? t4 : e2;
        }, 0);
      } }, { key: "hexToRgba", value: function() {
        var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "#999999", e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0.6;
        "#" !== t3.substring(0, 1) && (t3 = "#999999");
        var i2 = t3.replace("#", "");
        i2 = i2.match(new RegExp("(.{" + i2.length / 3 + "})", "g"));
        for (var a2 = 0; a2 < i2.length; a2++)
          i2[a2] = parseInt(1 === i2[a2].length ? i2[a2] + i2[a2] : i2[a2], 16);
        return void 0 !== e2 && i2.push(e2), "rgba(" + i2.join(",") + ")";
      } }, { key: "getOpacityFromRGBA", value: function(t3) {
        return parseFloat(t3.replace(/^.*,(.+)\)/, "$1"));
      } }, { key: "rgb2hex", value: function(t3) {
        return (t3 = t3.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i)) && 4 === t3.length ? "#" + ("0" + parseInt(t3[1], 10).toString(16)).slice(-2) + ("0" + parseInt(t3[2], 10).toString(16)).slice(-2) + ("0" + parseInt(t3[3], 10).toString(16)).slice(-2) : "";
      } }, { key: "isColorHex", value: function(t3) {
        return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)|(^#[0-9A-F]{8}$)/i.test(t3);
      } }, { key: "getPolygonPos", value: function(t3, e2) {
        for (var i2 = [], a2 = 2 * Math.PI / e2, s2 = 0; s2 < e2; s2++) {
          var r2 = {};
          r2.x = t3 * Math.sin(s2 * a2), r2.y = -t3 * Math.cos(s2 * a2), i2.push(r2);
        }
        return i2;
      } }, { key: "polarToCartesian", value: function(t3, e2, i2, a2) {
        var s2 = (a2 - 90) * Math.PI / 180;
        return { x: t3 + i2 * Math.cos(s2), y: e2 + i2 * Math.sin(s2) };
      } }, { key: "escapeString", value: function(t3) {
        var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "x", i2 = t3.toString().slice();
        return i2 = i2.replace(/[` ~!@#$%^&*()|+\=?;:'",.<>{}[\]\\/]/gi, e2);
      } }, { key: "negToZero", value: function(t3) {
        return t3 < 0 ? 0 : t3;
      } }, { key: "moveIndexInArray", value: function(t3, e2, i2) {
        if (i2 >= t3.length)
          for (var a2 = i2 - t3.length + 1; a2--; )
            t3.push(void 0);
        return t3.splice(i2, 0, t3.splice(e2, 1)[0]), t3;
      } }, { key: "extractNumber", value: function(t3) {
        return parseFloat(t3.replace(/[^\d.]*/g, ""));
      } }, { key: "findAncestor", value: function(t3, e2) {
        for (; (t3 = t3.parentElement) && !t3.classList.contains(e2); )
          ;
        return t3;
      } }, { key: "setELstyles", value: function(t3, e2) {
        for (var i2 in e2)
          e2.hasOwnProperty(i2) && (t3.style.key = e2[i2]);
      } }, { key: "isNumber", value: function(t3) {
        return !isNaN(t3) && parseFloat(Number(t3)) === t3 && !isNaN(parseInt(t3, 10));
      } }, { key: "isFloat", value: function(t3) {
        return Number(t3) === t3 && t3 % 1 != 0;
      } }, { key: "isSafari", value: function() {
        return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
      } }, { key: "isFirefox", value: function() {
        return navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
      } }, { key: "isIE11", value: function() {
        if (-1 !== window.navigator.userAgent.indexOf("MSIE") || window.navigator.appVersion.indexOf("Trident/") > -1)
          return true;
      } }, { key: "isIE", value: function() {
        var t3 = window.navigator.userAgent, e2 = t3.indexOf("MSIE ");
        if (e2 > 0)
          return parseInt(t3.substring(e2 + 5, t3.indexOf(".", e2)), 10);
        if (t3.indexOf("Trident/") > 0) {
          var i2 = t3.indexOf("rv:");
          return parseInt(t3.substring(i2 + 3, t3.indexOf(".", i2)), 10);
        }
        var a2 = t3.indexOf("Edge/");
        return a2 > 0 && parseInt(t3.substring(a2 + 5, t3.indexOf(".", a2)), 10);
      } }]), t2;
    }();
    var b = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w, this.setEasingFunctions();
      }
      return r(t2, [{ key: "setEasingFunctions", value: function() {
        var t3;
        if (!this.w.globals.easing) {
          switch (this.w.config.chart.animations.easing) {
            case "linear":
              t3 = "-";
              break;
            case "easein":
              t3 = "<";
              break;
            case "easeout":
              t3 = ">";
              break;
            case "easeinout":
            default:
              t3 = "<>";
              break;
            case "swing":
              t3 = function(t4) {
                var e2 = 1.70158;
                return (t4 -= 1) * t4 * ((e2 + 1) * t4 + e2) + 1;
              };
              break;
            case "bounce":
              t3 = function(t4) {
                return t4 < 1 / 2.75 ? 7.5625 * t4 * t4 : t4 < 2 / 2.75 ? 7.5625 * (t4 -= 1.5 / 2.75) * t4 + 0.75 : t4 < 2.5 / 2.75 ? 7.5625 * (t4 -= 2.25 / 2.75) * t4 + 0.9375 : 7.5625 * (t4 -= 2.625 / 2.75) * t4 + 0.984375;
              };
              break;
            case "elastic":
              t3 = function(t4) {
                return t4 === !!t4 ? t4 : Math.pow(2, -10 * t4) * Math.sin((t4 - 0.075) * (2 * Math.PI) / 0.3) + 1;
              };
          }
          this.w.globals.easing = t3;
        }
      } }, { key: "animateLine", value: function(t3, e2, i2, a2) {
        t3.attr(e2).animate(a2).attr(i2);
      } }, { key: "animateMarker", value: function(t3, e2, i2, a2, s2, r2) {
        e2 || (e2 = 0), t3.attr({ r: e2, width: e2, height: e2 }).animate(a2, s2).attr({ r: i2, width: i2.width, height: i2.height }).afterAll(function() {
          r2();
        });
      } }, { key: "animateCircle", value: function(t3, e2, i2, a2, s2) {
        t3.attr({ r: e2.r, cx: e2.cx, cy: e2.cy }).animate(a2, s2).attr({ r: i2.r, cx: i2.cx, cy: i2.cy });
      } }, { key: "animateRect", value: function(t3, e2, i2, a2, s2) {
        t3.attr(e2).animate(a2).attr(i2).afterAll(function() {
          return s2();
        });
      } }, { key: "animatePathsGradually", value: function(t3) {
        var e2 = t3.el, i2 = t3.realIndex, a2 = t3.j, s2 = t3.fill, r2 = t3.pathFrom, o2 = t3.pathTo, n2 = t3.speed, l2 = t3.delay, h2 = this.w, c2 = 0;
        h2.config.chart.animations.animateGradually.enabled && (c2 = h2.config.chart.animations.animateGradually.delay), h2.config.chart.animations.dynamicAnimation.enabled && h2.globals.dataChanged && "bar" !== h2.config.chart.type && (c2 = 0), this.morphSVG(e2, i2, a2, "line" !== h2.config.chart.type || h2.globals.comboCharts ? s2 : "stroke", r2, o2, n2, l2 * c2);
      } }, { key: "showDelayedElements", value: function() {
        this.w.globals.delayedElements.forEach(function(t3) {
          var e2 = t3.el;
          e2.classList.remove("apexcharts-element-hidden"), e2.classList.add("apexcharts-hidden-element-shown");
        });
      } }, { key: "animationCompleted", value: function(t3) {
        var e2 = this.w;
        e2.globals.animationEnded || (e2.globals.animationEnded = true, this.showDelayedElements(), "function" == typeof e2.config.chart.events.animationEnd && e2.config.chart.events.animationEnd(this.ctx, { el: t3, w: e2 }));
      } }, { key: "morphSVG", value: function(t3, e2, i2, a2, s2, r2, o2, n2) {
        var l2 = this, h2 = this.w;
        s2 || (s2 = t3.attr("pathFrom")), r2 || (r2 = t3.attr("pathTo"));
        var c2 = function(t4) {
          return "radar" === h2.config.chart.type && (o2 = 1), "M 0 ".concat(h2.globals.gridHeight);
        };
        (!s2 || s2.indexOf("undefined") > -1 || s2.indexOf("NaN") > -1) && (s2 = c2()), (!r2 || r2.indexOf("undefined") > -1 || r2.indexOf("NaN") > -1) && (r2 = c2()), h2.globals.shouldAnimate || (o2 = 1), t3.plot(s2).animate(1, h2.globals.easing, n2).plot(s2).animate(o2, h2.globals.easing, n2).plot(r2).afterAll(function() {
          x.isNumber(i2) ? i2 === h2.globals.series[h2.globals.maxValsInArrayIndex].length - 2 && h2.globals.shouldAnimate && l2.animationCompleted(t3) : "none" !== a2 && h2.globals.shouldAnimate && (!h2.globals.comboCharts && e2 === h2.globals.series.length - 1 || h2.globals.comboCharts) && l2.animationCompleted(t3), l2.showDelayedElements();
        });
      } }]), t2;
    }();
    var v = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
      }
      return r(t2, [{ key: "getDefaultFilter", value: function(t3, e2) {
        var i2 = this.w;
        t3.unfilter(true), new window.SVG.Filter().size("120%", "180%", "-5%", "-40%"), "none" !== i2.config.states.normal.filter ? this.applyFilter(t3, e2, i2.config.states.normal.filter.type, i2.config.states.normal.filter.value) : i2.config.chart.dropShadow.enabled && this.dropShadow(t3, i2.config.chart.dropShadow, e2);
      } }, { key: "addNormalFilter", value: function(t3, e2) {
        var i2 = this.w;
        i2.config.chart.dropShadow.enabled && !t3.node.classList.contains("apexcharts-marker") && this.dropShadow(t3, i2.config.chart.dropShadow, e2);
      } }, { key: "addLightenFilter", value: function(t3, e2, i2) {
        var a2 = this, s2 = this.w, r2 = i2.intensity;
        t3.unfilter(true);
        new window.SVG.Filter();
        t3.filter(function(t4) {
          var i3 = s2.config.chart.dropShadow;
          (i3.enabled ? a2.addShadow(t4, e2, i3) : t4).componentTransfer({ rgb: { type: "linear", slope: 1.5, intercept: r2 } });
        }), t3.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t3.filterer.node);
      } }, { key: "addDarkenFilter", value: function(t3, e2, i2) {
        var a2 = this, s2 = this.w, r2 = i2.intensity;
        t3.unfilter(true);
        new window.SVG.Filter();
        t3.filter(function(t4) {
          var i3 = s2.config.chart.dropShadow;
          (i3.enabled ? a2.addShadow(t4, e2, i3) : t4).componentTransfer({ rgb: { type: "linear", slope: r2 } });
        }), t3.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t3.filterer.node);
      } }, { key: "applyFilter", value: function(t3, e2, i2) {
        var a2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0.5;
        switch (i2) {
          case "none":
            this.addNormalFilter(t3, e2);
            break;
          case "lighten":
            this.addLightenFilter(t3, e2, { intensity: a2 });
            break;
          case "darken":
            this.addDarkenFilter(t3, e2, { intensity: a2 });
        }
      } }, { key: "addShadow", value: function(t3, e2, i2) {
        var a2 = i2.blur, s2 = i2.top, r2 = i2.left, o2 = i2.color, n2 = i2.opacity, l2 = t3.flood(Array.isArray(o2) ? o2[e2] : o2, n2).composite(t3.sourceAlpha, "in").offset(r2, s2).gaussianBlur(a2).merge(t3.source);
        return t3.blend(t3.source, l2);
      } }, { key: "dropShadow", value: function(t3, e2) {
        var i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, a2 = e2.top, s2 = e2.left, r2 = e2.blur, o2 = e2.color, n2 = e2.opacity, l2 = e2.noUserSpaceOnUse, h2 = this.w;
        return t3.unfilter(true), x.isIE() && "radialBar" === h2.config.chart.type || (o2 = Array.isArray(o2) ? o2[i2] : o2, t3.filter(function(t4) {
          var e3 = null;
          e3 = x.isSafari() || x.isFirefox() || x.isIE() ? t4.flood(o2, n2).composite(t4.sourceAlpha, "in").offset(s2, a2).gaussianBlur(r2) : t4.flood(o2, n2).composite(t4.sourceAlpha, "in").offset(s2, a2).gaussianBlur(r2).merge(t4.source), t4.blend(t4.source, e3);
        }), l2 || t3.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t3.filterer.node)), t3;
      } }, { key: "setSelectionFilter", value: function(t3, e2, i2) {
        var a2 = this.w;
        if (void 0 !== a2.globals.selectedDataPoints[e2] && a2.globals.selectedDataPoints[e2].indexOf(i2) > -1) {
          t3.node.setAttribute("selected", true);
          var s2 = a2.config.states.active.filter;
          "none" !== s2 && this.applyFilter(t3, e2, s2.type, s2.value);
        }
      } }, { key: "_scaleFilterSize", value: function(t3) {
        !function(e2) {
          for (var i2 in e2)
            e2.hasOwnProperty(i2) && t3.setAttribute(i2, e2[i2]);
        }({ width: "200%", height: "200%", x: "-50%", y: "-50%" });
      } }]), t2;
    }();
    var m = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
      }
      return r(t2, [{ key: "roundPathCorners", value: function(t3, e2) {
        function i2(t4, e3, i3) {
          var s3 = e3.x - t4.x, r3 = e3.y - t4.y, o3 = Math.sqrt(s3 * s3 + r3 * r3);
          return a2(t4, e3, Math.min(1, i3 / o3));
        }
        function a2(t4, e3, i3) {
          return { x: t4.x + (e3.x - t4.x) * i3, y: t4.y + (e3.y - t4.y) * i3 };
        }
        function s2(t4, e3) {
          t4.length > 2 && (t4[t4.length - 2] = e3.x, t4[t4.length - 1] = e3.y);
        }
        function r2(t4) {
          return { x: parseFloat(t4[t4.length - 2]), y: parseFloat(t4[t4.length - 1]) };
        }
        t3.indexOf("NaN") > -1 && (t3 = "");
        var o2 = t3.split(/[,\s]/).reduce(function(t4, e3) {
          var i3 = e3.match("([a-zA-Z])(.+)");
          return i3 ? (t4.push(i3[1]), t4.push(i3[2])) : t4.push(e3), t4;
        }, []).reduce(function(t4, e3) {
          return parseFloat(e3) == e3 && t4.length ? t4[t4.length - 1].push(e3) : t4.push([e3]), t4;
        }, []), n2 = [];
        if (o2.length > 1) {
          var l2 = r2(o2[0]), h2 = null;
          "Z" == o2[o2.length - 1][0] && o2[0].length > 2 && (h2 = ["L", l2.x, l2.y], o2[o2.length - 1] = h2), n2.push(o2[0]);
          for (var c2 = 1; c2 < o2.length; c2++) {
            var d2 = n2[n2.length - 1], g2 = o2[c2], u2 = g2 == h2 ? o2[1] : o2[c2 + 1];
            if (u2 && d2 && d2.length > 2 && "L" == g2[0] && u2.length > 2 && "L" == u2[0]) {
              var p2, f2, x2 = r2(d2), b2 = r2(g2), v2 = r2(u2);
              p2 = i2(b2, x2, e2), f2 = i2(b2, v2, e2), s2(g2, p2), g2.origPoint = b2, n2.push(g2);
              var m2 = a2(p2, b2, 0.5), y2 = a2(b2, f2, 0.5), w2 = ["C", m2.x, m2.y, y2.x, y2.y, f2.x, f2.y];
              w2.origPoint = b2, n2.push(w2);
            } else
              n2.push(g2);
          }
          if (h2) {
            var k2 = r2(n2[n2.length - 1]);
            n2.push(["Z"]), s2(n2[0], k2);
          }
        } else
          n2 = o2;
        return n2.reduce(function(t4, e3) {
          return t4 + e3.join(" ") + " ";
        }, "");
      } }, { key: "drawLine", value: function(t3, e2, i2, a2) {
        var s2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "#a8a8a8", r2 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0, o2 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null, n2 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : "butt";
        return this.w.globals.dom.Paper.line().attr({ x1: t3, y1: e2, x2: i2, y2: a2, stroke: s2, "stroke-dasharray": r2, "stroke-width": o2, "stroke-linecap": n2 });
      } }, { key: "drawRect", value: function() {
        var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, a2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, s2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, r2 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "#fefefe", o2 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 1, n2 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null, l2 = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : null, h2 = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : 0, c2 = this.w.globals.dom.Paper.rect();
        return c2.attr({ x: t3, y: e2, width: i2 > 0 ? i2 : 0, height: a2 > 0 ? a2 : 0, rx: s2, ry: s2, opacity: o2, "stroke-width": null !== n2 ? n2 : 0, stroke: null !== l2 ? l2 : "none", "stroke-dasharray": h2 }), c2.node.setAttribute("fill", r2), c2;
      } }, { key: "drawPolygon", value: function(t3) {
        var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "#e1e1e1", i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, a2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "none";
        return this.w.globals.dom.Paper.polygon(t3).attr({ fill: a2, stroke: e2, "stroke-width": i2 });
      } }, { key: "drawCircle", value: function(t3) {
        var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
        t3 < 0 && (t3 = 0);
        var i2 = this.w.globals.dom.Paper.circle(2 * t3);
        return null !== e2 && i2.attr(e2), i2;
      } }, { key: "drawPath", value: function(t3) {
        var e2 = t3.d, i2 = void 0 === e2 ? "" : e2, a2 = t3.stroke, s2 = void 0 === a2 ? "#a8a8a8" : a2, r2 = t3.strokeWidth, o2 = void 0 === r2 ? 1 : r2, n2 = t3.fill, l2 = t3.fillOpacity, h2 = void 0 === l2 ? 1 : l2, c2 = t3.strokeOpacity, d2 = void 0 === c2 ? 1 : c2, g2 = t3.classes, u2 = t3.strokeLinecap, p2 = void 0 === u2 ? null : u2, f2 = t3.strokeDashArray, x2 = void 0 === f2 ? 0 : f2, b2 = this.w;
        return null === p2 && (p2 = b2.config.stroke.lineCap), (i2.indexOf("undefined") > -1 || i2.indexOf("NaN") > -1) && (i2 = "M 0 ".concat(b2.globals.gridHeight)), b2.globals.dom.Paper.path(i2).attr({ fill: n2, "fill-opacity": h2, stroke: s2, "stroke-opacity": d2, "stroke-linecap": p2, "stroke-width": o2, "stroke-dasharray": x2, class: g2 });
      } }, { key: "group", value: function() {
        var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, e2 = this.w.globals.dom.Paper.group();
        return null !== t3 && e2.attr(t3), e2;
      } }, { key: "move", value: function(t3, e2) {
        var i2 = ["M", t3, e2].join(" ");
        return i2;
      } }, { key: "line", value: function(t3, e2) {
        var i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a2 = null;
        return null === i2 ? a2 = [" L", t3, e2].join(" ") : "H" === i2 ? a2 = [" H", t3].join(" ") : "V" === i2 && (a2 = [" V", e2].join(" ")), a2;
      } }, { key: "curve", value: function(t3, e2, i2, a2, s2, r2) {
        var o2 = ["C", t3, e2, i2, a2, s2, r2].join(" ");
        return o2;
      } }, { key: "quadraticCurve", value: function(t3, e2, i2, a2) {
        return ["Q", t3, e2, i2, a2].join(" ");
      } }, { key: "arc", value: function(t3, e2, i2, a2, s2, r2, o2) {
        var n2 = "A";
        arguments.length > 7 && void 0 !== arguments[7] && arguments[7] && (n2 = "a");
        var l2 = [n2, t3, e2, i2, a2, s2, r2, o2].join(" ");
        return l2;
      } }, { key: "renderPaths", value: function(t3) {
        var i2, a2 = t3.j, s2 = t3.realIndex, r2 = t3.pathFrom, o2 = t3.pathTo, n2 = t3.stroke, l2 = t3.strokeWidth, h2 = t3.strokeLinecap, c2 = t3.fill, d2 = t3.animationDelay, g2 = t3.initialSpeed, u2 = t3.dataChangeSpeed, p2 = t3.className, f2 = t3.shouldClipToGrid, x2 = void 0 === f2 || f2, m2 = t3.bindEventsOnPaths, y2 = void 0 === m2 || m2, w2 = t3.drawShadow, k2 = void 0 === w2 || w2, A2 = this.w, S2 = new v(this.ctx), C2 = new b(this.ctx), L2 = this.w.config.chart.animations.enabled, P2 = L2 && this.w.config.chart.animations.dynamicAnimation.enabled, I2 = !!(L2 && !A2.globals.resized || P2 && A2.globals.dataChanged && A2.globals.shouldAnimate);
        I2 ? i2 = r2 : (i2 = o2, A2.globals.animationEnded = true);
        var T2 = A2.config.stroke.dashArray, M2 = 0;
        M2 = Array.isArray(T2) ? T2[s2] : A2.config.stroke.dashArray;
        var z2 = this.drawPath({ d: i2, stroke: n2, strokeWidth: l2, fill: c2, fillOpacity: 1, classes: p2, strokeLinecap: h2, strokeDashArray: M2 });
        if (z2.attr("index", s2), x2 && z2.attr({ "clip-path": "url(#gridRectMask".concat(A2.globals.cuid, ")") }), "none" !== A2.config.states.normal.filter.type)
          S2.getDefaultFilter(z2, s2);
        else if (A2.config.chart.dropShadow.enabled && k2 && (!A2.config.chart.dropShadow.enabledOnSeries || A2.config.chart.dropShadow.enabledOnSeries && -1 !== A2.config.chart.dropShadow.enabledOnSeries.indexOf(s2))) {
          var X2 = A2.config.chart.dropShadow;
          S2.dropShadow(z2, X2, s2);
        }
        y2 && (z2.node.addEventListener("mouseenter", this.pathMouseEnter.bind(this, z2)), z2.node.addEventListener("mouseleave", this.pathMouseLeave.bind(this, z2)), z2.node.addEventListener("mousedown", this.pathMouseDown.bind(this, z2))), z2.attr({ pathTo: o2, pathFrom: r2 });
        var E2 = { el: z2, j: a2, realIndex: s2, pathFrom: r2, pathTo: o2, fill: c2, strokeWidth: l2, delay: d2 };
        return !L2 || A2.globals.resized || A2.globals.dataChanged ? !A2.globals.resized && A2.globals.dataChanged || C2.showDelayedElements() : C2.animatePathsGradually(e(e({}, E2), {}, { speed: g2 })), A2.globals.dataChanged && P2 && I2 && C2.animatePathsGradually(e(e({}, E2), {}, { speed: u2 })), z2;
      } }, { key: "drawPattern", value: function(t3, e2, i2) {
        var a2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "#a8a8a8", s2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
        return this.w.globals.dom.Paper.pattern(e2, i2, function(r2) {
          "horizontalLines" === t3 ? r2.line(0, 0, i2, 0).stroke({ color: a2, width: s2 + 1 }) : "verticalLines" === t3 ? r2.line(0, 0, 0, e2).stroke({ color: a2, width: s2 + 1 }) : "slantedLines" === t3 ? r2.line(0, 0, e2, i2).stroke({ color: a2, width: s2 }) : "squares" === t3 ? r2.rect(e2, i2).fill("none").stroke({ color: a2, width: s2 }) : "circles" === t3 && r2.circle(e2).fill("none").stroke({ color: a2, width: s2 });
        });
      } }, { key: "drawGradient", value: function(t3, e2, i2, a2, s2) {
        var r2, o2 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null, n2 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null, l2 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null, h2 = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0, c2 = this.w;
        e2.length < 9 && 0 === e2.indexOf("#") && (e2 = x.hexToRgba(e2, a2)), i2.length < 9 && 0 === i2.indexOf("#") && (i2 = x.hexToRgba(i2, s2));
        var d2 = 0, g2 = 1, u2 = 1, p2 = null;
        null !== n2 && (d2 = void 0 !== n2[0] ? n2[0] / 100 : 0, g2 = void 0 !== n2[1] ? n2[1] / 100 : 1, u2 = void 0 !== n2[2] ? n2[2] / 100 : 1, p2 = void 0 !== n2[3] ? n2[3] / 100 : null);
        var f2 = !("donut" !== c2.config.chart.type && "pie" !== c2.config.chart.type && "polarArea" !== c2.config.chart.type && "bubble" !== c2.config.chart.type);
        if (r2 = null === l2 || 0 === l2.length ? c2.globals.dom.Paper.gradient(f2 ? "radial" : "linear", function(t4) {
          t4.at(d2, e2, a2), t4.at(g2, i2, s2), t4.at(u2, i2, s2), null !== p2 && t4.at(p2, e2, a2);
        }) : c2.globals.dom.Paper.gradient(f2 ? "radial" : "linear", function(t4) {
          (Array.isArray(l2[h2]) ? l2[h2] : l2).forEach(function(e3) {
            t4.at(e3.offset / 100, e3.color, e3.opacity);
          });
        }), f2) {
          var b2 = c2.globals.gridWidth / 2, v2 = c2.globals.gridHeight / 2;
          "bubble" !== c2.config.chart.type ? r2.attr({ gradientUnits: "userSpaceOnUse", cx: b2, cy: v2, r: o2 }) : r2.attr({ cx: 0.5, cy: 0.5, r: 0.8, fx: 0.2, fy: 0.2 });
        } else
          "vertical" === t3 ? r2.from(0, 0).to(0, 1) : "diagonal" === t3 ? r2.from(0, 0).to(1, 1) : "horizontal" === t3 ? r2.from(0, 1).to(1, 1) : "diagonal2" === t3 && r2.from(1, 0).to(0, 1);
        return r2;
      } }, { key: "getTextBasedOnMaxWidth", value: function(t3) {
        var e2 = t3.text, i2 = t3.maxWidth, a2 = t3.fontSize, s2 = t3.fontFamily, r2 = this.getTextRects(e2, a2, s2), o2 = r2.width / e2.length, n2 = Math.floor(i2 / o2);
        return i2 < r2.width ? e2.slice(0, n2 - 3) + "..." : e2;
      } }, { key: "drawText", value: function(t3) {
        var i2 = this, a2 = t3.x, s2 = t3.y, r2 = t3.text, o2 = t3.textAnchor, n2 = t3.fontSize, l2 = t3.fontFamily, h2 = t3.fontWeight, c2 = t3.foreColor, d2 = t3.opacity, g2 = t3.maxWidth, u2 = t3.cssClass, p2 = void 0 === u2 ? "" : u2, f2 = t3.isPlainText, x2 = void 0 === f2 || f2, b2 = this.w;
        void 0 === r2 && (r2 = "");
        var v2 = r2;
        o2 || (o2 = "start"), c2 && c2.length || (c2 = b2.config.chart.foreColor), l2 = l2 || b2.config.chart.fontFamily, h2 = h2 || "regular";
        var m2, y2 = { maxWidth: g2, fontSize: n2 = n2 || "11px", fontFamily: l2 };
        return Array.isArray(r2) ? m2 = b2.globals.dom.Paper.text(function(t4) {
          for (var a3 = 0; a3 < r2.length; a3++)
            v2 = r2[a3], g2 && (v2 = i2.getTextBasedOnMaxWidth(e({ text: r2[a3] }, y2))), 0 === a3 ? t4.tspan(v2) : t4.tspan(v2).newLine();
        }) : (g2 && (v2 = this.getTextBasedOnMaxWidth(e({ text: r2 }, y2))), m2 = x2 ? b2.globals.dom.Paper.plain(r2) : b2.globals.dom.Paper.text(function(t4) {
          return t4.tspan(v2);
        })), m2.attr({ x: a2, y: s2, "text-anchor": o2, "dominant-baseline": "auto", "font-size": n2, "font-family": l2, "font-weight": h2, fill: c2, class: "apexcharts-text " + p2 }), m2.node.style.fontFamily = l2, m2.node.style.opacity = d2, m2;
      } }, { key: "drawMarker", value: function(t3, e2, i2) {
        t3 = t3 || 0;
        var a2 = i2.pSize || 0, s2 = null;
        if ("square" === i2.shape || "rect" === i2.shape) {
          var r2 = void 0 === i2.pRadius ? a2 / 2 : i2.pRadius;
          null !== e2 && a2 || (a2 = 0, r2 = 0);
          var o2 = 1.2 * a2 + r2, n2 = this.drawRect(o2, o2, o2, o2, r2);
          n2.attr({ x: t3 - o2 / 2, y: e2 - o2 / 2, cx: t3, cy: e2, class: i2.class ? i2.class : "", fill: i2.pointFillColor, "fill-opacity": i2.pointFillOpacity ? i2.pointFillOpacity : 1, stroke: i2.pointStrokeColor, "stroke-width": i2.pointStrokeWidth ? i2.pointStrokeWidth : 0, "stroke-opacity": i2.pointStrokeOpacity ? i2.pointStrokeOpacity : 1 }), s2 = n2;
        } else
          "circle" !== i2.shape && i2.shape || (x.isNumber(e2) || (a2 = 0, e2 = 0), s2 = this.drawCircle(a2, { cx: t3, cy: e2, class: i2.class ? i2.class : "", stroke: i2.pointStrokeColor, fill: i2.pointFillColor, "fill-opacity": i2.pointFillOpacity ? i2.pointFillOpacity : 1, "stroke-width": i2.pointStrokeWidth ? i2.pointStrokeWidth : 0, "stroke-opacity": i2.pointStrokeOpacity ? i2.pointStrokeOpacity : 1 }));
        return s2;
      } }, { key: "pathMouseEnter", value: function(t3, e2) {
        var i2 = this.w, a2 = new v(this.ctx), s2 = parseInt(t3.node.getAttribute("index"), 10), r2 = parseInt(t3.node.getAttribute("j"), 10);
        if ("function" == typeof i2.config.chart.events.dataPointMouseEnter && i2.config.chart.events.dataPointMouseEnter(e2, this.ctx, { seriesIndex: s2, dataPointIndex: r2, w: i2 }), this.ctx.events.fireEvent("dataPointMouseEnter", [e2, this.ctx, { seriesIndex: s2, dataPointIndex: r2, w: i2 }]), ("none" === i2.config.states.active.filter.type || "true" !== t3.node.getAttribute("selected")) && "none" !== i2.config.states.hover.filter.type && !i2.globals.isTouchDevice) {
          var o2 = i2.config.states.hover.filter;
          a2.applyFilter(t3, s2, o2.type, o2.value);
        }
      } }, { key: "pathMouseLeave", value: function(t3, e2) {
        var i2 = this.w, a2 = new v(this.ctx), s2 = parseInt(t3.node.getAttribute("index"), 10), r2 = parseInt(t3.node.getAttribute("j"), 10);
        "function" == typeof i2.config.chart.events.dataPointMouseLeave && i2.config.chart.events.dataPointMouseLeave(e2, this.ctx, { seriesIndex: s2, dataPointIndex: r2, w: i2 }), this.ctx.events.fireEvent("dataPointMouseLeave", [e2, this.ctx, { seriesIndex: s2, dataPointIndex: r2, w: i2 }]), "none" !== i2.config.states.active.filter.type && "true" === t3.node.getAttribute("selected") || "none" !== i2.config.states.hover.filter.type && a2.getDefaultFilter(t3, s2);
      } }, { key: "pathMouseDown", value: function(t3, e2) {
        var i2 = this.w, a2 = new v(this.ctx), s2 = parseInt(t3.node.getAttribute("index"), 10), r2 = parseInt(t3.node.getAttribute("j"), 10), o2 = "false";
        if ("true" === t3.node.getAttribute("selected")) {
          if (t3.node.setAttribute("selected", "false"), i2.globals.selectedDataPoints[s2].indexOf(r2) > -1) {
            var n2 = i2.globals.selectedDataPoints[s2].indexOf(r2);
            i2.globals.selectedDataPoints[s2].splice(n2, 1);
          }
        } else {
          if (!i2.config.states.active.allowMultipleDataPointsSelection && i2.globals.selectedDataPoints.length > 0) {
            i2.globals.selectedDataPoints = [];
            var l2 = i2.globals.dom.Paper.select(".apexcharts-series path").members, h2 = i2.globals.dom.Paper.select(".apexcharts-series circle, .apexcharts-series rect").members, c2 = function(t4) {
              Array.prototype.forEach.call(t4, function(t5) {
                t5.node.setAttribute("selected", "false"), a2.getDefaultFilter(t5, s2);
              });
            };
            c2(l2), c2(h2);
          }
          t3.node.setAttribute("selected", "true"), o2 = "true", void 0 === i2.globals.selectedDataPoints[s2] && (i2.globals.selectedDataPoints[s2] = []), i2.globals.selectedDataPoints[s2].push(r2);
        }
        if ("true" === o2) {
          var d2 = i2.config.states.active.filter;
          if ("none" !== d2)
            a2.applyFilter(t3, s2, d2.type, d2.value);
          else if ("none" !== i2.config.states.hover.filter && !i2.globals.isTouchDevice) {
            var g2 = i2.config.states.hover.filter;
            a2.applyFilter(t3, s2, g2.type, g2.value);
          }
        } else if ("none" !== i2.config.states.active.filter.type)
          if ("none" === i2.config.states.hover.filter.type || i2.globals.isTouchDevice)
            a2.getDefaultFilter(t3, s2);
          else {
            g2 = i2.config.states.hover.filter;
            a2.applyFilter(t3, s2, g2.type, g2.value);
          }
        "function" == typeof i2.config.chart.events.dataPointSelection && i2.config.chart.events.dataPointSelection(e2, this.ctx, { selectedDataPoints: i2.globals.selectedDataPoints, seriesIndex: s2, dataPointIndex: r2, w: i2 }), e2 && this.ctx.events.fireEvent("dataPointSelection", [e2, this.ctx, { selectedDataPoints: i2.globals.selectedDataPoints, seriesIndex: s2, dataPointIndex: r2, w: i2 }]);
      } }, { key: "rotateAroundCenter", value: function(t3) {
        var e2 = {};
        return t3 && "function" == typeof t3.getBBox && (e2 = t3.getBBox()), { x: e2.x + e2.width / 2, y: e2.y + e2.height / 2 };
      } }, { key: "getTextRects", value: function(t3, e2, i2, a2) {
        var s2 = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4], r2 = this.w, o2 = this.drawText({ x: -200, y: -200, text: t3, textAnchor: "start", fontSize: e2, fontFamily: i2, foreColor: "#fff", opacity: 0 });
        a2 && o2.attr("transform", a2), r2.globals.dom.Paper.add(o2);
        var n2 = o2.bbox();
        return s2 || (n2 = o2.node.getBoundingClientRect()), o2.remove(), { width: n2.width, height: n2.height };
      } }, { key: "placeTextWithEllipsis", value: function(t3, e2, i2) {
        if ("function" == typeof t3.getComputedTextLength && (t3.textContent = e2, e2.length > 0 && t3.getComputedTextLength() >= i2 / 1.1)) {
          for (var a2 = e2.length - 3; a2 > 0; a2 -= 3)
            if (t3.getSubStringLength(0, a2) <= i2 / 1.1)
              return void (t3.textContent = e2.substring(0, a2) + "...");
          t3.textContent = ".";
        }
      } }], [{ key: "setAttrs", value: function(t3, e2) {
        for (var i2 in e2)
          e2.hasOwnProperty(i2) && t3.setAttribute(i2, e2[i2]);
      } }]), t2;
    }();
    var y = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
      }
      return r(t2, [{ key: "getStackedSeriesTotals", value: function() {
        var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e2 = this.w, i2 = [];
        if (0 === e2.globals.series.length)
          return i2;
        for (var a2 = 0; a2 < e2.globals.series[e2.globals.maxValsInArrayIndex].length; a2++) {
          for (var s2 = 0, r2 = 0; r2 < e2.globals.series.length; r2++)
            void 0 !== e2.globals.series[r2][a2] && -1 === t3.indexOf(r2) && (s2 += e2.globals.series[r2][a2]);
          i2.push(s2);
        }
        return i2;
      } }, { key: "getSeriesTotalByIndex", value: function() {
        var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
        return null === t3 ? this.w.config.series.reduce(function(t4, e2) {
          return t4 + e2;
        }, 0) : this.w.globals.series[t3].reduce(function(t4, e2) {
          return t4 + e2;
        }, 0);
      } }, { key: "isSeriesNull", value: function() {
        var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
        return 0 === (null === t3 ? this.w.config.series.filter(function(t4) {
          return null !== t4;
        }) : this.w.config.series[t3].data.filter(function(t4) {
          return null !== t4;
        })).length;
      } }, { key: "seriesHaveSameValues", value: function(t3) {
        return this.w.globals.series[t3].every(function(t4, e2, i2) {
          return t4 === i2[0];
        });
      } }, { key: "getCategoryLabels", value: function(t3) {
        var e2 = this.w, i2 = t3.slice();
        return e2.config.xaxis.convertedCatToNumeric && (i2 = t3.map(function(t4, i3) {
          return e2.config.xaxis.labels.formatter(t4 - e2.globals.minX + 1);
        })), i2;
      } }, { key: "getLargestSeries", value: function() {
        var t3 = this.w;
        t3.globals.maxValsInArrayIndex = t3.globals.series.map(function(t4) {
          return t4.length;
        }).indexOf(Math.max.apply(Math, t3.globals.series.map(function(t4) {
          return t4.length;
        })));
      } }, { key: "getLargestMarkerSize", value: function() {
        var t3 = this.w, e2 = 0;
        return t3.globals.markers.size.forEach(function(t4) {
          e2 = Math.max(e2, t4);
        }), t3.config.markers.discrete && t3.config.markers.discrete.length && t3.config.markers.discrete.forEach(function(t4) {
          e2 = Math.max(e2, t4.size);
        }), e2 > 0 && (e2 += t3.config.markers.hover.sizeOffset + 1), t3.globals.markers.largestSize = e2, e2;
      } }, { key: "getSeriesTotals", value: function() {
        var t3 = this.w;
        t3.globals.seriesTotals = t3.globals.series.map(function(t4, e2) {
          var i2 = 0;
          if (Array.isArray(t4))
            for (var a2 = 0; a2 < t4.length; a2++)
              i2 += t4[a2];
          else
            i2 += t4;
          return i2;
        });
      } }, { key: "getSeriesTotalsXRange", value: function(t3, e2) {
        var i2 = this.w;
        return i2.globals.series.map(function(a2, s2) {
          for (var r2 = 0, o2 = 0; o2 < a2.length; o2++)
            i2.globals.seriesX[s2][o2] > t3 && i2.globals.seriesX[s2][o2] < e2 && (r2 += a2[o2]);
          return r2;
        });
      } }, { key: "getPercentSeries", value: function() {
        var t3 = this.w;
        t3.globals.seriesPercent = t3.globals.series.map(function(e2, i2) {
          var a2 = [];
          if (Array.isArray(e2))
            for (var s2 = 0; s2 < e2.length; s2++) {
              var r2 = t3.globals.stackedSeriesTotals[s2], o2 = 0;
              r2 && (o2 = 100 * e2[s2] / r2), a2.push(o2);
            }
          else {
            var n2 = 100 * e2 / t3.globals.seriesTotals.reduce(function(t4, e3) {
              return t4 + e3;
            }, 0);
            a2.push(n2);
          }
          return a2;
        });
      } }, { key: "getCalculatedRatios", value: function() {
        var t3, e2, i2, a2, s2 = this.w.globals, r2 = [], o2 = 0, n2 = [], l2 = 0.1, h2 = 0;
        if (s2.yRange = [], s2.isMultipleYAxis)
          for (var c2 = 0; c2 < s2.minYArr.length; c2++)
            s2.yRange.push(Math.abs(s2.minYArr[c2] - s2.maxYArr[c2])), n2.push(0);
        else
          s2.yRange.push(Math.abs(s2.minY - s2.maxY));
        s2.xRange = Math.abs(s2.maxX - s2.minX), s2.zRange = Math.abs(s2.maxZ - s2.minZ);
        for (var d2 = 0; d2 < s2.yRange.length; d2++)
          r2.push(s2.yRange[d2] / s2.gridHeight);
        if (e2 = s2.xRange / s2.gridWidth, i2 = Math.abs(s2.initialMaxX - s2.initialMinX) / s2.gridWidth, t3 = s2.yRange / s2.gridWidth, a2 = s2.xRange / s2.gridHeight, (o2 = s2.zRange / s2.gridHeight * 16) || (o2 = 1), s2.minY !== Number.MIN_VALUE && 0 !== Math.abs(s2.minY) && (s2.hasNegs = true), s2.isMultipleYAxis) {
          n2 = [];
          for (var g2 = 0; g2 < r2.length; g2++)
            n2.push(-s2.minYArr[g2] / r2[g2]);
        } else
          n2.push(-s2.minY / r2[0]), s2.minY !== Number.MIN_VALUE && 0 !== Math.abs(s2.minY) && (l2 = -s2.minY / t3, h2 = s2.minX / e2);
        return { yRatio: r2, invertedYRatio: t3, zRatio: o2, xRatio: e2, initialXRatio: i2, invertedXRatio: a2, baseLineInvertedY: l2, baseLineY: n2, baseLineX: h2 };
      } }, { key: "getLogSeries", value: function(t3) {
        var e2 = this, i2 = this.w;
        return i2.globals.seriesLog = t3.map(function(t4, a2) {
          return i2.config.yaxis[a2] && i2.config.yaxis[a2].logarithmic ? t4.map(function(t5) {
            return null === t5 ? null : e2.getLogVal(i2.config.yaxis[a2].logBase, t5, a2);
          }) : t4;
        }), i2.globals.invalidLogScale ? t3 : i2.globals.seriesLog;
      } }, { key: "getBaseLog", value: function(t3, e2) {
        return Math.log(e2) / Math.log(t3);
      } }, { key: "getLogVal", value: function(t3, e2, i2) {
        if (0 === e2)
          return 0;
        var a2 = this.w, s2 = 0 === a2.globals.minYArr[i2] ? -1 : this.getBaseLog(t3, a2.globals.minYArr[i2]), r2 = (0 === a2.globals.maxYArr[i2] ? 0 : this.getBaseLog(t3, a2.globals.maxYArr[i2])) - s2;
        return e2 < 1 ? e2 / r2 : (this.getBaseLog(t3, e2) - s2) / r2;
      } }, { key: "getLogYRatios", value: function(t3) {
        var e2 = this, i2 = this.w, a2 = this.w.globals;
        return a2.yLogRatio = t3.slice(), a2.logYRange = a2.yRange.map(function(t4, s2) {
          if (i2.config.yaxis[s2] && e2.w.config.yaxis[s2].logarithmic) {
            var r2, o2 = -Number.MAX_VALUE, n2 = Number.MIN_VALUE;
            return a2.seriesLog.forEach(function(t5, e3) {
              t5.forEach(function(t6) {
                i2.config.yaxis[e3] && i2.config.yaxis[e3].logarithmic && (o2 = Math.max(t6, o2), n2 = Math.min(t6, n2));
              });
            }), r2 = Math.pow(a2.yRange[s2], Math.abs(n2 - o2) / a2.yRange[s2]), a2.yLogRatio[s2] = r2 / a2.gridHeight, r2;
          }
        }), a2.invalidLogScale ? t3.slice() : a2.yLogRatio;
      } }], [{ key: "checkComboSeries", value: function(t3) {
        var e2 = false, i2 = 0, a2 = 0;
        return t3.length && void 0 !== t3[0].type && t3.forEach(function(t4) {
          "bar" !== t4.type && "column" !== t4.type && "candlestick" !== t4.type && "boxPlot" !== t4.type || i2++, void 0 !== t4.type && a2++;
        }), a2 > 0 && (e2 = true), { comboBarCount: i2, comboCharts: e2 };
      } }, { key: "extendArrayProps", value: function(t3, e2, i2) {
        return e2.yaxis && (e2 = t3.extendYAxis(e2, i2)), e2.annotations && (e2.annotations.yaxis && (e2 = t3.extendYAxisAnnotations(e2)), e2.annotations.xaxis && (e2 = t3.extendXAxisAnnotations(e2)), e2.annotations.points && (e2 = t3.extendPointAnnotations(e2))), e2;
      } }]), t2;
    }();
    var w = function() {
      function t2(e2) {
        a(this, t2), this.w = e2.w, this.annoCtx = e2;
      }
      return r(t2, [{ key: "setOrientations", value: function(t3) {
        var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, i2 = this.w;
        if ("vertical" === t3.label.orientation) {
          var a2 = null !== e2 ? e2 : 0, s2 = i2.globals.dom.baseEl.querySelector(".apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='".concat(a2, "']"));
          if (null !== s2) {
            var r2 = s2.getBoundingClientRect();
            s2.setAttribute("x", parseFloat(s2.getAttribute("x")) - r2.height + 4), "top" === t3.label.position ? s2.setAttribute("y", parseFloat(s2.getAttribute("y")) + r2.width) : s2.setAttribute("y", parseFloat(s2.getAttribute("y")) - r2.width);
            var o2 = this.annoCtx.graphics.rotateAroundCenter(s2), n2 = o2.x, l2 = o2.y;
            s2.setAttribute("transform", "rotate(-90 ".concat(n2, " ").concat(l2, ")"));
          }
        }
      } }, { key: "addBackgroundToAnno", value: function(t3, e2) {
        var i2 = this.w;
        if (!t3 || void 0 === e2.label.text || void 0 !== e2.label.text && !String(e2.label.text).trim())
          return null;
        var a2 = i2.globals.dom.baseEl.querySelector(".apexcharts-grid").getBoundingClientRect(), s2 = t3.getBoundingClientRect(), r2 = e2.label.style.padding.left, o2 = e2.label.style.padding.right, n2 = e2.label.style.padding.top, l2 = e2.label.style.padding.bottom;
        "vertical" === e2.label.orientation && (n2 = e2.label.style.padding.left, l2 = e2.label.style.padding.right, r2 = e2.label.style.padding.top, o2 = e2.label.style.padding.bottom);
        var h2 = s2.left - a2.left - r2, c2 = s2.top - a2.top - n2, d2 = this.annoCtx.graphics.drawRect(h2 - i2.globals.barPadForNumericAxis, c2, s2.width + r2 + o2, s2.height + n2 + l2, e2.label.borderRadius, e2.label.style.background, 1, e2.label.borderWidth, e2.label.borderColor, 0);
        return e2.id && d2.node.classList.add(e2.id), d2;
      } }, { key: "annotationsBackground", value: function() {
        var t3 = this, e2 = this.w, i2 = function(i3, a2, s2) {
          var r2 = e2.globals.dom.baseEl.querySelector(".apexcharts-".concat(s2, "-annotations .apexcharts-").concat(s2, "-annotation-label[rel='").concat(a2, "']"));
          if (r2) {
            var o2 = r2.parentNode, n2 = t3.addBackgroundToAnno(r2, i3);
            n2 && (o2.insertBefore(n2.node, r2), i3.label.mouseEnter && n2.node.addEventListener("mouseenter", i3.label.mouseEnter.bind(t3, i3)), i3.label.mouseLeave && n2.node.addEventListener("mouseleave", i3.label.mouseLeave.bind(t3, i3)), i3.label.click && n2.node.addEventListener("click", i3.label.click.bind(t3, i3)));
          }
        };
        e2.config.annotations.xaxis.map(function(t4, e3) {
          i2(t4, e3, "xaxis");
        }), e2.config.annotations.yaxis.map(function(t4, e3) {
          i2(t4, e3, "yaxis");
        }), e2.config.annotations.points.map(function(t4, e3) {
          i2(t4, e3, "point");
        });
      } }, { key: "getY1Y2", value: function(t3, e2) {
        var i2, a2 = "y1" === t3 ? e2.y : e2.y2, s2 = this.w;
        if (this.annoCtx.invertAxis) {
          var r2 = s2.globals.labels.indexOf(a2);
          s2.config.xaxis.convertedCatToNumeric && (r2 = s2.globals.categoryLabels.indexOf(a2));
          var o2 = s2.globals.dom.baseEl.querySelector(".apexcharts-yaxis-texts-g text:nth-child(" + (r2 + 1) + ")");
          o2 && (i2 = parseFloat(o2.getAttribute("y")));
        } else {
          var n2;
          if (s2.config.yaxis[e2.yAxisIndex].logarithmic)
            n2 = (a2 = new y(this.annoCtx.ctx).getLogVal(a2, e2.yAxisIndex)) / s2.globals.yLogRatio[e2.yAxisIndex];
          else
            n2 = (a2 - s2.globals.minYArr[e2.yAxisIndex]) / (s2.globals.yRange[e2.yAxisIndex] / s2.globals.gridHeight);
          i2 = s2.globals.gridHeight - n2, !e2.marker || void 0 !== e2.y && null !== e2.y || (i2 = 0), s2.config.yaxis[e2.yAxisIndex] && s2.config.yaxis[e2.yAxisIndex].reversed && (i2 = n2);
        }
        return "string" == typeof a2 && a2.indexOf("px") > -1 && (i2 = parseFloat(a2)), i2;
      } }, { key: "getX1X2", value: function(t3, e2) {
        var i2 = this.w, a2 = this.annoCtx.invertAxis ? i2.globals.minY : i2.globals.minX, s2 = this.annoCtx.invertAxis ? i2.globals.maxY : i2.globals.maxX, r2 = this.annoCtx.invertAxis ? i2.globals.yRange[0] : i2.globals.xRange, o2 = (e2.x - a2) / (r2 / i2.globals.gridWidth);
        this.annoCtx.inversedReversedAxis && (o2 = (s2 - e2.x) / (r2 / i2.globals.gridWidth)), "category" !== i2.config.xaxis.type && !i2.config.xaxis.convertedCatToNumeric || this.annoCtx.invertAxis || i2.globals.dataFormatXNumeric || (o2 = this.getStringX(e2.x));
        var n2 = (e2.x2 - a2) / (r2 / i2.globals.gridWidth);
        return this.annoCtx.inversedReversedAxis && (n2 = (s2 - e2.x2) / (r2 / i2.globals.gridWidth)), "category" !== i2.config.xaxis.type && !i2.config.xaxis.convertedCatToNumeric || this.annoCtx.invertAxis || i2.globals.dataFormatXNumeric || (n2 = this.getStringX(e2.x2)), void 0 !== e2.x && null !== e2.x || !e2.marker || (o2 = i2.globals.gridWidth), "x1" === t3 && "string" == typeof e2.x && e2.x.indexOf("px") > -1 && (o2 = parseFloat(e2.x)), "x2" === t3 && "string" == typeof e2.x2 && e2.x2.indexOf("px") > -1 && (n2 = parseFloat(e2.x2)), "x1" === t3 ? o2 : n2;
      } }, { key: "getStringX", value: function(t3) {
        var e2 = this.w, i2 = t3;
        e2.config.xaxis.convertedCatToNumeric && e2.globals.categoryLabels.length && (t3 = e2.globals.categoryLabels.indexOf(t3) + 1);
        var a2 = e2.globals.labels.indexOf(t3), s2 = e2.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g text:nth-child(" + (a2 + 1) + ")");
        return s2 && (i2 = parseFloat(s2.getAttribute("x"))), i2;
      } }]), t2;
    }();
    var k = function() {
      function t2(e2) {
        a(this, t2), this.w = e2.w, this.annoCtx = e2, this.invertAxis = this.annoCtx.invertAxis, this.helpers = new w(this.annoCtx);
      }
      return r(t2, [{ key: "addXaxisAnnotation", value: function(t3, e2, i2) {
        var a2, s2 = this.w, r2 = this.helpers.getX1X2("x1", t3), o2 = t3.label.text, n2 = t3.strokeDashArray;
        if (x.isNumber(r2)) {
          if (null === t3.x2 || void 0 === t3.x2) {
            var l2 = this.annoCtx.graphics.drawLine(r2 + t3.offsetX, 0 + t3.offsetY, r2 + t3.offsetX, s2.globals.gridHeight + t3.offsetY, t3.borderColor, n2, t3.borderWidth);
            e2.appendChild(l2.node), t3.id && l2.node.classList.add(t3.id);
          } else {
            if ((a2 = this.helpers.getX1X2("x2", t3)) < r2) {
              var h2 = r2;
              r2 = a2, a2 = h2;
            }
            var c2 = this.annoCtx.graphics.drawRect(r2 + t3.offsetX, 0 + t3.offsetY, a2 - r2, s2.globals.gridHeight + t3.offsetY, 0, t3.fillColor, t3.opacity, 1, t3.borderColor, n2);
            c2.node.classList.add("apexcharts-annotation-rect"), c2.attr("clip-path", "url(#gridRectMask".concat(s2.globals.cuid, ")")), e2.appendChild(c2.node), t3.id && c2.node.classList.add(t3.id);
          }
          var d2 = this.annoCtx.graphics.getTextRects(o2, parseFloat(t3.label.style.fontSize)), g2 = "top" === t3.label.position ? 4 : "center" === t3.label.position ? s2.globals.gridHeight / 2 + ("vertical" === t3.label.orientation ? d2.width / 2 : 0) : s2.globals.gridHeight, u2 = this.annoCtx.graphics.drawText({ x: r2 + t3.label.offsetX, y: g2 + t3.label.offsetY - ("vertical" === t3.label.orientation ? "top" === t3.label.position ? d2.width / 2 - 12 : -d2.width / 2 : 0), text: o2, textAnchor: t3.label.textAnchor, fontSize: t3.label.style.fontSize, fontFamily: t3.label.style.fontFamily, fontWeight: t3.label.style.fontWeight, foreColor: t3.label.style.color, cssClass: "apexcharts-xaxis-annotation-label ".concat(t3.label.style.cssClass, " ").concat(t3.id ? t3.id : "") });
          u2.attr({ rel: i2 }), e2.appendChild(u2.node), this.annoCtx.helpers.setOrientations(t3, i2);
        }
      } }, { key: "drawXAxisAnnotations", value: function() {
        var t3 = this, e2 = this.w, i2 = this.annoCtx.graphics.group({ class: "apexcharts-xaxis-annotations" });
        return e2.config.annotations.xaxis.map(function(e3, a2) {
          t3.addXaxisAnnotation(e3, i2.node, a2);
        }), i2;
      } }]), t2;
    }();
    var A = function() {
      function t2(e2) {
        a(this, t2), this.w = e2.w, this.annoCtx = e2, this.helpers = new w(this.annoCtx);
      }
      return r(t2, [{ key: "addYaxisAnnotation", value: function(t3, e2, i2) {
        var a2, s2 = this.w, r2 = t3.strokeDashArray, o2 = this.helpers.getY1Y2("y1", t3), n2 = t3.label.text;
        if (null === t3.y2 || void 0 === t3.y2) {
          var l2 = this.annoCtx.graphics.drawLine(0 + t3.offsetX, o2 + t3.offsetY, this._getYAxisAnnotationWidth(t3), o2 + t3.offsetY, t3.borderColor, r2, t3.borderWidth);
          e2.appendChild(l2.node), t3.id && l2.node.classList.add(t3.id);
        } else {
          if ((a2 = this.helpers.getY1Y2("y2", t3)) > o2) {
            var h2 = o2;
            o2 = a2, a2 = h2;
          }
          var c2 = this.annoCtx.graphics.drawRect(0 + t3.offsetX, a2 + t3.offsetY, this._getYAxisAnnotationWidth(t3), o2 - a2, 0, t3.fillColor, t3.opacity, 1, t3.borderColor, r2);
          c2.node.classList.add("apexcharts-annotation-rect"), c2.attr("clip-path", "url(#gridRectMask".concat(s2.globals.cuid, ")")), e2.appendChild(c2.node), t3.id && c2.node.classList.add(t3.id);
        }
        var d2 = "right" === t3.label.position ? s2.globals.gridWidth : "center" === t3.label.position ? s2.globals.gridWidth / 2 : 0, g2 = this.annoCtx.graphics.drawText({ x: d2 + t3.label.offsetX, y: (null != a2 ? a2 : o2) + t3.label.offsetY - 3, text: n2, textAnchor: t3.label.textAnchor, fontSize: t3.label.style.fontSize, fontFamily: t3.label.style.fontFamily, fontWeight: t3.label.style.fontWeight, foreColor: t3.label.style.color, cssClass: "apexcharts-yaxis-annotation-label ".concat(t3.label.style.cssClass, " ").concat(t3.id ? t3.id : "") });
        g2.attr({ rel: i2 }), e2.appendChild(g2.node);
      } }, { key: "_getYAxisAnnotationWidth", value: function(t3) {
        var e2 = this.w;
        e2.globals.gridWidth;
        return (t3.width.indexOf("%") > -1 ? e2.globals.gridWidth * parseInt(t3.width, 10) / 100 : parseInt(t3.width, 10)) + t3.offsetX;
      } }, { key: "drawYAxisAnnotations", value: function() {
        var t3 = this, e2 = this.w, i2 = this.annoCtx.graphics.group({ class: "apexcharts-yaxis-annotations" });
        return e2.config.annotations.yaxis.map(function(e3, a2) {
          t3.addYaxisAnnotation(e3, i2.node, a2);
        }), i2;
      } }]), t2;
    }();
    var S = function() {
      function t2(e2) {
        a(this, t2), this.w = e2.w, this.annoCtx = e2, this.helpers = new w(this.annoCtx);
      }
      return r(t2, [{ key: "addPointAnnotation", value: function(t3, e2, i2) {
        this.w;
        var a2 = this.helpers.getX1X2("x1", t3), s2 = this.helpers.getY1Y2("y1", t3);
        if (x.isNumber(a2)) {
          var r2 = { pSize: t3.marker.size, pointStrokeWidth: t3.marker.strokeWidth, pointFillColor: t3.marker.fillColor, pointStrokeColor: t3.marker.strokeColor, shape: t3.marker.shape, pRadius: t3.marker.radius, class: "apexcharts-point-annotation-marker ".concat(t3.marker.cssClass, " ").concat(t3.id ? t3.id : "") }, o2 = this.annoCtx.graphics.drawMarker(a2 + t3.marker.offsetX, s2 + t3.marker.offsetY, r2);
          e2.appendChild(o2.node);
          var n2 = t3.label.text ? t3.label.text : "", l2 = this.annoCtx.graphics.drawText({ x: a2 + t3.label.offsetX, y: s2 + t3.label.offsetY - t3.marker.size - parseFloat(t3.label.style.fontSize) / 1.6, text: n2, textAnchor: t3.label.textAnchor, fontSize: t3.label.style.fontSize, fontFamily: t3.label.style.fontFamily, fontWeight: t3.label.style.fontWeight, foreColor: t3.label.style.color, cssClass: "apexcharts-point-annotation-label ".concat(t3.label.style.cssClass, " ").concat(t3.id ? t3.id : "") });
          if (l2.attr({ rel: i2 }), e2.appendChild(l2.node), t3.customSVG.SVG) {
            var h2 = this.annoCtx.graphics.group({ class: "apexcharts-point-annotations-custom-svg " + t3.customSVG.cssClass });
            h2.attr({ transform: "translate(".concat(a2 + t3.customSVG.offsetX, ", ").concat(s2 + t3.customSVG.offsetY, ")") }), h2.node.innerHTML = t3.customSVG.SVG, e2.appendChild(h2.node);
          }
          if (t3.image.path) {
            var c2 = t3.image.width ? t3.image.width : 20, d2 = t3.image.height ? t3.image.height : 20;
            o2 = this.annoCtx.addImage({ x: a2 + t3.image.offsetX - c2 / 2, y: s2 + t3.image.offsetY - d2 / 2, width: c2, height: d2, path: t3.image.path, appendTo: ".apexcharts-point-annotations" });
          }
          t3.mouseEnter && o2.node.addEventListener("mouseenter", t3.mouseEnter.bind(this, t3)), t3.mouseLeave && o2.node.addEventListener("mouseleave", t3.mouseLeave.bind(this, t3)), t3.click && o2.node.addEventListener("click", t3.click.bind(this, t3));
        }
      } }, { key: "drawPointAnnotations", value: function() {
        var t3 = this, e2 = this.w, i2 = this.annoCtx.graphics.group({ class: "apexcharts-point-annotations" });
        return e2.config.annotations.points.map(function(e3, a2) {
          t3.addPointAnnotation(e3, i2.node, a2);
        }), i2;
      } }]), t2;
    }();
    var C = { name: "en", options: { months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], toolbar: { exportToSVG: "Download SVG", exportToPNG: "Download PNG", exportToCSV: "Download CSV", menu: "Menu", selection: "Selection", selectionZoom: "Selection Zoom", zoomIn: "Zoom In", zoomOut: "Zoom Out", pan: "Panning", reset: "Reset Zoom" } } };
    var L = function() {
      function t2() {
        a(this, t2), this.yAxis = { show: true, showAlways: false, showForNullSeries: true, seriesName: void 0, opposite: false, reversed: false, logarithmic: false, logBase: 10, tickAmount: void 0, forceNiceScale: false, max: void 0, min: void 0, floating: false, decimalsInFloat: void 0, labels: { show: true, minWidth: 0, maxWidth: 160, offsetX: 0, offsetY: 0, align: void 0, rotate: 0, padding: 20, style: { colors: [], fontSize: "11px", fontWeight: 400, fontFamily: void 0, cssClass: "" }, formatter: void 0 }, axisBorder: { show: false, color: "#e0e0e0", width: 1, offsetX: 0, offsetY: 0 }, axisTicks: { show: false, color: "#e0e0e0", width: 6, offsetX: 0, offsetY: 0 }, title: { text: void 0, rotate: -90, offsetY: 0, offsetX: 0, style: { color: void 0, fontSize: "11px", fontWeight: 900, fontFamily: void 0, cssClass: "" } }, tooltip: { enabled: false, offsetX: 0 }, crosshairs: { show: true, position: "front", stroke: { color: "#b6b6b6", width: 1, dashArray: 0 } } }, this.pointAnnotation = { id: void 0, x: 0, y: null, yAxisIndex: 0, seriesIndex: 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, marker: { size: 4, fillColor: "#fff", strokeWidth: 2, strokeColor: "#333", shape: "circle", offsetX: 0, offsetY: 0, radius: 2, cssClass: "" }, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "middle", offsetX: 0, offsetY: 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } }, customSVG: { SVG: void 0, cssClass: void 0, offsetX: 0, offsetY: 0 }, image: { path: void 0, width: 20, height: 20, offsetX: 0, offsetY: 0 } }, this.yAxisAnnotation = { id: void 0, y: 0, y2: null, strokeDashArray: 1, fillColor: "#c2c2c2", borderColor: "#c2c2c2", borderWidth: 1, opacity: 0.3, offsetX: 0, offsetY: 0, width: "100%", yAxisIndex: 0, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "end", position: "right", offsetX: 0, offsetY: -3, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } } }, this.xAxisAnnotation = { id: void 0, x: 0, x2: null, strokeDashArray: 1, fillColor: "#c2c2c2", borderColor: "#c2c2c2", borderWidth: 1, opacity: 0.3, offsetX: 0, offsetY: 0, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "middle", orientation: "vertical", position: "top", offsetX: 0, offsetY: 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } } }, this.text = { x: 0, y: 0, text: "", textAnchor: "start", foreColor: void 0, fontSize: "13px", fontFamily: void 0, fontWeight: 400, appendTo: ".apexcharts-annotations", backgroundColor: "transparent", borderColor: "#c2c2c2", borderRadius: 0, borderWidth: 0, paddingLeft: 4, paddingRight: 4, paddingTop: 2, paddingBottom: 2 };
      }
      return r(t2, [{ key: "init", value: function() {
        return { annotations: { yaxis: [this.yAxisAnnotation], xaxis: [this.xAxisAnnotation], points: [this.pointAnnotation], texts: [], images: [], shapes: [] }, chart: { animations: { enabled: true, easing: "easeinout", speed: 800, animateGradually: { delay: 150, enabled: true }, dynamicAnimation: { enabled: true, speed: 350 } }, background: "transparent", locales: [C], defaultLocale: "en", dropShadow: { enabled: false, enabledOnSeries: void 0, top: 2, left: 2, blur: 4, color: "#000", opacity: 0.35 }, events: { animationEnd: void 0, beforeMount: void 0, mounted: void 0, updated: void 0, click: void 0, mouseMove: void 0, mouseLeave: void 0, xAxisLabelClick: void 0, legendClick: void 0, markerClick: void 0, selection: void 0, dataPointSelection: void 0, dataPointMouseEnter: void 0, dataPointMouseLeave: void 0, beforeZoom: void 0, beforeResetZoom: void 0, zoomed: void 0, scrolled: void 0, brushScrolled: void 0 }, foreColor: "#373d3f", fontFamily: "Helvetica, Arial, sans-serif", height: "auto", parentHeightOffset: 15, redrawOnParentResize: true, redrawOnWindowResize: true, id: void 0, group: void 0, offsetX: 0, offsetY: 0, selection: { enabled: false, type: "x", fill: { color: "#24292e", opacity: 0.1 }, stroke: { width: 1, color: "#24292e", opacity: 0.4, dashArray: 3 }, xaxis: { min: void 0, max: void 0 }, yaxis: { min: void 0, max: void 0 } }, sparkline: { enabled: false }, brush: { enabled: false, autoScaleYaxis: true, target: void 0, targets: void 0 }, stacked: false, stackType: "normal", toolbar: { show: true, offsetX: 0, offsetY: 0, tools: { download: true, selection: true, zoom: true, zoomin: true, zoomout: true, pan: true, reset: true, customIcons: [] }, export: { csv: { filename: void 0, columnDelimiter: ",", headerCategory: "category", headerValue: "value", dateFormatter: function(t3) {
          return new Date(t3).toDateString();
        } }, png: { filename: void 0 }, svg: { filename: void 0 } }, autoSelected: "zoom" }, type: "line", width: "100%", zoom: { enabled: true, type: "x", autoScaleYaxis: false, zoomedArea: { fill: { color: "#90CAF9", opacity: 0.4 }, stroke: { color: "#0D47A1", opacity: 0.4, width: 1 } } } }, plotOptions: { area: { fillTo: "origin" }, bar: { horizontal: false, columnWidth: "70%", barHeight: "70%", distributed: false, borderRadius: 0, borderRadiusApplication: "around", borderRadiusWhenStacked: "last", rangeBarOverlap: true, rangeBarGroupRows: false, hideZeroBarsWhenGrouped: false, isDumbbell: false, dumbbellColors: void 0, isFunnel: false, isFunnel3d: true, colors: { ranges: [], backgroundBarColors: [], backgroundBarOpacity: 1, backgroundBarRadius: 0 }, dataLabels: { position: "top", maxItems: 100, hideOverflowingLabels: true, orientation: "horizontal", total: { enabled: false, formatter: void 0, offsetX: 0, offsetY: 0, style: { color: "#373d3f", fontSize: "12px", fontFamily: void 0, fontWeight: 600 } } } }, bubble: { zScaling: true, minBubbleRadius: void 0, maxBubbleRadius: void 0 }, candlestick: { colors: { upward: "#00B746", downward: "#EF403C" }, wick: { useFillColor: true } }, boxPlot: { colors: { upper: "#00E396", lower: "#008FFB" } }, heatmap: { radius: 2, enableShades: true, shadeIntensity: 0.5, reverseNegativeShade: false, distributed: false, useFillColorAsStroke: false, colorScale: { inverse: false, ranges: [], min: void 0, max: void 0 } }, treemap: { enableShades: true, shadeIntensity: 0.5, distributed: false, reverseNegativeShade: false, useFillColorAsStroke: false, dataLabels: { format: "scale" }, colorScale: { inverse: false, ranges: [], min: void 0, max: void 0 } }, radialBar: { inverseOrder: false, startAngle: 0, endAngle: 360, offsetX: 0, offsetY: 0, hollow: { margin: 5, size: "50%", background: "transparent", image: void 0, imageWidth: 150, imageHeight: 150, imageOffsetX: 0, imageOffsetY: 0, imageClipped: true, position: "front", dropShadow: { enabled: false, top: 0, left: 0, blur: 3, color: "#000", opacity: 0.5 } }, track: { show: true, startAngle: void 0, endAngle: void 0, background: "#f2f2f2", strokeWidth: "97%", opacity: 1, margin: 5, dropShadow: { enabled: false, top: 0, left: 0, blur: 3, color: "#000", opacity: 0.5 } }, dataLabels: { show: true, name: { show: true, fontSize: "16px", fontFamily: void 0, fontWeight: 600, color: void 0, offsetY: 0, formatter: function(t3) {
          return t3;
        } }, value: { show: true, fontSize: "14px", fontFamily: void 0, fontWeight: 400, color: void 0, offsetY: 16, formatter: function(t3) {
          return t3 + "%";
        } }, total: { show: false, label: "Total", fontSize: "16px", fontWeight: 600, fontFamily: void 0, color: void 0, formatter: function(t3) {
          return t3.globals.seriesTotals.reduce(function(t4, e2) {
            return t4 + e2;
          }, 0) / t3.globals.series.length + "%";
        } } } }, pie: { customScale: 1, offsetX: 0, offsetY: 0, startAngle: 0, endAngle: 360, expandOnClick: true, dataLabels: { offset: 0, minAngleToShowLabel: 10 }, donut: { size: "65%", background: "transparent", labels: { show: false, name: { show: true, fontSize: "16px", fontFamily: void 0, fontWeight: 600, color: void 0, offsetY: -10, formatter: function(t3) {
          return t3;
        } }, value: { show: true, fontSize: "20px", fontFamily: void 0, fontWeight: 400, color: void 0, offsetY: 10, formatter: function(t3) {
          return t3;
        } }, total: { show: false, showAlways: false, label: "Total", fontSize: "16px", fontWeight: 400, fontFamily: void 0, color: void 0, formatter: function(t3) {
          return t3.globals.seriesTotals.reduce(function(t4, e2) {
            return t4 + e2;
          }, 0);
        } } } } }, polarArea: { rings: { strokeWidth: 1, strokeColor: "#e8e8e8" }, spokes: { strokeWidth: 1, connectorColors: "#e8e8e8" } }, radar: { size: void 0, offsetX: 0, offsetY: 0, polygons: { strokeWidth: 1, strokeColors: "#e8e8e8", connectorColors: "#e8e8e8", fill: { colors: void 0 } } } }, colors: void 0, dataLabels: { enabled: true, enabledOnSeries: void 0, formatter: function(t3) {
          return null !== t3 ? t3 : "";
        }, textAnchor: "middle", distributed: false, offsetX: 0, offsetY: 0, style: { fontSize: "12px", fontFamily: void 0, fontWeight: 600, colors: void 0 }, background: { enabled: true, foreColor: "#fff", borderRadius: 2, padding: 4, opacity: 0.9, borderWidth: 1, borderColor: "#fff", dropShadow: { enabled: false, top: 1, left: 1, blur: 1, color: "#000", opacity: 0.45 } }, dropShadow: { enabled: false, top: 1, left: 1, blur: 1, color: "#000", opacity: 0.45 } }, fill: { type: "solid", colors: void 0, opacity: 0.85, gradient: { shade: "dark", type: "horizontal", shadeIntensity: 0.5, gradientToColors: void 0, inverseColors: true, opacityFrom: 1, opacityTo: 1, stops: [0, 50, 100], colorStops: [] }, image: { src: [], width: void 0, height: void 0 }, pattern: { style: "squares", width: 6, height: 6, strokeWidth: 2 } }, forecastDataPoints: { count: 0, fillOpacity: 0.5, strokeWidth: void 0, dashArray: 4 }, grid: { show: true, borderColor: "#e0e0e0", strokeDashArray: 0, position: "back", xaxis: { lines: { show: false } }, yaxis: { lines: { show: true } }, row: { colors: void 0, opacity: 0.5 }, column: { colors: void 0, opacity: 0.5 }, padding: { top: 0, right: 10, bottom: 0, left: 12 } }, labels: [], legend: { show: true, showForSingleSeries: false, showForNullSeries: true, showForZeroSeries: true, floating: false, position: "bottom", horizontalAlign: "center", inverseOrder: false, fontSize: "12px", fontFamily: void 0, fontWeight: 400, width: void 0, height: void 0, formatter: void 0, tooltipHoverFormatter: void 0, offsetX: -20, offsetY: 4, customLegendItems: [], labels: { colors: void 0, useSeriesColors: false }, markers: { width: 12, height: 12, strokeWidth: 0, fillColors: void 0, strokeColor: "#fff", radius: 12, customHTML: void 0, offsetX: 0, offsetY: 0, onClick: void 0 }, itemMargin: { horizontal: 5, vertical: 2 }, onItemClick: { toggleDataSeries: true }, onItemHover: { highlightDataSeries: true } }, markers: { discrete: [], size: 0, colors: void 0, strokeColors: "#fff", strokeWidth: 2, strokeOpacity: 0.9, strokeDashArray: 0, fillOpacity: 1, shape: "circle", width: 8, height: 8, radius: 2, offsetX: 0, offsetY: 0, onClick: void 0, onDblClick: void 0, showNullDataPoints: true, hover: { size: void 0, sizeOffset: 3 } }, noData: { text: void 0, align: "center", verticalAlign: "middle", offsetX: 0, offsetY: 0, style: { color: void 0, fontSize: "14px", fontFamily: void 0 } }, responsive: [], series: void 0, states: { normal: { filter: { type: "none", value: 0 } }, hover: { filter: { type: "lighten", value: 0.1 } }, active: { allowMultipleDataPointsSelection: false, filter: { type: "darken", value: 0.5 } } }, title: { text: void 0, align: "left", margin: 5, offsetX: 0, offsetY: 0, floating: false, style: { fontSize: "14px", fontWeight: 900, fontFamily: void 0, color: void 0 } }, subtitle: { text: void 0, align: "left", margin: 5, offsetX: 0, offsetY: 30, floating: false, style: { fontSize: "12px", fontWeight: 400, fontFamily: void 0, color: void 0 } }, stroke: { show: true, curve: "smooth", lineCap: "butt", width: 2, colors: void 0, dashArray: 0, fill: { type: "solid", colors: void 0, opacity: 0.85, gradient: { shade: "dark", type: "horizontal", shadeIntensity: 0.5, gradientToColors: void 0, inverseColors: true, opacityFrom: 1, opacityTo: 1, stops: [0, 50, 100], colorStops: [] } } }, tooltip: { enabled: true, enabledOnSeries: void 0, shared: true, followCursor: false, intersect: false, inverseOrder: false, custom: void 0, fillSeriesColor: false, theme: "light", cssClass: "", style: { fontSize: "12px", fontFamily: void 0 }, onDatasetHover: { highlightDataSeries: false }, x: { show: true, format: "dd MMM", formatter: void 0 }, y: { formatter: void 0, title: { formatter: function(t3) {
          return t3 ? t3 + ": " : "";
        } } }, z: { formatter: void 0, title: "Size: " }, marker: { show: true, fillColors: void 0 }, items: { display: "flex" }, fixed: { enabled: false, position: "topRight", offsetX: 0, offsetY: 0 } }, xaxis: { type: "category", categories: [], convertedCatToNumeric: false, offsetX: 0, offsetY: 0, overwriteCategories: void 0, labels: { show: true, rotate: -45, rotateAlways: false, hideOverlappingLabels: true, trim: false, minHeight: void 0, maxHeight: 120, showDuplicates: true, style: { colors: [], fontSize: "12px", fontWeight: 400, fontFamily: void 0, cssClass: "" }, offsetX: 0, offsetY: 0, format: void 0, formatter: void 0, datetimeUTC: true, datetimeFormatter: { year: "yyyy", month: "MMM 'yy", day: "dd MMM", hour: "HH:mm", minute: "HH:mm:ss", second: "HH:mm:ss" } }, group: { groups: [], style: { colors: [], fontSize: "12px", fontWeight: 400, fontFamily: void 0, cssClass: "" } }, axisBorder: { show: true, color: "#e0e0e0", width: "100%", height: 1, offsetX: 0, offsetY: 0 }, axisTicks: { show: true, color: "#e0e0e0", height: 6, offsetX: 0, offsetY: 0 }, tickAmount: void 0, tickPlacement: "on", min: void 0, max: void 0, range: void 0, floating: false, decimalsInFloat: void 0, position: "bottom", title: { text: void 0, offsetX: 0, offsetY: 0, style: { color: void 0, fontSize: "12px", fontWeight: 900, fontFamily: void 0, cssClass: "" } }, crosshairs: { show: true, width: 1, position: "back", opacity: 0.9, stroke: { color: "#b6b6b6", width: 1, dashArray: 3 }, fill: { type: "solid", color: "#B1B9C4", gradient: { colorFrom: "#D8E3F0", colorTo: "#BED1E6", stops: [0, 100], opacityFrom: 0.4, opacityTo: 0.5 } }, dropShadow: { enabled: false, left: 0, top: 0, blur: 1, opacity: 0.4 } }, tooltip: { enabled: true, offsetY: 0, formatter: void 0, style: { fontSize: "12px", fontFamily: void 0 } } }, yaxis: this.yAxis, theme: { mode: "light", palette: "palette1", monochrome: { enabled: false, color: "#008FFB", shadeTo: "light", shadeIntensity: 0.65 } } };
      } }]), t2;
    }();
    var P = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w, this.graphics = new m(this.ctx), this.w.globals.isBarHorizontal && (this.invertAxis = true), this.helpers = new w(this), this.xAxisAnnotations = new k(this), this.yAxisAnnotations = new A(this), this.pointsAnnotations = new S(this), this.w.globals.isBarHorizontal && this.w.config.yaxis[0].reversed && (this.inversedReversedAxis = true), this.xDivision = this.w.globals.gridWidth / this.w.globals.dataPoints;
      }
      return r(t2, [{ key: "drawAxesAnnotations", value: function() {
        var t3 = this.w;
        if (t3.globals.axisCharts) {
          for (var e2 = this.yAxisAnnotations.drawYAxisAnnotations(), i2 = this.xAxisAnnotations.drawXAxisAnnotations(), a2 = this.pointsAnnotations.drawPointAnnotations(), s2 = t3.config.chart.animations.enabled, r2 = [e2, i2, a2], o2 = [i2.node, e2.node, a2.node], n2 = 0; n2 < 3; n2++)
            t3.globals.dom.elGraphical.add(r2[n2]), !s2 || t3.globals.resized || t3.globals.dataChanged || "scatter" !== t3.config.chart.type && "bubble" !== t3.config.chart.type && t3.globals.dataPoints > 1 && o2[n2].classList.add("apexcharts-element-hidden"), t3.globals.delayedElements.push({ el: o2[n2], index: 0 });
          this.helpers.annotationsBackground();
        }
      } }, { key: "drawImageAnnos", value: function() {
        var t3 = this;
        this.w.config.annotations.images.map(function(e2, i2) {
          t3.addImage(e2, i2);
        });
      } }, { key: "drawTextAnnos", value: function() {
        var t3 = this;
        this.w.config.annotations.texts.map(function(e2, i2) {
          t3.addText(e2, i2);
        });
      } }, { key: "addXaxisAnnotation", value: function(t3, e2, i2) {
        this.xAxisAnnotations.addXaxisAnnotation(t3, e2, i2);
      } }, { key: "addYaxisAnnotation", value: function(t3, e2, i2) {
        this.yAxisAnnotations.addYaxisAnnotation(t3, e2, i2);
      } }, { key: "addPointAnnotation", value: function(t3, e2, i2) {
        this.pointsAnnotations.addPointAnnotation(t3, e2, i2);
      } }, { key: "addText", value: function(t3, e2) {
        var i2 = t3.x, a2 = t3.y, s2 = t3.text, r2 = t3.textAnchor, o2 = t3.foreColor, n2 = t3.fontSize, l2 = t3.fontFamily, h2 = t3.fontWeight, c2 = t3.cssClass, d2 = t3.backgroundColor, g2 = t3.borderWidth, u2 = t3.strokeDashArray, p2 = t3.borderRadius, f2 = t3.borderColor, x2 = t3.appendTo, b2 = void 0 === x2 ? ".apexcharts-annotations" : x2, v2 = t3.paddingLeft, m2 = void 0 === v2 ? 4 : v2, y2 = t3.paddingRight, w2 = void 0 === y2 ? 4 : y2, k2 = t3.paddingBottom, A2 = void 0 === k2 ? 2 : k2, S2 = t3.paddingTop, C2 = void 0 === S2 ? 2 : S2, L2 = this.w, P2 = this.graphics.drawText({ x: i2, y: a2, text: s2, textAnchor: r2 || "start", fontSize: n2 || "12px", fontWeight: h2 || "regular", fontFamily: l2 || L2.config.chart.fontFamily, foreColor: o2 || L2.config.chart.foreColor, cssClass: c2 }), I2 = L2.globals.dom.baseEl.querySelector(b2);
        I2 && I2.appendChild(P2.node);
        var T2 = P2.bbox();
        if (s2) {
          var M2 = this.graphics.drawRect(T2.x - m2, T2.y - C2, T2.width + m2 + w2, T2.height + A2 + C2, p2, d2 || "transparent", 1, g2, f2, u2);
          I2.insertBefore(M2.node, P2.node);
        }
      } }, { key: "addImage", value: function(t3, e2) {
        var i2 = this.w, a2 = t3.path, s2 = t3.x, r2 = void 0 === s2 ? 0 : s2, o2 = t3.y, n2 = void 0 === o2 ? 0 : o2, l2 = t3.width, h2 = void 0 === l2 ? 20 : l2, c2 = t3.height, d2 = void 0 === c2 ? 20 : c2, g2 = t3.appendTo, u2 = void 0 === g2 ? ".apexcharts-annotations" : g2, p2 = i2.globals.dom.Paper.image(a2);
        p2.size(h2, d2).move(r2, n2);
        var f2 = i2.globals.dom.baseEl.querySelector(u2);
        return f2 && f2.appendChild(p2.node), p2;
      } }, { key: "addXaxisAnnotationExternal", value: function(t3, e2, i2) {
        return this.addAnnotationExternal({ params: t3, pushToMemory: e2, context: i2, type: "xaxis", contextMethod: i2.addXaxisAnnotation }), i2;
      } }, { key: "addYaxisAnnotationExternal", value: function(t3, e2, i2) {
        return this.addAnnotationExternal({ params: t3, pushToMemory: e2, context: i2, type: "yaxis", contextMethod: i2.addYaxisAnnotation }), i2;
      } }, { key: "addPointAnnotationExternal", value: function(t3, e2, i2) {
        return void 0 === this.invertAxis && (this.invertAxis = i2.w.globals.isBarHorizontal), this.addAnnotationExternal({ params: t3, pushToMemory: e2, context: i2, type: "point", contextMethod: i2.addPointAnnotation }), i2;
      } }, { key: "addAnnotationExternal", value: function(t3) {
        var e2 = t3.params, i2 = t3.pushToMemory, a2 = t3.context, s2 = t3.type, r2 = t3.contextMethod, o2 = a2, n2 = o2.w, l2 = n2.globals.dom.baseEl.querySelector(".apexcharts-".concat(s2, "-annotations")), h2 = l2.childNodes.length + 1, c2 = new L(), d2 = Object.assign({}, "xaxis" === s2 ? c2.xAxisAnnotation : "yaxis" === s2 ? c2.yAxisAnnotation : c2.pointAnnotation), g2 = x.extend(d2, e2);
        switch (s2) {
          case "xaxis":
            this.addXaxisAnnotation(g2, l2, h2);
            break;
          case "yaxis":
            this.addYaxisAnnotation(g2, l2, h2);
            break;
          case "point":
            this.addPointAnnotation(g2, l2, h2);
        }
        var u2 = n2.globals.dom.baseEl.querySelector(".apexcharts-".concat(s2, "-annotations .apexcharts-").concat(s2, "-annotation-label[rel='").concat(h2, "']")), p2 = this.helpers.addBackgroundToAnno(u2, g2);
        return p2 && l2.insertBefore(p2.node, u2), i2 && n2.globals.memory.methodsToExec.push({ context: o2, id: g2.id ? g2.id : x.randomId(), method: r2, label: "addAnnotation", params: e2 }), a2;
      } }, { key: "clearAnnotations", value: function(t3) {
        var e2 = t3.w, i2 = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations");
        e2.globals.memory.methodsToExec.map(function(t4, i3) {
          "addText" !== t4.label && "addAnnotation" !== t4.label || e2.globals.memory.methodsToExec.splice(i3, 1);
        }), i2 = x.listToArray(i2), Array.prototype.forEach.call(i2, function(t4) {
          for (; t4.firstChild; )
            t4.removeChild(t4.firstChild);
        });
      } }, { key: "removeAnnotation", value: function(t3, e2) {
        var i2 = t3.w, a2 = i2.globals.dom.baseEl.querySelectorAll(".".concat(e2));
        a2 && (i2.globals.memory.methodsToExec.map(function(t4, a3) {
          t4.id === e2 && i2.globals.memory.methodsToExec.splice(a3, 1);
        }), Array.prototype.forEach.call(a2, function(t4) {
          t4.parentElement.removeChild(t4);
        }));
      } }]), t2;
    }();
    var I = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w, this.months31 = [1, 3, 5, 7, 8, 10, 12], this.months30 = [2, 4, 6, 9, 11], this.daysCntOfYear = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
      }
      return r(t2, [{ key: "isValidDate", value: function(t3) {
        return !isNaN(this.parseDate(t3));
      } }, { key: "getTimeStamp", value: function(t3) {
        return Date.parse(t3) ? this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t3).toISOString().substr(0, 25)).getTime() : new Date(t3).getTime() : t3;
      } }, { key: "getDate", value: function(t3) {
        return this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t3).toUTCString()) : new Date(t3);
      } }, { key: "parseDate", value: function(t3) {
        var e2 = Date.parse(t3);
        if (!isNaN(e2))
          return this.getTimeStamp(t3);
        var i2 = Date.parse(t3.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
        return i2 = this.getTimeStamp(i2);
      } }, { key: "parseDateWithTimezone", value: function(t3) {
        return Date.parse(t3.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
      } }, { key: "formatDate", value: function(t3, e2) {
        var i2 = this.w.globals.locale, a2 = this.w.config.xaxis.labels.datetimeUTC, s2 = ["\0"].concat(u(i2.months)), r2 = [""].concat(u(i2.shortMonths)), o2 = [""].concat(u(i2.days)), n2 = [""].concat(u(i2.shortDays));
        function l2(t4, e3) {
          var i3 = t4 + "";
          for (e3 = e3 || 2; i3.length < e3; )
            i3 = "0" + i3;
          return i3;
        }
        var h2 = a2 ? t3.getUTCFullYear() : t3.getFullYear();
        e2 = (e2 = (e2 = e2.replace(/(^|[^\\])yyyy+/g, "$1" + h2)).replace(/(^|[^\\])yy/g, "$1" + h2.toString().substr(2, 2))).replace(/(^|[^\\])y/g, "$1" + h2);
        var c2 = (a2 ? t3.getUTCMonth() : t3.getMonth()) + 1;
        e2 = (e2 = (e2 = (e2 = e2.replace(/(^|[^\\])MMMM+/g, "$1" + s2[0])).replace(/(^|[^\\])MMM/g, "$1" + r2[0])).replace(/(^|[^\\])MM/g, "$1" + l2(c2))).replace(/(^|[^\\])M/g, "$1" + c2);
        var d2 = a2 ? t3.getUTCDate() : t3.getDate();
        e2 = (e2 = (e2 = (e2 = e2.replace(/(^|[^\\])dddd+/g, "$1" + o2[0])).replace(/(^|[^\\])ddd/g, "$1" + n2[0])).replace(/(^|[^\\])dd/g, "$1" + l2(d2))).replace(/(^|[^\\])d/g, "$1" + d2);
        var g2 = a2 ? t3.getUTCHours() : t3.getHours(), p2 = g2 > 12 ? g2 - 12 : 0 === g2 ? 12 : g2;
        e2 = (e2 = (e2 = (e2 = e2.replace(/(^|[^\\])HH+/g, "$1" + l2(g2))).replace(/(^|[^\\])H/g, "$1" + g2)).replace(/(^|[^\\])hh+/g, "$1" + l2(p2))).replace(/(^|[^\\])h/g, "$1" + p2);
        var f2 = a2 ? t3.getUTCMinutes() : t3.getMinutes();
        e2 = (e2 = e2.replace(/(^|[^\\])mm+/g, "$1" + l2(f2))).replace(/(^|[^\\])m/g, "$1" + f2);
        var x2 = a2 ? t3.getUTCSeconds() : t3.getSeconds();
        e2 = (e2 = e2.replace(/(^|[^\\])ss+/g, "$1" + l2(x2))).replace(/(^|[^\\])s/g, "$1" + x2);
        var b2 = a2 ? t3.getUTCMilliseconds() : t3.getMilliseconds();
        e2 = e2.replace(/(^|[^\\])fff+/g, "$1" + l2(b2, 3)), b2 = Math.round(b2 / 10), e2 = e2.replace(/(^|[^\\])ff/g, "$1" + l2(b2)), b2 = Math.round(b2 / 10);
        var v2 = g2 < 12 ? "AM" : "PM";
        e2 = (e2 = (e2 = e2.replace(/(^|[^\\])f/g, "$1" + b2)).replace(/(^|[^\\])TT+/g, "$1" + v2)).replace(/(^|[^\\])T/g, "$1" + v2.charAt(0));
        var m2 = v2.toLowerCase();
        e2 = (e2 = e2.replace(/(^|[^\\])tt+/g, "$1" + m2)).replace(/(^|[^\\])t/g, "$1" + m2.charAt(0));
        var y2 = -t3.getTimezoneOffset(), w2 = a2 || !y2 ? "Z" : y2 > 0 ? "+" : "-";
        if (!a2) {
          var k2 = (y2 = Math.abs(y2)) % 60;
          w2 += l2(Math.floor(y2 / 60)) + ":" + l2(k2);
        }
        e2 = e2.replace(/(^|[^\\])K/g, "$1" + w2);
        var A2 = (a2 ? t3.getUTCDay() : t3.getDay()) + 1;
        return e2 = (e2 = (e2 = (e2 = (e2 = e2.replace(new RegExp(o2[0], "g"), o2[A2])).replace(new RegExp(n2[0], "g"), n2[A2])).replace(new RegExp(s2[0], "g"), s2[c2])).replace(new RegExp(r2[0], "g"), r2[c2])).replace(/\\(.)/g, "$1");
      } }, { key: "getTimeUnitsfromTimestamp", value: function(t3, e2, i2) {
        var a2 = this.w;
        void 0 !== a2.config.xaxis.min && (t3 = a2.config.xaxis.min), void 0 !== a2.config.xaxis.max && (e2 = a2.config.xaxis.max);
        var s2 = this.getDate(t3), r2 = this.getDate(e2), o2 = this.formatDate(s2, "yyyy MM dd HH mm ss fff").split(" "), n2 = this.formatDate(r2, "yyyy MM dd HH mm ss fff").split(" ");
        return { minMillisecond: parseInt(o2[6], 10), maxMillisecond: parseInt(n2[6], 10), minSecond: parseInt(o2[5], 10), maxSecond: parseInt(n2[5], 10), minMinute: parseInt(o2[4], 10), maxMinute: parseInt(n2[4], 10), minHour: parseInt(o2[3], 10), maxHour: parseInt(n2[3], 10), minDate: parseInt(o2[2], 10), maxDate: parseInt(n2[2], 10), minMonth: parseInt(o2[1], 10) - 1, maxMonth: parseInt(n2[1], 10) - 1, minYear: parseInt(o2[0], 10), maxYear: parseInt(n2[0], 10) };
      } }, { key: "isLeapYear", value: function(t3) {
        return t3 % 4 == 0 && t3 % 100 != 0 || t3 % 400 == 0;
      } }, { key: "calculcateLastDaysOfMonth", value: function(t3, e2, i2) {
        return this.determineDaysOfMonths(t3, e2) - i2;
      } }, { key: "determineDaysOfYear", value: function(t3) {
        var e2 = 365;
        return this.isLeapYear(t3) && (e2 = 366), e2;
      } }, { key: "determineRemainingDaysOfYear", value: function(t3, e2, i2) {
        var a2 = this.daysCntOfYear[e2] + i2;
        return e2 > 1 && this.isLeapYear() && a2++, a2;
      } }, { key: "determineDaysOfMonths", value: function(t3, e2) {
        var i2 = 30;
        switch (t3 = x.monthMod(t3), true) {
          case this.months30.indexOf(t3) > -1:
            2 === t3 && (i2 = this.isLeapYear(e2) ? 29 : 28);
            break;
          case this.months31.indexOf(t3) > -1:
          default:
            i2 = 31;
        }
        return i2;
      } }]), t2;
    }();
    var T = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w, this.tooltipKeyFormat = "dd MMM";
      }
      return r(t2, [{ key: "xLabelFormat", value: function(t3, e2, i2, a2) {
        var s2 = this.w;
        if ("datetime" === s2.config.xaxis.type && void 0 === s2.config.xaxis.labels.formatter && void 0 === s2.config.tooltip.x.formatter) {
          var r2 = new I(this.ctx);
          return r2.formatDate(r2.getDate(e2), s2.config.tooltip.x.format);
        }
        return t3(e2, i2, a2);
      } }, { key: "defaultGeneralFormatter", value: function(t3) {
        return Array.isArray(t3) ? t3.map(function(t4) {
          return t4;
        }) : t3;
      } }, { key: "defaultYFormatter", value: function(t3, e2, i2) {
        var a2 = this.w;
        return x.isNumber(t3) && (t3 = 0 !== a2.globals.yValueDecimal ? t3.toFixed(void 0 !== e2.decimalsInFloat ? e2.decimalsInFloat : a2.globals.yValueDecimal) : a2.globals.maxYArr[i2] - a2.globals.minYArr[i2] < 5 ? t3.toFixed(1) : t3.toFixed(0)), t3;
      } }, { key: "setLabelFormatters", value: function() {
        var t3 = this, e2 = this.w;
        return e2.globals.xaxisTooltipFormatter = function(e3) {
          return t3.defaultGeneralFormatter(e3);
        }, e2.globals.ttKeyFormatter = function(e3) {
          return t3.defaultGeneralFormatter(e3);
        }, e2.globals.ttZFormatter = function(t4) {
          return t4;
        }, e2.globals.legendFormatter = function(e3) {
          return t3.defaultGeneralFormatter(e3);
        }, void 0 !== e2.config.xaxis.labels.formatter ? e2.globals.xLabelFormatter = e2.config.xaxis.labels.formatter : e2.globals.xLabelFormatter = function(t4) {
          if (x.isNumber(t4)) {
            if (!e2.config.xaxis.convertedCatToNumeric && "numeric" === e2.config.xaxis.type) {
              if (x.isNumber(e2.config.xaxis.decimalsInFloat))
                return t4.toFixed(e2.config.xaxis.decimalsInFloat);
              var i2 = e2.globals.maxX - e2.globals.minX;
              return i2 > 0 && i2 < 100 ? t4.toFixed(1) : t4.toFixed(0);
            }
            if (e2.globals.isBarHorizontal) {
              if (e2.globals.maxY - e2.globals.minYArr < 4)
                return t4.toFixed(1);
            }
            return t4.toFixed(0);
          }
          return t4;
        }, "function" == typeof e2.config.tooltip.x.formatter ? e2.globals.ttKeyFormatter = e2.config.tooltip.x.formatter : e2.globals.ttKeyFormatter = e2.globals.xLabelFormatter, "function" == typeof e2.config.xaxis.tooltip.formatter && (e2.globals.xaxisTooltipFormatter = e2.config.xaxis.tooltip.formatter), (Array.isArray(e2.config.tooltip.y) || void 0 !== e2.config.tooltip.y.formatter) && (e2.globals.ttVal = e2.config.tooltip.y), void 0 !== e2.config.tooltip.z.formatter && (e2.globals.ttZFormatter = e2.config.tooltip.z.formatter), void 0 !== e2.config.legend.formatter && (e2.globals.legendFormatter = e2.config.legend.formatter), e2.config.yaxis.forEach(function(i2, a2) {
          void 0 !== i2.labels.formatter ? e2.globals.yLabelFormatters[a2] = i2.labels.formatter : e2.globals.yLabelFormatters[a2] = function(s2) {
            return e2.globals.xyCharts ? Array.isArray(s2) ? s2.map(function(e3) {
              return t3.defaultYFormatter(e3, i2, a2);
            }) : t3.defaultYFormatter(s2, i2, a2) : s2;
          };
        }), e2.globals;
      } }, { key: "heatmapLabelFormatters", value: function() {
        var t3 = this.w;
        if ("heatmap" === t3.config.chart.type) {
          t3.globals.yAxisScale[0].result = t3.globals.seriesNames.slice();
          var e2 = t3.globals.seriesNames.reduce(function(t4, e3) {
            return t4.length > e3.length ? t4 : e3;
          }, 0);
          t3.globals.yAxisScale[0].niceMax = e2, t3.globals.yAxisScale[0].niceMin = e2;
        }
      } }]), t2;
    }();
    var M = function(t2) {
      var e2, i2 = t2.isTimeline, a2 = t2.ctx, s2 = t2.seriesIndex, r2 = t2.dataPointIndex, o2 = t2.y1, n2 = t2.y2, l2 = t2.w, h2 = l2.globals.seriesRangeStart[s2][r2], c2 = l2.globals.seriesRangeEnd[s2][r2], d2 = l2.globals.labels[r2], g2 = l2.config.series[s2].name ? l2.config.series[s2].name : "", u2 = l2.globals.ttKeyFormatter, p2 = l2.config.tooltip.y.title.formatter, f2 = { w: l2, seriesIndex: s2, dataPointIndex: r2, start: h2, end: c2 };
      ("function" == typeof p2 && (g2 = p2(g2, f2)), null !== (e2 = l2.config.series[s2].data[r2]) && void 0 !== e2 && e2.x && (d2 = l2.config.series[s2].data[r2].x), i2) || "datetime" === l2.config.xaxis.type && (d2 = new T(a2).xLabelFormat(l2.globals.ttKeyFormatter, d2, d2, { i: void 0, dateFormatter: new I(a2).formatDate, w: l2 }));
      "function" == typeof u2 && (d2 = u2(d2, f2)), Number.isFinite(o2) && Number.isFinite(n2) && (h2 = o2, c2 = n2);
      var x2 = "", b2 = "", v2 = l2.globals.colors[s2];
      if (void 0 === l2.config.tooltip.x.formatter)
        if ("datetime" === l2.config.xaxis.type) {
          var m2 = new I(a2);
          x2 = m2.formatDate(m2.getDate(h2), l2.config.tooltip.x.format), b2 = m2.formatDate(m2.getDate(c2), l2.config.tooltip.x.format);
        } else
          x2 = h2, b2 = c2;
      else
        x2 = l2.config.tooltip.x.formatter(h2), b2 = l2.config.tooltip.x.formatter(c2);
      return { start: h2, end: c2, startVal: x2, endVal: b2, ylabel: d2, color: v2, seriesName: g2 };
    };
    var z = function(t2) {
      var e2 = t2.color, i2 = t2.seriesName, a2 = t2.ylabel, s2 = t2.start, r2 = t2.end, o2 = t2.seriesIndex, n2 = t2.dataPointIndex, l2 = t2.ctx.tooltip.tooltipLabels.getFormatters(o2);
      s2 = l2.yLbFormatter(s2), r2 = l2.yLbFormatter(r2);
      var h2 = l2.yLbFormatter(t2.w.globals.series[o2][n2]), c2 = '<span class="value start-value">\n  '.concat(s2, '\n  </span> <span class="separator">-</span> <span class="value end-value">\n  ').concat(r2, "\n  </span>");
      return '<div class="apexcharts-tooltip-rangebar"><div> <span class="series-name" style="color: ' + e2 + '">' + (i2 || "") + '</span></div><div> <span class="category">' + a2 + ": </span> " + (t2.w.globals.comboCharts ? "rangeArea" === t2.w.config.series[o2].type || "rangeBar" === t2.w.config.series[o2].type ? c2 : "<span>".concat(h2, "</span>") : c2) + " </div></div>";
    };
    var X = function() {
      function t2(e2) {
        a(this, t2), this.opts = e2;
      }
      return r(t2, [{ key: "hideYAxis", value: function() {
        this.opts.yaxis[0].show = false, this.opts.yaxis[0].title.text = "", this.opts.yaxis[0].axisBorder.show = false, this.opts.yaxis[0].axisTicks.show = false, this.opts.yaxis[0].floating = true;
      } }, { key: "line", value: function() {
        return { chart: { animations: { easing: "swing" } }, dataLabels: { enabled: false }, stroke: { width: 5, curve: "straight" }, markers: { size: 0, hover: { sizeOffset: 6 } }, xaxis: { crosshairs: { width: 1 } } };
      } }, { key: "sparkline", value: function(t3) {
        this.hideYAxis();
        return x.extend(t3, { grid: { show: false, padding: { left: 0, right: 0, top: 0, bottom: 0 } }, legend: { show: false }, xaxis: { labels: { show: false }, tooltip: { enabled: false }, axisBorder: { show: false }, axisTicks: { show: false } }, chart: { toolbar: { show: false }, zoom: { enabled: false } }, dataLabels: { enabled: false } });
      } }, { key: "bar", value: function() {
        return { chart: { stacked: false, animations: { easing: "swing" } }, plotOptions: { bar: { dataLabels: { position: "center" } } }, dataLabels: { style: { colors: ["#fff"] }, background: { enabled: false } }, stroke: { width: 0, lineCap: "round" }, fill: { opacity: 0.85 }, legend: { markers: { shape: "square", radius: 2, size: 8 } }, tooltip: { shared: false, intersect: true }, xaxis: { tooltip: { enabled: false }, tickPlacement: "between", crosshairs: { width: "barWidth", position: "back", fill: { type: "gradient" }, dropShadow: { enabled: false }, stroke: { width: 0 } } } };
      } }, { key: "funnel", value: function() {
        return this.hideYAxis(), e(e({}, this.bar()), {}, { chart: { animations: { easing: "linear", speed: 800, animateGradually: { enabled: false } } }, plotOptions: { bar: { horizontal: true, borderRadiusApplication: "around", borderRadius: 0, dataLabels: { position: "center" } } }, grid: { show: false, padding: { left: 0, right: 0 } }, xaxis: { labels: { show: false }, tooltip: { enabled: false }, axisBorder: { show: false }, axisTicks: { show: false } } });
      } }, { key: "candlestick", value: function() {
        var t3 = this;
        return { stroke: { width: 1, colors: ["#333"] }, fill: { opacity: 1 }, dataLabels: { enabled: false }, tooltip: { shared: true, custom: function(e2) {
          var i2 = e2.seriesIndex, a2 = e2.dataPointIndex, s2 = e2.w;
          return t3._getBoxTooltip(s2, i2, a2, ["Open", "High", "", "Low", "Close"], "candlestick");
        } }, states: { active: { filter: { type: "none" } } }, xaxis: { crosshairs: { width: 1 } } };
      } }, { key: "boxPlot", value: function() {
        var t3 = this;
        return { chart: { animations: { dynamicAnimation: { enabled: false } } }, stroke: { width: 1, colors: ["#24292e"] }, dataLabels: { enabled: false }, tooltip: { shared: true, custom: function(e2) {
          var i2 = e2.seriesIndex, a2 = e2.dataPointIndex, s2 = e2.w;
          return t3._getBoxTooltip(s2, i2, a2, ["Minimum", "Q1", "Median", "Q3", "Maximum"], "boxPlot");
        } }, markers: { size: 5, strokeWidth: 1, strokeColors: "#111" }, xaxis: { crosshairs: { width: 1 } } };
      } }, { key: "rangeBar", value: function() {
        return { chart: { animations: { animateGradually: false } }, stroke: { width: 0, lineCap: "square" }, plotOptions: { bar: { borderRadius: 0, dataLabels: { position: "center" } } }, dataLabels: { enabled: false, formatter: function(t3, e2) {
          e2.ctx;
          var i2 = e2.seriesIndex, a2 = e2.dataPointIndex, s2 = e2.w, r2 = function() {
            var t4 = s2.globals.seriesRangeStart[i2][a2];
            return s2.globals.seriesRangeEnd[i2][a2] - t4;
          };
          return s2.globals.comboCharts ? "rangeBar" === s2.config.series[i2].type || "rangeArea" === s2.config.series[i2].type ? r2() : t3 : r2();
        }, background: { enabled: false }, style: { colors: ["#fff"] } }, markers: { size: 10 }, tooltip: { shared: false, followCursor: true, custom: function(t3) {
          return t3.w.config.plotOptions && t3.w.config.plotOptions.bar && t3.w.config.plotOptions.bar.horizontal ? function(t4) {
            var i2 = M(e(e({}, t4), {}, { isTimeline: true })), a2 = i2.color, s2 = i2.seriesName, r2 = i2.ylabel, o2 = i2.startVal, n2 = i2.endVal;
            return z(e(e({}, t4), {}, { color: a2, seriesName: s2, ylabel: r2, start: o2, end: n2 }));
          }(t3) : function(t4) {
            var i2 = M(t4), a2 = i2.color, s2 = i2.seriesName, r2 = i2.ylabel, o2 = i2.start, n2 = i2.end;
            return z(e(e({}, t4), {}, { color: a2, seriesName: s2, ylabel: r2, start: o2, end: n2 }));
          }(t3);
        } }, xaxis: { tickPlacement: "between", tooltip: { enabled: false }, crosshairs: { stroke: { width: 0 } } } };
      } }, { key: "dumbbell", value: function(t3) {
        var e2, i2;
        return null !== (e2 = t3.plotOptions.bar) && void 0 !== e2 && e2.barHeight || (t3.plotOptions.bar.barHeight = 2), null !== (i2 = t3.plotOptions.bar) && void 0 !== i2 && i2.columnWidth || (t3.plotOptions.bar.columnWidth = 2), t3;
      } }, { key: "area", value: function() {
        return { stroke: { width: 4, fill: { type: "solid", gradient: { inverseColors: false, shade: "light", type: "vertical", opacityFrom: 0.65, opacityTo: 0.5, stops: [0, 100, 100] } } }, fill: { type: "gradient", gradient: { inverseColors: false, shade: "light", type: "vertical", opacityFrom: 0.65, opacityTo: 0.5, stops: [0, 100, 100] } }, markers: { size: 0, hover: { sizeOffset: 6 } }, tooltip: { followCursor: false } };
      } }, { key: "rangeArea", value: function() {
        return { stroke: { curve: "straight", width: 0 }, fill: { type: "solid", opacity: 0.6 }, markers: { size: 0 }, states: { hover: { filter: { type: "none" } }, active: { filter: { type: "none" } } }, tooltip: { intersect: false, shared: true, followCursor: true, custom: function(t3) {
          return function(t4) {
            var i2 = M(t4), a2 = i2.color, s2 = i2.seriesName, r2 = i2.ylabel, o2 = i2.start, n2 = i2.end;
            return z(e(e({}, t4), {}, { color: a2, seriesName: s2, ylabel: r2, start: o2, end: n2 }));
          }(t3);
        } } };
      } }, { key: "brush", value: function(t3) {
        return x.extend(t3, { chart: { toolbar: { autoSelected: "selection", show: false }, zoom: { enabled: false } }, dataLabels: { enabled: false }, stroke: { width: 1 }, tooltip: { enabled: false }, xaxis: { tooltip: { enabled: false } } });
      } }, { key: "stacked100", value: function(t3) {
        t3.dataLabels = t3.dataLabels || {}, t3.dataLabels.formatter = t3.dataLabels.formatter || void 0;
        var e2 = t3.dataLabels.formatter;
        return t3.yaxis.forEach(function(e3, i2) {
          t3.yaxis[i2].min = 0, t3.yaxis[i2].max = 100;
        }), "bar" === t3.chart.type && (t3.dataLabels.formatter = e2 || function(t4) {
          return "number" == typeof t4 && t4 ? t4.toFixed(0) + "%" : t4;
        }), t3;
      } }, { key: "stackedBars", value: function() {
        var t3 = this.bar();
        return e(e({}, t3), {}, { plotOptions: e(e({}, t3.plotOptions), {}, { bar: e(e({}, t3.plotOptions.bar), {}, { borderRadiusApplication: "end", borderRadiusWhenStacked: "last" }) }) });
      } }, { key: "convertCatToNumeric", value: function(t3) {
        return t3.xaxis.convertedCatToNumeric = true, t3;
      } }, { key: "convertCatToNumericXaxis", value: function(t3, e2, i2) {
        t3.xaxis.type = "numeric", t3.xaxis.labels = t3.xaxis.labels || {}, t3.xaxis.labels.formatter = t3.xaxis.labels.formatter || function(t4) {
          return x.isNumber(t4) ? Math.floor(t4) : t4;
        };
        var a2 = t3.xaxis.labels.formatter, s2 = t3.xaxis.categories && t3.xaxis.categories.length ? t3.xaxis.categories : t3.labels;
        return i2 && i2.length && (s2 = i2.map(function(t4) {
          return Array.isArray(t4) ? t4 : String(t4);
        })), s2 && s2.length && (t3.xaxis.labels.formatter = function(t4) {
          return x.isNumber(t4) ? a2(s2[Math.floor(t4) - 1]) : a2(t4);
        }), t3.xaxis.categories = [], t3.labels = [], t3.xaxis.tickAmount = t3.xaxis.tickAmount || "dataPoints", t3;
      } }, { key: "bubble", value: function() {
        return { dataLabels: { style: { colors: ["#fff"] } }, tooltip: { shared: false, intersect: true }, xaxis: { crosshairs: { width: 0 } }, fill: { type: "solid", gradient: { shade: "light", inverse: true, shadeIntensity: 0.55, opacityFrom: 0.4, opacityTo: 0.8 } } };
      } }, { key: "scatter", value: function() {
        return { dataLabels: { enabled: false }, tooltip: { shared: false, intersect: true }, markers: { size: 6, strokeWidth: 1, hover: { sizeOffset: 2 } } };
      } }, { key: "heatmap", value: function() {
        return { chart: { stacked: false }, fill: { opacity: 1 }, dataLabels: { style: { colors: ["#fff"] } }, stroke: { colors: ["#fff"] }, tooltip: { followCursor: true, marker: { show: false }, x: { show: false } }, legend: { position: "top", markers: { shape: "square", size: 10, offsetY: 2 } }, grid: { padding: { right: 20 } } };
      } }, { key: "treemap", value: function() {
        return { chart: { zoom: { enabled: false } }, dataLabels: { style: { fontSize: 14, fontWeight: 600, colors: ["#fff"] } }, stroke: { show: true, width: 2, colors: ["#fff"] }, legend: { show: false }, fill: { gradient: { stops: [0, 100] } }, tooltip: { followCursor: true, x: { show: false } }, grid: { padding: { left: 0, right: 0 } }, xaxis: { crosshairs: { show: false }, tooltip: { enabled: false } } };
      } }, { key: "pie", value: function() {
        return { chart: { toolbar: { show: false } }, plotOptions: { pie: { donut: { labels: { show: false } } } }, dataLabels: { formatter: function(t3) {
          return t3.toFixed(1) + "%";
        }, style: { colors: ["#fff"] }, background: { enabled: false }, dropShadow: { enabled: true } }, stroke: { colors: ["#fff"] }, fill: { opacity: 1, gradient: { shade: "light", stops: [0, 100] } }, tooltip: { theme: "dark", fillSeriesColor: true }, legend: { position: "right" } };
      } }, { key: "donut", value: function() {
        return { chart: { toolbar: { show: false } }, dataLabels: { formatter: function(t3) {
          return t3.toFixed(1) + "%";
        }, style: { colors: ["#fff"] }, background: { enabled: false }, dropShadow: { enabled: true } }, stroke: { colors: ["#fff"] }, fill: { opacity: 1, gradient: { shade: "light", shadeIntensity: 0.35, stops: [80, 100], opacityFrom: 1, opacityTo: 1 } }, tooltip: { theme: "dark", fillSeriesColor: true }, legend: { position: "right" } };
      } }, { key: "polarArea", value: function() {
        return this.opts.yaxis[0].tickAmount = this.opts.yaxis[0].tickAmount ? this.opts.yaxis[0].tickAmount : 6, { chart: { toolbar: { show: false } }, dataLabels: { formatter: function(t3) {
          return t3.toFixed(1) + "%";
        }, enabled: false }, stroke: { show: true, width: 2 }, fill: { opacity: 0.7 }, tooltip: { theme: "dark", fillSeriesColor: true }, legend: { position: "right" } };
      } }, { key: "radar", value: function() {
        return this.opts.yaxis[0].labels.offsetY = this.opts.yaxis[0].labels.offsetY ? this.opts.yaxis[0].labels.offsetY : 6, { dataLabels: { enabled: false, style: { fontSize: "11px" } }, stroke: { width: 2 }, markers: { size: 3, strokeWidth: 1, strokeOpacity: 1 }, fill: { opacity: 0.2 }, tooltip: { shared: false, intersect: true, followCursor: true }, grid: { show: false }, xaxis: { labels: { formatter: function(t3) {
          return t3;
        }, style: { colors: ["#a8a8a8"], fontSize: "11px" } }, tooltip: { enabled: false }, crosshairs: { show: false } } };
      } }, { key: "radialBar", value: function() {
        return { chart: { animations: { dynamicAnimation: { enabled: true, speed: 800 } }, toolbar: { show: false } }, fill: { gradient: { shade: "dark", shadeIntensity: 0.4, inverseColors: false, type: "diagonal2", opacityFrom: 1, opacityTo: 1, stops: [70, 98, 100] } }, legend: { show: false, position: "right" }, tooltip: { enabled: false, fillSeriesColor: true } };
      } }, { key: "_getBoxTooltip", value: function(t3, e2, i2, a2, s2) {
        var r2 = t3.globals.seriesCandleO[e2][i2], o2 = t3.globals.seriesCandleH[e2][i2], n2 = t3.globals.seriesCandleM[e2][i2], l2 = t3.globals.seriesCandleL[e2][i2], h2 = t3.globals.seriesCandleC[e2][i2];
        return t3.config.series[e2].type && t3.config.series[e2].type !== s2 ? '<div class="apexcharts-custom-tooltip">\n          '.concat(t3.config.series[e2].name ? t3.config.series[e2].name : "series-" + (e2 + 1), ": <strong>").concat(t3.globals.series[e2][i2], "</strong>\n        </div>") : '<div class="apexcharts-tooltip-box apexcharts-tooltip-'.concat(t3.config.chart.type, '">') + "<div>".concat(a2[0], ': <span class="value">') + r2 + "</span></div>" + "<div>".concat(a2[1], ': <span class="value">') + o2 + "</span></div>" + (n2 ? "<div>".concat(a2[2], ': <span class="value">') + n2 + "</span></div>" : "") + "<div>".concat(a2[3], ': <span class="value">') + l2 + "</span></div>" + "<div>".concat(a2[4], ': <span class="value">') + h2 + "</span></div></div>";
      } }]), t2;
    }();
    var E = function() {
      function t2(e2) {
        a(this, t2), this.opts = e2;
      }
      return r(t2, [{ key: "init", value: function(t3) {
        var e2 = t3.responsiveOverride, a2 = this.opts, s2 = new L(), r2 = new X(a2);
        this.chartType = a2.chart.type, a2 = this.extendYAxis(a2), a2 = this.extendAnnotations(a2);
        var o2 = s2.init(), n2 = {};
        if (a2 && "object" === i(a2)) {
          var l2, h2, c2, d2, g2, u2, p2, f2, b2, v2, m2 = {};
          m2 = -1 !== ["line", "area", "bar", "candlestick", "boxPlot", "rangeBar", "rangeArea", "bubble", "scatter", "heatmap", "treemap", "pie", "polarArea", "donut", "radar", "radialBar"].indexOf(a2.chart.type) ? r2[a2.chart.type]() : r2.line(), null !== (l2 = a2.plotOptions) && void 0 !== l2 && null !== (h2 = l2.bar) && void 0 !== h2 && h2.isFunnel && (m2 = r2.funnel()), a2.chart.stacked && "bar" === a2.chart.type && (m2 = r2.stackedBars()), null !== (c2 = a2.chart.brush) && void 0 !== c2 && c2.enabled && (m2 = r2.brush(m2)), a2.chart.stacked && "100%" === a2.chart.stackType && (a2 = r2.stacked100(a2)), null !== (d2 = a2.plotOptions) && void 0 !== d2 && null !== (g2 = d2.bar) && void 0 !== g2 && g2.isDumbbell && (a2 = r2.dumbbell(a2)), "monotoneCubic" === (null === (u2 = a2) || void 0 === u2 || null === (p2 = u2.stroke) || void 0 === p2 ? void 0 : p2.curve) && (a2.stroke.curve = "smooth"), this.checkForDarkTheme(window.Apex), this.checkForDarkTheme(a2), a2.xaxis = a2.xaxis || window.Apex.xaxis || {}, e2 || (a2.xaxis.convertedCatToNumeric = false), (null !== (f2 = (a2 = this.checkForCatToNumericXAxis(this.chartType, m2, a2)).chart.sparkline) && void 0 !== f2 && f2.enabled || null !== (b2 = window.Apex.chart) && void 0 !== b2 && null !== (v2 = b2.sparkline) && void 0 !== v2 && v2.enabled) && (m2 = r2.sparkline(m2)), n2 = x.extend(o2, m2);
        }
        var y2 = x.extend(n2, window.Apex);
        return o2 = x.extend(y2, a2), o2 = this.handleUserInputErrors(o2);
      } }, { key: "checkForCatToNumericXAxis", value: function(t3, e2, i2) {
        var a2, s2, r2 = new X(i2), o2 = ("bar" === t3 || "boxPlot" === t3) && (null === (a2 = i2.plotOptions) || void 0 === a2 || null === (s2 = a2.bar) || void 0 === s2 ? void 0 : s2.horizontal), n2 = "pie" === t3 || "polarArea" === t3 || "donut" === t3 || "radar" === t3 || "radialBar" === t3 || "heatmap" === t3, l2 = "datetime" !== i2.xaxis.type && "numeric" !== i2.xaxis.type, h2 = i2.xaxis.tickPlacement ? i2.xaxis.tickPlacement : e2.xaxis && e2.xaxis.tickPlacement;
        return o2 || n2 || !l2 || "between" === h2 || (i2 = r2.convertCatToNumeric(i2)), i2;
      } }, { key: "extendYAxis", value: function(t3, e2) {
        var i2 = new L();
        (void 0 === t3.yaxis || !t3.yaxis || Array.isArray(t3.yaxis) && 0 === t3.yaxis.length) && (t3.yaxis = {}), t3.yaxis.constructor !== Array && window.Apex.yaxis && window.Apex.yaxis.constructor !== Array && (t3.yaxis = x.extend(t3.yaxis, window.Apex.yaxis)), t3.yaxis.constructor !== Array ? t3.yaxis = [x.extend(i2.yAxis, t3.yaxis)] : t3.yaxis = x.extendArray(t3.yaxis, i2.yAxis);
        var a2 = false;
        t3.yaxis.forEach(function(t4) {
          t4.logarithmic && (a2 = true);
        });
        var s2 = t3.series;
        return e2 && !s2 && (s2 = e2.config.series), a2 && s2.length !== t3.yaxis.length && s2.length && (t3.yaxis = s2.map(function(e3, a3) {
          if (e3.name || (s2[a3].name = "series-".concat(a3 + 1)), t3.yaxis[a3])
            return t3.yaxis[a3].seriesName = s2[a3].name, t3.yaxis[a3];
          var r2 = x.extend(i2.yAxis, t3.yaxis[0]);
          return r2.show = false, r2;
        })), a2 && s2.length > 1 && s2.length !== t3.yaxis.length && console.warn("A multi-series logarithmic chart should have equal number of series and y-axes"), t3;
      } }, { key: "extendAnnotations", value: function(t3) {
        return void 0 === t3.annotations && (t3.annotations = {}, t3.annotations.yaxis = [], t3.annotations.xaxis = [], t3.annotations.points = []), t3 = this.extendYAxisAnnotations(t3), t3 = this.extendXAxisAnnotations(t3), t3 = this.extendPointAnnotations(t3);
      } }, { key: "extendYAxisAnnotations", value: function(t3) {
        var e2 = new L();
        return t3.annotations.yaxis = x.extendArray(void 0 !== t3.annotations.yaxis ? t3.annotations.yaxis : [], e2.yAxisAnnotation), t3;
      } }, { key: "extendXAxisAnnotations", value: function(t3) {
        var e2 = new L();
        return t3.annotations.xaxis = x.extendArray(void 0 !== t3.annotations.xaxis ? t3.annotations.xaxis : [], e2.xAxisAnnotation), t3;
      } }, { key: "extendPointAnnotations", value: function(t3) {
        var e2 = new L();
        return t3.annotations.points = x.extendArray(void 0 !== t3.annotations.points ? t3.annotations.points : [], e2.pointAnnotation), t3;
      } }, { key: "checkForDarkTheme", value: function(t3) {
        t3.theme && "dark" === t3.theme.mode && (t3.tooltip || (t3.tooltip = {}), "light" !== t3.tooltip.theme && (t3.tooltip.theme = "dark"), t3.chart.foreColor || (t3.chart.foreColor = "#f6f7f8"), t3.chart.background || (t3.chart.background = "#424242"), t3.theme.palette || (t3.theme.palette = "palette4"));
      } }, { key: "handleUserInputErrors", value: function(t3) {
        var e2 = t3;
        if (e2.tooltip.shared && e2.tooltip.intersect)
          throw new Error("tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false.");
        if ("bar" === e2.chart.type && e2.plotOptions.bar.horizontal) {
          if (e2.yaxis.length > 1)
            throw new Error("Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false");
          e2.yaxis[0].reversed && (e2.yaxis[0].opposite = true), e2.xaxis.tooltip.enabled = false, e2.yaxis[0].tooltip.enabled = false, e2.chart.zoom.enabled = false;
        }
        return "bar" !== e2.chart.type && "rangeBar" !== e2.chart.type || e2.tooltip.shared && "barWidth" === e2.xaxis.crosshairs.width && e2.series.length > 1 && (e2.xaxis.crosshairs.width = "tickWidth"), "candlestick" !== e2.chart.type && "boxPlot" !== e2.chart.type || e2.yaxis[0].reversed && (console.warn("Reversed y-axis in ".concat(e2.chart.type, " chart is not supported.")), e2.yaxis[0].reversed = false), e2;
      } }]), t2;
    }();
    var Y = function() {
      function t2() {
        a(this, t2);
      }
      return r(t2, [{ key: "initGlobalVars", value: function(t3) {
        t3.series = [], t3.seriesCandleO = [], t3.seriesCandleH = [], t3.seriesCandleM = [], t3.seriesCandleL = [], t3.seriesCandleC = [], t3.seriesRangeStart = [], t3.seriesRangeEnd = [], t3.seriesRange = [], t3.seriesPercent = [], t3.seriesGoals = [], t3.seriesX = [], t3.seriesZ = [], t3.seriesNames = [], t3.seriesTotals = [], t3.seriesLog = [], t3.seriesColors = [], t3.stackedSeriesTotals = [], t3.seriesXvalues = [], t3.seriesYvalues = [], t3.labels = [], t3.hasXaxisGroups = false, t3.groups = [], t3.hasSeriesGroups = false, t3.seriesGroups = [], t3.categoryLabels = [], t3.timescaleLabels = [], t3.noLabelsProvided = false, t3.resizeTimer = null, t3.selectionResizeTimer = null, t3.delayedElements = [], t3.pointsArray = [], t3.dataLabelsRects = [], t3.isXNumeric = false, t3.skipLastTimelinelabel = false, t3.skipFirstTimelinelabel = false, t3.isDataXYZ = false, t3.isMultiLineX = false, t3.isMultipleYAxis = false, t3.maxY = -Number.MAX_VALUE, t3.minY = Number.MIN_VALUE, t3.minYArr = [], t3.maxYArr = [], t3.maxX = -Number.MAX_VALUE, t3.minX = Number.MAX_VALUE, t3.initialMaxX = -Number.MAX_VALUE, t3.initialMinX = Number.MAX_VALUE, t3.maxDate = 0, t3.minDate = Number.MAX_VALUE, t3.minZ = Number.MAX_VALUE, t3.maxZ = -Number.MAX_VALUE, t3.minXDiff = Number.MAX_VALUE, t3.yAxisScale = [], t3.xAxisScale = null, t3.xAxisTicksPositions = [], t3.yLabelsCoords = [], t3.yTitleCoords = [], t3.barPadForNumericAxis = 0, t3.padHorizontal = 0, t3.xRange = 0, t3.yRange = [], t3.zRange = 0, t3.dataPoints = 0, t3.xTickAmount = 0;
      } }, { key: "globalVars", value: function(t3) {
        return { chartID: null, cuid: null, events: { beforeMount: [], mounted: [], updated: [], clicked: [], selection: [], dataPointSelection: [], zoomed: [], scrolled: [] }, colors: [], clientX: null, clientY: null, fill: { colors: [] }, stroke: { colors: [] }, dataLabels: { style: { colors: [] } }, radarPolygons: { fill: { colors: [] } }, markers: { colors: [], size: t3.markers.size, largestSize: 0 }, animationEnded: false, isTouchDevice: "ontouchstart" in window || navigator.msMaxTouchPoints, isDirty: false, isExecCalled: false, initialConfig: null, initialSeries: [], lastXAxis: [], lastYAxis: [], columnSeries: null, labels: [], timescaleLabels: [], noLabelsProvided: false, allSeriesCollapsed: false, collapsedSeries: [], collapsedSeriesIndices: [], ancillaryCollapsedSeries: [], ancillaryCollapsedSeriesIndices: [], risingSeries: [], dataFormatXNumeric: false, capturedSeriesIndex: -1, capturedDataPointIndex: -1, selectedDataPoints: [], goldenPadding: 35, invalidLogScale: false, ignoreYAxisIndexes: [], yAxisSameScaleIndices: [], maxValsInArrayIndex: 0, radialSize: 0, selection: void 0, zoomEnabled: "zoom" === t3.chart.toolbar.autoSelected && t3.chart.toolbar.tools.zoom && t3.chart.zoom.enabled, panEnabled: "pan" === t3.chart.toolbar.autoSelected && t3.chart.toolbar.tools.pan, selectionEnabled: "selection" === t3.chart.toolbar.autoSelected && t3.chart.toolbar.tools.selection, yaxis: null, mousedown: false, lastClientPosition: {}, visibleXRange: void 0, yValueDecimal: 0, total: 0, SVGNS: "http://www.w3.org/2000/svg", svgWidth: 0, svgHeight: 0, noData: false, locale: {}, dom: {}, memory: { methodsToExec: [] }, shouldAnimate: true, skipLastTimelinelabel: false, skipFirstTimelinelabel: false, delayedElements: [], axisCharts: true, isDataXYZ: false, resized: false, resizeTimer: null, comboCharts: false, dataChanged: false, previousPaths: [], allSeriesHasEqualX: true, pointsArray: [], dataLabelsRects: [], lastDrawnDataLabelsIndexes: [], hasNullValues: false, easing: null, zoomed: false, gridWidth: 0, gridHeight: 0, rotateXLabels: false, defaultLabels: false, xLabelFormatter: void 0, yLabelFormatters: [], xaxisTooltipFormatter: void 0, ttKeyFormatter: void 0, ttVal: void 0, ttZFormatter: void 0, LINE_HEIGHT_RATIO: 1.618, xAxisLabelsHeight: 0, xAxisGroupLabelsHeight: 0, xAxisLabelsWidth: 0, yAxisLabelsWidth: 0, scaleX: 1, scaleY: 1, translateX: 0, translateY: 0, translateYAxisX: [], yAxisWidths: [], translateXAxisY: 0, translateXAxisX: 0, tooltip: null };
      } }, { key: "init", value: function(t3) {
        var e2 = this.globalVars(t3);
        return this.initGlobalVars(e2), e2.initialConfig = x.extend({}, t3), e2.initialSeries = x.clone(t3.series), e2.lastXAxis = x.clone(e2.initialConfig.xaxis), e2.lastYAxis = x.clone(e2.initialConfig.yaxis), e2;
      } }]), t2;
    }();
    var F = function() {
      function t2(e2) {
        a(this, t2), this.opts = e2;
      }
      return r(t2, [{ key: "init", value: function() {
        var t3 = new E(this.opts).init({ responsiveOverride: false });
        return { config: t3, globals: new Y().init(t3) };
      } }]), t2;
    }();
    var R = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w, this.opts = null, this.seriesIndex = 0;
      }
      return r(t2, [{ key: "clippedImgArea", value: function(t3) {
        var e2 = this.w, i2 = e2.config, a2 = parseInt(e2.globals.gridWidth, 10), s2 = parseInt(e2.globals.gridHeight, 10), r2 = a2 > s2 ? a2 : s2, o2 = t3.image, n2 = 0, l2 = 0;
        void 0 === t3.width && void 0 === t3.height ? void 0 !== i2.fill.image.width && void 0 !== i2.fill.image.height ? (n2 = i2.fill.image.width + 1, l2 = i2.fill.image.height) : (n2 = r2 + 1, l2 = r2) : (n2 = t3.width, l2 = t3.height);
        var h2 = document.createElementNS(e2.globals.SVGNS, "pattern");
        m.setAttrs(h2, { id: t3.patternID, patternUnits: t3.patternUnits ? t3.patternUnits : "userSpaceOnUse", width: n2 + "px", height: l2 + "px" });
        var c2 = document.createElementNS(e2.globals.SVGNS, "image");
        h2.appendChild(c2), c2.setAttributeNS(window.SVG.xlink, "href", o2), m.setAttrs(c2, { x: 0, y: 0, preserveAspectRatio: "none", width: n2 + "px", height: l2 + "px" }), c2.style.opacity = t3.opacity, e2.globals.dom.elDefs.node.appendChild(h2);
      } }, { key: "getSeriesIndex", value: function(t3) {
        var e2 = this.w, i2 = e2.config.chart.type;
        return ("bar" === i2 || "rangeBar" === i2) && e2.config.plotOptions.bar.distributed || "heatmap" === i2 || "treemap" === i2 ? this.seriesIndex = t3.seriesNumber : this.seriesIndex = t3.seriesNumber % e2.globals.series.length, this.seriesIndex;
      } }, { key: "fillPath", value: function(t3) {
        var e2 = this.w;
        this.opts = t3;
        var i2, a2, s2, r2 = this.w.config;
        this.seriesIndex = this.getSeriesIndex(t3);
        var o2 = this.getFillColors()[this.seriesIndex];
        void 0 !== e2.globals.seriesColors[this.seriesIndex] && (o2 = e2.globals.seriesColors[this.seriesIndex]), "function" == typeof o2 && (o2 = o2({ seriesIndex: this.seriesIndex, dataPointIndex: t3.dataPointIndex, value: t3.value, w: e2 }));
        var n2 = t3.fillType ? t3.fillType : this.getFillType(this.seriesIndex), l2 = Array.isArray(r2.fill.opacity) ? r2.fill.opacity[this.seriesIndex] : r2.fill.opacity;
        t3.color && (o2 = t3.color), o2 || (o2 = "#fff", console.warn("undefined color - ApexCharts"));
        var h2 = o2;
        if (-1 === o2.indexOf("rgb") ? o2.length < 9 && (h2 = x.hexToRgba(o2, l2)) : o2.indexOf("rgba") > -1 && (l2 = x.getOpacityFromRGBA(o2)), t3.opacity && (l2 = t3.opacity), "pattern" === n2 && (a2 = this.handlePatternFill({ fillConfig: t3.fillConfig, patternFill: a2, fillColor: o2, fillOpacity: l2, defaultColor: h2 })), "gradient" === n2 && (s2 = this.handleGradientFill({ fillConfig: t3.fillConfig, fillColor: o2, fillOpacity: l2, i: this.seriesIndex })), "image" === n2) {
          var c2 = r2.fill.image.src, d2 = t3.patternID ? t3.patternID : "";
          this.clippedImgArea({ opacity: l2, image: Array.isArray(c2) ? t3.seriesNumber < c2.length ? c2[t3.seriesNumber] : c2[0] : c2, width: t3.width ? t3.width : void 0, height: t3.height ? t3.height : void 0, patternUnits: t3.patternUnits, patternID: "pattern".concat(e2.globals.cuid).concat(t3.seriesNumber + 1).concat(d2) }), i2 = "url(#pattern".concat(e2.globals.cuid).concat(t3.seriesNumber + 1).concat(d2, ")");
        } else
          i2 = "gradient" === n2 ? s2 : "pattern" === n2 ? a2 : h2;
        return t3.solid && (i2 = h2), i2;
      } }, { key: "getFillType", value: function(t3) {
        var e2 = this.w;
        return Array.isArray(e2.config.fill.type) ? e2.config.fill.type[t3] : e2.config.fill.type;
      } }, { key: "getFillColors", value: function() {
        var t3 = this.w, e2 = t3.config, i2 = this.opts, a2 = [];
        return t3.globals.comboCharts ? "line" === t3.config.series[this.seriesIndex].type ? Array.isArray(t3.globals.stroke.colors) ? a2 = t3.globals.stroke.colors : a2.push(t3.globals.stroke.colors) : Array.isArray(t3.globals.fill.colors) ? a2 = t3.globals.fill.colors : a2.push(t3.globals.fill.colors) : "line" === e2.chart.type ? Array.isArray(t3.globals.stroke.colors) ? a2 = t3.globals.stroke.colors : a2.push(t3.globals.stroke.colors) : Array.isArray(t3.globals.fill.colors) ? a2 = t3.globals.fill.colors : a2.push(t3.globals.fill.colors), void 0 !== i2.fillColors && (a2 = [], Array.isArray(i2.fillColors) ? a2 = i2.fillColors.slice() : a2.push(i2.fillColors)), a2;
      } }, { key: "handlePatternFill", value: function(t3) {
        var e2 = t3.fillConfig, i2 = t3.patternFill, a2 = t3.fillColor, s2 = t3.fillOpacity, r2 = t3.defaultColor, o2 = this.w.config.fill;
        e2 && (o2 = e2);
        var n2 = this.opts, l2 = new m(this.ctx), h2 = Array.isArray(o2.pattern.strokeWidth) ? o2.pattern.strokeWidth[this.seriesIndex] : o2.pattern.strokeWidth, c2 = a2;
        Array.isArray(o2.pattern.style) ? i2 = void 0 !== o2.pattern.style[n2.seriesNumber] ? l2.drawPattern(o2.pattern.style[n2.seriesNumber], o2.pattern.width, o2.pattern.height, c2, h2, s2) : r2 : i2 = l2.drawPattern(o2.pattern.style, o2.pattern.width, o2.pattern.height, c2, h2, s2);
        return i2;
      } }, { key: "handleGradientFill", value: function(t3) {
        var i2 = t3.fillColor, a2 = t3.fillOpacity, s2 = t3.fillConfig, r2 = t3.i, o2 = this.w.config.fill;
        s2 && (o2 = e(e({}, o2), s2));
        var n2, l2 = this.opts, h2 = new m(this.ctx), c2 = new x(), d2 = o2.gradient.type, g2 = i2, u2 = void 0 === o2.gradient.opacityFrom ? a2 : Array.isArray(o2.gradient.opacityFrom) ? o2.gradient.opacityFrom[r2] : o2.gradient.opacityFrom;
        g2.indexOf("rgba") > -1 && (u2 = x.getOpacityFromRGBA(g2));
        var p2 = void 0 === o2.gradient.opacityTo ? a2 : Array.isArray(o2.gradient.opacityTo) ? o2.gradient.opacityTo[r2] : o2.gradient.opacityTo;
        if (void 0 === o2.gradient.gradientToColors || 0 === o2.gradient.gradientToColors.length)
          n2 = "dark" === o2.gradient.shade ? c2.shadeColor(-1 * parseFloat(o2.gradient.shadeIntensity), i2.indexOf("rgb") > -1 ? x.rgb2hex(i2) : i2) : c2.shadeColor(parseFloat(o2.gradient.shadeIntensity), i2.indexOf("rgb") > -1 ? x.rgb2hex(i2) : i2);
        else if (o2.gradient.gradientToColors[l2.seriesNumber]) {
          var f2 = o2.gradient.gradientToColors[l2.seriesNumber];
          n2 = f2, f2.indexOf("rgba") > -1 && (p2 = x.getOpacityFromRGBA(f2));
        } else
          n2 = i2;
        if (o2.gradient.gradientFrom && (g2 = o2.gradient.gradientFrom), o2.gradient.gradientTo && (n2 = o2.gradient.gradientTo), o2.gradient.inverseColors) {
          var b2 = g2;
          g2 = n2, n2 = b2;
        }
        return g2.indexOf("rgb") > -1 && (g2 = x.rgb2hex(g2)), n2.indexOf("rgb") > -1 && (n2 = x.rgb2hex(n2)), h2.drawGradient(d2, g2, n2, u2, p2, l2.size, o2.gradient.stops, o2.gradient.colorStops, r2);
      } }]), t2;
    }();
    var H = function() {
      function t2(e2, i2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
      }
      return r(t2, [{ key: "setGlobalMarkerSize", value: function() {
        var t3 = this.w;
        if (t3.globals.markers.size = Array.isArray(t3.config.markers.size) ? t3.config.markers.size : [t3.config.markers.size], t3.globals.markers.size.length > 0) {
          if (t3.globals.markers.size.length < t3.globals.series.length + 1)
            for (var e2 = 0; e2 <= t3.globals.series.length; e2++)
              void 0 === t3.globals.markers.size[e2] && t3.globals.markers.size.push(t3.globals.markers.size[0]);
        } else
          t3.globals.markers.size = t3.config.series.map(function(e3) {
            return t3.config.markers.size;
          });
      } }, { key: "plotChartMarkers", value: function(t3, e2, i2, a2) {
        var s2, r2 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], o2 = this.w, n2 = e2, l2 = t3, h2 = null, c2 = new m(this.ctx), d2 = o2.config.markers.discrete && o2.config.markers.discrete.length;
        if ((o2.globals.markers.size[e2] > 0 || r2 || d2) && (h2 = c2.group({ class: r2 || d2 ? "" : "apexcharts-series-markers" })).attr("clip-path", "url(#gridRectMarkerMask".concat(o2.globals.cuid, ")")), Array.isArray(l2.x))
          for (var g2 = 0; g2 < l2.x.length; g2++) {
            var u2 = i2;
            1 === i2 && 0 === g2 && (u2 = 0), 1 === i2 && 1 === g2 && (u2 = 1);
            var p2 = "apexcharts-marker";
            if ("line" !== o2.config.chart.type && "area" !== o2.config.chart.type || o2.globals.comboCharts || o2.config.tooltip.intersect || (p2 += " no-pointer-events"), (Array.isArray(o2.config.markers.size) ? o2.globals.markers.size[e2] > 0 : o2.config.markers.size > 0) || r2 || d2) {
              x.isNumber(l2.y[g2]) ? p2 += " w".concat(x.randomId()) : p2 = "apexcharts-nullpoint";
              var f2 = this.getMarkerConfig({ cssClass: p2, seriesIndex: e2, dataPointIndex: u2 });
              o2.config.series[n2].data[u2] && (o2.config.series[n2].data[u2].fillColor && (f2.pointFillColor = o2.config.series[n2].data[u2].fillColor), o2.config.series[n2].data[u2].strokeColor && (f2.pointStrokeColor = o2.config.series[n2].data[u2].strokeColor)), a2 && (f2.pSize = a2), (l2.x[g2] < 0 || l2.x[g2] > o2.globals.gridWidth || l2.y[g2] < 0 || l2.y[g2] > o2.globals.gridHeight) && (f2.pSize = 0), (s2 = c2.drawMarker(l2.x[g2], l2.y[g2], f2)).attr("rel", u2), s2.attr("j", u2), s2.attr("index", e2), s2.node.setAttribute("default-marker-size", f2.pSize), new v(this.ctx).setSelectionFilter(s2, e2, u2), this.addEvents(s2), h2 && h2.add(s2);
            } else
              void 0 === o2.globals.pointsArray[e2] && (o2.globals.pointsArray[e2] = []), o2.globals.pointsArray[e2].push([l2.x[g2], l2.y[g2]]);
          }
        return h2;
      } }, { key: "getMarkerConfig", value: function(t3) {
        var e2 = t3.cssClass, i2 = t3.seriesIndex, a2 = t3.dataPointIndex, s2 = void 0 === a2 ? null : a2, r2 = t3.finishRadius, o2 = void 0 === r2 ? null : r2, n2 = this.w, l2 = this.getMarkerStyle(i2), h2 = n2.globals.markers.size[i2], c2 = n2.config.markers;
        return null !== s2 && c2.discrete.length && c2.discrete.map(function(t4) {
          t4.seriesIndex === i2 && t4.dataPointIndex === s2 && (l2.pointStrokeColor = t4.strokeColor, l2.pointFillColor = t4.fillColor, h2 = t4.size, l2.pointShape = t4.shape);
        }), { pSize: null === o2 ? h2 : o2, pRadius: c2.radius, width: Array.isArray(c2.width) ? c2.width[i2] : c2.width, height: Array.isArray(c2.height) ? c2.height[i2] : c2.height, pointStrokeWidth: Array.isArray(c2.strokeWidth) ? c2.strokeWidth[i2] : c2.strokeWidth, pointStrokeColor: l2.pointStrokeColor, pointFillColor: l2.pointFillColor, shape: l2.pointShape || (Array.isArray(c2.shape) ? c2.shape[i2] : c2.shape), class: e2, pointStrokeOpacity: Array.isArray(c2.strokeOpacity) ? c2.strokeOpacity[i2] : c2.strokeOpacity, pointStrokeDashArray: Array.isArray(c2.strokeDashArray) ? c2.strokeDashArray[i2] : c2.strokeDashArray, pointFillOpacity: Array.isArray(c2.fillOpacity) ? c2.fillOpacity[i2] : c2.fillOpacity, seriesIndex: i2 };
      } }, { key: "addEvents", value: function(t3) {
        var e2 = this.w, i2 = new m(this.ctx);
        t3.node.addEventListener("mouseenter", i2.pathMouseEnter.bind(this.ctx, t3)), t3.node.addEventListener("mouseleave", i2.pathMouseLeave.bind(this.ctx, t3)), t3.node.addEventListener("mousedown", i2.pathMouseDown.bind(this.ctx, t3)), t3.node.addEventListener("click", e2.config.markers.onClick), t3.node.addEventListener("dblclick", e2.config.markers.onDblClick), t3.node.addEventListener("touchstart", i2.pathMouseDown.bind(this.ctx, t3), { passive: true });
      } }, { key: "getMarkerStyle", value: function(t3) {
        var e2 = this.w, i2 = e2.globals.markers.colors, a2 = e2.config.markers.strokeColor || e2.config.markers.strokeColors;
        return { pointStrokeColor: Array.isArray(a2) ? a2[t3] : a2, pointFillColor: Array.isArray(i2) ? i2[t3] : i2 };
      } }]), t2;
    }();
    var D = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled;
      }
      return r(t2, [{ key: "draw", value: function(t3, e2, i2) {
        var a2 = this.w, s2 = new m(this.ctx), r2 = i2.realIndex, o2 = i2.pointsPos, n2 = i2.zRatio, l2 = i2.elParent, h2 = s2.group({ class: "apexcharts-series-markers apexcharts-series-".concat(a2.config.chart.type) });
        if (h2.attr("clip-path", "url(#gridRectMarkerMask".concat(a2.globals.cuid, ")")), Array.isArray(o2.x))
          for (var c2 = 0; c2 < o2.x.length; c2++) {
            var d2 = e2 + 1, g2 = true;
            0 === e2 && 0 === c2 && (d2 = 0), 0 === e2 && 1 === c2 && (d2 = 1);
            var u2 = 0, p2 = a2.globals.markers.size[r2];
            if (n2 !== 1 / 0) {
              var f2 = a2.config.plotOptions.bubble;
              p2 = a2.globals.seriesZ[r2][d2], f2.zScaling && (p2 /= n2), f2.minBubbleRadius && p2 < f2.minBubbleRadius && (p2 = f2.minBubbleRadius), f2.maxBubbleRadius && p2 > f2.maxBubbleRadius && (p2 = f2.maxBubbleRadius);
            }
            a2.config.chart.animations.enabled || (u2 = p2);
            var x2 = o2.x[c2], b2 = o2.y[c2];
            if (u2 = u2 || 0, null !== b2 && void 0 !== a2.globals.series[r2][d2] || (g2 = false), g2) {
              var v2 = this.drawPoint(x2, b2, u2, p2, r2, d2, e2);
              h2.add(v2);
            }
            l2.add(h2);
          }
      } }, { key: "drawPoint", value: function(t3, e2, i2, a2, s2, r2, o2) {
        var n2 = this.w, l2 = s2, h2 = new b(this.ctx), c2 = new v(this.ctx), d2 = new R(this.ctx), g2 = new H(this.ctx), u2 = new m(this.ctx), p2 = g2.getMarkerConfig({ cssClass: "apexcharts-marker", seriesIndex: l2, dataPointIndex: r2, finishRadius: "bubble" === n2.config.chart.type || n2.globals.comboCharts && n2.config.series[s2] && "bubble" === n2.config.series[s2].type ? a2 : null });
        a2 = p2.pSize;
        var f2, x2 = d2.fillPath({ seriesNumber: s2, dataPointIndex: r2, color: p2.pointFillColor, patternUnits: "objectBoundingBox", value: n2.globals.series[s2][o2] });
        if ("circle" === p2.shape ? f2 = u2.drawCircle(i2) : "square" !== p2.shape && "rect" !== p2.shape || (f2 = u2.drawRect(0, 0, p2.width - p2.pointStrokeWidth / 2, p2.height - p2.pointStrokeWidth / 2, p2.pRadius)), n2.config.series[l2].data[r2] && n2.config.series[l2].data[r2].fillColor && (x2 = n2.config.series[l2].data[r2].fillColor), f2.attr({ x: t3 - p2.width / 2 - p2.pointStrokeWidth / 2, y: e2 - p2.height / 2 - p2.pointStrokeWidth / 2, cx: t3, cy: e2, fill: x2, "fill-opacity": p2.pointFillOpacity, stroke: p2.pointStrokeColor, r: a2, "stroke-width": p2.pointStrokeWidth, "stroke-dasharray": p2.pointStrokeDashArray, "stroke-opacity": p2.pointStrokeOpacity }), n2.config.chart.dropShadow.enabled) {
          var y2 = n2.config.chart.dropShadow;
          c2.dropShadow(f2, y2, s2);
        }
        if (!this.initialAnim || n2.globals.dataChanged || n2.globals.resized)
          n2.globals.animationEnded = true;
        else {
          var w2 = n2.config.chart.animations.speed;
          h2.animateMarker(f2, 0, "circle" === p2.shape ? a2 : { width: p2.width, height: p2.height }, w2, n2.globals.easing, function() {
            window.setTimeout(function() {
              h2.animationCompleted(f2);
            }, 100);
          });
        }
        if (n2.globals.dataChanged && "circle" === p2.shape)
          if (this.dynamicAnim) {
            var k2, A2, S2, C2, L2 = n2.config.chart.animations.dynamicAnimation.speed;
            null != (C2 = n2.globals.previousPaths[s2] && n2.globals.previousPaths[s2][o2]) && (k2 = C2.x, A2 = C2.y, S2 = void 0 !== C2.r ? C2.r : a2);
            for (var P2 = 0; P2 < n2.globals.collapsedSeries.length; P2++)
              n2.globals.collapsedSeries[P2].index === s2 && (L2 = 1, a2 = 0);
            0 === t3 && 0 === e2 && (a2 = 0), h2.animateCircle(f2, { cx: k2, cy: A2, r: S2 }, { cx: t3, cy: e2, r: a2 }, L2, n2.globals.easing);
          } else
            f2.attr({ r: a2 });
        return f2.attr({ rel: r2, j: r2, index: s2, "default-marker-size": a2 }), c2.setSelectionFilter(f2, s2, r2), g2.addEvents(f2), f2.node.classList.add("apexcharts-marker"), f2;
      } }, { key: "centerTextInBubble", value: function(t3) {
        var e2 = this.w;
        return { y: t3 += parseInt(e2.config.dataLabels.style.fontSize, 10) / 4 };
      } }]), t2;
    }();
    var O = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
      }
      return r(t2, [{ key: "dataLabelsCorrection", value: function(t3, e2, i2, a2, s2, r2, o2) {
        var n2 = this.w, l2 = false, h2 = new m(this.ctx).getTextRects(i2, o2), c2 = h2.width, d2 = h2.height;
        e2 < 0 && (e2 = 0), e2 > n2.globals.gridHeight + d2 && (e2 = n2.globals.gridHeight + d2 / 2), void 0 === n2.globals.dataLabelsRects[a2] && (n2.globals.dataLabelsRects[a2] = []), n2.globals.dataLabelsRects[a2].push({ x: t3, y: e2, width: c2, height: d2 });
        var g2 = n2.globals.dataLabelsRects[a2].length - 2, u2 = void 0 !== n2.globals.lastDrawnDataLabelsIndexes[a2] ? n2.globals.lastDrawnDataLabelsIndexes[a2][n2.globals.lastDrawnDataLabelsIndexes[a2].length - 1] : 0;
        if (void 0 !== n2.globals.dataLabelsRects[a2][g2]) {
          var p2 = n2.globals.dataLabelsRects[a2][u2];
          (t3 > p2.x + p2.width || e2 > p2.y + p2.height || e2 + d2 < p2.y || t3 + c2 < p2.x) && (l2 = true);
        }
        return (0 === s2 || r2) && (l2 = true), { x: t3, y: e2, textRects: h2, drawnextLabel: l2 };
      } }, { key: "drawDataLabel", value: function(t3) {
        var e2 = this, i2 = t3.type, a2 = t3.pos, s2 = t3.i, r2 = t3.j, o2 = t3.isRangeStart, n2 = t3.strokeWidth, l2 = void 0 === n2 ? 2 : n2, h2 = this.w, c2 = new m(this.ctx), d2 = h2.config.dataLabels, g2 = 0, u2 = 0, p2 = r2, f2 = null;
        if (!d2.enabled || !Array.isArray(a2.x))
          return f2;
        f2 = c2.group({ class: "apexcharts-data-labels" });
        for (var x2 = 0; x2 < a2.x.length; x2++)
          if (g2 = a2.x[x2] + d2.offsetX, u2 = a2.y[x2] + d2.offsetY + l2, !isNaN(g2)) {
            1 === r2 && 0 === x2 && (p2 = 0), 1 === r2 && 1 === x2 && (p2 = 1);
            var b2 = h2.globals.series[s2][p2];
            "rangeArea" === i2 && (b2 = o2 ? h2.globals.seriesRangeStart[s2][p2] : h2.globals.seriesRangeEnd[s2][p2]);
            var v2 = "", y2 = function(t4) {
              return h2.config.dataLabels.formatter(t4, { ctx: e2.ctx, seriesIndex: s2, dataPointIndex: p2, w: h2 });
            };
            if ("bubble" === h2.config.chart.type)
              v2 = y2(b2 = h2.globals.seriesZ[s2][p2]), u2 = a2.y[x2], u2 = new D(this.ctx).centerTextInBubble(u2, s2, p2).y;
            else
              void 0 !== b2 && (v2 = y2(b2));
            this.plotDataLabelsText({ x: g2, y: u2, text: v2, i: s2, j: p2, parent: f2, offsetCorrection: true, dataLabelsConfig: h2.config.dataLabels });
          }
        return f2;
      } }, { key: "plotDataLabelsText", value: function(t3) {
        var e2 = this.w, i2 = new m(this.ctx), a2 = t3.x, s2 = t3.y, r2 = t3.i, o2 = t3.j, n2 = t3.text, l2 = t3.textAnchor, h2 = t3.fontSize, c2 = t3.parent, d2 = t3.dataLabelsConfig, g2 = t3.color, u2 = t3.alwaysDrawDataLabel, p2 = t3.offsetCorrection;
        if (!(Array.isArray(e2.config.dataLabels.enabledOnSeries) && e2.config.dataLabels.enabledOnSeries.indexOf(r2) < 0)) {
          var f2 = { x: a2, y: s2, drawnextLabel: true, textRects: null };
          p2 && (f2 = this.dataLabelsCorrection(a2, s2, n2, r2, o2, u2, parseInt(d2.style.fontSize, 10))), e2.globals.zoomed || (a2 = f2.x, s2 = f2.y), f2.textRects && (a2 < -10 - f2.textRects.width || a2 > e2.globals.gridWidth + f2.textRects.width + 10) && (n2 = "");
          var x2 = e2.globals.dataLabels.style.colors[r2];
          (("bar" === e2.config.chart.type || "rangeBar" === e2.config.chart.type) && e2.config.plotOptions.bar.distributed || e2.config.dataLabels.distributed) && (x2 = e2.globals.dataLabels.style.colors[o2]), "function" == typeof x2 && (x2 = x2({ series: e2.globals.series, seriesIndex: r2, dataPointIndex: o2, w: e2 })), g2 && (x2 = g2);
          var b2 = d2.offsetX, y2 = d2.offsetY;
          if ("bar" !== e2.config.chart.type && "rangeBar" !== e2.config.chart.type || (b2 = 0, y2 = 0), f2.drawnextLabel) {
            var w2 = i2.drawText({ width: 100, height: parseInt(d2.style.fontSize, 10), x: a2 + b2, y: s2 + y2, foreColor: x2, textAnchor: l2 || d2.textAnchor, text: n2, fontSize: h2 || d2.style.fontSize, fontFamily: d2.style.fontFamily, fontWeight: d2.style.fontWeight || "normal" });
            if (w2.attr({ class: "apexcharts-datalabel", cx: a2, cy: s2 }), d2.dropShadow.enabled) {
              var k2 = d2.dropShadow;
              new v(this.ctx).dropShadow(w2, k2);
            }
            c2.add(w2), void 0 === e2.globals.lastDrawnDataLabelsIndexes[r2] && (e2.globals.lastDrawnDataLabelsIndexes[r2] = []), e2.globals.lastDrawnDataLabelsIndexes[r2].push(o2);
          }
        }
      } }, { key: "addBackgroundToDataLabel", value: function(t3, e2) {
        var i2 = this.w, a2 = i2.config.dataLabels.background, s2 = a2.padding, r2 = a2.padding / 2, o2 = e2.width, n2 = e2.height, l2 = new m(this.ctx).drawRect(e2.x - s2, e2.y - r2 / 2, o2 + 2 * s2, n2 + r2, a2.borderRadius, "transparent" === i2.config.chart.background ? "#fff" : i2.config.chart.background, a2.opacity, a2.borderWidth, a2.borderColor);
        a2.dropShadow.enabled && new v(this.ctx).dropShadow(l2, a2.dropShadow);
        return l2;
      } }, { key: "dataLabelsBackground", value: function() {
        var t3 = this.w;
        if ("bubble" !== t3.config.chart.type)
          for (var e2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels text"), i2 = 0; i2 < e2.length; i2++) {
            var a2 = e2[i2], s2 = a2.getBBox(), r2 = null;
            if (s2.width && s2.height && (r2 = this.addBackgroundToDataLabel(a2, s2)), r2) {
              a2.parentNode.insertBefore(r2.node, a2);
              var o2 = a2.getAttribute("fill");
              t3.config.chart.animations.enabled && !t3.globals.resized && !t3.globals.dataChanged ? r2.animate().attr({ fill: o2 }) : r2.attr({ fill: o2 }), a2.setAttribute("fill", t3.config.dataLabels.background.foreColor);
            }
          }
      } }, { key: "bringForward", value: function() {
        for (var t3 = this.w, e2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels"), i2 = t3.globals.dom.baseEl.querySelector(".apexcharts-plot-series:last-child"), a2 = 0; a2 < e2.length; a2++)
          i2 && i2.insertBefore(e2[a2], i2.nextSibling);
      } }]), t2;
    }();
    var N = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w, this.legendInactiveClass = "legend-mouseover-inactive";
      }
      return r(t2, [{ key: "getAllSeriesEls", value: function() {
        return this.w.globals.dom.baseEl.getElementsByClassName("apexcharts-series");
      } }, { key: "getSeriesByName", value: function(t3) {
        return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner .apexcharts-series[seriesName='".concat(x.escapeString(t3), "']"));
      } }, { key: "isSeriesHidden", value: function(t3) {
        var e2 = this.getSeriesByName(t3), i2 = parseInt(e2.getAttribute("data:realIndex"), 10);
        return { isHidden: e2.classList.contains("apexcharts-series-collapsed"), realIndex: i2 };
      } }, { key: "addCollapsedClassToSeries", value: function(t3, e2) {
        var i2 = this.w;
        function a2(i3) {
          for (var a3 = 0; a3 < i3.length; a3++)
            i3[a3].index === e2 && t3.node.classList.add("apexcharts-series-collapsed");
        }
        a2(i2.globals.collapsedSeries), a2(i2.globals.ancillaryCollapsedSeries);
      } }, { key: "toggleSeries", value: function(t3) {
        var e2 = this.isSeriesHidden(t3);
        return this.ctx.legend.legendHelpers.toggleDataSeries(e2.realIndex, e2.isHidden), e2.isHidden;
      } }, { key: "showSeries", value: function(t3) {
        var e2 = this.isSeriesHidden(t3);
        e2.isHidden && this.ctx.legend.legendHelpers.toggleDataSeries(e2.realIndex, true);
      } }, { key: "hideSeries", value: function(t3) {
        var e2 = this.isSeriesHidden(t3);
        e2.isHidden || this.ctx.legend.legendHelpers.toggleDataSeries(e2.realIndex, false);
      } }, { key: "resetSeries", value: function() {
        var t3 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], a2 = this.w, s2 = x.clone(a2.globals.initialSeries);
        a2.globals.previousPaths = [], i2 ? (a2.globals.collapsedSeries = [], a2.globals.ancillaryCollapsedSeries = [], a2.globals.collapsedSeriesIndices = [], a2.globals.ancillaryCollapsedSeriesIndices = []) : s2 = this.emptyCollapsedSeries(s2), a2.config.series = s2, t3 && (e2 && (a2.globals.zoomed = false, this.ctx.updateHelpers.revertDefaultAxisMinMax()), this.ctx.updateHelpers._updateSeries(s2, a2.config.chart.animations.dynamicAnimation.enabled));
      } }, { key: "emptyCollapsedSeries", value: function(t3) {
        for (var e2 = this.w, i2 = 0; i2 < t3.length; i2++)
          e2.globals.collapsedSeriesIndices.indexOf(i2) > -1 && (t3[i2].data = []);
        return t3;
      } }, { key: "toggleSeriesOnHover", value: function(t3, e2) {
        var i2 = this.w;
        e2 || (e2 = t3.target);
        var a2 = i2.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels");
        if ("mousemove" === t3.type) {
          var s2 = parseInt(e2.getAttribute("rel"), 10) - 1, r2 = null, o2 = null;
          i2.globals.axisCharts || "radialBar" === i2.config.chart.type ? i2.globals.axisCharts ? (r2 = i2.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(s2, "']")), o2 = i2.globals.dom.baseEl.querySelector(".apexcharts-datalabels[data\\:realIndex='".concat(s2, "']"))) : r2 = i2.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(s2 + 1, "']")) : r2 = i2.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(s2 + 1, "'] path"));
          for (var n2 = 0; n2 < a2.length; n2++)
            a2[n2].classList.add(this.legendInactiveClass);
          null !== r2 && (i2.globals.axisCharts || r2.parentNode.classList.remove(this.legendInactiveClass), r2.classList.remove(this.legendInactiveClass), null !== o2 && o2.classList.remove(this.legendInactiveClass));
        } else if ("mouseout" === t3.type)
          for (var l2 = 0; l2 < a2.length; l2++)
            a2[l2].classList.remove(this.legendInactiveClass);
      } }, { key: "highlightRangeInSeries", value: function(t3, e2) {
        var i2 = this, a2 = this.w, s2 = a2.globals.dom.baseEl.getElementsByClassName("apexcharts-heatmap-rect"), r2 = function(t4) {
          for (var e3 = 0; e3 < s2.length; e3++)
            s2[e3].classList[t4](i2.legendInactiveClass);
        };
        if ("mousemove" === t3.type) {
          var o2 = parseInt(e2.getAttribute("rel"), 10) - 1;
          r2("add"), function(t4) {
            for (var e3 = 0; e3 < s2.length; e3++) {
              var a3 = parseInt(s2[e3].getAttribute("val"), 10);
              a3 >= t4.from && a3 <= t4.to && s2[e3].classList.remove(i2.legendInactiveClass);
            }
          }(a2.config.plotOptions.heatmap.colorScale.ranges[o2]);
        } else
          "mouseout" === t3.type && r2("remove");
      } }, { key: "getActiveConfigSeriesIndex", value: function() {
        var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "asc", e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], i2 = this.w, a2 = 0;
        if (i2.config.series.length > 1) {
          for (var s2 = i2.config.series.map(function(t4, a3) {
            return t4.data && t4.data.length > 0 && -1 === i2.globals.collapsedSeriesIndices.indexOf(a3) && (!i2.globals.comboCharts || 0 === e2.length || e2.length && e2.indexOf(i2.config.series[a3].type) > -1) ? a3 : -1;
          }), r2 = "asc" === t3 ? 0 : s2.length - 1; "asc" === t3 ? r2 < s2.length : r2 >= 0; "asc" === t3 ? r2++ : r2--)
            if (-1 !== s2[r2]) {
              a2 = s2[r2];
              break;
            }
        }
        return a2;
      } }, { key: "getBarSeriesIndices", value: function() {
        return this.w.globals.comboCharts ? this.w.config.series.map(function(t3, e2) {
          return "bar" === t3.type || "column" === t3.type ? e2 : -1;
        }).filter(function(t3) {
          return -1 !== t3;
        }) : this.w.config.series.map(function(t3, e2) {
          return e2;
        });
      } }, { key: "getPreviousPaths", value: function() {
        var t3 = this.w;
        function e2(e3, i3, a3) {
          for (var s3 = e3[i3].childNodes, r2 = { type: a3, paths: [], realIndex: e3[i3].getAttribute("data:realIndex") }, o2 = 0; o2 < s3.length; o2++)
            if (s3[o2].hasAttribute("pathTo")) {
              var n2 = s3[o2].getAttribute("pathTo");
              r2.paths.push({ d: n2 });
            }
          t3.globals.previousPaths.push(r2);
        }
        t3.globals.previousPaths = [];
        ["line", "area", "bar", "rangebar", "rangeArea", "candlestick", "radar"].forEach(function(i3) {
          for (var a3, s3 = (a3 = i3, t3.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(a3, "-series .apexcharts-series"))), r2 = 0; r2 < s3.length; r2++)
            e2(s3, r2, i3);
        }), this.handlePrevBubbleScatterPaths("bubble"), this.handlePrevBubbleScatterPaths("scatter");
        var i2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t3.config.chart.type, " .apexcharts-series"));
        if (i2.length > 0)
          for (var a2 = function(e3) {
            for (var i3 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t3.config.chart.type, " .apexcharts-series[data\\:realIndex='").concat(e3, "'] rect")), a3 = [], s3 = function(t4) {
              var e4 = function(e5) {
                return i3[t4].getAttribute(e5);
              }, s4 = { x: parseFloat(e4("x")), y: parseFloat(e4("y")), width: parseFloat(e4("width")), height: parseFloat(e4("height")) };
              a3.push({ rect: s4, color: i3[t4].getAttribute("color") });
            }, r2 = 0; r2 < i3.length; r2++)
              s3(r2);
            t3.globals.previousPaths.push(a3);
          }, s2 = 0; s2 < i2.length; s2++)
            a2(s2);
        t3.globals.axisCharts || (t3.globals.previousPaths = t3.globals.series);
      } }, { key: "handlePrevBubbleScatterPaths", value: function(t3) {
        var e2 = this.w, i2 = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t3, "-series .apexcharts-series"));
        if (i2.length > 0)
          for (var a2 = 0; a2 < i2.length; a2++) {
            for (var s2 = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t3, "-series .apexcharts-series[data\\:realIndex='").concat(a2, "'] circle")), r2 = [], o2 = 0; o2 < s2.length; o2++)
              r2.push({ x: s2[o2].getAttribute("cx"), y: s2[o2].getAttribute("cy"), r: s2[o2].getAttribute("r") });
            e2.globals.previousPaths.push(r2);
          }
      } }, { key: "clearPreviousPaths", value: function() {
        var t3 = this.w;
        t3.globals.previousPaths = [], t3.globals.allSeriesCollapsed = false;
      } }, { key: "handleNoData", value: function() {
        var t3 = this.w, e2 = t3.config.noData, i2 = new m(this.ctx), a2 = t3.globals.svgWidth / 2, s2 = t3.globals.svgHeight / 2, r2 = "middle";
        if (t3.globals.noData = true, t3.globals.animationEnded = true, "left" === e2.align ? (a2 = 10, r2 = "start") : "right" === e2.align && (a2 = t3.globals.svgWidth - 10, r2 = "end"), "top" === e2.verticalAlign ? s2 = 50 : "bottom" === e2.verticalAlign && (s2 = t3.globals.svgHeight - 50), a2 += e2.offsetX, s2 = s2 + parseInt(e2.style.fontSize, 10) + 2 + e2.offsetY, void 0 !== e2.text && "" !== e2.text) {
          var o2 = i2.drawText({ x: a2, y: s2, text: e2.text, textAnchor: r2, fontSize: e2.style.fontSize, fontFamily: e2.style.fontFamily, foreColor: e2.style.color, opacity: 1, class: "apexcharts-text-nodata" });
          t3.globals.dom.Paper.add(o2);
        }
      } }, { key: "setNullSeriesToZeroValues", value: function(t3) {
        for (var e2 = this.w, i2 = 0; i2 < t3.length; i2++)
          if (0 === t3[i2].length)
            for (var a2 = 0; a2 < t3[e2.globals.maxValsInArrayIndex].length; a2++)
              t3[i2].push(0);
        return t3;
      } }, { key: "hasAllSeriesEqualX", value: function() {
        for (var t3 = true, e2 = this.w, i2 = this.filteredSeriesX(), a2 = 0; a2 < i2.length - 1; a2++)
          if (i2[a2][0] !== i2[a2 + 1][0]) {
            t3 = false;
            break;
          }
        return e2.globals.allSeriesHasEqualX = t3, t3;
      } }, { key: "filteredSeriesX", value: function() {
        var t3 = this.w.globals.seriesX.map(function(t4) {
          return t4.length > 0 ? t4 : [];
        });
        return t3;
      } }]), t2;
    }();
    var W = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w, this.twoDSeries = [], this.threeDSeries = [], this.twoDSeriesX = [], this.seriesGoals = [], this.coreUtils = new y(this.ctx);
      }
      return r(t2, [{ key: "isMultiFormat", value: function() {
        return this.isFormatXY() || this.isFormat2DArray();
      } }, { key: "isFormatXY", value: function() {
        var t3 = this.w.config.series.slice(), e2 = new N(this.ctx);
        if (this.activeSeriesIndex = e2.getActiveConfigSeriesIndex(), void 0 !== t3[this.activeSeriesIndex].data && t3[this.activeSeriesIndex].data.length > 0 && null !== t3[this.activeSeriesIndex].data[0] && void 0 !== t3[this.activeSeriesIndex].data[0].x && null !== t3[this.activeSeriesIndex].data[0])
          return true;
      } }, { key: "isFormat2DArray", value: function() {
        var t3 = this.w.config.series.slice(), e2 = new N(this.ctx);
        if (this.activeSeriesIndex = e2.getActiveConfigSeriesIndex(), void 0 !== t3[this.activeSeriesIndex].data && t3[this.activeSeriesIndex].data.length > 0 && void 0 !== t3[this.activeSeriesIndex].data[0] && null !== t3[this.activeSeriesIndex].data[0] && t3[this.activeSeriesIndex].data[0].constructor === Array)
          return true;
      } }, { key: "handleFormat2DArray", value: function(t3, e2) {
        for (var i2 = this.w.config, a2 = this.w.globals, s2 = "boxPlot" === i2.chart.type || "boxPlot" === i2.series[e2].type, r2 = 0; r2 < t3[e2].data.length; r2++)
          if (void 0 !== t3[e2].data[r2][1] && (Array.isArray(t3[e2].data[r2][1]) && 4 === t3[e2].data[r2][1].length && !s2 ? this.twoDSeries.push(x.parseNumber(t3[e2].data[r2][1][3])) : t3[e2].data[r2].length >= 5 ? this.twoDSeries.push(x.parseNumber(t3[e2].data[r2][4])) : this.twoDSeries.push(x.parseNumber(t3[e2].data[r2][1])), a2.dataFormatXNumeric = true), "datetime" === i2.xaxis.type) {
            var o2 = new Date(t3[e2].data[r2][0]);
            o2 = new Date(o2).getTime(), this.twoDSeriesX.push(o2);
          } else
            this.twoDSeriesX.push(t3[e2].data[r2][0]);
        for (var n2 = 0; n2 < t3[e2].data.length; n2++)
          void 0 !== t3[e2].data[n2][2] && (this.threeDSeries.push(t3[e2].data[n2][2]), a2.isDataXYZ = true);
      } }, { key: "handleFormatXY", value: function(t3, e2) {
        var i2 = this.w.config, a2 = this.w.globals, s2 = new I(this.ctx), r2 = e2;
        a2.collapsedSeriesIndices.indexOf(e2) > -1 && (r2 = this.activeSeriesIndex);
        for (var o2 = 0; o2 < t3[e2].data.length; o2++)
          void 0 !== t3[e2].data[o2].y && (Array.isArray(t3[e2].data[o2].y) ? this.twoDSeries.push(x.parseNumber(t3[e2].data[o2].y[t3[e2].data[o2].y.length - 1])) : this.twoDSeries.push(x.parseNumber(t3[e2].data[o2].y))), void 0 !== t3[e2].data[o2].goals && Array.isArray(t3[e2].data[o2].goals) ? (void 0 === this.seriesGoals[e2] && (this.seriesGoals[e2] = []), this.seriesGoals[e2].push(t3[e2].data[o2].goals)) : (void 0 === this.seriesGoals[e2] && (this.seriesGoals[e2] = []), this.seriesGoals[e2].push(null));
        for (var n2 = 0; n2 < t3[r2].data.length; n2++) {
          var l2 = "string" == typeof t3[r2].data[n2].x, h2 = Array.isArray(t3[r2].data[n2].x), c2 = !h2 && !!s2.isValidDate(t3[r2].data[n2].x.toString());
          if (l2 || c2)
            if (l2 || i2.xaxis.convertedCatToNumeric) {
              var d2 = a2.isBarHorizontal && a2.isRangeData;
              "datetime" !== i2.xaxis.type || d2 ? (this.fallbackToCategory = true, this.twoDSeriesX.push(t3[r2].data[n2].x), isNaN(t3[r2].data[n2].x) || "category" === this.w.config.xaxis.type || "string" == typeof t3[r2].data[n2].x || (a2.isXNumeric = true)) : this.twoDSeriesX.push(s2.parseDate(t3[r2].data[n2].x));
            } else
              "datetime" === i2.xaxis.type ? this.twoDSeriesX.push(s2.parseDate(t3[r2].data[n2].x.toString())) : (a2.dataFormatXNumeric = true, a2.isXNumeric = true, this.twoDSeriesX.push(parseFloat(t3[r2].data[n2].x)));
          else
            h2 ? (this.fallbackToCategory = true, this.twoDSeriesX.push(t3[r2].data[n2].x)) : (a2.isXNumeric = true, a2.dataFormatXNumeric = true, this.twoDSeriesX.push(t3[r2].data[n2].x));
        }
        if (t3[e2].data[0] && void 0 !== t3[e2].data[0].z) {
          for (var g2 = 0; g2 < t3[e2].data.length; g2++)
            this.threeDSeries.push(t3[e2].data[g2].z);
          a2.isDataXYZ = true;
        }
      } }, { key: "handleRangeData", value: function(t3, e2) {
        var i2 = this.w.globals, a2 = {};
        return this.isFormat2DArray() ? a2 = this.handleRangeDataFormat("array", t3, e2) : this.isFormatXY() && (a2 = this.handleRangeDataFormat("xy", t3, e2)), i2.seriesRangeStart.push(a2.start), i2.seriesRangeEnd.push(a2.end), i2.seriesRange.push(a2.rangeUniques), i2.seriesRange.forEach(function(t4, e3) {
          t4 && t4.forEach(function(t5, e4) {
            t5.y.forEach(function(e5, i3) {
              for (var a3 = 0; a3 < t5.y.length; a3++)
                if (i3 !== a3) {
                  var s2 = e5.y1, r2 = e5.y2, o2 = t5.y[a3].y1;
                  s2 <= t5.y[a3].y2 && o2 <= r2 && (t5.overlaps.indexOf(e5.rangeName) < 0 && t5.overlaps.push(e5.rangeName), t5.overlaps.indexOf(t5.y[a3].rangeName) < 0 && t5.overlaps.push(t5.y[a3].rangeName));
                }
            });
          });
        }), a2;
      } }, { key: "handleCandleStickBoxData", value: function(t3, e2) {
        var i2 = this.w.globals, a2 = {};
        return this.isFormat2DArray() ? a2 = this.handleCandleStickBoxDataFormat("array", t3, e2) : this.isFormatXY() && (a2 = this.handleCandleStickBoxDataFormat("xy", t3, e2)), i2.seriesCandleO[e2] = a2.o, i2.seriesCandleH[e2] = a2.h, i2.seriesCandleM[e2] = a2.m, i2.seriesCandleL[e2] = a2.l, i2.seriesCandleC[e2] = a2.c, a2;
      } }, { key: "handleRangeDataFormat", value: function(t3, e2, i2) {
        var a2 = [], s2 = [], r2 = e2[i2].data.filter(function(t4, e3, i3) {
          return e3 === i3.findIndex(function(e4) {
            return e4.x === t4.x;
          });
        }).map(function(t4, e3) {
          return { x: t4.x, overlaps: [], y: [] };
        });
        if ("array" === t3)
          for (var o2 = 0; o2 < e2[i2].data.length; o2++)
            Array.isArray(e2[i2].data[o2]) ? (a2.push(e2[i2].data[o2][1][0]), s2.push(e2[i2].data[o2][1][1])) : (a2.push(e2[i2].data[o2]), s2.push(e2[i2].data[o2]));
        else if ("xy" === t3)
          for (var n2 = function(t4) {
            var o3 = Array.isArray(e2[i2].data[t4].y), n3 = x.randomId(), l3 = e2[i2].data[t4].x, h2 = { y1: o3 ? e2[i2].data[t4].y[0] : e2[i2].data[t4].y, y2: o3 ? e2[i2].data[t4].y[1] : e2[i2].data[t4].y, rangeName: n3 };
            e2[i2].data[t4].rangeName = n3;
            var c2 = r2.findIndex(function(t5) {
              return t5.x === l3;
            });
            r2[c2].y.push(h2), a2.push(h2.y1), s2.push(h2.y2);
          }, l2 = 0; l2 < e2[i2].data.length; l2++)
            n2(l2);
        return { start: a2, end: s2, rangeUniques: r2 };
      } }, { key: "handleCandleStickBoxDataFormat", value: function(t3, e2, i2) {
        var a2 = this.w, s2 = "boxPlot" === a2.config.chart.type || "boxPlot" === a2.config.series[i2].type, r2 = [], o2 = [], n2 = [], l2 = [], h2 = [];
        if ("array" === t3)
          if (s2 && 6 === e2[i2].data[0].length || !s2 && 5 === e2[i2].data[0].length)
            for (var c2 = 0; c2 < e2[i2].data.length; c2++)
              r2.push(e2[i2].data[c2][1]), o2.push(e2[i2].data[c2][2]), s2 ? (n2.push(e2[i2].data[c2][3]), l2.push(e2[i2].data[c2][4]), h2.push(e2[i2].data[c2][5])) : (l2.push(e2[i2].data[c2][3]), h2.push(e2[i2].data[c2][4]));
          else
            for (var d2 = 0; d2 < e2[i2].data.length; d2++)
              Array.isArray(e2[i2].data[d2][1]) && (r2.push(e2[i2].data[d2][1][0]), o2.push(e2[i2].data[d2][1][1]), s2 ? (n2.push(e2[i2].data[d2][1][2]), l2.push(e2[i2].data[d2][1][3]), h2.push(e2[i2].data[d2][1][4])) : (l2.push(e2[i2].data[d2][1][2]), h2.push(e2[i2].data[d2][1][3])));
        else if ("xy" === t3)
          for (var g2 = 0; g2 < e2[i2].data.length; g2++)
            Array.isArray(e2[i2].data[g2].y) && (r2.push(e2[i2].data[g2].y[0]), o2.push(e2[i2].data[g2].y[1]), s2 ? (n2.push(e2[i2].data[g2].y[2]), l2.push(e2[i2].data[g2].y[3]), h2.push(e2[i2].data[g2].y[4])) : (l2.push(e2[i2].data[g2].y[2]), h2.push(e2[i2].data[g2].y[3])));
        return { o: r2, h: o2, m: n2, l: l2, c: h2 };
      } }, { key: "parseDataAxisCharts", value: function(t3) {
        var e2, i2 = this, a2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.ctx, s2 = this.w.config, r2 = this.w.globals, o2 = new I(a2), n2 = s2.labels.length > 0 ? s2.labels.slice() : s2.xaxis.categories.slice();
        if (r2.isRangeBar = "rangeBar" === s2.chart.type && r2.isBarHorizontal, r2.hasXaxisGroups = "category" === s2.xaxis.type && s2.xaxis.group.groups.length > 0, r2.hasXaxisGroups && (r2.groups = s2.xaxis.group.groups), r2.hasSeriesGroups = null === (e2 = t3[0]) || void 0 === e2 ? void 0 : e2.group, r2.hasSeriesGroups) {
          var l2 = [], h2 = u(new Set(t3.map(function(t4) {
            return t4.group;
          })));
          t3.forEach(function(t4, e3) {
            var i3 = h2.indexOf(t4.group);
            l2[i3] || (l2[i3] = []), l2[i3].push(t4.name);
          }), r2.seriesGroups = l2;
        }
        for (var c2 = function() {
          for (var t4 = 0; t4 < n2.length; t4++)
            if ("string" == typeof n2[t4]) {
              if (!o2.isValidDate(n2[t4]))
                throw new Error("You have provided invalid Date format. Please provide a valid JavaScript Date");
              i2.twoDSeriesX.push(o2.parseDate(n2[t4]));
            } else
              i2.twoDSeriesX.push(n2[t4]);
        }, d2 = 0; d2 < t3.length; d2++) {
          if (this.twoDSeries = [], this.twoDSeriesX = [], this.threeDSeries = [], void 0 === t3[d2].data)
            return void console.error("It is a possibility that you may have not included 'data' property in series.");
          if ("rangeBar" !== s2.chart.type && "rangeArea" !== s2.chart.type && "rangeBar" !== t3[d2].type && "rangeArea" !== t3[d2].type || (r2.isRangeData = true, r2.isComboCharts ? "rangeBar" !== t3[d2].type && "rangeArea" !== t3[d2].type || this.handleRangeData(t3, d2) : "rangeBar" !== s2.chart.type && "rangeArea" !== s2.chart.type || this.handleRangeData(t3, d2)), this.isMultiFormat())
            this.isFormat2DArray() ? this.handleFormat2DArray(t3, d2) : this.isFormatXY() && this.handleFormatXY(t3, d2), "candlestick" !== s2.chart.type && "candlestick" !== t3[d2].type && "boxPlot" !== s2.chart.type && "boxPlot" !== t3[d2].type || this.handleCandleStickBoxData(t3, d2), r2.series.push(this.twoDSeries), r2.labels.push(this.twoDSeriesX), r2.seriesX.push(this.twoDSeriesX), r2.seriesGoals = this.seriesGoals, d2 !== this.activeSeriesIndex || this.fallbackToCategory || (r2.isXNumeric = true);
          else {
            "datetime" === s2.xaxis.type ? (r2.isXNumeric = true, c2(), r2.seriesX.push(this.twoDSeriesX)) : "numeric" === s2.xaxis.type && (r2.isXNumeric = true, n2.length > 0 && (this.twoDSeriesX = n2, r2.seriesX.push(this.twoDSeriesX))), r2.labels.push(this.twoDSeriesX);
            var g2 = t3[d2].data.map(function(t4) {
              return x.parseNumber(t4);
            });
            r2.series.push(g2);
          }
          r2.seriesZ.push(this.threeDSeries), void 0 !== t3[d2].name ? r2.seriesNames.push(t3[d2].name) : r2.seriesNames.push("series-" + parseInt(d2 + 1, 10)), void 0 !== t3[d2].color ? r2.seriesColors.push(t3[d2].color) : r2.seriesColors.push(void 0);
        }
        return this.w;
      } }, { key: "parseDataNonAxisCharts", value: function(t3) {
        var e2 = this.w.globals, i2 = this.w.config;
        e2.series = t3.slice(), e2.seriesNames = i2.labels.slice();
        for (var a2 = 0; a2 < e2.series.length; a2++)
          void 0 === e2.seriesNames[a2] && e2.seriesNames.push("series-" + (a2 + 1));
        return this.w;
      } }, { key: "handleExternalLabelsData", value: function(t3) {
        var e2 = this.w.config, i2 = this.w.globals;
        if (e2.xaxis.categories.length > 0)
          i2.labels = e2.xaxis.categories;
        else if (e2.labels.length > 0)
          i2.labels = e2.labels.slice();
        else if (this.fallbackToCategory) {
          if (i2.labels = i2.labels[0], i2.seriesRange.length && (i2.seriesRange.map(function(t4) {
            t4.forEach(function(t5) {
              i2.labels.indexOf(t5.x) < 0 && t5.x && i2.labels.push(t5.x);
            });
          }), i2.labels = Array.from(new Set(i2.labels.map(JSON.stringify)), JSON.parse)), e2.xaxis.convertedCatToNumeric)
            new X(e2).convertCatToNumericXaxis(e2, this.ctx, i2.seriesX[0]), this._generateExternalLabels(t3);
        } else
          this._generateExternalLabels(t3);
      } }, { key: "_generateExternalLabels", value: function(t3) {
        var e2 = this.w.globals, i2 = this.w.config, a2 = [];
        if (e2.axisCharts) {
          if (e2.series.length > 0)
            if (this.isFormatXY())
              for (var s2 = i2.series.map(function(t4, e3) {
                return t4.data.filter(function(t5, e4, i3) {
                  return i3.findIndex(function(e5) {
                    return e5.x === t5.x;
                  }) === e4;
                });
              }), r2 = s2.reduce(function(t4, e3, i3, a3) {
                return a3[t4].length > e3.length ? t4 : i3;
              }, 0), o2 = 0; o2 < s2[r2].length; o2++)
                a2.push(o2 + 1);
            else
              for (var n2 = 0; n2 < e2.series[e2.maxValsInArrayIndex].length; n2++)
                a2.push(n2 + 1);
          e2.seriesX = [];
          for (var l2 = 0; l2 < t3.length; l2++)
            e2.seriesX.push(a2);
          this.w.globals.isBarHorizontal || (e2.isXNumeric = true);
        }
        if (0 === a2.length) {
          a2 = e2.axisCharts ? [] : e2.series.map(function(t4, e3) {
            return e3 + 1;
          });
          for (var h2 = 0; h2 < t3.length; h2++)
            e2.seriesX.push(a2);
        }
        e2.labels = a2, i2.xaxis.convertedCatToNumeric && (e2.categoryLabels = a2.map(function(t4) {
          return i2.xaxis.labels.formatter(t4);
        })), e2.noLabelsProvided = true;
      } }, { key: "parseData", value: function(t3) {
        var e2 = this.w, i2 = e2.config, a2 = e2.globals;
        if (this.excludeCollapsedSeriesInYAxis(), this.fallbackToCategory = false, this.ctx.core.resetGlobals(), this.ctx.core.isMultipleY(), a2.axisCharts ? (this.parseDataAxisCharts(t3), this.coreUtils.getLargestSeries()) : this.parseDataNonAxisCharts(t3), i2.chart.stacked) {
          var s2 = new N(this.ctx);
          a2.series = s2.setNullSeriesToZeroValues(a2.series);
        }
        this.coreUtils.getSeriesTotals(), a2.axisCharts && (a2.stackedSeriesTotals = this.coreUtils.getStackedSeriesTotals()), this.coreUtils.getPercentSeries(), a2.dataFormatXNumeric || a2.isXNumeric && ("numeric" !== i2.xaxis.type || 0 !== i2.labels.length || 0 !== i2.xaxis.categories.length) || this.handleExternalLabelsData(t3);
        for (var r2 = this.coreUtils.getCategoryLabels(a2.labels), o2 = 0; o2 < r2.length; o2++)
          if (Array.isArray(r2[o2])) {
            a2.isMultiLineX = true;
            break;
          }
      } }, { key: "excludeCollapsedSeriesInYAxis", value: function() {
        var t3 = this, e2 = this.w;
        e2.globals.ignoreYAxisIndexes = e2.globals.collapsedSeries.map(function(i2, a2) {
          if (t3.w.globals.isMultipleYAxis && !e2.config.chart.stacked)
            return i2.index;
        });
      } }]), t2;
    }();
    var B = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
      }
      return r(t2, [{ key: "getLabel", value: function(t3, e2, i2, a2) {
        var s2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : [], r2 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "12px", o2 = !(arguments.length > 6 && void 0 !== arguments[6]) || arguments[6], n2 = this.w, l2 = void 0 === t3[a2] ? "" : t3[a2], h2 = l2, c2 = n2.globals.xLabelFormatter, d2 = n2.config.xaxis.labels.formatter, g2 = false, u2 = new T(this.ctx), p2 = l2;
        o2 && (h2 = u2.xLabelFormat(c2, l2, p2, { i: a2, dateFormatter: new I(this.ctx).formatDate, w: n2 }), void 0 !== d2 && (h2 = d2(l2, t3[a2], { i: a2, dateFormatter: new I(this.ctx).formatDate, w: n2 })));
        var f2, x2;
        e2.length > 0 ? (f2 = e2[a2].unit, x2 = null, e2.forEach(function(t4) {
          "month" === t4.unit ? x2 = "year" : "day" === t4.unit ? x2 = "month" : "hour" === t4.unit ? x2 = "day" : "minute" === t4.unit && (x2 = "hour");
        }), g2 = x2 === f2, i2 = e2[a2].position, h2 = e2[a2].value) : "datetime" === n2.config.xaxis.type && void 0 === d2 && (h2 = ""), void 0 === h2 && (h2 = ""), h2 = Array.isArray(h2) ? h2 : h2.toString();
        var b2 = new m(this.ctx), v2 = {};
        v2 = n2.globals.rotateXLabels && o2 ? b2.getTextRects(h2, parseInt(r2, 10), null, "rotate(".concat(n2.config.xaxis.labels.rotate, " 0 0)"), false) : b2.getTextRects(h2, parseInt(r2, 10));
        var y2 = !n2.config.xaxis.labels.showDuplicates && this.ctx.timeScale;
        return !Array.isArray(h2) && (0 === h2.indexOf("NaN") || 0 === h2.toLowerCase().indexOf("invalid") || h2.toLowerCase().indexOf("infinity") >= 0 || s2.indexOf(h2) >= 0 && y2) && (h2 = ""), { x: i2, text: h2, textRect: v2, isBold: g2 };
      } }, { key: "checkLabelBasedOnTickamount", value: function(t3, e2, i2) {
        var a2 = this.w, s2 = a2.config.xaxis.tickAmount;
        return "dataPoints" === s2 && (s2 = Math.round(a2.globals.gridWidth / 120)), s2 > i2 || t3 % Math.round(i2 / (s2 + 1)) == 0 || (e2.text = ""), e2;
      } }, { key: "checkForOverflowingLabels", value: function(t3, e2, i2, a2, s2) {
        var r2 = this.w;
        if (0 === t3 && r2.globals.skipFirstTimelinelabel && (e2.text = ""), t3 === i2 - 1 && r2.globals.skipLastTimelinelabel && (e2.text = ""), r2.config.xaxis.labels.hideOverlappingLabels && a2.length > 0) {
          var o2 = s2[s2.length - 1];
          e2.x < o2.textRect.width / (r2.globals.rotateXLabels ? Math.abs(r2.config.xaxis.labels.rotate) / 12 : 1.01) + o2.x && (e2.text = "");
        }
        return e2;
      } }, { key: "checkForReversedLabels", value: function(t3, e2) {
        var i2 = this.w;
        return i2.config.yaxis[t3] && i2.config.yaxis[t3].reversed && e2.reverse(), e2;
      } }, { key: "isYAxisHidden", value: function(t3) {
        var e2 = this.w, i2 = new y(this.ctx);
        return !e2.config.yaxis[t3].show || !e2.config.yaxis[t3].showForNullSeries && i2.isSeriesNull(t3) && -1 === e2.globals.collapsedSeriesIndices.indexOf(t3);
      } }, { key: "getYAxisForeColor", value: function(t3, e2) {
        var i2 = this.w;
        return Array.isArray(t3) && i2.globals.yAxisScale[e2] && this.ctx.theme.pushExtraColors(t3, i2.globals.yAxisScale[e2].result.length, false), t3;
      } }, { key: "drawYAxisTicks", value: function(t3, e2, i2, a2, s2, r2, o2) {
        var n2 = this.w, l2 = new m(this.ctx), h2 = n2.globals.translateY;
        if (a2.show && e2 > 0) {
          true === n2.config.yaxis[s2].opposite && (t3 += a2.width);
          for (var c2 = e2; c2 >= 0; c2--) {
            var d2 = h2 + e2 / 10 + n2.config.yaxis[s2].labels.offsetY - 1;
            n2.globals.isBarHorizontal && (d2 = r2 * c2), "heatmap" === n2.config.chart.type && (d2 += r2 / 2);
            var g2 = l2.drawLine(t3 + i2.offsetX - a2.width + a2.offsetX, d2 + a2.offsetY, t3 + i2.offsetX + a2.offsetX, d2 + a2.offsetY, a2.color);
            o2.add(g2), h2 += r2;
          }
        }
      } }]), t2;
    }();
    var G = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
      }
      return r(t2, [{ key: "scaleSvgNode", value: function(t3, e2) {
        var i2 = parseFloat(t3.getAttributeNS(null, "width")), a2 = parseFloat(t3.getAttributeNS(null, "height"));
        t3.setAttributeNS(null, "width", i2 * e2), t3.setAttributeNS(null, "height", a2 * e2), t3.setAttributeNS(null, "viewBox", "0 0 " + i2 + " " + a2);
      } }, { key: "fixSvgStringForIe11", value: function(t3) {
        if (!x.isIE11())
          return t3.replace(/&nbsp;/g, "&#160;");
        var e2 = 0, i2 = t3.replace(/xmlns="http:\/\/www.w3.org\/2000\/svg"/g, function(t4) {
          return 2 === ++e2 ? 'xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.dev"' : t4;
        });
        return i2 = (i2 = i2.replace(/xmlns:NS\d+=""/g, "")).replace(/NS\d+:(\w+:\w+=")/g, "$1");
      } }, { key: "getSvgString", value: function(t3) {
        null == t3 && (t3 = 1);
        var e2 = this.w.globals.dom.Paper.svg();
        if (1 !== t3) {
          var i2 = this.w.globals.dom.Paper.node.cloneNode(true);
          this.scaleSvgNode(i2, t3), e2 = new XMLSerializer().serializeToString(i2);
        }
        return this.fixSvgStringForIe11(e2);
      } }, { key: "cleanup", value: function() {
        var t3 = this.w, e2 = t3.globals.dom.baseEl.getElementsByClassName("apexcharts-xcrosshairs"), i2 = t3.globals.dom.baseEl.getElementsByClassName("apexcharts-ycrosshairs"), a2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-zoom-rect, .apexcharts-selection-rect");
        Array.prototype.forEach.call(a2, function(t4) {
          t4.setAttribute("width", 0);
        }), e2 && e2[0] && (e2[0].setAttribute("x", -500), e2[0].setAttribute("x1", -500), e2[0].setAttribute("x2", -500)), i2 && i2[0] && (i2[0].setAttribute("y", -100), i2[0].setAttribute("y1", -100), i2[0].setAttribute("y2", -100));
      } }, { key: "svgUrl", value: function() {
        this.cleanup();
        var t3 = this.getSvgString(), e2 = new Blob([t3], { type: "image/svg+xml;charset=utf-8" });
        return URL.createObjectURL(e2);
      } }, { key: "dataURI", value: function(t3) {
        var e2 = this;
        return new Promise(function(i2) {
          var a2 = e2.w, s2 = t3 ? t3.scale || t3.width / a2.globals.svgWidth : 1;
          e2.cleanup();
          var r2 = document.createElement("canvas");
          r2.width = a2.globals.svgWidth * s2, r2.height = parseInt(a2.globals.dom.elWrap.style.height, 10) * s2;
          var o2 = "transparent" === a2.config.chart.background ? "#fff" : a2.config.chart.background, n2 = r2.getContext("2d");
          n2.fillStyle = o2, n2.fillRect(0, 0, r2.width * s2, r2.height * s2);
          var l2 = e2.getSvgString(s2);
          if (window.canvg && x.isIE11()) {
            var h2 = window.canvg.Canvg.fromString(n2, l2, { ignoreClear: true, ignoreDimensions: true });
            h2.start();
            var c2 = r2.msToBlob();
            h2.stop(), i2({ blob: c2 });
          } else {
            var d2 = "data:image/svg+xml," + encodeURIComponent(l2), g2 = new Image();
            g2.crossOrigin = "anonymous", g2.onload = function() {
              if (n2.drawImage(g2, 0, 0), r2.msToBlob) {
                var t4 = r2.msToBlob();
                i2({ blob: t4 });
              } else {
                var e3 = r2.toDataURL("image/png");
                i2({ imgURI: e3 });
              }
            }, g2.src = d2;
          }
        });
      } }, { key: "exportToSVG", value: function() {
        this.triggerDownload(this.svgUrl(), this.w.config.chart.toolbar.export.svg.filename, ".svg");
      } }, { key: "exportToPng", value: function() {
        var t3 = this;
        this.dataURI().then(function(e2) {
          var i2 = e2.imgURI, a2 = e2.blob;
          a2 ? navigator.msSaveOrOpenBlob(a2, t3.w.globals.chartID + ".png") : t3.triggerDownload(i2, t3.w.config.chart.toolbar.export.png.filename, ".png");
        });
      } }, { key: "exportToCSV", value: function(t3) {
        var e2 = this, i2 = t3.series, a2 = t3.fileName, s2 = t3.columnDelimiter, r2 = void 0 === s2 ? "," : s2, o2 = t3.lineDelimiter, n2 = void 0 === o2 ? "\n" : o2, l2 = this.w;
        i2 || (i2 = l2.config.series);
        var h2 = [], c2 = [], d2 = "", g2 = l2.globals.series.map(function(t4, e3) {
          return -1 === l2.globals.collapsedSeriesIndices.indexOf(e3) ? t4 : [];
        }), p2 = Math.max.apply(Math, u(i2.map(function(t4) {
          return t4.data ? t4.data.length : 0;
        }))), f2 = new W(this.ctx), b2 = new B(this.ctx), v2 = function(t4) {
          var i3 = "";
          if (l2.globals.axisCharts) {
            if ("category" === l2.config.xaxis.type || l2.config.xaxis.convertedCatToNumeric)
              if (l2.globals.isBarHorizontal) {
                var a3 = l2.globals.yLabelFormatters[0], s3 = new N(e2.ctx).getActiveConfigSeriesIndex();
                i3 = a3(l2.globals.labels[t4], { seriesIndex: s3, dataPointIndex: t4, w: l2 });
              } else
                i3 = b2.getLabel(l2.globals.labels, l2.globals.timescaleLabels, 0, t4).text;
            "datetime" === l2.config.xaxis.type && (l2.config.xaxis.categories.length ? i3 = l2.config.xaxis.categories[t4] : l2.config.labels.length && (i3 = l2.config.labels[t4]));
          } else
            i3 = l2.config.labels[t4];
          return Array.isArray(i3) && (i3 = i3.join(" ")), x.isNumber(i3) ? i3 : i3.split(r2).join("");
        }, m2 = function(t4, e3) {
          if (h2.length && 0 === e3 && c2.push(h2.join(r2)), t4.data) {
            t4.data = t4.data.length && t4.data || u(Array(p2)).map(function() {
              return "";
            });
            for (var a3 = 0; a3 < t4.data.length; a3++) {
              h2 = [];
              var s3 = v2(a3);
              if (s3 || (f2.isFormatXY() ? s3 = i2[e3].data[a3].x : f2.isFormat2DArray() && (s3 = i2[e3].data[a3] ? i2[e3].data[a3][0] : "")), 0 === e3) {
                h2.push((d3 = s3, "datetime" === l2.config.xaxis.type && String(d3).length >= 10 ? l2.config.chart.toolbar.export.csv.dateFormatter(s3) : x.isNumber(s3) ? s3 : s3.split(r2).join("")));
                for (var o3 = 0; o3 < l2.globals.series.length; o3++) {
                  var n3;
                  if (f2.isFormatXY())
                    h2.push(null === (n3 = i2[o3].data[a3]) || void 0 === n3 ? void 0 : n3.y);
                  else
                    h2.push(g2[o3][a3]);
                }
              }
              ("candlestick" === l2.config.chart.type || t4.type && "candlestick" === t4.type) && (h2.pop(), h2.push(l2.globals.seriesCandleO[e3][a3]), h2.push(l2.globals.seriesCandleH[e3][a3]), h2.push(l2.globals.seriesCandleL[e3][a3]), h2.push(l2.globals.seriesCandleC[e3][a3])), ("boxPlot" === l2.config.chart.type || t4.type && "boxPlot" === t4.type) && (h2.pop(), h2.push(l2.globals.seriesCandleO[e3][a3]), h2.push(l2.globals.seriesCandleH[e3][a3]), h2.push(l2.globals.seriesCandleM[e3][a3]), h2.push(l2.globals.seriesCandleL[e3][a3]), h2.push(l2.globals.seriesCandleC[e3][a3])), "rangeBar" === l2.config.chart.type && (h2.pop(), h2.push(l2.globals.seriesRangeStart[e3][a3]), h2.push(l2.globals.seriesRangeEnd[e3][a3])), h2.length && c2.push(h2.join(r2));
            }
          }
          var d3;
        };
        h2.push(l2.config.chart.toolbar.export.csv.headerCategory), "boxPlot" === l2.config.chart.type ? (h2.push("minimum"), h2.push("q1"), h2.push("median"), h2.push("q3"), h2.push("maximum")) : "candlestick" === l2.config.chart.type ? (h2.push("open"), h2.push("high"), h2.push("low"), h2.push("close")) : "rangeBar" === l2.config.chart.type ? (h2.push("minimum"), h2.push("maximum")) : i2.map(function(t4, e3) {
          var i3 = (t4.name ? t4.name : "series-".concat(e3)) + "";
          l2.globals.axisCharts && h2.push(i3.split(r2).join("") ? i3.split(r2).join("") : "series-".concat(e3));
        }), l2.globals.axisCharts || (h2.push(l2.config.chart.toolbar.export.csv.headerValue), c2.push(h2.join(r2))), i2.map(function(t4, e3) {
          l2.globals.axisCharts ? m2(t4, e3) : ((h2 = []).push(l2.globals.labels[e3].split(r2).join("")), h2.push(g2[e3]), c2.push(h2.join(r2)));
        }), d2 += c2.join(n2), this.triggerDownload("data:text/csv; charset=utf-8," + encodeURIComponent("\uFEFF" + d2), a2 || l2.config.chart.toolbar.export.csv.filename, ".csv");
      } }, { key: "triggerDownload", value: function(t3, e2, i2) {
        var a2 = document.createElement("a");
        a2.href = t3, a2.download = (e2 || this.w.globals.chartID) + i2, document.body.appendChild(a2), a2.click(), document.body.removeChild(a2);
      } }]), t2;
    }();
    var V = function() {
      function t2(e2, i2) {
        a(this, t2), this.ctx = e2, this.elgrid = i2, this.w = e2.w;
        var s2 = this.w;
        this.axesUtils = new B(e2), this.xaxisLabels = s2.globals.labels.slice(), s2.globals.timescaleLabels.length > 0 && !s2.globals.isBarHorizontal && (this.xaxisLabels = s2.globals.timescaleLabels.slice()), s2.config.xaxis.overwriteCategories && (this.xaxisLabels = s2.config.xaxis.overwriteCategories), this.drawnLabels = [], this.drawnLabelsRects = [], "top" === s2.config.xaxis.position ? this.offY = 0 : this.offY = s2.globals.gridHeight + 1, this.offY = this.offY + s2.config.xaxis.axisBorder.offsetY, this.isCategoryBarHorizontal = "bar" === s2.config.chart.type && s2.config.plotOptions.bar.horizontal, this.xaxisFontSize = s2.config.xaxis.labels.style.fontSize, this.xaxisFontFamily = s2.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = s2.config.xaxis.labels.style.colors, this.xaxisBorderWidth = s2.config.xaxis.axisBorder.width, this.isCategoryBarHorizontal && (this.xaxisBorderWidth = s2.config.yaxis[0].axisBorder.width.toString()), this.xaxisBorderWidth.indexOf("%") > -1 ? this.xaxisBorderWidth = s2.globals.gridWidth * parseInt(this.xaxisBorderWidth, 10) / 100 : this.xaxisBorderWidth = parseInt(this.xaxisBorderWidth, 10), this.xaxisBorderHeight = s2.config.xaxis.axisBorder.height, this.yaxis = s2.config.yaxis[0];
      }
      return r(t2, [{ key: "drawXaxis", value: function() {
        var t3 = this.w, e2 = new m(this.ctx), i2 = e2.group({ class: "apexcharts-xaxis", transform: "translate(".concat(t3.config.xaxis.offsetX, ", ").concat(t3.config.xaxis.offsetY, ")") }), a2 = e2.group({ class: "apexcharts-xaxis-texts-g", transform: "translate(".concat(t3.globals.translateXAxisX, ", ").concat(t3.globals.translateXAxisY, ")") });
        i2.add(a2);
        for (var s2 = [], r2 = 0; r2 < this.xaxisLabels.length; r2++)
          s2.push(this.xaxisLabels[r2]);
        if (this.drawXAxisLabelAndGroup(true, e2, a2, s2, t3.globals.isXNumeric, function(t4, e3) {
          return e3;
        }), t3.globals.hasXaxisGroups) {
          var o2 = t3.globals.groups;
          s2 = [];
          for (var n2 = 0; n2 < o2.length; n2++)
            s2.push(o2[n2].title);
          var l2 = {};
          t3.config.xaxis.group.style && (l2.xaxisFontSize = t3.config.xaxis.group.style.fontSize, l2.xaxisFontFamily = t3.config.xaxis.group.style.fontFamily, l2.xaxisForeColors = t3.config.xaxis.group.style.colors, l2.fontWeight = t3.config.xaxis.group.style.fontWeight, l2.cssClass = t3.config.xaxis.group.style.cssClass), this.drawXAxisLabelAndGroup(false, e2, a2, s2, false, function(t4, e3) {
            return o2[t4].cols * e3;
          }, l2);
        }
        if (void 0 !== t3.config.xaxis.title.text) {
          var h2 = e2.group({ class: "apexcharts-xaxis-title" }), c2 = e2.drawText({ x: t3.globals.gridWidth / 2 + t3.config.xaxis.title.offsetX, y: this.offY + parseFloat(this.xaxisFontSize) + ("bottom" === t3.config.xaxis.position ? t3.globals.xAxisLabelsHeight : -t3.globals.xAxisLabelsHeight - 10) + t3.config.xaxis.title.offsetY, text: t3.config.xaxis.title.text, textAnchor: "middle", fontSize: t3.config.xaxis.title.style.fontSize, fontFamily: t3.config.xaxis.title.style.fontFamily, fontWeight: t3.config.xaxis.title.style.fontWeight, foreColor: t3.config.xaxis.title.style.color, cssClass: "apexcharts-xaxis-title-text " + t3.config.xaxis.title.style.cssClass });
          h2.add(c2), i2.add(h2);
        }
        if (t3.config.xaxis.axisBorder.show) {
          var d2 = t3.globals.barPadForNumericAxis, g2 = e2.drawLine(t3.globals.padHorizontal + t3.config.xaxis.axisBorder.offsetX - d2, this.offY, this.xaxisBorderWidth + d2, this.offY, t3.config.xaxis.axisBorder.color, 0, this.xaxisBorderHeight);
          this.elgrid && this.elgrid.elGridBorders && t3.config.grid.show ? this.elgrid.elGridBorders.add(g2) : i2.add(g2);
        }
        return i2;
      } }, { key: "drawXAxisLabelAndGroup", value: function(t3, e2, i2, a2, s2, r2) {
        var o2, n2 = this, l2 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : {}, h2 = [], c2 = [], d2 = this.w, g2 = l2.xaxisFontSize || this.xaxisFontSize, u2 = l2.xaxisFontFamily || this.xaxisFontFamily, p2 = l2.xaxisForeColors || this.xaxisForeColors, f2 = l2.fontWeight || d2.config.xaxis.labels.style.fontWeight, x2 = l2.cssClass || d2.config.xaxis.labels.style.cssClass, b2 = d2.globals.padHorizontal, v2 = a2.length, m2 = "category" === d2.config.xaxis.type ? d2.globals.dataPoints : v2;
        if (0 === m2 && v2 > m2 && (m2 = v2), s2) {
          var y2 = m2 > 1 ? m2 - 1 : m2;
          o2 = d2.globals.gridWidth / Math.min(y2, v2 - 1), b2 = b2 + r2(0, o2) / 2 + d2.config.xaxis.labels.offsetX;
        } else
          o2 = d2.globals.gridWidth / m2, b2 = b2 + r2(0, o2) + d2.config.xaxis.labels.offsetX;
        for (var w2 = function(s3) {
          var l3 = b2 - r2(s3, o2) / 2 + d2.config.xaxis.labels.offsetX;
          0 === s3 && 1 === v2 && o2 / 2 === b2 && 1 === m2 && (l3 = d2.globals.gridWidth / 2);
          var y3 = n2.axesUtils.getLabel(a2, d2.globals.timescaleLabels, l3, s3, h2, g2, t3), w3 = 28;
          d2.globals.rotateXLabels && t3 && (w3 = 22), d2.config.xaxis.title.text && "top" === d2.config.xaxis.position && (w3 += parseFloat(d2.config.xaxis.title.style.fontSize) + 2), t3 || (w3 = w3 + parseFloat(g2) + (d2.globals.xAxisLabelsHeight - d2.globals.xAxisGroupLabelsHeight) + (d2.globals.rotateXLabels ? 10 : 0)), y3 = void 0 !== d2.config.xaxis.tickAmount && "dataPoints" !== d2.config.xaxis.tickAmount && "datetime" !== d2.config.xaxis.type ? n2.axesUtils.checkLabelBasedOnTickamount(s3, y3, v2) : n2.axesUtils.checkForOverflowingLabels(s3, y3, v2, h2, c2);
          if (d2.config.xaxis.labels.show) {
            var k3 = e2.drawText({ x: y3.x, y: n2.offY + d2.config.xaxis.labels.offsetY + w3 - ("top" === d2.config.xaxis.position ? d2.globals.xAxisHeight + d2.config.xaxis.axisTicks.height - 2 : 0), text: y3.text, textAnchor: "middle", fontWeight: y3.isBold ? 600 : f2, fontSize: g2, fontFamily: u2, foreColor: Array.isArray(p2) ? t3 && d2.config.xaxis.convertedCatToNumeric ? p2[d2.globals.minX + s3 - 1] : p2[s3] : p2, isPlainText: false, cssClass: (t3 ? "apexcharts-xaxis-label " : "apexcharts-xaxis-group-label ") + x2 });
            if (i2.add(k3), k3.on("click", function(t4) {
              if ("function" == typeof d2.config.chart.events.xAxisLabelClick) {
                var e3 = Object.assign({}, d2, { labelIndex: s3 });
                d2.config.chart.events.xAxisLabelClick(t4, n2.ctx, e3);
              }
            }), t3) {
              var A2 = document.createElementNS(d2.globals.SVGNS, "title");
              A2.textContent = Array.isArray(y3.text) ? y3.text.join(" ") : y3.text, k3.node.appendChild(A2), "" !== y3.text && (h2.push(y3.text), c2.push(y3));
            }
          }
          s3 < v2 - 1 && (b2 += r2(s3 + 1, o2));
        }, k2 = 0; k2 <= v2 - 1; k2++)
          w2(k2);
      } }, { key: "drawXaxisInversed", value: function(t3) {
        var e2, i2, a2 = this, s2 = this.w, r2 = new m(this.ctx), o2 = s2.config.yaxis[0].opposite ? s2.globals.translateYAxisX[t3] : 0, n2 = r2.group({ class: "apexcharts-yaxis apexcharts-xaxis-inversed", rel: t3 }), l2 = r2.group({ class: "apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g", transform: "translate(" + o2 + ", 0)" });
        n2.add(l2);
        var h2 = [];
        if (s2.config.yaxis[t3].show)
          for (var c2 = 0; c2 < this.xaxisLabels.length; c2++)
            h2.push(this.xaxisLabels[c2]);
        e2 = s2.globals.gridHeight / h2.length, i2 = -e2 / 2.2;
        var d2 = s2.globals.yLabelFormatters[0], g2 = s2.config.yaxis[0].labels;
        if (g2.show)
          for (var u2 = function(o3) {
            var n3 = void 0 === h2[o3] ? "" : h2[o3];
            n3 = d2(n3, { seriesIndex: t3, dataPointIndex: o3, w: s2 });
            var c3 = a2.axesUtils.getYAxisForeColor(g2.style.colors, t3), u3 = 0;
            Array.isArray(n3) && (u3 = n3.length / 2 * parseInt(g2.style.fontSize, 10));
            var p3 = g2.offsetX - 15, f3 = "end";
            a2.yaxis.opposite && (f3 = "start"), "left" === s2.config.yaxis[0].labels.align ? (p3 = g2.offsetX, f3 = "start") : "center" === s2.config.yaxis[0].labels.align ? (p3 = g2.offsetX, f3 = "middle") : "right" === s2.config.yaxis[0].labels.align && (f3 = "end");
            var x3 = r2.drawText({ x: p3, y: i2 + e2 + g2.offsetY - u3, text: n3, textAnchor: f3, foreColor: Array.isArray(c3) ? c3[o3] : c3, fontSize: g2.style.fontSize, fontFamily: g2.style.fontFamily, fontWeight: g2.style.fontWeight, isPlainText: false, cssClass: "apexcharts-yaxis-label " + g2.style.cssClass, maxWidth: g2.maxWidth });
            l2.add(x3), x3.on("click", function(t4) {
              if ("function" == typeof s2.config.chart.events.xAxisLabelClick) {
                var e3 = Object.assign({}, s2, { labelIndex: o3 });
                s2.config.chart.events.xAxisLabelClick(t4, a2.ctx, e3);
              }
            });
            var b3 = document.createElementNS(s2.globals.SVGNS, "title");
            if (b3.textContent = Array.isArray(n3) ? n3.join(" ") : n3, x3.node.appendChild(b3), 0 !== s2.config.yaxis[t3].labels.rotate) {
              var v3 = r2.rotateAroundCenter(x3.node);
              x3.node.setAttribute("transform", "rotate(".concat(s2.config.yaxis[t3].labels.rotate, " 0 ").concat(v3.y, ")"));
            }
            i2 += e2;
          }, p2 = 0; p2 <= h2.length - 1; p2++)
            u2(p2);
        if (void 0 !== s2.config.yaxis[0].title.text) {
          var f2 = r2.group({ class: "apexcharts-yaxis-title apexcharts-xaxis-title-inversed", transform: "translate(" + o2 + ", 0)" }), x2 = r2.drawText({ x: s2.config.yaxis[0].title.offsetX, y: s2.globals.gridHeight / 2 + s2.config.yaxis[0].title.offsetY, text: s2.config.yaxis[0].title.text, textAnchor: "middle", foreColor: s2.config.yaxis[0].title.style.color, fontSize: s2.config.yaxis[0].title.style.fontSize, fontWeight: s2.config.yaxis[0].title.style.fontWeight, fontFamily: s2.config.yaxis[0].title.style.fontFamily, cssClass: "apexcharts-yaxis-title-text " + s2.config.yaxis[0].title.style.cssClass });
          f2.add(x2), n2.add(f2);
        }
        var b2 = 0;
        this.isCategoryBarHorizontal && s2.config.yaxis[0].opposite && (b2 = s2.globals.gridWidth);
        var v2 = s2.config.xaxis.axisBorder;
        if (v2.show) {
          var y2 = r2.drawLine(s2.globals.padHorizontal + v2.offsetX + b2, 1 + v2.offsetY, s2.globals.padHorizontal + v2.offsetX + b2, s2.globals.gridHeight + v2.offsetY, v2.color, 0);
          this.elgrid && this.elgrid.elGridBorders && s2.config.grid.show ? this.elgrid.elGridBorders.add(y2) : n2.add(y2);
        }
        return s2.config.yaxis[0].axisTicks.show && this.axesUtils.drawYAxisTicks(b2, h2.length, s2.config.yaxis[0].axisBorder, s2.config.yaxis[0].axisTicks, 0, e2, n2), n2;
      } }, { key: "drawXaxisTicks", value: function(t3, e2, i2) {
        var a2 = this.w, s2 = t3;
        if (!(t3 < 0 || t3 - 2 > a2.globals.gridWidth)) {
          var r2 = this.offY + a2.config.xaxis.axisTicks.offsetY;
          if (e2 = e2 + r2 + a2.config.xaxis.axisTicks.height, "top" === a2.config.xaxis.position && (e2 = r2 - a2.config.xaxis.axisTicks.height), a2.config.xaxis.axisTicks.show) {
            var o2 = new m(this.ctx).drawLine(t3 + a2.config.xaxis.axisTicks.offsetX, r2 + a2.config.xaxis.offsetY, s2 + a2.config.xaxis.axisTicks.offsetX, e2 + a2.config.xaxis.offsetY, a2.config.xaxis.axisTicks.color);
            i2.add(o2), o2.node.classList.add("apexcharts-xaxis-tick");
          }
        }
      } }, { key: "getXAxisTicksPositions", value: function() {
        var t3 = this.w, e2 = [], i2 = this.xaxisLabels.length, a2 = t3.globals.padHorizontal;
        if (t3.globals.timescaleLabels.length > 0)
          for (var s2 = 0; s2 < i2; s2++)
            a2 = this.xaxisLabels[s2].position, e2.push(a2);
        else
          for (var r2 = i2, o2 = 0; o2 < r2; o2++) {
            var n2 = r2;
            t3.globals.isXNumeric && "bar" !== t3.config.chart.type && (n2 -= 1), a2 += t3.globals.gridWidth / n2, e2.push(a2);
          }
        return e2;
      } }, { key: "xAxisLabelCorrections", value: function() {
        var t3 = this.w, e2 = new m(this.ctx), i2 = t3.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g"), a2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-texts-g text:not(.apexcharts-xaxis-group-label)"), s2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-inversed text"), r2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-inversed-texts-g text tspan");
        if (t3.globals.rotateXLabels || t3.config.xaxis.labels.rotateAlways)
          for (var o2 = 0; o2 < a2.length; o2++) {
            var n2 = e2.rotateAroundCenter(a2[o2]);
            n2.y = n2.y - 1, n2.x = n2.x + 1, a2[o2].setAttribute("transform", "rotate(".concat(t3.config.xaxis.labels.rotate, " ").concat(n2.x, " ").concat(n2.y, ")")), a2[o2].setAttribute("text-anchor", "end");
            i2.setAttribute("transform", "translate(0, ".concat(-10, ")"));
            var l2 = a2[o2].childNodes;
            t3.config.xaxis.labels.trim && Array.prototype.forEach.call(l2, function(i3) {
              e2.placeTextWithEllipsis(i3, i3.textContent, t3.globals.xAxisLabelsHeight - ("bottom" === t3.config.legend.position ? 20 : 10));
            });
          }
        else
          !function() {
            for (var i3 = t3.globals.gridWidth / (t3.globals.labels.length + 1), s3 = 0; s3 < a2.length; s3++) {
              var r3 = a2[s3].childNodes;
              t3.config.xaxis.labels.trim && "datetime" !== t3.config.xaxis.type && Array.prototype.forEach.call(r3, function(t4) {
                e2.placeTextWithEllipsis(t4, t4.textContent, i3);
              });
            }
          }();
        if (s2.length > 0) {
          var h2 = s2[s2.length - 1].getBBox(), c2 = s2[0].getBBox();
          h2.x < -20 && s2[s2.length - 1].parentNode.removeChild(s2[s2.length - 1]), c2.x + c2.width > t3.globals.gridWidth && !t3.globals.isBarHorizontal && s2[0].parentNode.removeChild(s2[0]);
          for (var d2 = 0; d2 < r2.length; d2++)
            e2.placeTextWithEllipsis(r2[d2], r2[d2].textContent, t3.config.yaxis[0].labels.maxWidth - (t3.config.yaxis[0].title.text ? 2 * parseFloat(t3.config.yaxis[0].title.style.fontSize) : 0) - 15);
        }
      } }]), t2;
    }();
    var j = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
        var i2 = this.w;
        this.xaxisLabels = i2.globals.labels.slice(), this.axesUtils = new B(e2), this.isRangeBar = i2.globals.seriesRange.length && i2.globals.isBarHorizontal, i2.globals.timescaleLabels.length > 0 && (this.xaxisLabels = i2.globals.timescaleLabels.slice());
      }
      return r(t2, [{ key: "drawGridArea", value: function() {
        var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, e2 = this.w, i2 = new m(this.ctx);
        null === t3 && (t3 = i2.group({ class: "apexcharts-grid" }));
        var a2 = i2.drawLine(e2.globals.padHorizontal, 1, e2.globals.padHorizontal, e2.globals.gridHeight, "transparent"), s2 = i2.drawLine(e2.globals.padHorizontal, e2.globals.gridHeight, e2.globals.gridWidth, e2.globals.gridHeight, "transparent");
        return t3.add(s2), t3.add(a2), t3;
      } }, { key: "drawGrid", value: function() {
        var t3 = null;
        return this.w.globals.axisCharts && (t3 = this.renderGrid(), this.drawGridArea(t3.el)), t3;
      } }, { key: "createGridMask", value: function() {
        var t3 = this.w, e2 = t3.globals, i2 = new m(this.ctx), a2 = Array.isArray(t3.config.stroke.width) ? 0 : t3.config.stroke.width;
        if (Array.isArray(t3.config.stroke.width)) {
          var s2 = 0;
          t3.config.stroke.width.forEach(function(t4) {
            s2 = Math.max(s2, t4);
          }), a2 = s2;
        }
        e2.dom.elGridRectMask = document.createElementNS(e2.SVGNS, "clipPath"), e2.dom.elGridRectMask.setAttribute("id", "gridRectMask".concat(e2.cuid)), e2.dom.elGridRectMarkerMask = document.createElementNS(e2.SVGNS, "clipPath"), e2.dom.elGridRectMarkerMask.setAttribute("id", "gridRectMarkerMask".concat(e2.cuid)), e2.dom.elForecastMask = document.createElementNS(e2.SVGNS, "clipPath"), e2.dom.elForecastMask.setAttribute("id", "forecastMask".concat(e2.cuid)), e2.dom.elNonForecastMask = document.createElementNS(e2.SVGNS, "clipPath"), e2.dom.elNonForecastMask.setAttribute("id", "nonForecastMask".concat(e2.cuid));
        var r2 = t3.config.chart.type, o2 = 0, n2 = 0;
        ("bar" === r2 || "rangeBar" === r2 || "candlestick" === r2 || "boxPlot" === r2 || t3.globals.comboBarCount > 0) && t3.globals.isXNumeric && !t3.globals.isBarHorizontal && (o2 = t3.config.grid.padding.left, n2 = t3.config.grid.padding.right, e2.barPadForNumericAxis > o2 && (o2 = e2.barPadForNumericAxis, n2 = e2.barPadForNumericAxis)), e2.dom.elGridRect = i2.drawRect(-a2 / 2 - o2 - 2, -a2 / 2, e2.gridWidth + a2 + n2 + o2 + 4, e2.gridHeight + a2, 0, "#fff");
        var l2 = t3.globals.markers.largestSize + 1;
        e2.dom.elGridRectMarker = i2.drawRect(2 * -l2, 2 * -l2, e2.gridWidth + 4 * l2, e2.gridHeight + 4 * l2, 0, "#fff"), e2.dom.elGridRectMask.appendChild(e2.dom.elGridRect.node), e2.dom.elGridRectMarkerMask.appendChild(e2.dom.elGridRectMarker.node);
        var h2 = e2.dom.baseEl.querySelector("defs");
        h2.appendChild(e2.dom.elGridRectMask), h2.appendChild(e2.dom.elForecastMask), h2.appendChild(e2.dom.elNonForecastMask), h2.appendChild(e2.dom.elGridRectMarkerMask);
      } }, { key: "_drawGridLines", value: function(t3) {
        var e2 = t3.i, i2 = t3.x1, a2 = t3.y1, s2 = t3.x2, r2 = t3.y2, o2 = t3.xCount, n2 = t3.parent, l2 = this.w;
        if (!(0 === e2 && l2.globals.skipFirstTimelinelabel || e2 === o2 - 1 && l2.globals.skipLastTimelinelabel && !l2.config.xaxis.labels.formatter || "radar" === l2.config.chart.type)) {
          l2.config.grid.xaxis.lines.show && this._drawGridLine({ i: e2, x1: i2, y1: a2, x2: s2, y2: r2, xCount: o2, parent: n2 });
          var h2 = 0;
          if (l2.globals.hasXaxisGroups && "between" === l2.config.xaxis.tickPlacement) {
            var c2 = l2.globals.groups;
            if (c2) {
              for (var d2 = 0, g2 = 0; d2 < e2 && g2 < c2.length; g2++)
                d2 += c2[g2].cols;
              d2 === e2 && (h2 = 0.6 * l2.globals.xAxisLabelsHeight);
            }
          }
          new V(this.ctx).drawXaxisTicks(i2, h2, l2.globals.dom.elGraphical);
        }
      } }, { key: "_drawGridLine", value: function(t3) {
        var e2 = t3.i, i2 = t3.x1, a2 = t3.y1, s2 = t3.x2, r2 = t3.y2, o2 = t3.xCount, n2 = t3.parent, l2 = this.w, h2 = false, c2 = n2.node.classList.contains("apexcharts-gridlines-horizontal"), d2 = l2.config.grid.strokeDashArray, g2 = l2.globals.barPadForNumericAxis;
        (0 === a2 && 0 === r2 || 0 === i2 && 0 === s2) && (h2 = true), a2 === l2.globals.gridHeight && r2 === l2.globals.gridHeight && (h2 = true), !l2.globals.isBarHorizontal || 0 !== e2 && e2 !== o2 - 1 || (h2 = true);
        var u2 = new m(this).drawLine(i2 - (c2 ? g2 : 0), a2, s2 + (c2 ? g2 : 0), r2, l2.config.grid.borderColor, d2);
        u2.node.classList.add("apexcharts-gridline"), h2 && l2.config.grid.show ? this.elGridBorders.add(u2) : n2.add(u2);
      } }, { key: "_drawGridBandRect", value: function(t3) {
        var e2 = t3.c, i2 = t3.x1, a2 = t3.y1, s2 = t3.x2, r2 = t3.y2, o2 = t3.type, n2 = this.w, l2 = new m(this.ctx), h2 = n2.globals.barPadForNumericAxis;
        if ("column" !== o2 || "datetime" !== n2.config.xaxis.type) {
          var c2 = n2.config.grid[o2].colors[e2], d2 = l2.drawRect(i2 - ("row" === o2 ? h2 : 0), a2, s2 + ("row" === o2 ? 2 * h2 : 0), r2, 0, c2, n2.config.grid[o2].opacity);
          this.elg.add(d2), d2.attr("clip-path", "url(#gridRectMask".concat(n2.globals.cuid, ")")), d2.node.classList.add("apexcharts-grid-".concat(o2));
        }
      } }, { key: "_drawXYLines", value: function(t3) {
        var e2 = this, i2 = t3.xCount, a2 = t3.tickAmount, s2 = this.w;
        if (s2.config.grid.xaxis.lines.show || s2.config.xaxis.axisTicks.show) {
          var r2, o2 = s2.globals.padHorizontal, n2 = s2.globals.gridHeight;
          s2.globals.timescaleLabels.length ? function(t4) {
            for (var a3 = t4.xC, s3 = t4.x1, r3 = t4.y1, o3 = t4.x2, n3 = t4.y2, l3 = 0; l3 < a3; l3++)
              s3 = e2.xaxisLabels[l3].position, o3 = e2.xaxisLabels[l3].position, e2._drawGridLines({ i: l3, x1: s3, y1: r3, x2: o3, y2: n3, xCount: i2, parent: e2.elgridLinesV });
          }({ xC: i2, x1: o2, y1: 0, x2: r2, y2: n2 }) : (s2.globals.isXNumeric && (i2 = s2.globals.xAxisScale.result.length), function(t4) {
            for (var a3 = t4.xC, r3 = t4.x1, o3 = t4.y1, n3 = t4.x2, l3 = t4.y2, h3 = 0; h3 < a3 + (s2.globals.isXNumeric ? 0 : 1); h3++)
              0 === h3 && 1 === a3 && 1 === s2.globals.dataPoints && (n3 = r3 = s2.globals.gridWidth / 2), e2._drawGridLines({ i: h3, x1: r3, y1: o3, x2: n3, y2: l3, xCount: i2, parent: e2.elgridLinesV }), n3 = r3 += s2.globals.gridWidth / (s2.globals.isXNumeric ? a3 - 1 : a3);
          }({ xC: i2, x1: o2, y1: 0, x2: r2, y2: n2 }));
        }
        if (s2.config.grid.yaxis.lines.show) {
          var l2 = 0, h2 = 0, c2 = s2.globals.gridWidth, d2 = a2 + 1;
          this.isRangeBar && (d2 = s2.globals.labels.length);
          for (var g2 = 0; g2 < d2 + (this.isRangeBar ? 1 : 0); g2++)
            this._drawGridLine({ i: g2, xCount: d2 + (this.isRangeBar ? 1 : 0), x1: 0, y1: l2, x2: c2, y2: h2, parent: this.elgridLinesH }), h2 = l2 += s2.globals.gridHeight / (this.isRangeBar ? d2 : a2);
        }
      } }, { key: "_drawInvertedXYLines", value: function(t3) {
        var e2 = t3.xCount, i2 = this.w;
        if (i2.config.grid.xaxis.lines.show || i2.config.xaxis.axisTicks.show)
          for (var a2, s2 = i2.globals.padHorizontal, r2 = i2.globals.gridHeight, o2 = 0; o2 < e2 + 1; o2++) {
            i2.config.grid.xaxis.lines.show && this._drawGridLine({ i: o2, xCount: e2 + 1, x1: s2, y1: 0, x2: a2, y2: r2, parent: this.elgridLinesV }), new V(this.ctx).drawXaxisTicks(s2, 0, i2.globals.dom.elGraphical), a2 = s2 = s2 + i2.globals.gridWidth / e2 + 0.3;
          }
        if (i2.config.grid.yaxis.lines.show)
          for (var n2 = 0, l2 = 0, h2 = i2.globals.gridWidth, c2 = 0; c2 < i2.globals.dataPoints + 1; c2++)
            this._drawGridLine({ i: c2, xCount: i2.globals.dataPoints + 1, x1: 0, y1: n2, x2: h2, y2: l2, parent: this.elgridLinesH }), l2 = n2 += i2.globals.gridHeight / i2.globals.dataPoints;
      } }, { key: "renderGrid", value: function() {
        var t3 = this.w, e2 = new m(this.ctx);
        this.elg = e2.group({ class: "apexcharts-grid" }), this.elgridLinesH = e2.group({ class: "apexcharts-gridlines-horizontal" }), this.elgridLinesV = e2.group({ class: "apexcharts-gridlines-vertical" }), this.elGridBorders = e2.group({ class: "apexcharts-grid-borders" }), this.elg.add(this.elgridLinesH), this.elg.add(this.elgridLinesV), t3.config.grid.show || (this.elgridLinesV.hide(), this.elgridLinesH.hide(), this.elGridBorders.hide());
        for (var i2, a2 = t3.globals.yAxisScale.length ? t3.globals.yAxisScale[0].result.length - 1 : 5, s2 = 0; s2 < t3.globals.series.length && (void 0 !== t3.globals.yAxisScale[s2] && (a2 = t3.globals.yAxisScale[s2].result.length - 1), !(a2 > 2)); s2++)
          ;
        return !t3.globals.isBarHorizontal || this.isRangeBar ? (i2 = this.xaxisLabels.length, this.isRangeBar && (i2--, a2 = t3.globals.labels.length, t3.config.xaxis.tickAmount && t3.config.xaxis.labels.formatter && (i2 = t3.config.xaxis.tickAmount)), this._drawXYLines({ xCount: i2, tickAmount: a2 })) : (i2 = a2, a2 = t3.globals.xTickAmount, this._drawInvertedXYLines({ xCount: i2, tickAmount: a2 })), this.drawGridBands(i2, a2), { el: this.elg, elGridBorders: this.elGridBorders, xAxisTickWidth: t3.globals.gridWidth / i2 };
      } }, { key: "drawGridBands", value: function(t3, e2) {
        var i2 = this.w;
        if (void 0 !== i2.config.grid.row.colors && i2.config.grid.row.colors.length > 0)
          for (var a2 = 0, s2 = i2.globals.gridHeight / e2, r2 = i2.globals.gridWidth, o2 = 0, n2 = 0; o2 < e2; o2++, n2++)
            n2 >= i2.config.grid.row.colors.length && (n2 = 0), this._drawGridBandRect({ c: n2, x1: 0, y1: a2, x2: r2, y2: s2, type: "row" }), a2 += i2.globals.gridHeight / e2;
        if (void 0 !== i2.config.grid.column.colors && i2.config.grid.column.colors.length > 0)
          for (var l2 = i2.globals.isBarHorizontal || "on" !== i2.config.xaxis.tickPlacement || "category" !== i2.config.xaxis.type && !i2.config.xaxis.convertedCatToNumeric ? t3 : t3 - 1, h2 = i2.globals.padHorizontal, c2 = i2.globals.padHorizontal + i2.globals.gridWidth / l2, d2 = i2.globals.gridHeight, g2 = 0, u2 = 0; g2 < t3; g2++, u2++)
            u2 >= i2.config.grid.column.colors.length && (u2 = 0), this._drawGridBandRect({ c: u2, x1: h2, y1: 0, x2: c2, y2: d2, type: "column" }), h2 += i2.globals.gridWidth / l2;
      } }]), t2;
    }();
    var _ = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
      }
      return r(t2, [{ key: "niceScale", value: function(t3, e2) {
        var i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10, a2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, s2 = arguments.length > 4 ? arguments[4] : void 0, r2 = this.w, o2 = Math.abs(e2 - t3);
        if ("dataPoints" === (i2 = this._adjustTicksForSmallRange(i2, a2, o2)) && (i2 = r2.globals.dataPoints - 1), t3 === Number.MIN_VALUE && 0 === e2 || !x.isNumber(t3) && !x.isNumber(e2) || t3 === Number.MIN_VALUE && e2 === -Number.MAX_VALUE)
          return t3 = 0, e2 = i2, this.linearScale(t3, e2, i2);
        t3 > e2 ? (console.warn("axis.min cannot be greater than axis.max"), e2 = t3 + 0.1) : t3 === e2 && (t3 = 0 === t3 ? 0 : t3 - 0.5, e2 = 0 === e2 ? 2 : e2 + 0.5);
        var n2 = [];
        o2 < 1 && s2 && ("candlestick" === r2.config.chart.type || "candlestick" === r2.config.series[a2].type || "boxPlot" === r2.config.chart.type || "boxPlot" === r2.config.series[a2].type || r2.globals.isRangeData) && (e2 *= 1.01);
        var l2 = i2 + 1;
        l2 < 2 ? l2 = 2 : l2 > 2 && (l2 -= 2);
        var h2 = o2 / l2, c2 = Math.floor(x.log10(h2)), d2 = Math.pow(10, c2), g2 = Math.round(h2 / d2);
        g2 < 1 && (g2 = 1);
        var u2 = g2 * d2, p2 = u2 * Math.floor(t3 / u2), f2 = u2 * Math.ceil(e2 / u2), b2 = p2;
        if (s2 && o2 > 2) {
          for (; n2.push(x.stripNumber(b2, 7)), !((b2 += u2) > f2); )
            ;
          return { result: n2, niceMin: n2[0], niceMax: n2[n2.length - 1] };
        }
        var v2 = t3;
        (n2 = []).push(x.stripNumber(v2, 7));
        for (var m2 = Math.abs(e2 - t3) / i2, y2 = 0; y2 <= i2; y2++)
          v2 += m2, n2.push(v2);
        return n2[n2.length - 2] >= e2 && n2.pop(), { result: n2, niceMin: n2[0], niceMax: n2[n2.length - 1] };
      } }, { key: "linearScale", value: function(t3, e2) {
        var i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10, a2 = arguments.length > 3 ? arguments[3] : void 0, s2 = Math.abs(e2 - t3);
        "dataPoints" === (i2 = this._adjustTicksForSmallRange(i2, a2, s2)) && (i2 = this.w.globals.dataPoints - 1);
        var r2 = s2 / i2;
        i2 === Number.MAX_VALUE && (i2 = 10, r2 = 1);
        for (var o2 = [], n2 = t3; i2 >= 0; )
          o2.push(n2), n2 += r2, i2 -= 1;
        return { result: o2, niceMin: o2[0], niceMax: o2[o2.length - 1] };
      } }, { key: "logarithmicScaleNice", value: function(t3, e2, i2) {
        e2 <= 0 && (e2 = Math.max(t3, i2)), t3 <= 0 && (t3 = Math.min(e2, i2));
        for (var a2 = [], s2 = Math.ceil(Math.log(e2) / Math.log(i2) + 1), r2 = Math.floor(Math.log(t3) / Math.log(i2)); r2 < s2; r2++)
          a2.push(Math.pow(i2, r2));
        return { result: a2, niceMin: a2[0], niceMax: a2[a2.length - 1] };
      } }, { key: "logarithmicScale", value: function(t3, e2, i2) {
        e2 <= 0 && (e2 = Math.max(t3, i2)), t3 <= 0 && (t3 = Math.min(e2, i2));
        for (var a2 = [], s2 = Math.log(e2) / Math.log(i2), r2 = Math.log(t3) / Math.log(i2), o2 = s2 - r2, n2 = Math.round(o2), l2 = o2 / n2, h2 = 0, c2 = r2; h2 < n2; h2++, c2 += l2)
          a2.push(Math.pow(i2, c2));
        return a2.push(Math.pow(i2, s2)), { result: a2, niceMin: t3, niceMax: e2 };
      } }, { key: "_adjustTicksForSmallRange", value: function(t3, e2, i2) {
        var a2 = t3;
        if (void 0 !== e2 && this.w.config.yaxis[e2].labels.formatter && void 0 === this.w.config.yaxis[e2].tickAmount) {
          var s2 = Number(this.w.config.yaxis[e2].labels.formatter(1));
          x.isNumber(s2) && 0 === this.w.globals.yValueDecimal && (a2 = Math.ceil(i2));
        }
        return a2 < t3 ? a2 : t3;
      } }, { key: "setYScaleForIndex", value: function(t3, e2, i2) {
        var a2 = this.w.globals, s2 = this.w.config, r2 = a2.isBarHorizontal ? s2.xaxis : s2.yaxis[t3];
        void 0 === a2.yAxisScale[t3] && (a2.yAxisScale[t3] = []);
        var o2 = Math.abs(i2 - e2);
        if (r2.logarithmic && o2 <= 5 && (a2.invalidLogScale = true), r2.logarithmic && o2 > 5)
          a2.allSeriesCollapsed = false, a2.yAxisScale[t3] = this.logarithmicScale(e2, i2, r2.logBase), a2.yAxisScale[t3] = r2.forceNiceScale ? this.logarithmicScaleNice(e2, i2, r2.logBase) : this.logarithmicScale(e2, i2, r2.logBase);
        else if (i2 !== -Number.MAX_VALUE && x.isNumber(i2))
          if (a2.allSeriesCollapsed = false, void 0 === r2.min && void 0 === r2.max || r2.forceNiceScale) {
            var n2 = void 0 === s2.yaxis[t3].max && void 0 === s2.yaxis[t3].min || s2.yaxis[t3].forceNiceScale;
            a2.yAxisScale[t3] = this.niceScale(e2, i2, r2.tickAmount ? r2.tickAmount : o2 < 5 && o2 > 1 ? o2 + 1 : 5, t3, n2);
          } else
            a2.yAxisScale[t3] = this.linearScale(e2, i2, r2.tickAmount, t3);
        else
          a2.yAxisScale[t3] = this.linearScale(0, 5, 5);
      } }, { key: "setXScale", value: function(t3, e2) {
        var i2 = this.w, a2 = i2.globals, s2 = i2.config.xaxis, r2 = Math.abs(e2 - t3);
        return e2 !== -Number.MAX_VALUE && x.isNumber(e2) ? a2.xAxisScale = this.linearScale(t3, e2, s2.tickAmount ? s2.tickAmount : r2 < 5 && r2 > 1 ? r2 + 1 : 5, 0) : a2.xAxisScale = this.linearScale(0, 5, 5), a2.xAxisScale;
      } }, { key: "setMultipleYScales", value: function() {
        var t3 = this, e2 = this.w.globals, i2 = this.w.config, a2 = e2.minYArr.concat([]), s2 = e2.maxYArr.concat([]), r2 = [];
        i2.yaxis.forEach(function(e3, o2) {
          var n2 = o2;
          i2.series.forEach(function(t4, i3) {
            t4.name === e3.seriesName && (n2 = i3, o2 !== i3 ? r2.push({ index: i3, similarIndex: o2, alreadyExists: true }) : r2.push({ index: i3 }));
          });
          var l2 = a2[n2], h2 = s2[n2];
          t3.setYScaleForIndex(o2, l2, h2);
        }), this.sameScaleInMultipleAxes(a2, s2, r2);
      } }, { key: "sameScaleInMultipleAxes", value: function(t3, e2, i2) {
        var a2 = this, s2 = this.w.config, r2 = this.w.globals, o2 = [];
        i2.forEach(function(t4) {
          t4.alreadyExists && (void 0 === o2[t4.index] && (o2[t4.index] = []), o2[t4.index].push(t4.index), o2[t4.index].push(t4.similarIndex));
        }), r2.yAxisSameScaleIndices = o2, o2.forEach(function(t4, e3) {
          o2.forEach(function(i3, a3) {
            var s3, r3;
            e3 !== a3 && (s3 = t4, r3 = i3, s3.filter(function(t5) {
              return -1 !== r3.indexOf(t5);
            })).length > 0 && (o2[e3] = o2[e3].concat(o2[a3]));
          });
        });
        var n2 = o2.map(function(t4) {
          return t4.filter(function(e3, i3) {
            return t4.indexOf(e3) === i3;
          });
        }).map(function(t4) {
          return t4.sort();
        });
        o2 = o2.filter(function(t4) {
          return !!t4;
        });
        var l2 = n2.slice(), h2 = l2.map(function(t4) {
          return JSON.stringify(t4);
        });
        l2 = l2.filter(function(t4, e3) {
          return h2.indexOf(JSON.stringify(t4)) === e3;
        });
        var c2 = [], d2 = [];
        t3.forEach(function(t4, i3) {
          l2.forEach(function(a3, s3) {
            a3.indexOf(i3) > -1 && (void 0 === c2[s3] && (c2[s3] = [], d2[s3] = []), c2[s3].push({ key: i3, value: t4 }), d2[s3].push({ key: i3, value: e2[i3] }));
          });
        });
        var g2 = Array.apply(null, Array(l2.length)).map(Number.prototype.valueOf, Number.MIN_VALUE), u2 = Array.apply(null, Array(l2.length)).map(Number.prototype.valueOf, -Number.MAX_VALUE);
        c2.forEach(function(t4, e3) {
          t4.forEach(function(t5, i3) {
            g2[e3] = Math.min(t5.value, g2[e3]);
          });
        }), d2.forEach(function(t4, e3) {
          t4.forEach(function(t5, i3) {
            u2[e3] = Math.max(t5.value, u2[e3]);
          });
        }), t3.forEach(function(t4, e3) {
          d2.forEach(function(t5, i3) {
            var o3 = g2[i3], n3 = u2[i3];
            s2.chart.stacked && (n3 = 0, t5.forEach(function(t6, e4) {
              t6.value !== -Number.MAX_VALUE && (n3 += t6.value), o3 !== Number.MIN_VALUE && (o3 += c2[i3][e4].value);
            })), t5.forEach(function(i4, l3) {
              t5[l3].key === e3 && (void 0 !== s2.yaxis[e3].min && (o3 = "function" == typeof s2.yaxis[e3].min ? s2.yaxis[e3].min(r2.minY) : s2.yaxis[e3].min), void 0 !== s2.yaxis[e3].max && (n3 = "function" == typeof s2.yaxis[e3].max ? s2.yaxis[e3].max(r2.maxY) : s2.yaxis[e3].max), a2.setYScaleForIndex(e3, o3, n3));
            });
          });
        });
      } }, { key: "autoScaleY", value: function(t3, e2, i2) {
        t3 || (t3 = this);
        var a2 = t3.w;
        if (a2.globals.isMultipleYAxis || a2.globals.collapsedSeries.length)
          return console.warn("autoScaleYaxis not supported in a multi-yaxis chart."), e2;
        var s2 = a2.globals.seriesX[0], r2 = a2.config.chart.stacked;
        return e2.forEach(function(t4, o2) {
          for (var n2 = 0, l2 = 0; l2 < s2.length; l2++)
            if (s2[l2] >= i2.xaxis.min) {
              n2 = l2;
              break;
            }
          var h2, c2, d2 = a2.globals.minYArr[o2], g2 = a2.globals.maxYArr[o2], u2 = a2.globals.stackedSeriesTotals;
          a2.globals.series.forEach(function(o3, l3) {
            var p2 = o3[n2];
            r2 ? (p2 = u2[n2], h2 = c2 = p2, u2.forEach(function(t5, e3) {
              s2[e3] <= i2.xaxis.max && s2[e3] >= i2.xaxis.min && (t5 > c2 && null !== t5 && (c2 = t5), o3[e3] < h2 && null !== o3[e3] && (h2 = o3[e3]));
            })) : (h2 = c2 = p2, o3.forEach(function(t5, e3) {
              if (s2[e3] <= i2.xaxis.max && s2[e3] >= i2.xaxis.min) {
                var r3 = t5, o4 = t5;
                a2.globals.series.forEach(function(i3, a3) {
                  null !== t5 && (r3 = Math.min(i3[e3], r3), o4 = Math.max(i3[e3], o4));
                }), o4 > c2 && null !== o4 && (c2 = o4), r3 < h2 && null !== r3 && (h2 = r3);
              }
            })), void 0 === h2 && void 0 === c2 && (h2 = d2, c2 = g2), c2 *= c2 < 0 ? 0.9 : 1.1, 0 === (h2 *= h2 < 0 ? 1.1 : 0.9) && 0 === c2 && (h2 = -1, c2 = 1), c2 < 0 && c2 < g2 && (c2 = g2), h2 < 0 && h2 > d2 && (h2 = d2), e2.length > 1 ? (e2[l3].min = void 0 === t4.min ? h2 : t4.min, e2[l3].max = void 0 === t4.max ? c2 : t4.max) : (e2[0].min = void 0 === t4.min ? h2 : t4.min, e2[0].max = void 0 === t4.max ? c2 : t4.max);
          });
        }), e2;
      } }]), t2;
    }();
    var U = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w, this.scales = new _(e2);
      }
      return r(t2, [{ key: "init", value: function() {
        this.setYRange(), this.setXRange(), this.setZRange();
      } }, { key: "getMinYMaxY", value: function(t3) {
        var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : -Number.MAX_VALUE, a2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, s2 = this.w.config, r2 = this.w.globals, o2 = -Number.MAX_VALUE, n2 = Number.MIN_VALUE;
        null === a2 && (a2 = t3 + 1);
        var l2 = r2.series, h2 = l2, c2 = l2;
        "candlestick" === s2.chart.type ? (h2 = r2.seriesCandleL, c2 = r2.seriesCandleH) : "boxPlot" === s2.chart.type ? (h2 = r2.seriesCandleO, c2 = r2.seriesCandleC) : r2.isRangeData && (h2 = r2.seriesRangeStart, c2 = r2.seriesRangeEnd);
        for (var d2 = t3; d2 < a2; d2++) {
          r2.dataPoints = Math.max(r2.dataPoints, l2[d2].length), r2.categoryLabels.length && (r2.dataPoints = r2.categoryLabels.filter(function(t4) {
            return void 0 !== t4;
          }).length), r2.labels.length && "datetime" !== s2.xaxis.type && 0 !== r2.series.reduce(function(t4, e3) {
            return t4 + e3.length;
          }, 0) && (r2.dataPoints = Math.max(r2.dataPoints, r2.labels.length));
          for (var g2 = 0; g2 < r2.series[d2].length; g2++) {
            var u2 = l2[d2][g2];
            null !== u2 && x.isNumber(u2) ? (void 0 !== c2[d2][g2] && (o2 = Math.max(o2, c2[d2][g2]), e2 = Math.min(e2, c2[d2][g2])), void 0 !== h2[d2][g2] && (e2 = Math.min(e2, h2[d2][g2]), i2 = Math.max(i2, h2[d2][g2])), "candlestick" !== this.w.config.chart.type && "boxPlot" !== this.w.config.chart.type && "rangeArea" === this.w.config.chart.type && "rangeBar" === this.w.config.chart.type || ("candlestick" !== this.w.config.chart.type && "boxPlot" !== this.w.config.chart.type || void 0 !== r2.seriesCandleC[d2][g2] && (o2 = Math.max(o2, r2.seriesCandleO[d2][g2]), o2 = Math.max(o2, r2.seriesCandleH[d2][g2]), o2 = Math.max(o2, r2.seriesCandleL[d2][g2]), o2 = Math.max(o2, r2.seriesCandleC[d2][g2]), "boxPlot" === this.w.config.chart.type && (o2 = Math.max(o2, r2.seriesCandleM[d2][g2]))), !s2.series[d2].type || "candlestick" === s2.series[d2].type && "boxPlot" === s2.series[d2].type && "rangeArea" === s2.series[d2].type && "rangeBar" === s2.series[d2].type || (o2 = Math.max(o2, r2.series[d2][g2]), e2 = Math.min(e2, r2.series[d2][g2])), i2 = o2), r2.seriesGoals[d2] && r2.seriesGoals[d2][g2] && Array.isArray(r2.seriesGoals[d2][g2]) && r2.seriesGoals[d2][g2].forEach(function(t4) {
              n2 !== Number.MIN_VALUE && (n2 = Math.min(n2, t4.value), e2 = n2), o2 = Math.max(o2, t4.value), i2 = o2;
            }), x.isFloat(u2) && (u2 = x.noExponents(u2), r2.yValueDecimal = Math.max(r2.yValueDecimal, u2.toString().split(".")[1].length)), n2 > h2[d2][g2] && h2[d2][g2] < 0 && (n2 = h2[d2][g2])) : r2.hasNullValues = true;
          }
        }
        return "rangeBar" === s2.chart.type && r2.seriesRangeStart.length && r2.isBarHorizontal && (n2 = e2), "bar" === s2.chart.type && (n2 < 0 && o2 < 0 && (o2 = 0), n2 === Number.MIN_VALUE && (n2 = 0)), { minY: n2, maxY: o2, lowestY: e2, highestY: i2 };
      } }, { key: "setYRange", value: function() {
        var t3 = this.w.globals, e2 = this.w.config;
        t3.maxY = -Number.MAX_VALUE, t3.minY = Number.MIN_VALUE;
        var i2 = Number.MAX_VALUE;
        if (t3.isMultipleYAxis)
          for (var a2 = 0; a2 < t3.series.length; a2++) {
            var s2 = this.getMinYMaxY(a2, i2, null, a2 + 1);
            t3.minYArr.push(s2.minY), t3.maxYArr.push(s2.maxY), i2 = s2.lowestY;
          }
        var r2 = this.getMinYMaxY(0, i2, null, t3.series.length);
        if (t3.minY = r2.minY, t3.maxY = r2.maxY, i2 = r2.lowestY, e2.chart.stacked && this._setStackedMinMax(), ("line" === e2.chart.type || "area" === e2.chart.type || "candlestick" === e2.chart.type || "boxPlot" === e2.chart.type || "rangeBar" === e2.chart.type && !t3.isBarHorizontal) && t3.minY === Number.MIN_VALUE && i2 !== -Number.MAX_VALUE && i2 !== t3.maxY) {
          var o2 = t3.maxY - i2;
          (i2 >= 0 && i2 <= 10 || void 0 !== e2.yaxis[0].min || void 0 !== e2.yaxis[0].max) && (o2 = 0), t3.minY = i2 - 5 * o2 / 100, i2 > 0 && t3.minY < 0 && (t3.minY = 0), t3.maxY = t3.maxY + 5 * o2 / 100;
        }
        if (e2.yaxis.forEach(function(e3, i3) {
          void 0 !== e3.max && ("number" == typeof e3.max ? t3.maxYArr[i3] = e3.max : "function" == typeof e3.max && (t3.maxYArr[i3] = e3.max(t3.isMultipleYAxis ? t3.maxYArr[i3] : t3.maxY)), t3.maxY = t3.maxYArr[i3]), void 0 !== e3.min && ("number" == typeof e3.min ? t3.minYArr[i3] = e3.min : "function" == typeof e3.min && (t3.minYArr[i3] = e3.min(t3.isMultipleYAxis ? t3.minYArr[i3] === Number.MIN_VALUE ? 0 : t3.minYArr[i3] : t3.minY)), t3.minY = t3.minYArr[i3]);
        }), t3.isBarHorizontal) {
          ["min", "max"].forEach(function(i3) {
            void 0 !== e2.xaxis[i3] && "number" == typeof e2.xaxis[i3] && ("min" === i3 ? t3.minY = e2.xaxis[i3] : t3.maxY = e2.xaxis[i3]);
          });
        }
        return t3.isMultipleYAxis ? (this.scales.setMultipleYScales(), t3.minY = i2, t3.yAxisScale.forEach(function(e3, i3) {
          t3.minYArr[i3] = e3.niceMin, t3.maxYArr[i3] = e3.niceMax;
        })) : (this.scales.setYScaleForIndex(0, t3.minY, t3.maxY), t3.minY = t3.yAxisScale[0].niceMin, t3.maxY = t3.yAxisScale[0].niceMax, t3.minYArr[0] = t3.yAxisScale[0].niceMin, t3.maxYArr[0] = t3.yAxisScale[0].niceMax), { minY: t3.minY, maxY: t3.maxY, minYArr: t3.minYArr, maxYArr: t3.maxYArr, yAxisScale: t3.yAxisScale };
      } }, { key: "setXRange", value: function() {
        var t3 = this.w.globals, e2 = this.w.config, i2 = "numeric" === e2.xaxis.type || "datetime" === e2.xaxis.type || "category" === e2.xaxis.type && !t3.noLabelsProvided || t3.noLabelsProvided || t3.isXNumeric;
        if (t3.isXNumeric && function() {
          for (var e3 = 0; e3 < t3.series.length; e3++)
            if (t3.labels[e3])
              for (var i3 = 0; i3 < t3.labels[e3].length; i3++)
                null !== t3.labels[e3][i3] && x.isNumber(t3.labels[e3][i3]) && (t3.maxX = Math.max(t3.maxX, t3.labels[e3][i3]), t3.initialMaxX = Math.max(t3.maxX, t3.labels[e3][i3]), t3.minX = Math.min(t3.minX, t3.labels[e3][i3]), t3.initialMinX = Math.min(t3.minX, t3.labels[e3][i3]));
        }(), t3.noLabelsProvided && 0 === e2.xaxis.categories.length && (t3.maxX = t3.labels[t3.labels.length - 1], t3.initialMaxX = t3.labels[t3.labels.length - 1], t3.minX = 1, t3.initialMinX = 1), t3.isXNumeric || t3.noLabelsProvided || t3.dataFormatXNumeric) {
          var a2;
          if (void 0 === e2.xaxis.tickAmount ? (a2 = Math.round(t3.svgWidth / 150), "numeric" === e2.xaxis.type && t3.dataPoints < 30 && (a2 = t3.dataPoints - 1), a2 > t3.dataPoints && 0 !== t3.dataPoints && (a2 = t3.dataPoints - 1)) : "dataPoints" === e2.xaxis.tickAmount ? (t3.series.length > 1 && (a2 = t3.series[t3.maxValsInArrayIndex].length - 1), t3.isXNumeric && (a2 = t3.maxX - t3.minX - 1)) : a2 = e2.xaxis.tickAmount, t3.xTickAmount = a2, void 0 !== e2.xaxis.max && "number" == typeof e2.xaxis.max && (t3.maxX = e2.xaxis.max), void 0 !== e2.xaxis.min && "number" == typeof e2.xaxis.min && (t3.minX = e2.xaxis.min), void 0 !== e2.xaxis.range && (t3.minX = t3.maxX - e2.xaxis.range), t3.minX !== Number.MAX_VALUE && t3.maxX !== -Number.MAX_VALUE)
            if (e2.xaxis.convertedCatToNumeric && !t3.dataFormatXNumeric) {
              for (var s2 = [], r2 = t3.minX - 1; r2 < t3.maxX; r2++)
                s2.push(r2 + 1);
              t3.xAxisScale = { result: s2, niceMin: s2[0], niceMax: s2[s2.length - 1] };
            } else
              t3.xAxisScale = this.scales.setXScale(t3.minX, t3.maxX);
          else
            t3.xAxisScale = this.scales.linearScale(0, a2, a2), t3.noLabelsProvided && t3.labels.length > 0 && (t3.xAxisScale = this.scales.linearScale(1, t3.labels.length, a2 - 1), t3.seriesX = t3.labels.slice());
          i2 && (t3.labels = t3.xAxisScale.result.slice());
        }
        return t3.isBarHorizontal && t3.labels.length && (t3.xTickAmount = t3.labels.length), this._handleSingleDataPoint(), this._getMinXDiff(), { minX: t3.minX, maxX: t3.maxX };
      } }, { key: "setZRange", value: function() {
        var t3 = this.w.globals;
        if (t3.isDataXYZ) {
          for (var e2 = 0; e2 < t3.series.length; e2++)
            if (void 0 !== t3.seriesZ[e2])
              for (var i2 = 0; i2 < t3.seriesZ[e2].length; i2++)
                null !== t3.seriesZ[e2][i2] && x.isNumber(t3.seriesZ[e2][i2]) && (t3.maxZ = Math.max(t3.maxZ, t3.seriesZ[e2][i2]), t3.minZ = Math.min(t3.minZ, t3.seriesZ[e2][i2]));
        }
      } }, { key: "_handleSingleDataPoint", value: function() {
        var t3 = this.w.globals, e2 = this.w.config;
        if (t3.minX === t3.maxX) {
          var i2 = new I(this.ctx);
          if ("datetime" === e2.xaxis.type) {
            var a2 = i2.getDate(t3.minX);
            e2.xaxis.labels.datetimeUTC ? a2.setUTCDate(a2.getUTCDate() - 2) : a2.setDate(a2.getDate() - 2), t3.minX = new Date(a2).getTime();
            var s2 = i2.getDate(t3.maxX);
            e2.xaxis.labels.datetimeUTC ? s2.setUTCDate(s2.getUTCDate() + 2) : s2.setDate(s2.getDate() + 2), t3.maxX = new Date(s2).getTime();
          } else
            ("numeric" === e2.xaxis.type || "category" === e2.xaxis.type && !t3.noLabelsProvided) && (t3.minX = t3.minX - 2, t3.initialMinX = t3.minX, t3.maxX = t3.maxX + 2, t3.initialMaxX = t3.maxX);
        }
      } }, { key: "_getMinXDiff", value: function() {
        var t3 = this.w.globals;
        t3.isXNumeric && t3.seriesX.forEach(function(e2, i2) {
          1 === e2.length && e2.push(t3.seriesX[t3.maxValsInArrayIndex][t3.seriesX[t3.maxValsInArrayIndex].length - 1]);
          var a2 = e2.slice();
          a2.sort(function(t4, e3) {
            return t4 - e3;
          }), a2.forEach(function(e3, i3) {
            if (i3 > 0) {
              var s2 = e3 - a2[i3 - 1];
              s2 > 0 && (t3.minXDiff = Math.min(s2, t3.minXDiff));
            }
          }), 1 !== t3.dataPoints && t3.minXDiff !== Number.MAX_VALUE || (t3.minXDiff = 0.5);
        });
      } }, { key: "_setStackedMinMax", value: function() {
        var t3 = this, e2 = this.w.globals;
        if (e2.series.length) {
          var i2 = e2.seriesGroups;
          i2.length || (i2 = [this.w.config.series.map(function(t4) {
            return t4.name;
          })]);
          var a2 = {}, s2 = {};
          i2.forEach(function(i3) {
            a2[i3] = [], s2[i3] = [], t3.w.config.series.map(function(t4, e3) {
              return i3.indexOf(t4.name) > -1 ? e3 : null;
            }).filter(function(t4) {
              return null !== t4;
            }).forEach(function(t4) {
              for (var r2 = 0; r2 < e2.series[e2.maxValsInArrayIndex].length; r2++)
                void 0 === a2[i3][r2] && (a2[i3][r2] = 0, s2[i3][r2] = 0), null !== e2.series[t4][r2] && x.isNumber(e2.series[t4][r2]) && (e2.series[t4][r2] > 0 ? a2[i3][r2] += parseFloat(e2.series[t4][r2]) + 1e-4 : s2[i3][r2] += parseFloat(e2.series[t4][r2]));
            });
          }), Object.entries(a2).forEach(function(t4) {
            var i3 = g(t4, 1)[0];
            a2[i3].forEach(function(t5, r2) {
              e2.maxY = Math.max(e2.maxY, a2[i3][r2]), e2.minY = Math.min(e2.minY, s2[i3][r2]);
            });
          });
        }
      } }]), t2;
    }();
    var q = function() {
      function t2(e2, i2) {
        a(this, t2), this.ctx = e2, this.elgrid = i2, this.w = e2.w;
        var s2 = this.w;
        this.xaxisFontSize = s2.config.xaxis.labels.style.fontSize, this.axisFontFamily = s2.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = s2.config.xaxis.labels.style.colors, this.isCategoryBarHorizontal = "bar" === s2.config.chart.type && s2.config.plotOptions.bar.horizontal, this.xAxisoffX = 0, "bottom" === s2.config.xaxis.position && (this.xAxisoffX = s2.globals.gridHeight), this.drawnLabels = [], this.axesUtils = new B(e2);
      }
      return r(t2, [{ key: "drawYaxis", value: function(t3) {
        var e2 = this, i2 = this.w, a2 = new m(this.ctx), s2 = i2.config.yaxis[t3].labels.style, r2 = s2.fontSize, o2 = s2.fontFamily, n2 = s2.fontWeight, l2 = a2.group({ class: "apexcharts-yaxis", rel: t3, transform: "translate(" + i2.globals.translateYAxisX[t3] + ", 0)" });
        if (this.axesUtils.isYAxisHidden(t3))
          return l2;
        var h2 = a2.group({ class: "apexcharts-yaxis-texts-g" });
        l2.add(h2);
        var c2 = i2.globals.yAxisScale[t3].result.length - 1, d2 = i2.globals.gridHeight / c2, g2 = i2.globals.translateY, u2 = i2.globals.yLabelFormatters[t3], p2 = i2.globals.yAxisScale[t3].result.slice();
        p2 = this.axesUtils.checkForReversedLabels(t3, p2);
        var f2 = "";
        if (i2.config.yaxis[t3].labels.show)
          for (var x2 = function(l3) {
            var x3 = p2[l3];
            x3 = u2(x3, l3, i2);
            var b3 = i2.config.yaxis[t3].labels.padding;
            i2.config.yaxis[t3].opposite && 0 !== i2.config.yaxis.length && (b3 *= -1);
            var v3 = "end";
            i2.config.yaxis[t3].opposite && (v3 = "start"), "left" === i2.config.yaxis[t3].labels.align ? v3 = "start" : "center" === i2.config.yaxis[t3].labels.align ? v3 = "middle" : "right" === i2.config.yaxis[t3].labels.align && (v3 = "end");
            var m2 = e2.axesUtils.getYAxisForeColor(s2.colors, t3), y3 = i2.config.yaxis[t3].labels.offsetY;
            "heatmap" === i2.config.chart.type && (y3 -= (i2.globals.gridHeight / i2.globals.series.length - 1) / 2);
            var w3 = a2.drawText({ x: b3, y: g2 + c2 / 10 + y3 + 1, text: x3, textAnchor: v3, fontSize: r2, fontFamily: o2, fontWeight: n2, maxWidth: i2.config.yaxis[t3].labels.maxWidth, foreColor: Array.isArray(m2) ? m2[l3] : m2, isPlainText: false, cssClass: "apexcharts-yaxis-label " + s2.cssClass });
            l3 === c2 && (f2 = w3), h2.add(w3);
            var k3 = document.createElementNS(i2.globals.SVGNS, "title");
            if (k3.textContent = Array.isArray(x3) ? x3.join(" ") : x3, w3.node.appendChild(k3), 0 !== i2.config.yaxis[t3].labels.rotate) {
              var A3 = a2.rotateAroundCenter(f2.node), S3 = a2.rotateAroundCenter(w3.node);
              w3.node.setAttribute("transform", "rotate(".concat(i2.config.yaxis[t3].labels.rotate, " ").concat(A3.x, " ").concat(S3.y, ")"));
            }
            g2 += d2;
          }, b2 = c2; b2 >= 0; b2--)
            x2(b2);
        if (void 0 !== i2.config.yaxis[t3].title.text) {
          var v2 = a2.group({ class: "apexcharts-yaxis-title" }), y2 = 0;
          i2.config.yaxis[t3].opposite && (y2 = i2.globals.translateYAxisX[t3]);
          var w2 = a2.drawText({ x: y2, y: i2.globals.gridHeight / 2 + i2.globals.translateY + i2.config.yaxis[t3].title.offsetY, text: i2.config.yaxis[t3].title.text, textAnchor: "end", foreColor: i2.config.yaxis[t3].title.style.color, fontSize: i2.config.yaxis[t3].title.style.fontSize, fontWeight: i2.config.yaxis[t3].title.style.fontWeight, fontFamily: i2.config.yaxis[t3].title.style.fontFamily, cssClass: "apexcharts-yaxis-title-text " + i2.config.yaxis[t3].title.style.cssClass });
          v2.add(w2), l2.add(v2);
        }
        var k2 = i2.config.yaxis[t3].axisBorder, A2 = 31 + k2.offsetX;
        if (i2.config.yaxis[t3].opposite && (A2 = -31 - k2.offsetX), k2.show) {
          var S2 = a2.drawLine(A2, i2.globals.translateY + k2.offsetY - 2, A2, i2.globals.gridHeight + i2.globals.translateY + k2.offsetY + 2, k2.color, 0, k2.width);
          l2.add(S2);
        }
        return i2.config.yaxis[t3].axisTicks.show && this.axesUtils.drawYAxisTicks(A2, c2, k2, i2.config.yaxis[t3].axisTicks, t3, d2, l2), l2;
      } }, { key: "drawYaxisInversed", value: function(t3) {
        var e2 = this.w, i2 = new m(this.ctx), a2 = i2.group({ class: "apexcharts-xaxis apexcharts-yaxis-inversed" }), s2 = i2.group({ class: "apexcharts-xaxis-texts-g", transform: "translate(".concat(e2.globals.translateXAxisX, ", ").concat(e2.globals.translateXAxisY, ")") });
        a2.add(s2);
        var r2 = e2.globals.yAxisScale[t3].result.length - 1, o2 = e2.globals.gridWidth / r2 + 0.1, n2 = o2 + e2.config.xaxis.labels.offsetX, l2 = e2.globals.xLabelFormatter, h2 = e2.globals.yAxisScale[t3].result.slice(), c2 = e2.globals.timescaleLabels;
        c2.length > 0 && (this.xaxisLabels = c2.slice(), r2 = (h2 = c2.slice()).length), h2 = this.axesUtils.checkForReversedLabels(t3, h2);
        var d2 = c2.length;
        if (e2.config.xaxis.labels.show)
          for (var g2 = d2 ? 0 : r2; d2 ? g2 < d2 : g2 >= 0; d2 ? g2++ : g2--) {
            var u2 = h2[g2];
            u2 = l2(u2, g2, e2);
            var p2 = e2.globals.gridWidth + e2.globals.padHorizontal - (n2 - o2 + e2.config.xaxis.labels.offsetX);
            if (c2.length) {
              var f2 = this.axesUtils.getLabel(h2, c2, p2, g2, this.drawnLabels, this.xaxisFontSize);
              p2 = f2.x, u2 = f2.text, this.drawnLabels.push(f2.text), 0 === g2 && e2.globals.skipFirstTimelinelabel && (u2 = ""), g2 === h2.length - 1 && e2.globals.skipLastTimelinelabel && (u2 = "");
            }
            var x2 = i2.drawText({ x: p2, y: this.xAxisoffX + e2.config.xaxis.labels.offsetY + 30 - ("top" === e2.config.xaxis.position ? e2.globals.xAxisHeight + e2.config.xaxis.axisTicks.height - 2 : 0), text: u2, textAnchor: "middle", foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[t3] : this.xaxisForeColors, fontSize: this.xaxisFontSize, fontFamily: this.xaxisFontFamily, fontWeight: e2.config.xaxis.labels.style.fontWeight, isPlainText: false, cssClass: "apexcharts-xaxis-label " + e2.config.xaxis.labels.style.cssClass });
            s2.add(x2), x2.tspan(u2);
            var b2 = document.createElementNS(e2.globals.SVGNS, "title");
            b2.textContent = u2, x2.node.appendChild(b2), n2 += o2;
          }
        return this.inversedYAxisTitleText(a2), this.inversedYAxisBorder(a2), a2;
      } }, { key: "inversedYAxisBorder", value: function(t3) {
        var e2 = this.w, i2 = new m(this.ctx), a2 = e2.config.xaxis.axisBorder;
        if (a2.show) {
          var s2 = 0;
          "bar" === e2.config.chart.type && e2.globals.isXNumeric && (s2 -= 15);
          var r2 = i2.drawLine(e2.globals.padHorizontal + s2 + a2.offsetX, this.xAxisoffX, e2.globals.gridWidth, this.xAxisoffX, a2.color, 0, a2.height);
          this.elgrid && this.elgrid.elGridBorders && e2.config.grid.show ? this.elgrid.elGridBorders.add(r2) : t3.add(r2);
        }
      } }, { key: "inversedYAxisTitleText", value: function(t3) {
        var e2 = this.w, i2 = new m(this.ctx);
        if (void 0 !== e2.config.xaxis.title.text) {
          var a2 = i2.group({ class: "apexcharts-xaxis-title apexcharts-yaxis-title-inversed" }), s2 = i2.drawText({ x: e2.globals.gridWidth / 2 + e2.config.xaxis.title.offsetX, y: this.xAxisoffX + parseFloat(this.xaxisFontSize) + parseFloat(e2.config.xaxis.title.style.fontSize) + e2.config.xaxis.title.offsetY + 20, text: e2.config.xaxis.title.text, textAnchor: "middle", fontSize: e2.config.xaxis.title.style.fontSize, fontFamily: e2.config.xaxis.title.style.fontFamily, fontWeight: e2.config.xaxis.title.style.fontWeight, foreColor: e2.config.xaxis.title.style.color, cssClass: "apexcharts-xaxis-title-text " + e2.config.xaxis.title.style.cssClass });
          a2.add(s2), t3.add(a2);
        }
      } }, { key: "yAxisTitleRotate", value: function(t3, e2) {
        var i2 = this.w, a2 = new m(this.ctx), s2 = { width: 0, height: 0 }, r2 = { width: 0, height: 0 }, o2 = i2.globals.dom.baseEl.querySelector(" .apexcharts-yaxis[rel='".concat(t3, "'] .apexcharts-yaxis-texts-g"));
        null !== o2 && (s2 = o2.getBoundingClientRect());
        var n2 = i2.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(t3, "'] .apexcharts-yaxis-title text"));
        if (null !== n2 && (r2 = n2.getBoundingClientRect()), null !== n2) {
          var l2 = this.xPaddingForYAxisTitle(t3, s2, r2, e2);
          n2.setAttribute("x", l2.xPos - (e2 ? 10 : 0));
        }
        if (null !== n2) {
          var h2 = a2.rotateAroundCenter(n2);
          n2.setAttribute("transform", "rotate(".concat(e2 ? -1 * i2.config.yaxis[t3].title.rotate : i2.config.yaxis[t3].title.rotate, " ").concat(h2.x, " ").concat(h2.y, ")"));
        }
      } }, { key: "xPaddingForYAxisTitle", value: function(t3, e2, i2, a2) {
        var s2 = this.w, r2 = 0, o2 = 0, n2 = 10;
        return void 0 === s2.config.yaxis[t3].title.text || t3 < 0 ? { xPos: o2, padd: 0 } : (a2 ? (o2 = e2.width + s2.config.yaxis[t3].title.offsetX + i2.width / 2 + n2 / 2, 0 === (r2 += 1) && (o2 -= n2 / 2)) : (o2 = -1 * e2.width + s2.config.yaxis[t3].title.offsetX + n2 / 2 + i2.width / 2, s2.globals.isBarHorizontal && (n2 = 25, o2 = -1 * e2.width - s2.config.yaxis[t3].title.offsetX - n2)), { xPos: o2, padd: n2 });
      } }, { key: "setYAxisXPosition", value: function(t3, e2) {
        var i2 = this.w, a2 = 0, s2 = 0, r2 = 18, o2 = 1;
        i2.config.yaxis.length > 1 && (this.multipleYs = true), i2.config.yaxis.map(function(n2, l2) {
          var h2 = i2.globals.ignoreYAxisIndexes.indexOf(l2) > -1 || !n2.show || n2.floating || 0 === t3[l2].width, c2 = t3[l2].width + e2[l2].width;
          n2.opposite ? i2.globals.isBarHorizontal ? (s2 = i2.globals.gridWidth + i2.globals.translateX - 1, i2.globals.translateYAxisX[l2] = s2 - n2.labels.offsetX) : (s2 = i2.globals.gridWidth + i2.globals.translateX + o2, h2 || (o2 = o2 + c2 + 20), i2.globals.translateYAxisX[l2] = s2 - n2.labels.offsetX + 20) : (a2 = i2.globals.translateX - r2, h2 || (r2 = r2 + c2 + 20), i2.globals.translateYAxisX[l2] = a2 + n2.labels.offsetX);
        });
      } }, { key: "setYAxisTextAlignments", value: function() {
        var t3 = this.w, e2 = t3.globals.dom.baseEl.getElementsByClassName("apexcharts-yaxis");
        (e2 = x.listToArray(e2)).forEach(function(e3, i2) {
          var a2 = t3.config.yaxis[i2];
          if (a2 && !a2.floating && void 0 !== a2.labels.align) {
            var s2 = t3.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(i2, "'] .apexcharts-yaxis-texts-g")), r2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(i2, "'] .apexcharts-yaxis-label"));
            r2 = x.listToArray(r2);
            var o2 = s2.getBoundingClientRect();
            "left" === a2.labels.align ? (r2.forEach(function(t4, e4) {
              t4.setAttribute("text-anchor", "start");
            }), a2.opposite || s2.setAttribute("transform", "translate(-".concat(o2.width, ", 0)"))) : "center" === a2.labels.align ? (r2.forEach(function(t4, e4) {
              t4.setAttribute("text-anchor", "middle");
            }), s2.setAttribute("transform", "translate(".concat(o2.width / 2 * (a2.opposite ? 1 : -1), ", 0)"))) : "right" === a2.labels.align && (r2.forEach(function(t4, e4) {
              t4.setAttribute("text-anchor", "end");
            }), a2.opposite && s2.setAttribute("transform", "translate(".concat(o2.width, ", 0)")));
          }
        });
      } }]), t2;
    }();
    var Z = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w, this.documentEvent = x.bind(this.documentEvent, this);
      }
      return r(t2, [{ key: "addEventListener", value: function(t3, e2) {
        var i2 = this.w;
        i2.globals.events.hasOwnProperty(t3) ? i2.globals.events[t3].push(e2) : i2.globals.events[t3] = [e2];
      } }, { key: "removeEventListener", value: function(t3, e2) {
        var i2 = this.w;
        if (i2.globals.events.hasOwnProperty(t3)) {
          var a2 = i2.globals.events[t3].indexOf(e2);
          -1 !== a2 && i2.globals.events[t3].splice(a2, 1);
        }
      } }, { key: "fireEvent", value: function(t3, e2) {
        var i2 = this.w;
        if (i2.globals.events.hasOwnProperty(t3)) {
          e2 && e2.length || (e2 = []);
          for (var a2 = i2.globals.events[t3], s2 = a2.length, r2 = 0; r2 < s2; r2++)
            a2[r2].apply(null, e2);
        }
      } }, { key: "setupEventHandlers", value: function() {
        var t3 = this, e2 = this.w, i2 = this.ctx, a2 = e2.globals.dom.baseEl.querySelector(e2.globals.chartClass);
        this.ctx.eventList.forEach(function(t4) {
          a2.addEventListener(t4, function(t5) {
            var a3 = Object.assign({}, e2, { seriesIndex: e2.globals.capturedSeriesIndex, dataPointIndex: e2.globals.capturedDataPointIndex });
            "mousemove" === t5.type || "touchmove" === t5.type ? "function" == typeof e2.config.chart.events.mouseMove && e2.config.chart.events.mouseMove(t5, i2, a3) : "mouseleave" === t5.type || "touchleave" === t5.type ? "function" == typeof e2.config.chart.events.mouseLeave && e2.config.chart.events.mouseLeave(t5, i2, a3) : ("mouseup" === t5.type && 1 === t5.which || "touchend" === t5.type) && ("function" == typeof e2.config.chart.events.click && e2.config.chart.events.click(t5, i2, a3), i2.ctx.events.fireEvent("click", [t5, i2, a3]));
          }, { capture: false, passive: true });
        }), this.ctx.eventList.forEach(function(i3) {
          e2.globals.dom.baseEl.addEventListener(i3, t3.documentEvent, { passive: true });
        }), this.ctx.core.setupBrushHandler();
      } }, { key: "documentEvent", value: function(t3) {
        var e2 = this.w, i2 = t3.target.className;
        if ("click" === t3.type) {
          var a2 = e2.globals.dom.baseEl.querySelector(".apexcharts-menu");
          a2 && a2.classList.contains("apexcharts-menu-open") && "apexcharts-menu-icon" !== i2 && a2.classList.remove("apexcharts-menu-open");
        }
        e2.globals.clientX = "touchmove" === t3.type ? t3.touches[0].clientX : t3.clientX, e2.globals.clientY = "touchmove" === t3.type ? t3.touches[0].clientY : t3.clientY;
      } }]), t2;
    }();
    var $ = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
      }
      return r(t2, [{ key: "setCurrentLocaleValues", value: function(t3) {
        var e2 = this.w.config.chart.locales;
        window.Apex.chart && window.Apex.chart.locales && window.Apex.chart.locales.length > 0 && (e2 = this.w.config.chart.locales.concat(window.Apex.chart.locales));
        var i2 = e2.filter(function(e3) {
          return e3.name === t3;
        })[0];
        if (!i2)
          throw new Error("Wrong locale name provided. Please make sure you set the correct locale name in options");
        var a2 = x.extend(C, i2);
        this.w.globals.locale = a2.options;
      } }]), t2;
    }();
    var J = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
      }
      return r(t2, [{ key: "drawAxis", value: function(t3, e2) {
        var i2, a2, s2 = this, r2 = this.w.globals, o2 = this.w.config, n2 = new V(this.ctx, e2), l2 = new q(this.ctx, e2);
        r2.axisCharts && "radar" !== t3 && (r2.isBarHorizontal ? (a2 = l2.drawYaxisInversed(0), i2 = n2.drawXaxisInversed(0), r2.dom.elGraphical.add(i2), r2.dom.elGraphical.add(a2)) : (i2 = n2.drawXaxis(), r2.dom.elGraphical.add(i2), o2.yaxis.map(function(t4, e3) {
          if (-1 === r2.ignoreYAxisIndexes.indexOf(e3) && (a2 = l2.drawYaxis(e3), r2.dom.Paper.add(a2), "back" === s2.w.config.grid.position)) {
            var i3 = r2.dom.Paper.children()[1];
            i3.remove(), r2.dom.Paper.add(i3);
          }
        })));
      } }]), t2;
    }();
    var Q = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
      }
      return r(t2, [{ key: "drawXCrosshairs", value: function() {
        var t3 = this.w, e2 = new m(this.ctx), i2 = new v(this.ctx), a2 = t3.config.xaxis.crosshairs.fill.gradient, s2 = t3.config.xaxis.crosshairs.dropShadow, r2 = t3.config.xaxis.crosshairs.fill.type, o2 = a2.colorFrom, n2 = a2.colorTo, l2 = a2.opacityFrom, h2 = a2.opacityTo, c2 = a2.stops, d2 = s2.enabled, g2 = s2.left, u2 = s2.top, p2 = s2.blur, f2 = s2.color, b2 = s2.opacity, y2 = t3.config.xaxis.crosshairs.fill.color;
        if (t3.config.xaxis.crosshairs.show) {
          "gradient" === r2 && (y2 = e2.drawGradient("vertical", o2, n2, l2, h2, null, c2, null));
          var w2 = e2.drawRect();
          1 === t3.config.xaxis.crosshairs.width && (w2 = e2.drawLine());
          var k2 = t3.globals.gridHeight;
          (!x.isNumber(k2) || k2 < 0) && (k2 = 0);
          var A2 = t3.config.xaxis.crosshairs.width;
          (!x.isNumber(A2) || A2 < 0) && (A2 = 0), w2.attr({ class: "apexcharts-xcrosshairs", x: 0, y: 0, y2: k2, width: A2, height: k2, fill: y2, filter: "none", "fill-opacity": t3.config.xaxis.crosshairs.opacity, stroke: t3.config.xaxis.crosshairs.stroke.color, "stroke-width": t3.config.xaxis.crosshairs.stroke.width, "stroke-dasharray": t3.config.xaxis.crosshairs.stroke.dashArray }), d2 && (w2 = i2.dropShadow(w2, { left: g2, top: u2, blur: p2, color: f2, opacity: b2 })), t3.globals.dom.elGraphical.add(w2);
        }
      } }, { key: "drawYCrosshairs", value: function() {
        var t3 = this.w, e2 = new m(this.ctx), i2 = t3.config.yaxis[0].crosshairs, a2 = t3.globals.barPadForNumericAxis;
        if (t3.config.yaxis[0].crosshairs.show) {
          var s2 = e2.drawLine(-a2, 0, t3.globals.gridWidth + a2, 0, i2.stroke.color, i2.stroke.dashArray, i2.stroke.width);
          s2.attr({ class: "apexcharts-ycrosshairs" }), t3.globals.dom.elGraphical.add(s2);
        }
        var r2 = e2.drawLine(-a2, 0, t3.globals.gridWidth + a2, 0, i2.stroke.color, 0, 0);
        r2.attr({ class: "apexcharts-ycrosshairs-hidden" }), t3.globals.dom.elGraphical.add(r2);
      } }]), t2;
    }();
    var K = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
      }
      return r(t2, [{ key: "checkResponsiveConfig", value: function(t3) {
        var e2 = this, i2 = this.w, a2 = i2.config;
        if (0 !== a2.responsive.length) {
          var s2 = a2.responsive.slice();
          s2.sort(function(t4, e3) {
            return t4.breakpoint > e3.breakpoint ? 1 : e3.breakpoint > t4.breakpoint ? -1 : 0;
          }).reverse();
          var r2 = new E({}), o2 = function() {
            var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, a3 = s2[0].breakpoint, o3 = window.innerWidth > 0 ? window.innerWidth : screen.width;
            if (o3 > a3) {
              var n3 = y.extendArrayProps(r2, i2.globals.initialConfig, i2);
              t4 = x.extend(n3, t4), t4 = x.extend(i2.config, t4), e2.overrideResponsiveOptions(t4);
            } else
              for (var l2 = 0; l2 < s2.length; l2++)
                o3 < s2[l2].breakpoint && (t4 = y.extendArrayProps(r2, s2[l2].options, i2), t4 = x.extend(i2.config, t4), e2.overrideResponsiveOptions(t4));
          };
          if (t3) {
            var n2 = y.extendArrayProps(r2, t3, i2);
            n2 = x.extend(i2.config, n2), o2(n2 = x.extend(n2, t3));
          } else
            o2({});
        }
      } }, { key: "overrideResponsiveOptions", value: function(t3) {
        var e2 = new E(t3).init({ responsiveOverride: true });
        this.w.config = e2;
      } }]), t2;
    }();
    var tt = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.colors = [], this.w = e2.w;
        var i2 = this.w;
        this.isColorFn = false, this.isHeatmapDistributed = "treemap" === i2.config.chart.type && i2.config.plotOptions.treemap.distributed || "heatmap" === i2.config.chart.type && i2.config.plotOptions.heatmap.distributed, this.isBarDistributed = i2.config.plotOptions.bar.distributed && ("bar" === i2.config.chart.type || "rangeBar" === i2.config.chart.type);
      }
      return r(t2, [{ key: "init", value: function() {
        this.setDefaultColors();
      } }, { key: "setDefaultColors", value: function() {
        var t3, e2 = this, i2 = this.w, a2 = new x();
        if (i2.globals.dom.elWrap.classList.add("apexcharts-theme-".concat(i2.config.theme.mode)), void 0 === i2.config.colors || 0 === (null === (t3 = i2.config.colors) || void 0 === t3 ? void 0 : t3.length) ? i2.globals.colors = this.predefined() : (i2.globals.colors = i2.config.colors, Array.isArray(i2.config.colors) && i2.config.colors.length > 0 && "function" == typeof i2.config.colors[0] && (i2.globals.colors = i2.config.series.map(function(t4, a3) {
          var s3 = i2.config.colors[a3];
          return s3 || (s3 = i2.config.colors[0]), "function" == typeof s3 ? (e2.isColorFn = true, s3({ value: i2.globals.axisCharts ? i2.globals.series[a3][0] ? i2.globals.series[a3][0] : 0 : i2.globals.series[a3], seriesIndex: a3, dataPointIndex: a3, w: i2 })) : s3;
        }))), i2.globals.seriesColors.map(function(t4, e3) {
          t4 && (i2.globals.colors[e3] = t4);
        }), i2.config.theme.monochrome.enabled) {
          var s2 = [], r2 = i2.globals.series.length;
          (this.isBarDistributed || this.isHeatmapDistributed) && (r2 = i2.globals.series[0].length * i2.globals.series.length);
          for (var o2 = i2.config.theme.monochrome.color, n2 = 1 / (r2 / i2.config.theme.monochrome.shadeIntensity), l2 = i2.config.theme.monochrome.shadeTo, h2 = 0, c2 = 0; c2 < r2; c2++) {
            var d2 = void 0;
            "dark" === l2 ? (d2 = a2.shadeColor(-1 * h2, o2), h2 += n2) : (d2 = a2.shadeColor(h2, o2), h2 += n2), s2.push(d2);
          }
          i2.globals.colors = s2.slice();
        }
        var g2 = i2.globals.colors.slice();
        this.pushExtraColors(i2.globals.colors);
        ["fill", "stroke"].forEach(function(t4) {
          void 0 === i2.config[t4].colors ? i2.globals[t4].colors = e2.isColorFn ? i2.config.colors : g2 : i2.globals[t4].colors = i2.config[t4].colors.slice(), e2.pushExtraColors(i2.globals[t4].colors);
        }), void 0 === i2.config.dataLabels.style.colors ? i2.globals.dataLabels.style.colors = g2 : i2.globals.dataLabels.style.colors = i2.config.dataLabels.style.colors.slice(), this.pushExtraColors(i2.globals.dataLabels.style.colors, 50), void 0 === i2.config.plotOptions.radar.polygons.fill.colors ? i2.globals.radarPolygons.fill.colors = ["dark" === i2.config.theme.mode ? "#424242" : "none"] : i2.globals.radarPolygons.fill.colors = i2.config.plotOptions.radar.polygons.fill.colors.slice(), this.pushExtraColors(i2.globals.radarPolygons.fill.colors, 20), void 0 === i2.config.markers.colors ? i2.globals.markers.colors = g2 : i2.globals.markers.colors = i2.config.markers.colors.slice(), this.pushExtraColors(i2.globals.markers.colors);
      } }, { key: "pushExtraColors", value: function(t3, e2) {
        var i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a2 = this.w, s2 = e2 || a2.globals.series.length;
        if (null === i2 && (i2 = this.isBarDistributed || this.isHeatmapDistributed || "heatmap" === a2.config.chart.type && a2.config.plotOptions.heatmap.colorScale.inverse), i2 && a2.globals.series.length && (s2 = a2.globals.series[a2.globals.maxValsInArrayIndex].length * a2.globals.series.length), t3.length < s2)
          for (var r2 = s2 - t3.length, o2 = 0; o2 < r2; o2++)
            t3.push(t3[o2]);
      } }, { key: "updateThemeOptions", value: function(t3) {
        t3.chart = t3.chart || {}, t3.tooltip = t3.tooltip || {};
        var e2 = t3.theme.mode || "light", i2 = t3.theme.palette ? t3.theme.palette : "dark" === e2 ? "palette4" : "palette1", a2 = t3.chart.foreColor ? t3.chart.foreColor : "dark" === e2 ? "#f6f7f8" : "#373d3f";
        return t3.tooltip.theme = e2, t3.chart.foreColor = a2, t3.theme.palette = i2, t3;
      } }, { key: "predefined", value: function() {
        switch (this.w.config.theme.palette) {
          case "palette1":
          default:
            this.colors = ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"];
            break;
          case "palette2":
            this.colors = ["#3f51b5", "#03a9f4", "#4caf50", "#f9ce1d", "#FF9800"];
            break;
          case "palette3":
            this.colors = ["#33b2df", "#546E7A", "#d4526e", "#13d8aa", "#A5978B"];
            break;
          case "palette4":
            this.colors = ["#4ecdc4", "#c7f464", "#81D4FA", "#fd6a6a", "#546E7A"];
            break;
          case "palette5":
            this.colors = ["#2b908f", "#f9a3a4", "#90ee7e", "#fa4443", "#69d2e7"];
            break;
          case "palette6":
            this.colors = ["#449DD1", "#F86624", "#EA3546", "#662E9B", "#C5D86D"];
            break;
          case "palette7":
            this.colors = ["#D7263D", "#1B998B", "#2E294E", "#F46036", "#E2C044"];
            break;
          case "palette8":
            this.colors = ["#662E9B", "#F86624", "#F9C80E", "#EA3546", "#43BCCD"];
            break;
          case "palette9":
            this.colors = ["#5C4742", "#A5978B", "#8D5B4C", "#5A2A27", "#C4BBAF"];
            break;
          case "palette10":
            this.colors = ["#A300D6", "#7D02EB", "#5653FE", "#2983FF", "#00B1F2"];
        }
        return this.colors;
      } }]), t2;
    }();
    var et = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
      }
      return r(t2, [{ key: "draw", value: function() {
        this.drawTitleSubtitle("title"), this.drawTitleSubtitle("subtitle");
      } }, { key: "drawTitleSubtitle", value: function(t3) {
        var e2 = this.w, i2 = "title" === t3 ? e2.config.title : e2.config.subtitle, a2 = e2.globals.svgWidth / 2, s2 = i2.offsetY, r2 = "middle";
        if ("left" === i2.align ? (a2 = 10, r2 = "start") : "right" === i2.align && (a2 = e2.globals.svgWidth - 10, r2 = "end"), a2 += i2.offsetX, s2 = s2 + parseInt(i2.style.fontSize, 10) + i2.margin / 2, void 0 !== i2.text) {
          var o2 = new m(this.ctx).drawText({ x: a2, y: s2, text: i2.text, textAnchor: r2, fontSize: i2.style.fontSize, fontFamily: i2.style.fontFamily, fontWeight: i2.style.fontWeight, foreColor: i2.style.color, opacity: 1 });
          o2.node.setAttribute("class", "apexcharts-".concat(t3, "-text")), e2.globals.dom.Paper.add(o2);
        }
      } }]), t2;
    }();
    var it = function() {
      function t2(e2) {
        a(this, t2), this.w = e2.w, this.dCtx = e2;
      }
      return r(t2, [{ key: "getTitleSubtitleCoords", value: function(t3) {
        var e2 = this.w, i2 = 0, a2 = 0, s2 = "title" === t3 ? e2.config.title.floating : e2.config.subtitle.floating, r2 = e2.globals.dom.baseEl.querySelector(".apexcharts-".concat(t3, "-text"));
        if (null !== r2 && !s2) {
          var o2 = r2.getBoundingClientRect();
          i2 = o2.width, a2 = e2.globals.axisCharts ? o2.height + 5 : o2.height;
        }
        return { width: i2, height: a2 };
      } }, { key: "getLegendsRect", value: function() {
        var t3 = this.w, e2 = t3.globals.dom.elLegendWrap;
        t3.config.legend.height || "top" !== t3.config.legend.position && "bottom" !== t3.config.legend.position || (e2.style.maxHeight = t3.globals.svgHeight / 2 + "px");
        var i2 = Object.assign({}, x.getBoundingClientRect(e2));
        return null !== e2 && !t3.config.legend.floating && t3.config.legend.show ? this.dCtx.lgRect = { x: i2.x, y: i2.y, height: i2.height, width: 0 === i2.height ? 0 : i2.width } : this.dCtx.lgRect = { x: 0, y: 0, height: 0, width: 0 }, "left" !== t3.config.legend.position && "right" !== t3.config.legend.position || 1.5 * this.dCtx.lgRect.width > t3.globals.svgWidth && (this.dCtx.lgRect.width = t3.globals.svgWidth / 1.5), this.dCtx.lgRect;
      } }, { key: "getLargestStringFromMultiArr", value: function(t3, e2) {
        var i2 = t3;
        if (this.w.globals.isMultiLineX) {
          var a2 = e2.map(function(t4, e3) {
            return Array.isArray(t4) ? t4.length : 1;
          }), s2 = Math.max.apply(Math, u(a2));
          i2 = e2[a2.indexOf(s2)];
        }
        return i2;
      } }]), t2;
    }();
    var at = function() {
      function t2(e2) {
        a(this, t2), this.w = e2.w, this.dCtx = e2;
      }
      return r(t2, [{ key: "getxAxisLabelsCoords", value: function() {
        var t3, e2 = this.w, i2 = e2.globals.labels.slice();
        if (e2.config.xaxis.convertedCatToNumeric && 0 === i2.length && (i2 = e2.globals.categoryLabels), e2.globals.timescaleLabels.length > 0) {
          var a2 = this.getxAxisTimeScaleLabelsCoords();
          t3 = { width: a2.width, height: a2.height }, e2.globals.rotateXLabels = false;
        } else {
          this.dCtx.lgWidthForSideLegends = "left" !== e2.config.legend.position && "right" !== e2.config.legend.position || e2.config.legend.floating ? 0 : this.dCtx.lgRect.width;
          var s2 = e2.globals.xLabelFormatter, r2 = x.getLargestStringFromArr(i2), o2 = this.dCtx.dimHelpers.getLargestStringFromMultiArr(r2, i2);
          e2.globals.isBarHorizontal && (o2 = r2 = e2.globals.yAxisScale[0].result.reduce(function(t4, e3) {
            return t4.length > e3.length ? t4 : e3;
          }, 0));
          var n2 = new T(this.dCtx.ctx), l2 = r2;
          r2 = n2.xLabelFormat(s2, r2, l2, { i: void 0, dateFormatter: new I(this.dCtx.ctx).formatDate, w: e2 }), o2 = n2.xLabelFormat(s2, o2, l2, { i: void 0, dateFormatter: new I(this.dCtx.ctx).formatDate, w: e2 }), (e2.config.xaxis.convertedCatToNumeric && void 0 === r2 || "" === String(r2).trim()) && (o2 = r2 = "1");
          var h2 = new m(this.dCtx.ctx), c2 = h2.getTextRects(r2, e2.config.xaxis.labels.style.fontSize), d2 = c2;
          if (r2 !== o2 && (d2 = h2.getTextRects(o2, e2.config.xaxis.labels.style.fontSize)), (t3 = { width: c2.width >= d2.width ? c2.width : d2.width, height: c2.height >= d2.height ? c2.height : d2.height }).width * i2.length > e2.globals.svgWidth - this.dCtx.lgWidthForSideLegends - this.dCtx.yAxisWidth - this.dCtx.gridPad.left - this.dCtx.gridPad.right && 0 !== e2.config.xaxis.labels.rotate || e2.config.xaxis.labels.rotateAlways) {
            if (!e2.globals.isBarHorizontal) {
              e2.globals.rotateXLabels = true;
              var g2 = function(t4) {
                return h2.getTextRects(t4, e2.config.xaxis.labels.style.fontSize, e2.config.xaxis.labels.style.fontFamily, "rotate(".concat(e2.config.xaxis.labels.rotate, " 0 0)"), false);
              };
              c2 = g2(r2), r2 !== o2 && (d2 = g2(o2)), t3.height = (c2.height > d2.height ? c2.height : d2.height) / 1.5, t3.width = c2.width > d2.width ? c2.width : d2.width;
            }
          } else
            e2.globals.rotateXLabels = false;
        }
        return e2.config.xaxis.labels.show || (t3 = { width: 0, height: 0 }), { width: t3.width, height: t3.height };
      } }, { key: "getxAxisGroupLabelsCoords", value: function() {
        var t3, e2 = this.w;
        if (!e2.globals.hasXaxisGroups)
          return { width: 0, height: 0 };
        var i2, a2 = (null === (t3 = e2.config.xaxis.group.style) || void 0 === t3 ? void 0 : t3.fontSize) || e2.config.xaxis.labels.style.fontSize, s2 = e2.globals.groups.map(function(t4) {
          return t4.title;
        }), r2 = x.getLargestStringFromArr(s2), o2 = this.dCtx.dimHelpers.getLargestStringFromMultiArr(r2, s2), n2 = new m(this.dCtx.ctx), l2 = n2.getTextRects(r2, a2), h2 = l2;
        return r2 !== o2 && (h2 = n2.getTextRects(o2, a2)), i2 = { width: l2.width >= h2.width ? l2.width : h2.width, height: l2.height >= h2.height ? l2.height : h2.height }, e2.config.xaxis.labels.show || (i2 = { width: 0, height: 0 }), { width: i2.width, height: i2.height };
      } }, { key: "getxAxisTitleCoords", value: function() {
        var t3 = this.w, e2 = 0, i2 = 0;
        if (void 0 !== t3.config.xaxis.title.text) {
          var a2 = new m(this.dCtx.ctx).getTextRects(t3.config.xaxis.title.text, t3.config.xaxis.title.style.fontSize);
          e2 = a2.width, i2 = a2.height;
        }
        return { width: e2, height: i2 };
      } }, { key: "getxAxisTimeScaleLabelsCoords", value: function() {
        var t3, e2 = this.w;
        this.dCtx.timescaleLabels = e2.globals.timescaleLabels.slice();
        var i2 = this.dCtx.timescaleLabels.map(function(t4) {
          return t4.value;
        }), a2 = i2.reduce(function(t4, e3) {
          return void 0 === t4 ? (console.error("You have possibly supplied invalid Date format. Please supply a valid JavaScript Date"), 0) : t4.length > e3.length ? t4 : e3;
        }, 0);
        return 1.05 * (t3 = new m(this.dCtx.ctx).getTextRects(a2, e2.config.xaxis.labels.style.fontSize)).width * i2.length > e2.globals.gridWidth && 0 !== e2.config.xaxis.labels.rotate && (e2.globals.overlappingXLabels = true), t3;
      } }, { key: "additionalPaddingXLabels", value: function(t3) {
        var e2 = this, i2 = this.w, a2 = i2.globals, s2 = i2.config, r2 = s2.xaxis.type, o2 = t3.width;
        a2.skipLastTimelinelabel = false, a2.skipFirstTimelinelabel = false;
        var n2 = i2.config.yaxis[0].opposite && i2.globals.isBarHorizontal, l2 = function(t4, n3) {
          s2.yaxis.length > 1 && function(t5) {
            return -1 !== a2.collapsedSeriesIndices.indexOf(t5);
          }(n3) || function(t5) {
            if (e2.dCtx.timescaleLabels && e2.dCtx.timescaleLabels.length) {
              var n4 = e2.dCtx.timescaleLabels[0], l3 = e2.dCtx.timescaleLabels[e2.dCtx.timescaleLabels.length - 1].position + o2 / 1.75 - e2.dCtx.yAxisWidthRight, h2 = n4.position - o2 / 1.75 + e2.dCtx.yAxisWidthLeft, c2 = "right" === i2.config.legend.position && e2.dCtx.lgRect.width > 0 ? e2.dCtx.lgRect.width : 0;
              l3 > a2.svgWidth - a2.translateX - c2 && (a2.skipLastTimelinelabel = true), h2 < -(t5.show && !t5.floating || "bar" !== s2.chart.type && "candlestick" !== s2.chart.type && "rangeBar" !== s2.chart.type && "boxPlot" !== s2.chart.type ? 10 : o2 / 1.75) && (a2.skipFirstTimelinelabel = true);
            } else
              "datetime" === r2 ? e2.dCtx.gridPad.right < o2 && !a2.rotateXLabels && (a2.skipLastTimelinelabel = true) : "datetime" !== r2 && e2.dCtx.gridPad.right < o2 / 2 - e2.dCtx.yAxisWidthRight && !a2.rotateXLabels && !i2.config.xaxis.labels.trim && ("between" !== i2.config.xaxis.tickPlacement || i2.globals.isBarHorizontal) && (e2.dCtx.xPadRight = o2 / 2 + 1);
          }(t4);
        };
        s2.yaxis.forEach(function(t4, i3) {
          n2 ? (e2.dCtx.gridPad.left < o2 && (e2.dCtx.xPadLeft = o2 / 2 + 1), e2.dCtx.xPadRight = o2 / 2 + 1) : l2(t4, i3);
        });
      } }]), t2;
    }();
    var st = function() {
      function t2(e2) {
        a(this, t2), this.w = e2.w, this.dCtx = e2;
      }
      return r(t2, [{ key: "getyAxisLabelsCoords", value: function() {
        var t3 = this, e2 = this.w, i2 = [], a2 = 10, s2 = new B(this.dCtx.ctx);
        return e2.config.yaxis.map(function(r2, o2) {
          var n2 = { seriesIndex: o2, dataPointIndex: -1, w: e2 }, l2 = e2.globals.yAxisScale[o2], h2 = 0;
          if (!s2.isYAxisHidden(o2) && r2.labels.show && void 0 !== r2.labels.minWidth && (h2 = r2.labels.minWidth), !s2.isYAxisHidden(o2) && r2.labels.show && l2.result.length) {
            var c2 = e2.globals.yLabelFormatters[o2], d2 = l2.niceMin === Number.MIN_VALUE ? 0 : l2.niceMin, g2 = l2.result.reduce(function(t4, e3) {
              var i3, a3;
              return (null === (i3 = String(c2(t4, n2))) || void 0 === i3 ? void 0 : i3.length) > (null === (a3 = String(c2(e3, n2))) || void 0 === a3 ? void 0 : a3.length) ? t4 : e3;
            }, d2), u2 = g2 = c2(g2, n2);
            if (void 0 !== g2 && 0 !== g2.length || (g2 = l2.niceMax), e2.globals.isBarHorizontal) {
              a2 = 0;
              var p2 = e2.globals.labels.slice();
              g2 = x.getLargestStringFromArr(p2), g2 = c2(g2, { seriesIndex: o2, dataPointIndex: -1, w: e2 }), u2 = t3.dCtx.dimHelpers.getLargestStringFromMultiArr(g2, p2);
            }
            var f2 = new m(t3.dCtx.ctx), b2 = "rotate(".concat(r2.labels.rotate, " 0 0)"), v2 = f2.getTextRects(g2, r2.labels.style.fontSize, r2.labels.style.fontFamily, b2, false), y2 = v2;
            g2 !== u2 && (y2 = f2.getTextRects(u2, r2.labels.style.fontSize, r2.labels.style.fontFamily, b2, false)), i2.push({ width: (h2 > y2.width || h2 > v2.width ? h2 : y2.width > v2.width ? y2.width : v2.width) + a2, height: y2.height > v2.height ? y2.height : v2.height });
          } else
            i2.push({ width: 0, height: 0 });
        }), i2;
      } }, { key: "getyAxisTitleCoords", value: function() {
        var t3 = this, e2 = this.w, i2 = [];
        return e2.config.yaxis.map(function(e3, a2) {
          if (e3.show && void 0 !== e3.title.text) {
            var s2 = new m(t3.dCtx.ctx), r2 = "rotate(".concat(e3.title.rotate, " 0 0)"), o2 = s2.getTextRects(e3.title.text, e3.title.style.fontSize, e3.title.style.fontFamily, r2, false);
            i2.push({ width: o2.width, height: o2.height });
          } else
            i2.push({ width: 0, height: 0 });
        }), i2;
      } }, { key: "getTotalYAxisWidth", value: function() {
        var t3 = this.w, e2 = 0, i2 = 0, a2 = 0, s2 = t3.globals.yAxisScale.length > 1 ? 10 : 0, r2 = new B(this.dCtx.ctx), o2 = function(o3, n2) {
          var l2 = t3.config.yaxis[n2].floating, h2 = 0;
          o3.width > 0 && !l2 ? (h2 = o3.width + s2, function(e3) {
            return t3.globals.ignoreYAxisIndexes.indexOf(e3) > -1;
          }(n2) && (h2 = h2 - o3.width - s2)) : h2 = l2 || r2.isYAxisHidden(n2) ? 0 : 5, t3.config.yaxis[n2].opposite ? a2 += h2 : i2 += h2, e2 += h2;
        };
        return t3.globals.yLabelsCoords.map(function(t4, e3) {
          o2(t4, e3);
        }), t3.globals.yTitleCoords.map(function(t4, e3) {
          o2(t4, e3);
        }), t3.globals.isBarHorizontal && !t3.config.yaxis[0].floating && (e2 = t3.globals.yLabelsCoords[0].width + t3.globals.yTitleCoords[0].width + 15), this.dCtx.yAxisWidthLeft = i2, this.dCtx.yAxisWidthRight = a2, e2;
      } }]), t2;
    }();
    var rt = function() {
      function t2(e2) {
        a(this, t2), this.w = e2.w, this.dCtx = e2;
      }
      return r(t2, [{ key: "gridPadForColumnsInNumericAxis", value: function(t3) {
        var e2 = this.w;
        if (e2.globals.noData || e2.globals.allSeriesCollapsed)
          return 0;
        var i2 = function(t4) {
          return "bar" === t4 || "rangeBar" === t4 || "candlestick" === t4 || "boxPlot" === t4;
        }, a2 = e2.config.chart.type, s2 = 0, r2 = i2(a2) ? e2.config.series.length : 1;
        if (e2.globals.comboBarCount > 0 && (r2 = e2.globals.comboBarCount), e2.globals.collapsedSeries.forEach(function(t4) {
          i2(t4.type) && (r2 -= 1);
        }), e2.config.chart.stacked && (r2 = 1), (i2(a2) || e2.globals.comboBarCount > 0) && e2.globals.isXNumeric && !e2.globals.isBarHorizontal && r2 > 0) {
          var o2, n2, l2 = Math.abs(e2.globals.initialMaxX - e2.globals.initialMinX);
          l2 <= 3 && (l2 = e2.globals.dataPoints), o2 = l2 / t3, e2.globals.minXDiff && e2.globals.minXDiff / o2 > 0 && (n2 = e2.globals.minXDiff / o2), n2 > t3 / 2 && (n2 /= 2), (s2 = n2 / r2 * parseInt(e2.config.plotOptions.bar.columnWidth, 10) / 100) < 1 && (s2 = 1), s2 = s2 / (r2 > 1 ? 1 : 1.5) + 5, e2.globals.barPadForNumericAxis = s2;
        }
        return s2;
      } }, { key: "gridPadFortitleSubtitle", value: function() {
        var t3 = this, e2 = this.w, i2 = e2.globals, a2 = this.dCtx.isSparkline || !e2.globals.axisCharts ? 0 : 10;
        ["title", "subtitle"].forEach(function(i3) {
          void 0 !== e2.config[i3].text ? a2 += e2.config[i3].margin : a2 += t3.dCtx.isSparkline || !e2.globals.axisCharts ? 0 : 5;
        }), !e2.config.legend.show || "bottom" !== e2.config.legend.position || e2.config.legend.floating || e2.globals.axisCharts || (a2 += 10);
        var s2 = this.dCtx.dimHelpers.getTitleSubtitleCoords("title"), r2 = this.dCtx.dimHelpers.getTitleSubtitleCoords("subtitle");
        i2.gridHeight = i2.gridHeight - s2.height - r2.height - a2, i2.translateY = i2.translateY + s2.height + r2.height + a2;
      } }, { key: "setGridXPosForDualYAxis", value: function(t3, e2) {
        var i2 = this.w, a2 = new B(this.dCtx.ctx);
        i2.config.yaxis.map(function(s2, r2) {
          -1 !== i2.globals.ignoreYAxisIndexes.indexOf(r2) || s2.floating || a2.isYAxisHidden(r2) || (s2.opposite && (i2.globals.translateX = i2.globals.translateX - (e2[r2].width + t3[r2].width) - parseInt(i2.config.yaxis[r2].labels.style.fontSize, 10) / 1.2 - 12), i2.globals.translateX < 2 && (i2.globals.translateX = 2));
        });
      } }]), t2;
    }();
    var ot = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w, this.lgRect = {}, this.yAxisWidth = 0, this.yAxisWidthLeft = 0, this.yAxisWidthRight = 0, this.xAxisHeight = 0, this.isSparkline = this.w.config.chart.sparkline.enabled, this.dimHelpers = new it(this), this.dimYAxis = new st(this), this.dimXAxis = new at(this), this.dimGrid = new rt(this), this.lgWidthForSideLegends = 0, this.gridPad = this.w.config.grid.padding, this.xPadRight = 0, this.xPadLeft = 0;
      }
      return r(t2, [{ key: "plotCoords", value: function() {
        var t3 = this, e2 = this.w, i2 = e2.globals;
        this.lgRect = this.dimHelpers.getLegendsRect(), this.isSparkline && (e2.config.markers.discrete.length > 0 || e2.config.markers.size > 0) && Object.entries(this.gridPad).forEach(function(e3) {
          var i3 = g(e3, 2), a3 = i3[0], s2 = i3[1];
          t3.gridPad[a3] = Math.max(s2, t3.w.globals.markers.largestSize / 1.5);
        }), i2.axisCharts ? this.setDimensionsForAxisCharts() : this.setDimensionsForNonAxisCharts(), this.dimGrid.gridPadFortitleSubtitle(), i2.gridHeight = i2.gridHeight - this.gridPad.top - this.gridPad.bottom, i2.gridWidth = i2.gridWidth - this.gridPad.left - this.gridPad.right - this.xPadRight - this.xPadLeft;
        var a2 = this.dimGrid.gridPadForColumnsInNumericAxis(i2.gridWidth);
        i2.gridWidth = i2.gridWidth - 2 * a2, i2.translateX = i2.translateX + this.gridPad.left + this.xPadLeft + (a2 > 0 ? a2 + 4 : 0), i2.translateY = i2.translateY + this.gridPad.top;
      } }, { key: "setDimensionsForAxisCharts", value: function() {
        var t3 = this, e2 = this.w, i2 = e2.globals, a2 = this.dimYAxis.getyAxisLabelsCoords(), s2 = this.dimYAxis.getyAxisTitleCoords();
        e2.globals.yLabelsCoords = [], e2.globals.yTitleCoords = [], e2.config.yaxis.map(function(t4, i3) {
          e2.globals.yLabelsCoords.push({ width: a2[i3].width, index: i3 }), e2.globals.yTitleCoords.push({ width: s2[i3].width, index: i3 });
        }), this.yAxisWidth = this.dimYAxis.getTotalYAxisWidth();
        var r2 = this.dimXAxis.getxAxisLabelsCoords(), o2 = this.dimXAxis.getxAxisGroupLabelsCoords(), n2 = this.dimXAxis.getxAxisTitleCoords();
        this.conditionalChecksForAxisCoords(r2, n2, o2), i2.translateXAxisY = e2.globals.rotateXLabels ? this.xAxisHeight / 8 : -4, i2.translateXAxisX = e2.globals.rotateXLabels && e2.globals.isXNumeric && e2.config.xaxis.labels.rotate <= -45 ? -this.xAxisWidth / 4 : 0, e2.globals.isBarHorizontal && (i2.rotateXLabels = false, i2.translateXAxisY = parseInt(e2.config.xaxis.labels.style.fontSize, 10) / 1.5 * -1), i2.translateXAxisY = i2.translateXAxisY + e2.config.xaxis.labels.offsetY, i2.translateXAxisX = i2.translateXAxisX + e2.config.xaxis.labels.offsetX;
        var l2 = this.yAxisWidth, h2 = this.xAxisHeight;
        i2.xAxisLabelsHeight = this.xAxisHeight - n2.height, i2.xAxisGroupLabelsHeight = i2.xAxisLabelsHeight - r2.height, i2.xAxisLabelsWidth = this.xAxisWidth, i2.xAxisHeight = this.xAxisHeight;
        var c2 = 10;
        ("radar" === e2.config.chart.type || this.isSparkline) && (l2 = 0, h2 = i2.goldenPadding), this.isSparkline && (this.lgRect = { height: 0, width: 0 }), (this.isSparkline || "treemap" === e2.config.chart.type) && (l2 = 0, h2 = 0, c2 = 0), this.isSparkline || this.dimXAxis.additionalPaddingXLabels(r2);
        var d2 = function() {
          i2.translateX = l2, i2.gridHeight = i2.svgHeight - t3.lgRect.height - h2 - (t3.isSparkline || "treemap" === e2.config.chart.type ? 0 : e2.globals.rotateXLabels ? 10 : 15), i2.gridWidth = i2.svgWidth - l2;
        };
        switch ("top" === e2.config.xaxis.position && (c2 = i2.xAxisHeight - e2.config.xaxis.axisTicks.height - 5), e2.config.legend.position) {
          case "bottom":
            i2.translateY = c2, d2();
            break;
          case "top":
            i2.translateY = this.lgRect.height + c2, d2();
            break;
          case "left":
            i2.translateY = c2, i2.translateX = this.lgRect.width + l2, i2.gridHeight = i2.svgHeight - h2 - 12, i2.gridWidth = i2.svgWidth - this.lgRect.width - l2;
            break;
          case "right":
            i2.translateY = c2, i2.translateX = l2, i2.gridHeight = i2.svgHeight - h2 - 12, i2.gridWidth = i2.svgWidth - this.lgRect.width - l2 - 5;
            break;
          default:
            throw new Error("Legend position not supported");
        }
        this.dimGrid.setGridXPosForDualYAxis(s2, a2), new q(this.ctx).setYAxisXPosition(a2, s2);
      } }, { key: "setDimensionsForNonAxisCharts", value: function() {
        var t3 = this.w, e2 = t3.globals, i2 = t3.config, a2 = 0;
        t3.config.legend.show && !t3.config.legend.floating && (a2 = 20);
        var s2 = "pie" === i2.chart.type || "polarArea" === i2.chart.type || "donut" === i2.chart.type ? "pie" : "radialBar", r2 = i2.plotOptions[s2].offsetY, o2 = i2.plotOptions[s2].offsetX;
        if (!i2.legend.show || i2.legend.floating)
          return e2.gridHeight = e2.svgHeight - i2.grid.padding.left + i2.grid.padding.right, e2.gridWidth = e2.gridHeight, e2.translateY = r2, void (e2.translateX = o2 + (e2.svgWidth - e2.gridWidth) / 2);
        switch (i2.legend.position) {
          case "bottom":
            e2.gridHeight = e2.svgHeight - this.lgRect.height - e2.goldenPadding, e2.gridWidth = e2.svgWidth, e2.translateY = r2 - 10, e2.translateX = o2 + (e2.svgWidth - e2.gridWidth) / 2;
            break;
          case "top":
            e2.gridHeight = e2.svgHeight - this.lgRect.height - e2.goldenPadding, e2.gridWidth = e2.svgWidth, e2.translateY = this.lgRect.height + r2 + 10, e2.translateX = o2 + (e2.svgWidth - e2.gridWidth) / 2;
            break;
          case "left":
            e2.gridWidth = e2.svgWidth - this.lgRect.width - a2, e2.gridHeight = "auto" !== i2.chart.height ? e2.svgHeight : e2.gridWidth, e2.translateY = r2, e2.translateX = o2 + this.lgRect.width + a2;
            break;
          case "right":
            e2.gridWidth = e2.svgWidth - this.lgRect.width - a2 - 5, e2.gridHeight = "auto" !== i2.chart.height ? e2.svgHeight : e2.gridWidth, e2.translateY = r2, e2.translateX = o2 + 10;
            break;
          default:
            throw new Error("Legend position not supported");
        }
      } }, { key: "conditionalChecksForAxisCoords", value: function(t3, e2, i2) {
        var a2 = this.w, s2 = a2.globals.hasXaxisGroups ? 2 : 1, r2 = i2.height + t3.height + e2.height, o2 = a2.globals.isMultiLineX ? 1.2 : a2.globals.LINE_HEIGHT_RATIO, n2 = a2.globals.rotateXLabels ? 22 : 10, l2 = a2.globals.rotateXLabels && "bottom" === a2.config.legend.position ? 10 : 0;
        this.xAxisHeight = r2 * o2 + s2 * n2 + l2, this.xAxisWidth = t3.width, this.xAxisHeight - e2.height > a2.config.xaxis.labels.maxHeight && (this.xAxisHeight = a2.config.xaxis.labels.maxHeight), a2.config.xaxis.labels.minHeight && this.xAxisHeight < a2.config.xaxis.labels.minHeight && (this.xAxisHeight = a2.config.xaxis.labels.minHeight), a2.config.xaxis.floating && (this.xAxisHeight = 0);
        var h2 = 0, c2 = 0;
        a2.config.yaxis.forEach(function(t4) {
          h2 += t4.labels.minWidth, c2 += t4.labels.maxWidth;
        }), this.yAxisWidth < h2 && (this.yAxisWidth = h2), this.yAxisWidth > c2 && (this.yAxisWidth = c2);
      } }]), t2;
    }();
    var nt = function() {
      function t2(e2) {
        a(this, t2), this.w = e2.w, this.lgCtx = e2;
      }
      return r(t2, [{ key: "getLegendStyles", value: function() {
        var t3 = document.createElement("style");
        t3.setAttribute("type", "text/css");
        var e2 = document.createTextNode("	\n    	\n      .apexcharts-legend {	\n        display: flex;	\n        overflow: auto;	\n        padding: 0 10px;	\n      }	\n      .apexcharts-legend.apx-legend-position-bottom, .apexcharts-legend.apx-legend-position-top {	\n        flex-wrap: wrap	\n      }	\n      .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {	\n        flex-direction: column;	\n        bottom: 0;	\n      }	\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-left, .apexcharts-legend.apx-legend-position-top.apexcharts-align-left, .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {	\n        justify-content: flex-start;	\n      }	\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-center, .apexcharts-legend.apx-legend-position-top.apexcharts-align-center {	\n        justify-content: center;  	\n      }	\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-right, .apexcharts-legend.apx-legend-position-top.apexcharts-align-right {	\n        justify-content: flex-end;	\n      }	\n      .apexcharts-legend-series {	\n        cursor: pointer;	\n        line-height: normal;	\n      }	\n      .apexcharts-legend.apx-legend-position-bottom .apexcharts-legend-series, .apexcharts-legend.apx-legend-position-top .apexcharts-legend-series{	\n        display: flex;	\n        align-items: center;	\n      }	\n      .apexcharts-legend-text {	\n        position: relative;	\n        font-size: 14px;	\n      }	\n      .apexcharts-legend-text *, .apexcharts-legend-marker * {	\n        pointer-events: none;	\n      }	\n      .apexcharts-legend-marker {	\n        position: relative;	\n        display: inline-block;	\n        cursor: pointer;	\n        margin-right: 3px;	\n        border-style: solid;\n      }	\n      	\n      .apexcharts-legend.apexcharts-align-right .apexcharts-legend-series, .apexcharts-legend.apexcharts-align-left .apexcharts-legend-series{	\n        display: inline-block;	\n      }	\n      .apexcharts-legend-series.apexcharts-no-click {	\n        cursor: auto;	\n      }	\n      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {	\n        display: none !important;	\n      }	\n      .apexcharts-inactive-legend {	\n        opacity: 0.45;	\n      }");
        return t3.appendChild(e2), t3;
      } }, { key: "getLegendBBox", value: function() {
        var t3 = this.w.globals.dom.baseEl.querySelector(".apexcharts-legend").getBoundingClientRect(), e2 = t3.width;
        return { clwh: t3.height, clww: e2 };
      } }, { key: "appendToForeignObject", value: function() {
        this.w.globals.dom.elLegendForeign.appendChild(this.getLegendStyles());
      } }, { key: "toggleDataSeries", value: function(t3, e2) {
        var i2 = this, a2 = this.w;
        if (a2.globals.axisCharts || "radialBar" === a2.config.chart.type) {
          a2.globals.resized = true;
          var s2 = null, r2 = null;
          if (a2.globals.risingSeries = [], a2.globals.axisCharts ? (s2 = a2.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(t3, "']")), r2 = parseInt(s2.getAttribute("data:realIndex"), 10)) : (s2 = a2.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(t3 + 1, "']")), r2 = parseInt(s2.getAttribute("rel"), 10) - 1), e2)
            [{ cs: a2.globals.collapsedSeries, csi: a2.globals.collapsedSeriesIndices }, { cs: a2.globals.ancillaryCollapsedSeries, csi: a2.globals.ancillaryCollapsedSeriesIndices }].forEach(function(t4) {
              i2.riseCollapsedSeries(t4.cs, t4.csi, r2);
            });
          else
            this.hideSeries({ seriesEl: s2, realIndex: r2 });
        } else {
          var o2 = a2.globals.dom.Paper.select(" .apexcharts-series[rel='".concat(t3 + 1, "'] path")), n2 = a2.config.chart.type;
          if ("pie" === n2 || "polarArea" === n2 || "donut" === n2) {
            var l2 = a2.config.plotOptions.pie.donut.labels;
            new m(this.lgCtx.ctx).pathMouseDown(o2.members[0], null), this.lgCtx.ctx.pie.printDataLabelsInner(o2.members[0].node, l2);
          }
          o2.fire("click");
        }
      } }, { key: "hideSeries", value: function(t3) {
        var e2 = t3.seriesEl, i2 = t3.realIndex, a2 = this.w, s2 = x.clone(a2.config.series);
        if (a2.globals.axisCharts) {
          var r2 = false;
          if (a2.config.yaxis[i2] && a2.config.yaxis[i2].show && a2.config.yaxis[i2].showAlways && (r2 = true, a2.globals.ancillaryCollapsedSeriesIndices.indexOf(i2) < 0 && (a2.globals.ancillaryCollapsedSeries.push({ index: i2, data: s2[i2].data.slice(), type: e2.parentNode.className.baseVal.split("-")[1] }), a2.globals.ancillaryCollapsedSeriesIndices.push(i2))), !r2) {
            a2.globals.collapsedSeries.push({ index: i2, data: s2[i2].data.slice(), type: e2.parentNode.className.baseVal.split("-")[1] }), a2.globals.collapsedSeriesIndices.push(i2);
            var o2 = a2.globals.risingSeries.indexOf(i2);
            a2.globals.risingSeries.splice(o2, 1);
          }
        } else
          a2.globals.collapsedSeries.push({ index: i2, data: s2[i2] }), a2.globals.collapsedSeriesIndices.push(i2);
        for (var n2 = e2.childNodes, l2 = 0; l2 < n2.length; l2++)
          n2[l2].classList.contains("apexcharts-series-markers-wrap") && (n2[l2].classList.contains("apexcharts-hide") ? n2[l2].classList.remove("apexcharts-hide") : n2[l2].classList.add("apexcharts-hide"));
        a2.globals.allSeriesCollapsed = a2.globals.collapsedSeries.length === a2.config.series.length, s2 = this._getSeriesBasedOnCollapsedState(s2), this.lgCtx.ctx.updateHelpers._updateSeries(s2, a2.config.chart.animations.dynamicAnimation.enabled);
      } }, { key: "riseCollapsedSeries", value: function(t3, e2, i2) {
        var a2 = this.w, s2 = x.clone(a2.config.series);
        if (t3.length > 0) {
          for (var r2 = 0; r2 < t3.length; r2++)
            t3[r2].index === i2 && (a2.globals.axisCharts ? (s2[i2].data = t3[r2].data.slice(), t3.splice(r2, 1), e2.splice(r2, 1), a2.globals.risingSeries.push(i2)) : (s2[i2] = t3[r2].data, t3.splice(r2, 1), e2.splice(r2, 1), a2.globals.risingSeries.push(i2)));
          s2 = this._getSeriesBasedOnCollapsedState(s2), this.lgCtx.ctx.updateHelpers._updateSeries(s2, a2.config.chart.animations.dynamicAnimation.enabled);
        }
      } }, { key: "_getSeriesBasedOnCollapsedState", value: function(t3) {
        var e2 = this.w;
        return e2.globals.axisCharts ? t3.forEach(function(i2, a2) {
          e2.globals.collapsedSeriesIndices.indexOf(a2) > -1 && (t3[a2].data = []);
        }) : t3.forEach(function(i2, a2) {
          e2.globals.collapsedSeriesIndices.indexOf(a2) > -1 && (t3[a2] = 0);
        }), t3;
      } }]), t2;
    }();
    var lt = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w, this.onLegendClick = this.onLegendClick.bind(this), this.onLegendHovered = this.onLegendHovered.bind(this), this.isBarsDistributed = "bar" === this.w.config.chart.type && this.w.config.plotOptions.bar.distributed && 1 === this.w.config.series.length, this.legendHelpers = new nt(this);
      }
      return r(t2, [{ key: "init", value: function() {
        var t3 = this.w, e2 = t3.globals, i2 = t3.config;
        if ((i2.legend.showForSingleSeries && 1 === e2.series.length || this.isBarsDistributed || e2.series.length > 1 || !e2.axisCharts) && i2.legend.show) {
          for (; e2.dom.elLegendWrap.firstChild; )
            e2.dom.elLegendWrap.removeChild(e2.dom.elLegendWrap.firstChild);
          this.drawLegends(), x.isIE11() ? document.getElementsByTagName("head")[0].appendChild(this.legendHelpers.getLegendStyles()) : this.legendHelpers.appendToForeignObject(), "bottom" === i2.legend.position || "top" === i2.legend.position ? this.legendAlignHorizontal() : "right" !== i2.legend.position && "left" !== i2.legend.position || this.legendAlignVertical();
        }
      } }, { key: "drawLegends", value: function() {
        var t3 = this, e2 = this.w, i2 = e2.config.legend.fontFamily, a2 = e2.globals.seriesNames, s2 = e2.globals.colors.slice();
        if ("heatmap" === e2.config.chart.type) {
          var r2 = e2.config.plotOptions.heatmap.colorScale.ranges;
          a2 = r2.map(function(t4) {
            return t4.name ? t4.name : t4.from + " - " + t4.to;
          }), s2 = r2.map(function(t4) {
            return t4.color;
          });
        } else
          this.isBarsDistributed && (a2 = e2.globals.labels.slice());
        e2.config.legend.customLegendItems.length && (a2 = e2.config.legend.customLegendItems);
        for (var o2 = e2.globals.legendFormatter, n2 = e2.config.legend.inverseOrder, l2 = n2 ? a2.length - 1 : 0; n2 ? l2 >= 0 : l2 <= a2.length - 1; n2 ? l2-- : l2++) {
          var h2, c2 = o2(a2[l2], { seriesIndex: l2, w: e2 }), d2 = false, g2 = false;
          if (e2.globals.collapsedSeries.length > 0)
            for (var u2 = 0; u2 < e2.globals.collapsedSeries.length; u2++)
              e2.globals.collapsedSeries[u2].index === l2 && (d2 = true);
          if (e2.globals.ancillaryCollapsedSeriesIndices.length > 0)
            for (var p2 = 0; p2 < e2.globals.ancillaryCollapsedSeriesIndices.length; p2++)
              e2.globals.ancillaryCollapsedSeriesIndices[p2] === l2 && (g2 = true);
          var f2 = document.createElement("span");
          f2.classList.add("apexcharts-legend-marker");
          var b2 = e2.config.legend.markers.offsetX, v2 = e2.config.legend.markers.offsetY, w2 = e2.config.legend.markers.height, k2 = e2.config.legend.markers.width, A2 = e2.config.legend.markers.strokeWidth, S2 = e2.config.legend.markers.strokeColor, C2 = e2.config.legend.markers.radius, L2 = f2.style;
          L2.background = s2[l2], L2.color = s2[l2], L2.setProperty("background", s2[l2], "important"), e2.config.legend.markers.fillColors && e2.config.legend.markers.fillColors[l2] && (L2.background = e2.config.legend.markers.fillColors[l2]), void 0 !== e2.globals.seriesColors[l2] && (L2.background = e2.globals.seriesColors[l2], L2.color = e2.globals.seriesColors[l2]), L2.height = Array.isArray(w2) ? parseFloat(w2[l2]) + "px" : parseFloat(w2) + "px", L2.width = Array.isArray(k2) ? parseFloat(k2[l2]) + "px" : parseFloat(k2) + "px", L2.left = (Array.isArray(b2) ? parseFloat(b2[l2]) : parseFloat(b2)) + "px", L2.top = (Array.isArray(v2) ? parseFloat(v2[l2]) : parseFloat(v2)) + "px", L2.borderWidth = Array.isArray(A2) ? A2[l2] : A2, L2.borderColor = Array.isArray(S2) ? S2[l2] : S2, L2.borderRadius = Array.isArray(C2) ? parseFloat(C2[l2]) + "px" : parseFloat(C2) + "px", e2.config.legend.markers.customHTML && (Array.isArray(e2.config.legend.markers.customHTML) ? e2.config.legend.markers.customHTML[l2] && (f2.innerHTML = e2.config.legend.markers.customHTML[l2]()) : f2.innerHTML = e2.config.legend.markers.customHTML()), m.setAttrs(f2, { rel: l2 + 1, "data:collapsed": d2 || g2 }), (d2 || g2) && f2.classList.add("apexcharts-inactive-legend");
          var P2 = document.createElement("div"), I2 = document.createElement("span");
          I2.classList.add("apexcharts-legend-text"), I2.innerHTML = Array.isArray(c2) ? c2.join(" ") : c2;
          var T2 = e2.config.legend.labels.useSeriesColors ? e2.globals.colors[l2] : Array.isArray(e2.config.legend.labels.colors) ? null === (h2 = e2.config.legend.labels.colors) || void 0 === h2 ? void 0 : h2[l2] : e2.config.legend.labels.colors;
          T2 || (T2 = e2.config.chart.foreColor), I2.style.color = T2, I2.style.fontSize = parseFloat(e2.config.legend.fontSize) + "px", I2.style.fontWeight = e2.config.legend.fontWeight, I2.style.fontFamily = i2 || e2.config.chart.fontFamily, m.setAttrs(I2, { rel: l2 + 1, i: l2, "data:default-text": encodeURIComponent(c2), "data:collapsed": d2 || g2 }), P2.appendChild(f2), P2.appendChild(I2);
          var M2 = new y(this.ctx);
          if (!e2.config.legend.showForZeroSeries)
            0 === M2.getSeriesTotalByIndex(l2) && M2.seriesHaveSameValues(l2) && !M2.isSeriesNull(l2) && -1 === e2.globals.collapsedSeriesIndices.indexOf(l2) && -1 === e2.globals.ancillaryCollapsedSeriesIndices.indexOf(l2) && P2.classList.add("apexcharts-hidden-zero-series");
          e2.config.legend.showForNullSeries || M2.isSeriesNull(l2) && -1 === e2.globals.collapsedSeriesIndices.indexOf(l2) && -1 === e2.globals.ancillaryCollapsedSeriesIndices.indexOf(l2) && P2.classList.add("apexcharts-hidden-null-series"), e2.globals.dom.elLegendWrap.appendChild(P2), e2.globals.dom.elLegendWrap.classList.add("apexcharts-align-".concat(e2.config.legend.horizontalAlign)), e2.globals.dom.elLegendWrap.classList.add("apx-legend-position-" + e2.config.legend.position), P2.classList.add("apexcharts-legend-series"), P2.style.margin = "".concat(e2.config.legend.itemMargin.vertical, "px ").concat(e2.config.legend.itemMargin.horizontal, "px"), e2.globals.dom.elLegendWrap.style.width = e2.config.legend.width ? e2.config.legend.width + "px" : "", e2.globals.dom.elLegendWrap.style.height = e2.config.legend.height ? e2.config.legend.height + "px" : "", m.setAttrs(P2, { rel: l2 + 1, seriesName: x.escapeString(a2[l2]), "data:collapsed": d2 || g2 }), (d2 || g2) && P2.classList.add("apexcharts-inactive-legend"), e2.config.legend.onItemClick.toggleDataSeries || P2.classList.add("apexcharts-no-click");
        }
        e2.globals.dom.elWrap.addEventListener("click", t3.onLegendClick, true), e2.config.legend.onItemHover.highlightDataSeries && 0 === e2.config.legend.customLegendItems.length && (e2.globals.dom.elWrap.addEventListener("mousemove", t3.onLegendHovered, true), e2.globals.dom.elWrap.addEventListener("mouseout", t3.onLegendHovered, true));
      } }, { key: "setLegendWrapXY", value: function(t3, e2) {
        var i2 = this.w, a2 = i2.globals.dom.elLegendWrap, s2 = a2.getBoundingClientRect(), r2 = 0, o2 = 0;
        if ("bottom" === i2.config.legend.position)
          o2 += i2.globals.svgHeight - s2.height / 2;
        else if ("top" === i2.config.legend.position) {
          var n2 = new ot(this.ctx), l2 = n2.dimHelpers.getTitleSubtitleCoords("title").height, h2 = n2.dimHelpers.getTitleSubtitleCoords("subtitle").height;
          o2 = o2 + (l2 > 0 ? l2 - 10 : 0) + (h2 > 0 ? h2 - 10 : 0);
        }
        a2.style.position = "absolute", r2 = r2 + t3 + i2.config.legend.offsetX, o2 = o2 + e2 + i2.config.legend.offsetY, a2.style.left = r2 + "px", a2.style.top = o2 + "px", "bottom" === i2.config.legend.position ? (a2.style.top = "auto", a2.style.bottom = 5 - i2.config.legend.offsetY + "px") : "right" === i2.config.legend.position && (a2.style.left = "auto", a2.style.right = 25 + i2.config.legend.offsetX + "px");
        ["width", "height"].forEach(function(t4) {
          a2.style[t4] && (a2.style[t4] = parseInt(i2.config.legend[t4], 10) + "px");
        });
      } }, { key: "legendAlignHorizontal", value: function() {
        var t3 = this.w;
        t3.globals.dom.elLegendWrap.style.right = 0;
        var e2 = this.legendHelpers.getLegendBBox(), i2 = new ot(this.ctx), a2 = i2.dimHelpers.getTitleSubtitleCoords("title"), s2 = i2.dimHelpers.getTitleSubtitleCoords("subtitle"), r2 = 0;
        "bottom" === t3.config.legend.position ? r2 = -e2.clwh / 1.8 : "top" === t3.config.legend.position && (r2 = a2.height + s2.height + t3.config.title.margin + t3.config.subtitle.margin - 10), this.setLegendWrapXY(20, r2);
      } }, { key: "legendAlignVertical", value: function() {
        var t3 = this.w, e2 = this.legendHelpers.getLegendBBox(), i2 = 0;
        "left" === t3.config.legend.position && (i2 = 20), "right" === t3.config.legend.position && (i2 = t3.globals.svgWidth - e2.clww - 10), this.setLegendWrapXY(i2, 20);
      } }, { key: "onLegendHovered", value: function(t3) {
        var e2 = this.w, i2 = t3.target.classList.contains("apexcharts-legend-series") || t3.target.classList.contains("apexcharts-legend-text") || t3.target.classList.contains("apexcharts-legend-marker");
        if ("heatmap" === e2.config.chart.type || this.isBarsDistributed) {
          if (i2) {
            var a2 = parseInt(t3.target.getAttribute("rel"), 10) - 1;
            this.ctx.events.fireEvent("legendHover", [this.ctx, a2, this.w]), new N(this.ctx).highlightRangeInSeries(t3, t3.target);
          }
        } else
          !t3.target.classList.contains("apexcharts-inactive-legend") && i2 && new N(this.ctx).toggleSeriesOnHover(t3, t3.target);
      } }, { key: "onLegendClick", value: function(t3) {
        var e2 = this.w;
        if (!e2.config.legend.customLegendItems.length && (t3.target.classList.contains("apexcharts-legend-series") || t3.target.classList.contains("apexcharts-legend-text") || t3.target.classList.contains("apexcharts-legend-marker"))) {
          var i2 = parseInt(t3.target.getAttribute("rel"), 10) - 1, a2 = "true" === t3.target.getAttribute("data:collapsed"), s2 = this.w.config.chart.events.legendClick;
          "function" == typeof s2 && s2(this.ctx, i2, this.w), this.ctx.events.fireEvent("legendClick", [this.ctx, i2, this.w]);
          var r2 = this.w.config.legend.markers.onClick;
          "function" == typeof r2 && t3.target.classList.contains("apexcharts-legend-marker") && (r2(this.ctx, i2, this.w), this.ctx.events.fireEvent("legendMarkerClick", [this.ctx, i2, this.w])), "treemap" !== e2.config.chart.type && "heatmap" !== e2.config.chart.type && !this.isBarsDistributed && e2.config.legend.onItemClick.toggleDataSeries && this.legendHelpers.toggleDataSeries(i2, a2);
        }
      } }]), t2;
    }();
    var ht = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
        var i2 = this.w;
        this.ev = this.w.config.chart.events, this.selectedClass = "apexcharts-selected", this.localeValues = this.w.globals.locale.toolbar, this.minX = i2.globals.minX, this.maxX = i2.globals.maxX;
      }
      return r(t2, [{ key: "createToolbar", value: function() {
        var t3 = this, e2 = this.w, i2 = function() {
          return document.createElement("div");
        }, a2 = i2();
        if (a2.setAttribute("class", "apexcharts-toolbar"), a2.style.top = e2.config.chart.toolbar.offsetY + "px", a2.style.right = 3 - e2.config.chart.toolbar.offsetX + "px", e2.globals.dom.elWrap.appendChild(a2), this.elZoom = i2(), this.elZoomIn = i2(), this.elZoomOut = i2(), this.elPan = i2(), this.elSelection = i2(), this.elZoomReset = i2(), this.elMenuIcon = i2(), this.elMenu = i2(), this.elCustomIcons = [], this.t = e2.config.chart.toolbar.tools, Array.isArray(this.t.customIcons))
          for (var s2 = 0; s2 < this.t.customIcons.length; s2++)
            this.elCustomIcons.push(i2());
        var r2 = [], o2 = function(i3, a3, s3) {
          var o3 = i3.toLowerCase();
          t3.t[o3] && e2.config.chart.zoom.enabled && r2.push({ el: a3, icon: "string" == typeof t3.t[o3] ? t3.t[o3] : s3, title: t3.localeValues[i3], class: "apexcharts-".concat(o3, "-icon") });
        };
        o2("zoomIn", this.elZoomIn, '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n'), o2("zoomOut", this.elZoomOut, '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n');
        var n2 = function(i3) {
          t3.t[i3] && e2.config.chart[i3].enabled && r2.push({ el: "zoom" === i3 ? t3.elZoom : t3.elSelection, icon: "string" == typeof t3.t[i3] ? t3.t[i3] : "zoom" === i3 ? '<svg xmlns="http://www.w3.org/2000/svg" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>\n    <path d="M0 0h24v24H0V0z" fill="none"/>\n    <path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"/>\n</svg>' : '<svg fill="#6E8192" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z"/>\n</svg>', title: t3.localeValues["zoom" === i3 ? "selectionZoom" : "selection"], class: e2.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-".concat(i3, "-icon") });
        };
        n2("zoom"), n2("selection"), this.t.pan && e2.config.chart.zoom.enabled && r2.push({ el: this.elPan, icon: "string" == typeof this.t.pan ? this.t.pan : '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <defs>\n        <path d="M0 0h24v24H0z" id="a"/>\n    </defs>\n    <clipPath id="b">\n        <use overflow="visible" xlink:href="#a"/>\n    </clipPath>\n    <path clip-path="url(#b)" d="M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z"/>\n</svg>', title: this.localeValues.pan, class: e2.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-pan-icon" }), o2("reset", this.elZoomReset, '<svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>\n    <path d="M0 0h24v24H0z" fill="none"/>\n</svg>'), this.t.download && r2.push({ el: this.elMenuIcon, icon: "string" == typeof this.t.download ? this.t.download : '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>', title: this.localeValues.menu, class: "apexcharts-menu-icon" });
        for (var l2 = 0; l2 < this.elCustomIcons.length; l2++)
          r2.push({ el: this.elCustomIcons[l2], icon: this.t.customIcons[l2].icon, title: this.t.customIcons[l2].title, index: this.t.customIcons[l2].index, class: "apexcharts-toolbar-custom-icon " + this.t.customIcons[l2].class });
        r2.forEach(function(t4, e3) {
          t4.index && x.moveIndexInArray(r2, e3, t4.index);
        });
        for (var h2 = 0; h2 < r2.length; h2++)
          m.setAttrs(r2[h2].el, { class: r2[h2].class, title: r2[h2].title }), r2[h2].el.innerHTML = r2[h2].icon, a2.appendChild(r2[h2].el);
        this._createHamburgerMenu(a2), e2.globals.zoomEnabled ? this.elZoom.classList.add(this.selectedClass) : e2.globals.panEnabled ? this.elPan.classList.add(this.selectedClass) : e2.globals.selectionEnabled && this.elSelection.classList.add(this.selectedClass), this.addToolbarEventListeners();
      } }, { key: "_createHamburgerMenu", value: function(t3) {
        this.elMenuItems = [], t3.appendChild(this.elMenu), m.setAttrs(this.elMenu, { class: "apexcharts-menu" });
        var e2 = [{ name: "exportSVG", title: this.localeValues.exportToSVG }, { name: "exportPNG", title: this.localeValues.exportToPNG }, { name: "exportCSV", title: this.localeValues.exportToCSV }];
        this.w.globals.allSeriesHasEqualX || e2.splice(2, 1);
        for (var i2 = 0; i2 < e2.length; i2++)
          this.elMenuItems.push(document.createElement("div")), this.elMenuItems[i2].innerHTML = e2[i2].title, m.setAttrs(this.elMenuItems[i2], { class: "apexcharts-menu-item ".concat(e2[i2].name), title: e2[i2].title }), this.elMenu.appendChild(this.elMenuItems[i2]);
      } }, { key: "addToolbarEventListeners", value: function() {
        var t3 = this;
        this.elZoomReset.addEventListener("click", this.handleZoomReset.bind(this)), this.elSelection.addEventListener("click", this.toggleZoomSelection.bind(this, "selection")), this.elZoom.addEventListener("click", this.toggleZoomSelection.bind(this, "zoom")), this.elZoomIn.addEventListener("click", this.handleZoomIn.bind(this)), this.elZoomOut.addEventListener("click", this.handleZoomOut.bind(this)), this.elPan.addEventListener("click", this.togglePanning.bind(this)), this.elMenuIcon.addEventListener("click", this.toggleMenu.bind(this)), this.elMenuItems.forEach(function(e3) {
          e3.classList.contains("exportSVG") ? e3.addEventListener("click", t3.handleDownload.bind(t3, "svg")) : e3.classList.contains("exportPNG") ? e3.addEventListener("click", t3.handleDownload.bind(t3, "png")) : e3.classList.contains("exportCSV") && e3.addEventListener("click", t3.handleDownload.bind(t3, "csv"));
        });
        for (var e2 = 0; e2 < this.t.customIcons.length; e2++)
          this.elCustomIcons[e2].addEventListener("click", this.t.customIcons[e2].click.bind(this, this.ctx, this.ctx.w));
      } }, { key: "toggleZoomSelection", value: function(t3) {
        this.ctx.getSyncedCharts().forEach(function(e2) {
          e2.ctx.toolbar.toggleOtherControls();
          var i2 = "selection" === t3 ? e2.ctx.toolbar.elSelection : e2.ctx.toolbar.elZoom, a2 = "selection" === t3 ? "selectionEnabled" : "zoomEnabled";
          e2.w.globals[a2] = !e2.w.globals[a2], i2.classList.contains(e2.ctx.toolbar.selectedClass) ? i2.classList.remove(e2.ctx.toolbar.selectedClass) : i2.classList.add(e2.ctx.toolbar.selectedClass);
        });
      } }, { key: "getToolbarIconsReference", value: function() {
        var t3 = this.w;
        this.elZoom || (this.elZoom = t3.globals.dom.baseEl.querySelector(".apexcharts-zoom-icon")), this.elPan || (this.elPan = t3.globals.dom.baseEl.querySelector(".apexcharts-pan-icon")), this.elSelection || (this.elSelection = t3.globals.dom.baseEl.querySelector(".apexcharts-selection-icon"));
      } }, { key: "enableZoomPanFromToolbar", value: function(t3) {
        this.toggleOtherControls(), "pan" === t3 ? this.w.globals.panEnabled = true : this.w.globals.zoomEnabled = true;
        var e2 = "pan" === t3 ? this.elPan : this.elZoom, i2 = "pan" === t3 ? this.elZoom : this.elPan;
        e2 && e2.classList.add(this.selectedClass), i2 && i2.classList.remove(this.selectedClass);
      } }, { key: "togglePanning", value: function() {
        this.ctx.getSyncedCharts().forEach(function(t3) {
          t3.ctx.toolbar.toggleOtherControls(), t3.w.globals.panEnabled = !t3.w.globals.panEnabled, t3.ctx.toolbar.elPan.classList.contains(t3.ctx.toolbar.selectedClass) ? t3.ctx.toolbar.elPan.classList.remove(t3.ctx.toolbar.selectedClass) : t3.ctx.toolbar.elPan.classList.add(t3.ctx.toolbar.selectedClass);
        });
      } }, { key: "toggleOtherControls", value: function() {
        var t3 = this, e2 = this.w;
        e2.globals.panEnabled = false, e2.globals.zoomEnabled = false, e2.globals.selectionEnabled = false, this.getToolbarIconsReference(), [this.elPan, this.elSelection, this.elZoom].forEach(function(e3) {
          e3 && e3.classList.remove(t3.selectedClass);
        });
      } }, { key: "handleZoomIn", value: function() {
        var t3 = this.w;
        t3.globals.isRangeBar && (this.minX = t3.globals.minY, this.maxX = t3.globals.maxY);
        var e2 = (this.minX + this.maxX) / 2, i2 = (this.minX + e2) / 2, a2 = (this.maxX + e2) / 2, s2 = this._getNewMinXMaxX(i2, a2);
        t3.globals.disableZoomIn || this.zoomUpdateOptions(s2.minX, s2.maxX);
      } }, { key: "handleZoomOut", value: function() {
        var t3 = this.w;
        if (t3.globals.isRangeBar && (this.minX = t3.globals.minY, this.maxX = t3.globals.maxY), !("datetime" === t3.config.xaxis.type && new Date(this.minX).getUTCFullYear() < 1e3)) {
          var e2 = (this.minX + this.maxX) / 2, i2 = this.minX - (e2 - this.minX), a2 = this.maxX - (e2 - this.maxX), s2 = this._getNewMinXMaxX(i2, a2);
          t3.globals.disableZoomOut || this.zoomUpdateOptions(s2.minX, s2.maxX);
        }
      } }, { key: "_getNewMinXMaxX", value: function(t3, e2) {
        var i2 = this.w.config.xaxis.convertedCatToNumeric;
        return { minX: i2 ? Math.floor(t3) : t3, maxX: i2 ? Math.floor(e2) : e2 };
      } }, { key: "zoomUpdateOptions", value: function(t3, e2) {
        var i2 = this.w;
        if (void 0 !== t3 || void 0 !== e2) {
          if (!(i2.config.xaxis.convertedCatToNumeric && (t3 < 1 && (t3 = 1, e2 = i2.globals.dataPoints), e2 - t3 < 2))) {
            var a2 = { min: t3, max: e2 }, s2 = this.getBeforeZoomRange(a2);
            s2 && (a2 = s2.xaxis);
            var r2 = { xaxis: a2 }, o2 = x.clone(i2.globals.initialConfig.yaxis);
            if (i2.config.chart.zoom.autoScaleYaxis)
              o2 = new _(this.ctx).autoScaleY(this.ctx, o2, { xaxis: a2 });
            i2.config.chart.group || (r2.yaxis = o2), this.w.globals.zoomed = true, this.ctx.updateHelpers._updateOptions(r2, false, this.w.config.chart.animations.dynamicAnimation.enabled), this.zoomCallback(a2, o2);
          }
        } else
          this.handleZoomReset();
      } }, { key: "zoomCallback", value: function(t3, e2) {
        "function" == typeof this.ev.zoomed && this.ev.zoomed(this.ctx, { xaxis: t3, yaxis: e2 });
      } }, { key: "getBeforeZoomRange", value: function(t3, e2) {
        var i2 = null;
        return "function" == typeof this.ev.beforeZoom && (i2 = this.ev.beforeZoom(this, { xaxis: t3, yaxis: e2 })), i2;
      } }, { key: "toggleMenu", value: function() {
        var t3 = this;
        window.setTimeout(function() {
          t3.elMenu.classList.contains("apexcharts-menu-open") ? t3.elMenu.classList.remove("apexcharts-menu-open") : t3.elMenu.classList.add("apexcharts-menu-open");
        }, 0);
      } }, { key: "handleDownload", value: function(t3) {
        var e2 = this.w, i2 = new G(this.ctx);
        switch (t3) {
          case "svg":
            i2.exportToSVG(this.ctx);
            break;
          case "png":
            i2.exportToPng(this.ctx);
            break;
          case "csv":
            i2.exportToCSV({ series: e2.config.series, columnDelimiter: e2.config.chart.toolbar.export.csv.columnDelimiter });
        }
      } }, { key: "handleZoomReset", value: function(t3) {
        this.ctx.getSyncedCharts().forEach(function(t4) {
          var e2 = t4.w;
          if (e2.globals.lastXAxis.min = e2.globals.initialConfig.xaxis.min, e2.globals.lastXAxis.max = e2.globals.initialConfig.xaxis.max, t4.updateHelpers.revertDefaultAxisMinMax(), "function" == typeof e2.config.chart.events.beforeResetZoom) {
            var i2 = e2.config.chart.events.beforeResetZoom(t4, e2);
            i2 && t4.updateHelpers.revertDefaultAxisMinMax(i2);
          }
          "function" == typeof e2.config.chart.events.zoomed && t4.ctx.toolbar.zoomCallback({ min: e2.config.xaxis.min, max: e2.config.xaxis.max }), e2.globals.zoomed = false;
          var a2 = t4.ctx.series.emptyCollapsedSeries(x.clone(e2.globals.initialSeries));
          t4.updateHelpers._updateSeries(a2, e2.config.chart.animations.dynamicAnimation.enabled);
        });
      } }, { key: "destroy", value: function() {
        this.elZoom = null, this.elZoomIn = null, this.elZoomOut = null, this.elPan = null, this.elSelection = null, this.elZoomReset = null, this.elMenuIcon = null;
      } }]), t2;
    }();
    var ct = function(t2) {
      n(i2, ht);
      var e2 = d(i2);
      function i2(t3) {
        var s2;
        return a(this, i2), (s2 = e2.call(this, t3)).ctx = t3, s2.w = t3.w, s2.dragged = false, s2.graphics = new m(s2.ctx), s2.eventList = ["mousedown", "mouseleave", "mousemove", "touchstart", "touchmove", "mouseup", "touchend"], s2.clientX = 0, s2.clientY = 0, s2.startX = 0, s2.endX = 0, s2.dragX = 0, s2.startY = 0, s2.endY = 0, s2.dragY = 0, s2.moveDirection = "none", s2;
      }
      return r(i2, [{ key: "init", value: function(t3) {
        var e3 = this, i3 = t3.xyRatios, a2 = this.w, s2 = this;
        this.xyRatios = i3, this.zoomRect = this.graphics.drawRect(0, 0, 0, 0), this.selectionRect = this.graphics.drawRect(0, 0, 0, 0), this.gridRect = a2.globals.dom.baseEl.querySelector(".apexcharts-grid"), this.zoomRect.node.classList.add("apexcharts-zoom-rect"), this.selectionRect.node.classList.add("apexcharts-selection-rect"), a2.globals.dom.elGraphical.add(this.zoomRect), a2.globals.dom.elGraphical.add(this.selectionRect), "x" === a2.config.chart.selection.type ? this.slDraggableRect = this.selectionRect.draggable({ minX: 0, minY: 0, maxX: a2.globals.gridWidth, maxY: a2.globals.gridHeight }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : "y" === a2.config.chart.selection.type ? this.slDraggableRect = this.selectionRect.draggable({ minX: 0, maxX: a2.globals.gridWidth }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : this.slDraggableRect = this.selectionRect.draggable().on("dragmove", this.selectionDragging.bind(this, "dragging")), this.preselectedSelection(), this.hoverArea = a2.globals.dom.baseEl.querySelector("".concat(a2.globals.chartClass, " .apexcharts-svg")), this.hoverArea.classList.add("apexcharts-zoomable"), this.eventList.forEach(function(t4) {
          e3.hoverArea.addEventListener(t4, s2.svgMouseEvents.bind(s2, i3), { capture: false, passive: true });
        });
      } }, { key: "destroy", value: function() {
        this.slDraggableRect && (this.slDraggableRect.draggable(false), this.slDraggableRect.off(), this.selectionRect.off()), this.selectionRect = null, this.zoomRect = null, this.gridRect = null;
      } }, { key: "svgMouseEvents", value: function(t3, e3) {
        var i3 = this.w, a2 = this, s2 = this.ctx.toolbar, r2 = i3.globals.zoomEnabled ? i3.config.chart.zoom.type : i3.config.chart.selection.type, o2 = i3.config.chart.toolbar.autoSelected;
        if (e3.shiftKey ? (this.shiftWasPressed = true, s2.enableZoomPanFromToolbar("pan" === o2 ? "zoom" : "pan")) : this.shiftWasPressed && (s2.enableZoomPanFromToolbar(o2), this.shiftWasPressed = false), e3.target) {
          var n2, l2 = e3.target.classList;
          if (e3.target.parentNode && null !== e3.target.parentNode && (n2 = e3.target.parentNode.classList), !(l2.contains("apexcharts-selection-rect") || l2.contains("apexcharts-legend-marker") || l2.contains("apexcharts-legend-text") || n2 && n2.contains("apexcharts-toolbar"))) {
            if (a2.clientX = "touchmove" === e3.type || "touchstart" === e3.type ? e3.touches[0].clientX : "touchend" === e3.type ? e3.changedTouches[0].clientX : e3.clientX, a2.clientY = "touchmove" === e3.type || "touchstart" === e3.type ? e3.touches[0].clientY : "touchend" === e3.type ? e3.changedTouches[0].clientY : e3.clientY, "mousedown" === e3.type && 1 === e3.which) {
              var h2 = a2.gridRect.getBoundingClientRect();
              a2.startX = a2.clientX - h2.left, a2.startY = a2.clientY - h2.top, a2.dragged = false, a2.w.globals.mousedown = true;
            }
            if (("mousemove" === e3.type && 1 === e3.which || "touchmove" === e3.type) && (a2.dragged = true, i3.globals.panEnabled ? (i3.globals.selection = null, a2.w.globals.mousedown && a2.panDragging({ context: a2, zoomtype: r2, xyRatios: t3 })) : (a2.w.globals.mousedown && i3.globals.zoomEnabled || a2.w.globals.mousedown && i3.globals.selectionEnabled) && (a2.selection = a2.selectionDrawing({ context: a2, zoomtype: r2 }))), "mouseup" === e3.type || "touchend" === e3.type || "mouseleave" === e3.type) {
              var c2 = a2.gridRect.getBoundingClientRect();
              a2.w.globals.mousedown && (a2.endX = a2.clientX - c2.left, a2.endY = a2.clientY - c2.top, a2.dragX = Math.abs(a2.endX - a2.startX), a2.dragY = Math.abs(a2.endY - a2.startY), (i3.globals.zoomEnabled || i3.globals.selectionEnabled) && a2.selectionDrawn({ context: a2, zoomtype: r2 }), i3.globals.panEnabled && i3.config.xaxis.convertedCatToNumeric && a2.delayedPanScrolled()), i3.globals.zoomEnabled && a2.hideSelectionRect(this.selectionRect), a2.dragged = false, a2.w.globals.mousedown = false;
            }
            this.makeSelectionRectDraggable();
          }
        }
      } }, { key: "makeSelectionRectDraggable", value: function() {
        var t3 = this.w;
        if (this.selectionRect) {
          var e3 = this.selectionRect.node.getBoundingClientRect();
          e3.width > 0 && e3.height > 0 && this.slDraggableRect.selectize({ points: "l, r", pointSize: 8, pointType: "rect" }).resize({ constraint: { minX: 0, minY: 0, maxX: t3.globals.gridWidth, maxY: t3.globals.gridHeight } }).on("resizing", this.selectionDragging.bind(this, "resizing"));
        }
      } }, { key: "preselectedSelection", value: function() {
        var t3 = this.w, e3 = this.xyRatios;
        if (!t3.globals.zoomEnabled) {
          if (void 0 !== t3.globals.selection && null !== t3.globals.selection)
            this.drawSelectionRect(t3.globals.selection);
          else if (void 0 !== t3.config.chart.selection.xaxis.min && void 0 !== t3.config.chart.selection.xaxis.max) {
            var i3 = (t3.config.chart.selection.xaxis.min - t3.globals.minX) / e3.xRatio, a2 = { x: i3, y: 0, width: t3.globals.gridWidth - (t3.globals.maxX - t3.config.chart.selection.xaxis.max) / e3.xRatio - i3, height: t3.globals.gridHeight, translateX: 0, translateY: 0, selectionEnabled: true };
            this.drawSelectionRect(a2), this.makeSelectionRectDraggable(), "function" == typeof t3.config.chart.events.selection && t3.config.chart.events.selection(this.ctx, { xaxis: { min: t3.config.chart.selection.xaxis.min, max: t3.config.chart.selection.xaxis.max }, yaxis: {} });
          }
        }
      } }, { key: "drawSelectionRect", value: function(t3) {
        var e3 = t3.x, i3 = t3.y, a2 = t3.width, s2 = t3.height, r2 = t3.translateX, o2 = void 0 === r2 ? 0 : r2, n2 = t3.translateY, l2 = void 0 === n2 ? 0 : n2, h2 = this.w, c2 = this.zoomRect, d2 = this.selectionRect;
        if (this.dragged || null !== h2.globals.selection) {
          var g2 = { transform: "translate(" + o2 + ", " + l2 + ")" };
          h2.globals.zoomEnabled && this.dragged && (a2 < 0 && (a2 = 1), c2.attr({ x: e3, y: i3, width: a2, height: s2, fill: h2.config.chart.zoom.zoomedArea.fill.color, "fill-opacity": h2.config.chart.zoom.zoomedArea.fill.opacity, stroke: h2.config.chart.zoom.zoomedArea.stroke.color, "stroke-width": h2.config.chart.zoom.zoomedArea.stroke.width, "stroke-opacity": h2.config.chart.zoom.zoomedArea.stroke.opacity }), m.setAttrs(c2.node, g2)), h2.globals.selectionEnabled && (d2.attr({ x: e3, y: i3, width: a2 > 0 ? a2 : 0, height: s2 > 0 ? s2 : 0, fill: h2.config.chart.selection.fill.color, "fill-opacity": h2.config.chart.selection.fill.opacity, stroke: h2.config.chart.selection.stroke.color, "stroke-width": h2.config.chart.selection.stroke.width, "stroke-dasharray": h2.config.chart.selection.stroke.dashArray, "stroke-opacity": h2.config.chart.selection.stroke.opacity }), m.setAttrs(d2.node, g2));
        }
      } }, { key: "hideSelectionRect", value: function(t3) {
        t3 && t3.attr({ x: 0, y: 0, width: 0, height: 0 });
      } }, { key: "selectionDrawing", value: function(t3) {
        var e3 = t3.context, i3 = t3.zoomtype, a2 = this.w, s2 = e3, r2 = this.gridRect.getBoundingClientRect(), o2 = s2.startX - 1, n2 = s2.startY, l2 = false, h2 = false, c2 = s2.clientX - r2.left - o2, d2 = s2.clientY - r2.top - n2, g2 = {};
        return Math.abs(c2 + o2) > a2.globals.gridWidth ? c2 = a2.globals.gridWidth - o2 : s2.clientX - r2.left < 0 && (c2 = o2), o2 > s2.clientX - r2.left && (l2 = true, c2 = Math.abs(c2)), n2 > s2.clientY - r2.top && (h2 = true, d2 = Math.abs(d2)), g2 = "x" === i3 ? { x: l2 ? o2 - c2 : o2, y: 0, width: c2, height: a2.globals.gridHeight } : "y" === i3 ? { x: 0, y: h2 ? n2 - d2 : n2, width: a2.globals.gridWidth, height: d2 } : { x: l2 ? o2 - c2 : o2, y: h2 ? n2 - d2 : n2, width: c2, height: d2 }, s2.drawSelectionRect(g2), s2.selectionDragging("resizing"), g2;
      } }, { key: "selectionDragging", value: function(t3, e3) {
        var i3 = this, a2 = this.w, s2 = this.xyRatios, r2 = this.selectionRect, o2 = 0;
        "resizing" === t3 && (o2 = 30);
        var n2 = function(t4) {
          return parseFloat(r2.node.getAttribute(t4));
        }, l2 = { x: n2("x"), y: n2("y"), width: n2("width"), height: n2("height") };
        a2.globals.selection = l2, "function" == typeof a2.config.chart.events.selection && a2.globals.selectionEnabled && (clearTimeout(this.w.globals.selectionResizeTimer), this.w.globals.selectionResizeTimer = window.setTimeout(function() {
          var t4 = i3.gridRect.getBoundingClientRect(), e4 = r2.node.getBoundingClientRect(), o3 = { xaxis: { min: a2.globals.xAxisScale.niceMin + (e4.left - t4.left) * s2.xRatio, max: a2.globals.xAxisScale.niceMin + (e4.right - t4.left) * s2.xRatio }, yaxis: { min: a2.globals.yAxisScale[0].niceMin + (t4.bottom - e4.bottom) * s2.yRatio[0], max: a2.globals.yAxisScale[0].niceMax - (e4.top - t4.top) * s2.yRatio[0] } };
          a2.config.chart.events.selection(i3.ctx, o3), a2.config.chart.brush.enabled && void 0 !== a2.config.chart.events.brushScrolled && a2.config.chart.events.brushScrolled(i3.ctx, o3);
        }, o2));
      } }, { key: "selectionDrawn", value: function(t3) {
        var e3 = t3.context, i3 = t3.zoomtype, a2 = this.w, s2 = e3, r2 = this.xyRatios, o2 = this.ctx.toolbar;
        if (s2.startX > s2.endX) {
          var n2 = s2.startX;
          s2.startX = s2.endX, s2.endX = n2;
        }
        if (s2.startY > s2.endY) {
          var l2 = s2.startY;
          s2.startY = s2.endY, s2.endY = l2;
        }
        var h2 = void 0, c2 = void 0;
        a2.globals.isRangeBar ? (h2 = a2.globals.yAxisScale[0].niceMin + s2.startX * r2.invertedYRatio, c2 = a2.globals.yAxisScale[0].niceMin + s2.endX * r2.invertedYRatio) : (h2 = a2.globals.xAxisScale.niceMin + s2.startX * r2.xRatio, c2 = a2.globals.xAxisScale.niceMin + s2.endX * r2.xRatio);
        var d2 = [], g2 = [];
        if (a2.config.yaxis.forEach(function(t4, e4) {
          d2.push(a2.globals.yAxisScale[e4].niceMax - r2.yRatio[e4] * s2.startY), g2.push(a2.globals.yAxisScale[e4].niceMax - r2.yRatio[e4] * s2.endY);
        }), s2.dragged && (s2.dragX > 10 || s2.dragY > 10) && h2 !== c2) {
          if (a2.globals.zoomEnabled) {
            var u2 = x.clone(a2.globals.initialConfig.yaxis), p2 = x.clone(a2.globals.initialConfig.xaxis);
            if (a2.globals.zoomed = true, a2.config.xaxis.convertedCatToNumeric && (h2 = Math.floor(h2), c2 = Math.floor(c2), h2 < 1 && (h2 = 1, c2 = a2.globals.dataPoints), c2 - h2 < 2 && (c2 = h2 + 1)), "xy" !== i3 && "x" !== i3 || (p2 = { min: h2, max: c2 }), "xy" !== i3 && "y" !== i3 || u2.forEach(function(t4, e4) {
              u2[e4].min = g2[e4], u2[e4].max = d2[e4];
            }), a2.config.chart.zoom.autoScaleYaxis) {
              var f2 = new _(s2.ctx);
              u2 = f2.autoScaleY(s2.ctx, u2, { xaxis: p2 });
            }
            if (o2) {
              var b2 = o2.getBeforeZoomRange(p2, u2);
              b2 && (p2 = b2.xaxis ? b2.xaxis : p2, u2 = b2.yaxis ? b2.yaxis : u2);
            }
            var v2 = { xaxis: p2 };
            a2.config.chart.group || (v2.yaxis = u2), s2.ctx.updateHelpers._updateOptions(v2, false, s2.w.config.chart.animations.dynamicAnimation.enabled), "function" == typeof a2.config.chart.events.zoomed && o2.zoomCallback(p2, u2);
          } else if (a2.globals.selectionEnabled) {
            var m2, y2 = null;
            m2 = { min: h2, max: c2 }, "xy" !== i3 && "y" !== i3 || (y2 = x.clone(a2.config.yaxis)).forEach(function(t4, e4) {
              y2[e4].min = g2[e4], y2[e4].max = d2[e4];
            }), a2.globals.selection = s2.selection, "function" == typeof a2.config.chart.events.selection && a2.config.chart.events.selection(s2.ctx, { xaxis: m2, yaxis: y2 });
          }
        }
      } }, { key: "panDragging", value: function(t3) {
        var e3 = t3.context, i3 = this.w, a2 = e3;
        if (void 0 !== i3.globals.lastClientPosition.x) {
          var s2 = i3.globals.lastClientPosition.x - a2.clientX, r2 = i3.globals.lastClientPosition.y - a2.clientY;
          Math.abs(s2) > Math.abs(r2) && s2 > 0 ? this.moveDirection = "left" : Math.abs(s2) > Math.abs(r2) && s2 < 0 ? this.moveDirection = "right" : Math.abs(r2) > Math.abs(s2) && r2 > 0 ? this.moveDirection = "up" : Math.abs(r2) > Math.abs(s2) && r2 < 0 && (this.moveDirection = "down");
        }
        i3.globals.lastClientPosition = { x: a2.clientX, y: a2.clientY };
        var o2 = i3.globals.isRangeBar ? i3.globals.minY : i3.globals.minX, n2 = i3.globals.isRangeBar ? i3.globals.maxY : i3.globals.maxX;
        i3.config.xaxis.convertedCatToNumeric || a2.panScrolled(o2, n2);
      } }, { key: "delayedPanScrolled", value: function() {
        var t3 = this.w, e3 = t3.globals.minX, i3 = t3.globals.maxX, a2 = (t3.globals.maxX - t3.globals.minX) / 2;
        "left" === this.moveDirection ? (e3 = t3.globals.minX + a2, i3 = t3.globals.maxX + a2) : "right" === this.moveDirection && (e3 = t3.globals.minX - a2, i3 = t3.globals.maxX - a2), e3 = Math.floor(e3), i3 = Math.floor(i3), this.updateScrolledChart({ xaxis: { min: e3, max: i3 } }, e3, i3);
      } }, { key: "panScrolled", value: function(t3, e3) {
        var i3 = this.w, a2 = this.xyRatios, s2 = x.clone(i3.globals.initialConfig.yaxis), r2 = a2.xRatio, o2 = i3.globals.minX, n2 = i3.globals.maxX;
        i3.globals.isRangeBar && (r2 = a2.invertedYRatio, o2 = i3.globals.minY, n2 = i3.globals.maxY), "left" === this.moveDirection ? (t3 = o2 + i3.globals.gridWidth / 15 * r2, e3 = n2 + i3.globals.gridWidth / 15 * r2) : "right" === this.moveDirection && (t3 = o2 - i3.globals.gridWidth / 15 * r2, e3 = n2 - i3.globals.gridWidth / 15 * r2), i3.globals.isRangeBar || (t3 < i3.globals.initialMinX || e3 > i3.globals.initialMaxX) && (t3 = o2, e3 = n2);
        var l2 = { min: t3, max: e3 };
        i3.config.chart.zoom.autoScaleYaxis && (s2 = new _(this.ctx).autoScaleY(this.ctx, s2, { xaxis: l2 }));
        var h2 = { xaxis: { min: t3, max: e3 } };
        i3.config.chart.group || (h2.yaxis = s2), this.updateScrolledChart(h2, t3, e3);
      } }, { key: "updateScrolledChart", value: function(t3, e3, i3) {
        var a2 = this.w;
        this.ctx.updateHelpers._updateOptions(t3, false, false), "function" == typeof a2.config.chart.events.scrolled && a2.config.chart.events.scrolled(this.ctx, { xaxis: { min: e3, max: i3 } });
      } }]), i2;
    }();
    var dt = function() {
      function t2(e2) {
        a(this, t2), this.w = e2.w, this.ttCtx = e2, this.ctx = e2.ctx;
      }
      return r(t2, [{ key: "getNearestValues", value: function(t3) {
        var e2 = t3.hoverArea, i2 = t3.elGrid, a2 = t3.clientX, s2 = t3.clientY, r2 = this.w, o2 = i2.getBoundingClientRect(), n2 = o2.width, l2 = o2.height, h2 = n2 / (r2.globals.dataPoints - 1), c2 = l2 / r2.globals.dataPoints, d2 = this.hasBars();
        !r2.globals.comboCharts && !d2 || r2.config.xaxis.convertedCatToNumeric || (h2 = n2 / r2.globals.dataPoints);
        var g2 = a2 - o2.left - r2.globals.barPadForNumericAxis, u2 = s2 - o2.top;
        g2 < 0 || u2 < 0 || g2 > n2 || u2 > l2 ? (e2.classList.remove("hovering-zoom"), e2.classList.remove("hovering-pan")) : r2.globals.zoomEnabled ? (e2.classList.remove("hovering-pan"), e2.classList.add("hovering-zoom")) : r2.globals.panEnabled && (e2.classList.remove("hovering-zoom"), e2.classList.add("hovering-pan"));
        var p2 = Math.round(g2 / h2), f2 = Math.floor(u2 / c2);
        d2 && !r2.config.xaxis.convertedCatToNumeric && (p2 = Math.ceil(g2 / h2), p2 -= 1);
        var b2 = null, v2 = null, m2 = r2.globals.seriesXvalues.map(function(t4) {
          return t4.filter(function(t5) {
            return x.isNumber(t5);
          });
        }), y2 = r2.globals.seriesYvalues.map(function(t4) {
          return t4.filter(function(t5) {
            return x.isNumber(t5);
          });
        });
        if (r2.globals.isXNumeric) {
          var w2 = this.ttCtx.getElGrid().getBoundingClientRect(), k2 = g2 * (w2.width / n2), A2 = u2 * (w2.height / l2);
          b2 = (v2 = this.closestInMultiArray(k2, A2, m2, y2)).index, p2 = v2.j, null !== b2 && (m2 = r2.globals.seriesXvalues[b2], p2 = (v2 = this.closestInArray(k2, m2)).index);
        }
        return r2.globals.capturedSeriesIndex = null === b2 ? -1 : b2, (!p2 || p2 < 1) && (p2 = 0), r2.globals.isBarHorizontal ? r2.globals.capturedDataPointIndex = f2 : r2.globals.capturedDataPointIndex = p2, { capturedSeries: b2, j: r2.globals.isBarHorizontal ? f2 : p2, hoverX: g2, hoverY: u2 };
      } }, { key: "closestInMultiArray", value: function(t3, e2, i2, a2) {
        var s2 = this.w, r2 = 0, o2 = null, n2 = -1;
        s2.globals.series.length > 1 ? r2 = this.getFirstActiveXArray(i2) : o2 = 0;
        var l2 = i2[r2][0], h2 = Math.abs(t3 - l2);
        if (i2.forEach(function(e3) {
          e3.forEach(function(e4, i3) {
            var a3 = Math.abs(t3 - e4);
            a3 <= h2 && (h2 = a3, n2 = i3);
          });
        }), -1 !== n2) {
          var c2 = a2[r2][n2], d2 = Math.abs(e2 - c2);
          o2 = r2, a2.forEach(function(t4, i3) {
            var a3 = Math.abs(e2 - t4[n2]);
            a3 <= d2 && (d2 = a3, o2 = i3);
          });
        }
        return { index: o2, j: n2 };
      } }, { key: "getFirstActiveXArray", value: function(t3) {
        for (var e2 = this.w, i2 = 0, a2 = t3.map(function(t4, e3) {
          return t4.length > 0 ? e3 : -1;
        }), s2 = 0; s2 < a2.length; s2++)
          if (-1 !== a2[s2] && -1 === e2.globals.collapsedSeriesIndices.indexOf(s2) && -1 === e2.globals.ancillaryCollapsedSeriesIndices.indexOf(s2)) {
            i2 = a2[s2];
            break;
          }
        return i2;
      } }, { key: "closestInArray", value: function(t3, e2) {
        for (var i2 = e2[0], a2 = null, s2 = Math.abs(t3 - i2), r2 = 0; r2 < e2.length; r2++) {
          var o2 = Math.abs(t3 - e2[r2]);
          o2 < s2 && (s2 = o2, a2 = r2);
        }
        return { index: a2 };
      } }, { key: "isXoverlap", value: function(t3) {
        var e2 = [], i2 = this.w.globals.seriesX.filter(function(t4) {
          return void 0 !== t4[0];
        });
        if (i2.length > 0)
          for (var a2 = 0; a2 < i2.length - 1; a2++)
            void 0 !== i2[a2][t3] && void 0 !== i2[a2 + 1][t3] && i2[a2][t3] !== i2[a2 + 1][t3] && e2.push("unEqual");
        return 0 === e2.length;
      } }, { key: "isInitialSeriesSameLen", value: function() {
        for (var t3 = true, e2 = this.w.globals.initialSeries, i2 = 0; i2 < e2.length - 1; i2++)
          if (e2[i2].data.length !== e2[i2 + 1].data.length) {
            t3 = false;
            break;
          }
        return t3;
      } }, { key: "getBarsHeight", value: function(t3) {
        return u(t3).reduce(function(t4, e2) {
          return t4 + e2.getBBox().height;
        }, 0);
      } }, { key: "getElMarkers", value: function(t3) {
        return "number" == typeof t3 ? this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:realIndex='".concat(t3, "'] .apexcharts-series-markers-wrap > *")) : this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap > *");
      } }, { key: "getAllMarkers", value: function() {
        var t3 = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap");
        (t3 = u(t3)).sort(function(t4, e3) {
          var i2 = Number(t4.getAttribute("data:realIndex")), a2 = Number(e3.getAttribute("data:realIndex"));
          return a2 < i2 ? 1 : a2 > i2 ? -1 : 0;
        });
        var e2 = [];
        return t3.forEach(function(t4) {
          e2.push(t4.querySelector(".apexcharts-marker"));
        }), e2;
      } }, { key: "hasMarkers", value: function(t3) {
        return this.getElMarkers(t3).length > 0;
      } }, { key: "getElBars", value: function() {
        return this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-bar-series,  .apexcharts-candlestick-series, .apexcharts-boxPlot-series, .apexcharts-rangebar-series");
      } }, { key: "hasBars", value: function() {
        return this.getElBars().length > 0;
      } }, { key: "getHoverMarkerSize", value: function(t3) {
        var e2 = this.w, i2 = e2.config.markers.hover.size;
        return void 0 === i2 && (i2 = e2.globals.markers.size[t3] + e2.config.markers.hover.sizeOffset), i2;
      } }, { key: "toggleAllTooltipSeriesGroups", value: function(t3) {
        var e2 = this.w, i2 = this.ttCtx;
        0 === i2.allTooltipSeriesGroups.length && (i2.allTooltipSeriesGroups = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-tooltip-series-group"));
        for (var a2 = i2.allTooltipSeriesGroups, s2 = 0; s2 < a2.length; s2++)
          "enable" === t3 ? (a2[s2].classList.add("apexcharts-active"), a2[s2].style.display = e2.config.tooltip.items.display) : (a2[s2].classList.remove("apexcharts-active"), a2[s2].style.display = "none");
      } }]), t2;
    }();
    var gt = function() {
      function t2(e2) {
        a(this, t2), this.w = e2.w, this.ctx = e2.ctx, this.ttCtx = e2, this.tooltipUtil = new dt(e2);
      }
      return r(t2, [{ key: "drawSeriesTexts", value: function(t3) {
        var e2 = t3.shared, i2 = void 0 === e2 || e2, a2 = t3.ttItems, s2 = t3.i, r2 = void 0 === s2 ? 0 : s2, o2 = t3.j, n2 = void 0 === o2 ? null : o2, l2 = t3.y1, h2 = t3.y2, c2 = t3.e, d2 = this.w;
        void 0 !== d2.config.tooltip.custom ? this.handleCustomTooltip({ i: r2, j: n2, y1: l2, y2: h2, w: d2 }) : this.toggleActiveInactiveSeries(i2);
        var g2 = this.getValuesToPrint({ i: r2, j: n2 });
        this.printLabels({ i: r2, j: n2, values: g2, ttItems: a2, shared: i2, e: c2 });
        var u2 = this.ttCtx.getElTooltip();
        this.ttCtx.tooltipRect.ttWidth = u2.getBoundingClientRect().width, this.ttCtx.tooltipRect.ttHeight = u2.getBoundingClientRect().height;
      } }, { key: "printLabels", value: function(t3) {
        var i2, a2 = this, s2 = t3.i, r2 = t3.j, o2 = t3.values, n2 = t3.ttItems, l2 = t3.shared, h2 = t3.e, c2 = this.w, d2 = [], g2 = function(t4) {
          return c2.globals.seriesGoals[t4] && c2.globals.seriesGoals[t4][r2] && Array.isArray(c2.globals.seriesGoals[t4][r2]);
        }, u2 = o2.xVal, p2 = o2.zVal, f2 = o2.xAxisTTVal, x2 = "", b2 = c2.globals.colors[s2];
        null !== r2 && c2.config.plotOptions.bar.distributed && (b2 = c2.globals.colors[r2]);
        for (var v2 = function(t4, o3) {
          var v3 = a2.getFormatters(s2);
          x2 = a2.getSeriesName({ fn: v3.yLbTitleFormatter, index: s2, seriesIndex: s2, j: r2 }), "treemap" === c2.config.chart.type && (x2 = v3.yLbTitleFormatter(String(c2.config.series[s2].data[r2].x), { series: c2.globals.series, seriesIndex: s2, dataPointIndex: r2, w: c2 }));
          var m3 = c2.config.tooltip.inverseOrder ? o3 : t4;
          if (c2.globals.axisCharts) {
            var y3 = function(t5) {
              var e2, i3, a3, s3;
              return c2.globals.isRangeData ? v3.yLbFormatter(null === (e2 = c2.globals.seriesRangeStart) || void 0 === e2 || null === (i3 = e2[t5]) || void 0 === i3 ? void 0 : i3[r2], { series: c2.globals.seriesRangeStart, seriesIndex: t5, dataPointIndex: r2, w: c2 }) + " - " + v3.yLbFormatter(null === (a3 = c2.globals.seriesRangeEnd) || void 0 === a3 || null === (s3 = a3[t5]) || void 0 === s3 ? void 0 : s3[r2], { series: c2.globals.seriesRangeEnd, seriesIndex: t5, dataPointIndex: r2, w: c2 }) : v3.yLbFormatter(c2.globals.series[t5][r2], { series: c2.globals.series, seriesIndex: t5, dataPointIndex: r2, w: c2 });
            };
            if (l2)
              v3 = a2.getFormatters(m3), x2 = a2.getSeriesName({ fn: v3.yLbTitleFormatter, index: m3, seriesIndex: s2, j: r2 }), b2 = c2.globals.colors[m3], i2 = y3(m3), g2(m3) && (d2 = c2.globals.seriesGoals[m3][r2].map(function(t5) {
                return { attrs: t5, val: v3.yLbFormatter(t5.value, { seriesIndex: m3, dataPointIndex: r2, w: c2 }) };
              }));
            else {
              var w2, k2 = null == h2 || null === (w2 = h2.target) || void 0 === w2 ? void 0 : w2.getAttribute("fill");
              k2 && (b2 = -1 !== k2.indexOf("url") ? document.querySelector(k2.substr(4).slice(0, -1)).childNodes[0].getAttribute("stroke") : k2), i2 = y3(s2), g2(s2) && Array.isArray(c2.globals.seriesGoals[s2][r2]) && (d2 = c2.globals.seriesGoals[s2][r2].map(function(t5) {
                return { attrs: t5, val: v3.yLbFormatter(t5.value, { seriesIndex: s2, dataPointIndex: r2, w: c2 }) };
              }));
            }
          }
          null === r2 && (i2 = v3.yLbFormatter(c2.globals.series[s2], e(e({}, c2), {}, { seriesIndex: s2, dataPointIndex: s2 }))), a2.DOMHandling({ i: s2, t: m3, j: r2, ttItems: n2, values: { val: i2, goalVals: d2, xVal: u2, xAxisTTVal: f2, zVal: p2 }, seriesName: x2, shared: l2, pColor: b2 });
        }, m2 = 0, y2 = c2.globals.series.length - 1; m2 < c2.globals.series.length; m2++, y2--)
          v2(m2, y2);
      } }, { key: "getFormatters", value: function(t3) {
        var e2, i2 = this.w, a2 = i2.globals.yLabelFormatters[t3];
        return void 0 !== i2.globals.ttVal ? Array.isArray(i2.globals.ttVal) ? (a2 = i2.globals.ttVal[t3] && i2.globals.ttVal[t3].formatter, e2 = i2.globals.ttVal[t3] && i2.globals.ttVal[t3].title && i2.globals.ttVal[t3].title.formatter) : (a2 = i2.globals.ttVal.formatter, "function" == typeof i2.globals.ttVal.title.formatter && (e2 = i2.globals.ttVal.title.formatter)) : e2 = i2.config.tooltip.y.title.formatter, "function" != typeof a2 && (a2 = i2.globals.yLabelFormatters[0] ? i2.globals.yLabelFormatters[0] : function(t4) {
          return t4;
        }), "function" != typeof e2 && (e2 = function(t4) {
          return t4;
        }), { yLbFormatter: a2, yLbTitleFormatter: e2 };
      } }, { key: "getSeriesName", value: function(t3) {
        var e2 = t3.fn, i2 = t3.index, a2 = t3.seriesIndex, s2 = t3.j, r2 = this.w;
        return e2(String(r2.globals.seriesNames[i2]), { series: r2.globals.series, seriesIndex: a2, dataPointIndex: s2, w: r2 });
      } }, { key: "DOMHandling", value: function(t3) {
        t3.i;
        var e2 = t3.t, i2 = t3.j, a2 = t3.ttItems, s2 = t3.values, r2 = t3.seriesName, o2 = t3.shared, n2 = t3.pColor, l2 = this.w, h2 = this.ttCtx, c2 = s2.val, d2 = s2.goalVals, g2 = s2.xVal, u2 = s2.xAxisTTVal, p2 = s2.zVal, f2 = null;
        f2 = a2[e2].children, l2.config.tooltip.fillSeriesColor && (a2[e2].style.backgroundColor = n2, f2[0].style.display = "none"), h2.showTooltipTitle && (null === h2.tooltipTitle && (h2.tooltipTitle = l2.globals.dom.baseEl.querySelector(".apexcharts-tooltip-title")), h2.tooltipTitle.innerHTML = g2), h2.isXAxisTooltipEnabled && (h2.xaxisTooltipText.innerHTML = "" !== u2 ? u2 : g2);
        var x2 = a2[e2].querySelector(".apexcharts-tooltip-text-y-label");
        x2 && (x2.innerHTML = r2 || "");
        var b2 = a2[e2].querySelector(".apexcharts-tooltip-text-y-value");
        b2 && (b2.innerHTML = void 0 !== c2 ? c2 : ""), f2[0] && f2[0].classList.contains("apexcharts-tooltip-marker") && (l2.config.tooltip.marker.fillColors && Array.isArray(l2.config.tooltip.marker.fillColors) && (n2 = l2.config.tooltip.marker.fillColors[e2]), f2[0].style.backgroundColor = n2), l2.config.tooltip.marker.show || (f2[0].style.display = "none");
        var v2 = a2[e2].querySelector(".apexcharts-tooltip-text-goals-label"), m2 = a2[e2].querySelector(".apexcharts-tooltip-text-goals-value");
        if (d2.length && l2.globals.seriesGoals[e2]) {
          var y2 = function() {
            var t4 = "<div >", e3 = "<div>";
            d2.forEach(function(i3, a3) {
              t4 += ' <div style="display: flex"><span class="apexcharts-tooltip-marker" style="background-color: '.concat(i3.attrs.strokeColor, '; height: 3px; border-radius: 0; top: 5px;"></span> ').concat(i3.attrs.name, "</div>"), e3 += "<div>".concat(i3.val, "</div>");
            }), v2.innerHTML = t4 + "</div>", m2.innerHTML = e3 + "</div>";
          };
          o2 ? l2.globals.seriesGoals[e2][i2] && Array.isArray(l2.globals.seriesGoals[e2][i2]) ? y2() : (v2.innerHTML = "", m2.innerHTML = "") : y2();
        } else
          v2.innerHTML = "", m2.innerHTML = "";
        null !== p2 && (a2[e2].querySelector(".apexcharts-tooltip-text-z-label").innerHTML = l2.config.tooltip.z.title, a2[e2].querySelector(".apexcharts-tooltip-text-z-value").innerHTML = void 0 !== p2 ? p2 : "");
        o2 && f2[0] && (null == c2 || l2.globals.ancillaryCollapsedSeriesIndices.indexOf(e2) > -1 || l2.globals.collapsedSeriesIndices.indexOf(e2) > -1 ? f2[0].parentNode.style.display = "none" : f2[0].parentNode.style.display = l2.config.tooltip.items.display);
      } }, { key: "toggleActiveInactiveSeries", value: function(t3) {
        var e2 = this.w;
        if (t3)
          this.tooltipUtil.toggleAllTooltipSeriesGroups("enable");
        else {
          this.tooltipUtil.toggleAllTooltipSeriesGroups("disable");
          var i2 = e2.globals.dom.baseEl.querySelector(".apexcharts-tooltip-series-group");
          i2 && (i2.classList.add("apexcharts-active"), i2.style.display = e2.config.tooltip.items.display);
        }
      } }, { key: "getValuesToPrint", value: function(t3) {
        var e2 = t3.i, i2 = t3.j, a2 = this.w, s2 = this.ctx.series.filteredSeriesX(), r2 = "", o2 = "", n2 = null, l2 = null, h2 = { series: a2.globals.series, seriesIndex: e2, dataPointIndex: i2, w: a2 }, c2 = a2.globals.ttZFormatter;
        null === i2 ? l2 = a2.globals.series[e2] : a2.globals.isXNumeric && "treemap" !== a2.config.chart.type ? (r2 = s2[e2][i2], 0 === s2[e2].length && (r2 = s2[this.tooltipUtil.getFirstActiveXArray(s2)][i2])) : r2 = void 0 !== a2.globals.labels[i2] ? a2.globals.labels[i2] : "";
        var d2 = r2;
        a2.globals.isXNumeric && "datetime" === a2.config.xaxis.type ? r2 = new T(this.ctx).xLabelFormat(a2.globals.ttKeyFormatter, d2, d2, { i: void 0, dateFormatter: new I(this.ctx).formatDate, w: this.w }) : r2 = a2.globals.isBarHorizontal ? a2.globals.yLabelFormatters[0](d2, h2) : a2.globals.xLabelFormatter(d2, h2);
        return void 0 !== a2.config.tooltip.x.formatter && (r2 = a2.globals.ttKeyFormatter(d2, h2)), a2.globals.seriesZ.length > 0 && a2.globals.seriesZ[e2].length > 0 && (n2 = c2(a2.globals.seriesZ[e2][i2], a2)), o2 = "function" == typeof a2.config.xaxis.tooltip.formatter ? a2.globals.xaxisTooltipFormatter(d2, h2) : r2, { val: Array.isArray(l2) ? l2.join(" ") : l2, xVal: Array.isArray(r2) ? r2.join(" ") : r2, xAxisTTVal: Array.isArray(o2) ? o2.join(" ") : o2, zVal: n2 };
      } }, { key: "handleCustomTooltip", value: function(t3) {
        var e2 = t3.i, i2 = t3.j, a2 = t3.y1, s2 = t3.y2, r2 = t3.w, o2 = this.ttCtx.getElTooltip(), n2 = r2.config.tooltip.custom;
        Array.isArray(n2) && n2[e2] && (n2 = n2[e2]), o2.innerHTML = n2({ ctx: this.ctx, series: r2.globals.series, seriesIndex: e2, dataPointIndex: i2, y1: a2, y2: s2, w: r2 });
      } }]), t2;
    }();
    var ut = function() {
      function t2(e2) {
        a(this, t2), this.ttCtx = e2, this.ctx = e2.ctx, this.w = e2.w;
      }
      return r(t2, [{ key: "moveXCrosshairs", value: function(t3) {
        var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, i2 = this.ttCtx, a2 = this.w, s2 = i2.getElXCrosshairs(), r2 = t3 - i2.xcrosshairsWidth / 2, o2 = a2.globals.labels.slice().length;
        if (null !== e2 && (r2 = a2.globals.gridWidth / o2 * e2), null === s2 || a2.globals.isBarHorizontal || (s2.setAttribute("x", r2), s2.setAttribute("x1", r2), s2.setAttribute("x2", r2), s2.setAttribute("y2", a2.globals.gridHeight), s2.classList.add("apexcharts-active")), r2 < 0 && (r2 = 0), r2 > a2.globals.gridWidth && (r2 = a2.globals.gridWidth), i2.isXAxisTooltipEnabled) {
          var n2 = r2;
          "tickWidth" !== a2.config.xaxis.crosshairs.width && "barWidth" !== a2.config.xaxis.crosshairs.width || (n2 = r2 + i2.xcrosshairsWidth / 2), this.moveXAxisTooltip(n2);
        }
      } }, { key: "moveYCrosshairs", value: function(t3) {
        var e2 = this.ttCtx;
        null !== e2.ycrosshairs && m.setAttrs(e2.ycrosshairs, { y1: t3, y2: t3 }), null !== e2.ycrosshairsHidden && m.setAttrs(e2.ycrosshairsHidden, { y1: t3, y2: t3 });
      } }, { key: "moveXAxisTooltip", value: function(t3) {
        var e2 = this.w, i2 = this.ttCtx;
        if (null !== i2.xaxisTooltip && 0 !== i2.xcrosshairsWidth) {
          i2.xaxisTooltip.classList.add("apexcharts-active");
          var a2 = i2.xaxisOffY + e2.config.xaxis.tooltip.offsetY + e2.globals.translateY + 1 + e2.config.xaxis.offsetY;
          if (t3 -= i2.xaxisTooltip.getBoundingClientRect().width / 2, !isNaN(t3)) {
            t3 += e2.globals.translateX;
            var s2;
            s2 = new m(this.ctx).getTextRects(i2.xaxisTooltipText.innerHTML), i2.xaxisTooltipText.style.minWidth = s2.width + "px", i2.xaxisTooltip.style.left = t3 + "px", i2.xaxisTooltip.style.top = a2 + "px";
          }
        }
      } }, { key: "moveYAxisTooltip", value: function(t3) {
        var e2 = this.w, i2 = this.ttCtx;
        null === i2.yaxisTTEls && (i2.yaxisTTEls = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
        var a2 = parseInt(i2.ycrosshairsHidden.getAttribute("y1"), 10), s2 = e2.globals.translateY + a2, r2 = i2.yaxisTTEls[t3].getBoundingClientRect().height, o2 = e2.globals.translateYAxisX[t3] - 2;
        e2.config.yaxis[t3].opposite && (o2 -= 26), s2 -= r2 / 2, -1 === e2.globals.ignoreYAxisIndexes.indexOf(t3) ? (i2.yaxisTTEls[t3].classList.add("apexcharts-active"), i2.yaxisTTEls[t3].style.top = s2 + "px", i2.yaxisTTEls[t3].style.left = o2 + e2.config.yaxis[t3].tooltip.offsetX + "px") : i2.yaxisTTEls[t3].classList.remove("apexcharts-active");
      } }, { key: "moveTooltip", value: function(t3, e2) {
        var i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a2 = this.w, s2 = this.ttCtx, r2 = s2.getElTooltip(), o2 = s2.tooltipRect, n2 = null !== i2 ? parseFloat(i2) : 1, l2 = parseFloat(t3) + n2 + 5, h2 = parseFloat(e2) + n2 / 2;
        if (l2 > a2.globals.gridWidth / 2 && (l2 = l2 - o2.ttWidth - n2 - 10), l2 > a2.globals.gridWidth - o2.ttWidth - 10 && (l2 = a2.globals.gridWidth - o2.ttWidth), l2 < -20 && (l2 = -20), a2.config.tooltip.followCursor) {
          var c2 = s2.getElGrid().getBoundingClientRect();
          (l2 = s2.e.clientX - c2.left) > a2.globals.gridWidth / 2 && (l2 -= s2.tooltipRect.ttWidth), (h2 = s2.e.clientY + a2.globals.translateY - c2.top) > a2.globals.gridHeight / 2 && (h2 -= s2.tooltipRect.ttHeight);
        } else
          a2.globals.isBarHorizontal || o2.ttHeight / 2 + h2 > a2.globals.gridHeight && (h2 = a2.globals.gridHeight - o2.ttHeight + a2.globals.translateY);
        isNaN(l2) || (l2 += a2.globals.translateX, r2.style.left = l2 + "px", r2.style.top = h2 + "px");
      } }, { key: "moveMarkers", value: function(t3, e2) {
        var i2 = this.w, a2 = this.ttCtx;
        if (i2.globals.markers.size[t3] > 0)
          for (var s2 = i2.globals.dom.baseEl.querySelectorAll(" .apexcharts-series[data\\:realIndex='".concat(t3, "'] .apexcharts-marker")), r2 = 0; r2 < s2.length; r2++)
            parseInt(s2[r2].getAttribute("rel"), 10) === e2 && (a2.marker.resetPointsSize(), a2.marker.enlargeCurrentPoint(e2, s2[r2]));
        else
          a2.marker.resetPointsSize(), this.moveDynamicPointOnHover(e2, t3);
      } }, { key: "moveDynamicPointOnHover", value: function(t3, e2) {
        var i2, a2, s2 = this.w, r2 = this.ttCtx, o2 = s2.globals.pointsArray, n2 = r2.tooltipUtil.getHoverMarkerSize(e2), l2 = s2.config.series[e2].type;
        if (!l2 || "column" !== l2 && "candlestick" !== l2 && "boxPlot" !== l2) {
          i2 = o2[e2][t3][0], a2 = o2[e2][t3][1] ? o2[e2][t3][1] : 0;
          var h2 = s2.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(e2, "'] .apexcharts-series-markers circle"));
          h2 && a2 < s2.globals.gridHeight && a2 > 0 && (h2.setAttribute("r", n2), h2.setAttribute("cx", i2), h2.setAttribute("cy", a2)), this.moveXCrosshairs(i2), r2.fixedTooltip || this.moveTooltip(i2, a2, n2);
        }
      } }, { key: "moveDynamicPointsOnHover", value: function(t3) {
        var e2, i2 = this.ttCtx, a2 = i2.w, s2 = 0, r2 = 0, o2 = a2.globals.pointsArray;
        e2 = new N(this.ctx).getActiveConfigSeriesIndex("asc", ["line", "area", "scatter", "bubble"]);
        var n2 = i2.tooltipUtil.getHoverMarkerSize(e2);
        o2[e2] && (s2 = o2[e2][t3][0], r2 = o2[e2][t3][1]);
        var l2 = i2.tooltipUtil.getAllMarkers();
        if (null !== l2)
          for (var h2 = 0; h2 < a2.globals.series.length; h2++) {
            var c2 = o2[h2];
            if (a2.globals.comboCharts && void 0 === c2 && l2.splice(h2, 0, null), c2 && c2.length) {
              var d2 = o2[h2][t3][1], g2 = void 0;
              if (l2[h2].setAttribute("cx", s2), "rangeArea" === a2.config.chart.type && !a2.globals.comboCharts) {
                var u2 = t3 + a2.globals.series[h2].length;
                g2 = o2[h2][u2][1], d2 -= Math.abs(d2 - g2) / 2;
              }
              null !== d2 && !isNaN(d2) && d2 < a2.globals.gridHeight + n2 && d2 + n2 > 0 ? (l2[h2] && l2[h2].setAttribute("r", n2), l2[h2] && l2[h2].setAttribute("cy", d2)) : l2[h2] && l2[h2].setAttribute("r", 0);
            }
          }
        this.moveXCrosshairs(s2), i2.fixedTooltip || this.moveTooltip(s2, r2 || a2.globals.gridHeight, n2);
      } }, { key: "moveStickyTooltipOverBars", value: function(t3, e2) {
        var i2 = this.w, a2 = this.ttCtx, s2 = i2.globals.columnSeries ? i2.globals.columnSeries.length : i2.globals.series.length, r2 = s2 >= 2 && s2 % 2 == 0 ? Math.floor(s2 / 2) : Math.floor(s2 / 2) + 1;
        i2.globals.isBarHorizontal && (r2 = new N(this.ctx).getActiveConfigSeriesIndex("desc") + 1);
        var o2 = i2.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[rel='".concat(r2, "'] path[j='").concat(t3, "'], .apexcharts-candlestick-series .apexcharts-series[rel='").concat(r2, "'] path[j='").concat(t3, "'], .apexcharts-boxPlot-series .apexcharts-series[rel='").concat(r2, "'] path[j='").concat(t3, "'], .apexcharts-rangebar-series .apexcharts-series[rel='").concat(r2, "'] path[j='").concat(t3, "']"));
        o2 || "number" != typeof e2 || (o2 = i2.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[data\\:realIndex='".concat(e2, "'] path[j='").concat(t3, "'],\n        .apexcharts-candlestick-series .apexcharts-series[data\\:realIndex='").concat(e2, "'] path[j='").concat(t3, "'],\n        .apexcharts-boxPlot-series .apexcharts-series[data\\:realIndex='").concat(e2, "'] path[j='").concat(t3, "'],\n        .apexcharts-rangebar-series .apexcharts-series[data\\:realIndex='").concat(e2, "'] path[j='").concat(t3, "']")));
        var n2 = o2 ? parseFloat(o2.getAttribute("cx")) : 0, l2 = o2 ? parseFloat(o2.getAttribute("cy")) : 0, h2 = o2 ? parseFloat(o2.getAttribute("barWidth")) : 0, c2 = a2.getElGrid().getBoundingClientRect(), d2 = o2 && (o2.classList.contains("apexcharts-candlestick-area") || o2.classList.contains("apexcharts-boxPlot-area"));
        i2.globals.isXNumeric ? (o2 && !d2 && (n2 -= s2 % 2 != 0 ? h2 / 2 : 0), o2 && d2 && i2.globals.comboCharts && (n2 -= h2 / 2)) : i2.globals.isBarHorizontal || (n2 = a2.xAxisTicksPositions[t3 - 1] + a2.dataPointsDividedWidth / 2, isNaN(n2) && (n2 = a2.xAxisTicksPositions[t3] - a2.dataPointsDividedWidth / 2)), i2.globals.isBarHorizontal ? l2 -= a2.tooltipRect.ttHeight : i2.config.tooltip.followCursor ? l2 = a2.e.clientY - c2.top - a2.tooltipRect.ttHeight / 2 : l2 + a2.tooltipRect.ttHeight + 15 > i2.globals.gridHeight && (l2 = i2.globals.gridHeight), i2.globals.isBarHorizontal || this.moveXCrosshairs(n2), a2.fixedTooltip || this.moveTooltip(n2, l2 || i2.globals.gridHeight);
      } }]), t2;
    }();
    var pt = function() {
      function t2(e2) {
        a(this, t2), this.w = e2.w, this.ttCtx = e2, this.ctx = e2.ctx, this.tooltipPosition = new ut(e2);
      }
      return r(t2, [{ key: "drawDynamicPoints", value: function() {
        var t3 = this.w, e2 = new m(this.ctx), i2 = new H(this.ctx), a2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
        a2 = u(a2), t3.config.chart.stacked && a2.sort(function(t4, e3) {
          return parseFloat(t4.getAttribute("data:realIndex")) - parseFloat(e3.getAttribute("data:realIndex"));
        });
        for (var s2 = 0; s2 < a2.length; s2++) {
          var r2 = a2[s2].querySelector(".apexcharts-series-markers-wrap");
          if (null !== r2) {
            var o2 = void 0, n2 = "apexcharts-marker w".concat((Math.random() + 1).toString(36).substring(4));
            "line" !== t3.config.chart.type && "area" !== t3.config.chart.type || t3.globals.comboCharts || t3.config.tooltip.intersect || (n2 += " no-pointer-events");
            var l2 = i2.getMarkerConfig({ cssClass: n2, seriesIndex: Number(r2.getAttribute("data:realIndex")) });
            (o2 = e2.drawMarker(0, 0, l2)).node.setAttribute("default-marker-size", 0);
            var h2 = document.createElementNS(t3.globals.SVGNS, "g");
            h2.classList.add("apexcharts-series-markers"), h2.appendChild(o2.node), r2.appendChild(h2);
          }
        }
      } }, { key: "enlargeCurrentPoint", value: function(t3, e2) {
        var i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, s2 = this.w;
        "bubble" !== s2.config.chart.type && this.newPointSize(t3, e2);
        var r2 = e2.getAttribute("cx"), o2 = e2.getAttribute("cy");
        if (null !== i2 && null !== a2 && (r2 = i2, o2 = a2), this.tooltipPosition.moveXCrosshairs(r2), !this.fixedTooltip) {
          if ("radar" === s2.config.chart.type) {
            var n2 = this.ttCtx.getElGrid().getBoundingClientRect();
            r2 = this.ttCtx.e.clientX - n2.left;
          }
          this.tooltipPosition.moveTooltip(r2, o2, s2.config.markers.hover.size);
        }
      } }, { key: "enlargePoints", value: function(t3) {
        for (var e2 = this.w, i2 = this, a2 = this.ttCtx, s2 = t3, r2 = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), o2 = e2.config.markers.hover.size, n2 = 0; n2 < r2.length; n2++) {
          var l2 = r2[n2].getAttribute("rel"), h2 = r2[n2].getAttribute("index");
          if (void 0 === o2 && (o2 = e2.globals.markers.size[h2] + e2.config.markers.hover.sizeOffset), s2 === parseInt(l2, 10)) {
            i2.newPointSize(s2, r2[n2]);
            var c2 = r2[n2].getAttribute("cx"), d2 = r2[n2].getAttribute("cy");
            i2.tooltipPosition.moveXCrosshairs(c2), a2.fixedTooltip || i2.tooltipPosition.moveTooltip(c2, d2, o2);
          } else
            i2.oldPointSize(r2[n2]);
        }
      } }, { key: "newPointSize", value: function(t3, e2) {
        var i2 = this.w, a2 = i2.config.markers.hover.size, s2 = 0 === t3 ? e2.parentNode.firstChild : e2.parentNode.lastChild;
        if ("0" !== s2.getAttribute("default-marker-size")) {
          var r2 = parseInt(s2.getAttribute("index"), 10);
          void 0 === a2 && (a2 = i2.globals.markers.size[r2] + i2.config.markers.hover.sizeOffset), a2 < 0 && (a2 = 0), s2.setAttribute("r", a2);
        }
      } }, { key: "oldPointSize", value: function(t3) {
        var e2 = parseFloat(t3.getAttribute("default-marker-size"));
        t3.setAttribute("r", e2);
      } }, { key: "resetPointsSize", value: function() {
        for (var t3 = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), e2 = 0; e2 < t3.length; e2++) {
          var i2 = parseFloat(t3[e2].getAttribute("default-marker-size"));
          x.isNumber(i2) && i2 >= 0 ? t3[e2].setAttribute("r", i2) : t3[e2].setAttribute("r", 0);
        }
      } }]), t2;
    }();
    var ft = function() {
      function t2(e2) {
        a(this, t2), this.w = e2.w;
        var i2 = this.w;
        this.ttCtx = e2, this.isVerticalGroupedRangeBar = !i2.globals.isBarHorizontal && "rangeBar" === i2.config.chart.type && i2.config.plotOptions.bar.rangeBarGroupRows;
      }
      return r(t2, [{ key: "getAttr", value: function(t3, e2) {
        return parseFloat(t3.target.getAttribute(e2));
      } }, { key: "handleHeatTreeTooltip", value: function(t3) {
        var e2 = t3.e, i2 = t3.opt, a2 = t3.x, s2 = t3.y, r2 = t3.type, o2 = this.ttCtx, n2 = this.w;
        if (e2.target.classList.contains("apexcharts-".concat(r2, "-rect"))) {
          var l2 = this.getAttr(e2, "i"), h2 = this.getAttr(e2, "j"), c2 = this.getAttr(e2, "cx"), d2 = this.getAttr(e2, "cy"), g2 = this.getAttr(e2, "width"), u2 = this.getAttr(e2, "height");
          if (o2.tooltipLabels.drawSeriesTexts({ ttItems: i2.ttItems, i: l2, j: h2, shared: false, e: e2 }), n2.globals.capturedSeriesIndex = l2, n2.globals.capturedDataPointIndex = h2, a2 = c2 + o2.tooltipRect.ttWidth / 2 + g2, s2 = d2 + o2.tooltipRect.ttHeight / 2 - u2 / 2, o2.tooltipPosition.moveXCrosshairs(c2 + g2 / 2), a2 > n2.globals.gridWidth / 2 && (a2 = c2 - o2.tooltipRect.ttWidth / 2 + g2), o2.w.config.tooltip.followCursor) {
            var p2 = n2.globals.dom.elWrap.getBoundingClientRect();
            a2 = n2.globals.clientX - p2.left - (a2 > n2.globals.gridWidth / 2 ? o2.tooltipRect.ttWidth : 0), s2 = n2.globals.clientY - p2.top - (s2 > n2.globals.gridHeight / 2 ? o2.tooltipRect.ttHeight : 0);
          }
        }
        return { x: a2, y: s2 };
      } }, { key: "handleMarkerTooltip", value: function(t3) {
        var e2, i2, a2 = t3.e, s2 = t3.opt, r2 = t3.x, o2 = t3.y, n2 = this.w, l2 = this.ttCtx;
        if (a2.target.classList.contains("apexcharts-marker")) {
          var h2 = parseInt(s2.paths.getAttribute("cx"), 10), c2 = parseInt(s2.paths.getAttribute("cy"), 10), d2 = parseFloat(s2.paths.getAttribute("val"));
          if (i2 = parseInt(s2.paths.getAttribute("rel"), 10), e2 = parseInt(s2.paths.parentNode.parentNode.parentNode.getAttribute("rel"), 10) - 1, l2.intersect) {
            var g2 = x.findAncestor(s2.paths, "apexcharts-series");
            g2 && (e2 = parseInt(g2.getAttribute("data:realIndex"), 10));
          }
          if (l2.tooltipLabels.drawSeriesTexts({ ttItems: s2.ttItems, i: e2, j: i2, shared: !l2.showOnIntersect && n2.config.tooltip.shared, e: a2 }), "mouseup" === a2.type && l2.markerClick(a2, e2, i2), n2.globals.capturedSeriesIndex = e2, n2.globals.capturedDataPointIndex = i2, r2 = h2, o2 = c2 + n2.globals.translateY - 1.4 * l2.tooltipRect.ttHeight, l2.w.config.tooltip.followCursor) {
            var u2 = l2.getElGrid().getBoundingClientRect();
            o2 = l2.e.clientY + n2.globals.translateY - u2.top;
          }
          d2 < 0 && (o2 = c2), l2.marker.enlargeCurrentPoint(i2, s2.paths, r2, o2);
        }
        return { x: r2, y: o2 };
      } }, { key: "handleBarTooltip", value: function(t3) {
        var e2, i2, a2 = t3.e, s2 = t3.opt, r2 = this.w, o2 = this.ttCtx, n2 = o2.getElTooltip(), l2 = 0, h2 = 0, c2 = 0, d2 = this.getBarTooltipXY({ e: a2, opt: s2 });
        e2 = d2.i;
        var g2 = d2.barHeight, u2 = d2.j;
        r2.globals.capturedSeriesIndex = e2, r2.globals.capturedDataPointIndex = u2, r2.globals.isBarHorizontal && o2.tooltipUtil.hasBars() || !r2.config.tooltip.shared ? (h2 = d2.x, c2 = d2.y, i2 = Array.isArray(r2.config.stroke.width) ? r2.config.stroke.width[e2] : r2.config.stroke.width, l2 = h2) : r2.globals.comboCharts || r2.config.tooltip.shared || (l2 /= 2), isNaN(c2) && (c2 = r2.globals.svgHeight - o2.tooltipRect.ttHeight);
        var p2 = parseInt(s2.paths.parentNode.getAttribute("data:realIndex"), 10), f2 = r2.globals.isMultipleYAxis ? r2.config.yaxis[p2] && r2.config.yaxis[p2].reversed : r2.config.yaxis[0].reversed;
        if (h2 + o2.tooltipRect.ttWidth > r2.globals.gridWidth && !f2 ? h2 -= o2.tooltipRect.ttWidth : h2 < 0 && (h2 = 0), o2.w.config.tooltip.followCursor) {
          var x2 = o2.getElGrid().getBoundingClientRect();
          c2 = o2.e.clientY - x2.top;
        }
        null === o2.tooltip && (o2.tooltip = r2.globals.dom.baseEl.querySelector(".apexcharts-tooltip")), r2.config.tooltip.shared || (r2.globals.comboBarCount > 0 ? o2.tooltipPosition.moveXCrosshairs(l2 + i2 / 2) : o2.tooltipPosition.moveXCrosshairs(l2)), !o2.fixedTooltip && (!r2.config.tooltip.shared || r2.globals.isBarHorizontal && o2.tooltipUtil.hasBars()) && (f2 && (h2 -= o2.tooltipRect.ttWidth) < 0 && (h2 = 0), !f2 || r2.globals.isBarHorizontal && o2.tooltipUtil.hasBars() || (c2 = c2 + g2 - 2 * (r2.globals.series[e2][u2] < 0 ? g2 : 0)), c2 = c2 + r2.globals.translateY - o2.tooltipRect.ttHeight / 2, n2.style.left = h2 + r2.globals.translateX + "px", n2.style.top = c2 + "px");
      } }, { key: "getBarTooltipXY", value: function(t3) {
        var e2 = this, i2 = t3.e, a2 = t3.opt, s2 = this.w, r2 = null, o2 = this.ttCtx, n2 = 0, l2 = 0, h2 = 0, c2 = 0, d2 = 0, g2 = i2.target.classList;
        if (g2.contains("apexcharts-bar-area") || g2.contains("apexcharts-candlestick-area") || g2.contains("apexcharts-boxPlot-area") || g2.contains("apexcharts-rangebar-area")) {
          var u2 = i2.target, p2 = u2.getBoundingClientRect(), f2 = a2.elGrid.getBoundingClientRect(), x2 = p2.height;
          d2 = p2.height;
          var b2 = p2.width, v2 = parseInt(u2.getAttribute("cx"), 10), m2 = parseInt(u2.getAttribute("cy"), 10);
          c2 = parseFloat(u2.getAttribute("barWidth"));
          var y2 = "touchmove" === i2.type ? i2.touches[0].clientX : i2.clientX;
          r2 = parseInt(u2.getAttribute("j"), 10), n2 = parseInt(u2.parentNode.getAttribute("rel"), 10) - 1;
          var w2 = u2.getAttribute("data-range-y1"), k2 = u2.getAttribute("data-range-y2");
          s2.globals.comboCharts && (n2 = parseInt(u2.parentNode.getAttribute("data:realIndex"), 10));
          var A2 = function(t4) {
            return s2.globals.isXNumeric ? v2 - b2 / 2 : e2.isVerticalGroupedRangeBar ? v2 + b2 / 2 : v2 - o2.dataPointsDividedWidth + b2 / 2;
          }, S2 = function() {
            return m2 - o2.dataPointsDividedHeight + x2 / 2 - o2.tooltipRect.ttHeight / 2;
          };
          o2.tooltipLabels.drawSeriesTexts({ ttItems: a2.ttItems, i: n2, j: r2, y1: w2 ? parseInt(w2, 10) : null, y2: k2 ? parseInt(k2, 10) : null, shared: !o2.showOnIntersect && s2.config.tooltip.shared, e: i2 }), s2.config.tooltip.followCursor ? s2.globals.isBarHorizontal ? (l2 = y2 - f2.left + 15, h2 = S2()) : (l2 = A2(), h2 = i2.clientY - f2.top - o2.tooltipRect.ttHeight / 2 - 15) : s2.globals.isBarHorizontal ? ((l2 = v2) < o2.xyRatios.baseLineInvertedY && (l2 = v2 - o2.tooltipRect.ttWidth), h2 = S2()) : (l2 = A2(), h2 = m2);
        }
        return { x: l2, y: h2, barHeight: d2, barWidth: c2, i: n2, j: r2 };
      } }]), t2;
    }();
    var xt = function() {
      function t2(e2) {
        a(this, t2), this.w = e2.w, this.ttCtx = e2;
      }
      return r(t2, [{ key: "drawXaxisTooltip", value: function() {
        var t3 = this.w, e2 = this.ttCtx, i2 = "bottom" === t3.config.xaxis.position;
        e2.xaxisOffY = i2 ? t3.globals.gridHeight + 1 : -t3.globals.xAxisHeight - t3.config.xaxis.axisTicks.height + 3;
        var a2 = i2 ? "apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom" : "apexcharts-xaxistooltip apexcharts-xaxistooltip-top", s2 = t3.globals.dom.elWrap;
        e2.isXAxisTooltipEnabled && (null === t3.globals.dom.baseEl.querySelector(".apexcharts-xaxistooltip") && (e2.xaxisTooltip = document.createElement("div"), e2.xaxisTooltip.setAttribute("class", a2 + " apexcharts-theme-" + t3.config.tooltip.theme), s2.appendChild(e2.xaxisTooltip), e2.xaxisTooltipText = document.createElement("div"), e2.xaxisTooltipText.classList.add("apexcharts-xaxistooltip-text"), e2.xaxisTooltipText.style.fontFamily = t3.config.xaxis.tooltip.style.fontFamily || t3.config.chart.fontFamily, e2.xaxisTooltipText.style.fontSize = t3.config.xaxis.tooltip.style.fontSize, e2.xaxisTooltip.appendChild(e2.xaxisTooltipText)));
      } }, { key: "drawYaxisTooltip", value: function() {
        for (var t3 = this.w, e2 = this.ttCtx, i2 = function(i3) {
          var a3 = t3.config.yaxis[i3].opposite || t3.config.yaxis[i3].crosshairs.opposite;
          e2.yaxisOffX = a3 ? t3.globals.gridWidth + 1 : 1;
          var s2 = "apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i3, a3 ? " apexcharts-yaxistooltip-right" : " apexcharts-yaxistooltip-left");
          t3.globals.yAxisSameScaleIndices.map(function(e3, a4) {
            e3.map(function(e4, a5) {
              a5 === i3 && (s2 += t3.config.yaxis[a5].show ? " " : " apexcharts-yaxistooltip-hidden");
            });
          });
          var r2 = t3.globals.dom.elWrap;
          null === t3.globals.dom.baseEl.querySelector(".apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i3)) && (e2.yaxisTooltip = document.createElement("div"), e2.yaxisTooltip.setAttribute("class", s2 + " apexcharts-theme-" + t3.config.tooltip.theme), r2.appendChild(e2.yaxisTooltip), 0 === i3 && (e2.yaxisTooltipText = []), e2.yaxisTooltipText[i3] = document.createElement("div"), e2.yaxisTooltipText[i3].classList.add("apexcharts-yaxistooltip-text"), e2.yaxisTooltip.appendChild(e2.yaxisTooltipText[i3]));
        }, a2 = 0; a2 < t3.config.yaxis.length; a2++)
          i2(a2);
      } }, { key: "setXCrosshairWidth", value: function() {
        var t3 = this.w, e2 = this.ttCtx, i2 = e2.getElXCrosshairs();
        if (e2.xcrosshairsWidth = parseInt(t3.config.xaxis.crosshairs.width, 10), t3.globals.comboCharts) {
          var a2 = t3.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
          if (null !== a2 && "barWidth" === t3.config.xaxis.crosshairs.width) {
            var s2 = parseFloat(a2.getAttribute("barWidth"));
            e2.xcrosshairsWidth = s2;
          } else if ("tickWidth" === t3.config.xaxis.crosshairs.width) {
            var r2 = t3.globals.labels.length;
            e2.xcrosshairsWidth = t3.globals.gridWidth / r2;
          }
        } else if ("tickWidth" === t3.config.xaxis.crosshairs.width) {
          var o2 = t3.globals.labels.length;
          e2.xcrosshairsWidth = t3.globals.gridWidth / o2;
        } else if ("barWidth" === t3.config.xaxis.crosshairs.width) {
          var n2 = t3.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
          if (null !== n2) {
            var l2 = parseFloat(n2.getAttribute("barWidth"));
            e2.xcrosshairsWidth = l2;
          } else
            e2.xcrosshairsWidth = 1;
        }
        t3.globals.isBarHorizontal && (e2.xcrosshairsWidth = 0), null !== i2 && e2.xcrosshairsWidth > 0 && i2.setAttribute("width", e2.xcrosshairsWidth);
      } }, { key: "handleYCrosshair", value: function() {
        var t3 = this.w, e2 = this.ttCtx;
        e2.ycrosshairs = t3.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs"), e2.ycrosshairsHidden = t3.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs-hidden");
      } }, { key: "drawYaxisTooltipText", value: function(t3, e2, i2) {
        var a2 = this.ttCtx, s2 = this.w, r2 = s2.globals.yLabelFormatters[t3];
        if (a2.yaxisTooltips[t3]) {
          var o2 = a2.getElGrid().getBoundingClientRect(), n2 = (e2 - o2.top) * i2.yRatio[t3], l2 = s2.globals.maxYArr[t3] - s2.globals.minYArr[t3], h2 = s2.globals.minYArr[t3] + (l2 - n2);
          a2.tooltipPosition.moveYCrosshairs(e2 - o2.top), a2.yaxisTooltipText[t3].innerHTML = r2(h2), a2.tooltipPosition.moveYAxisTooltip(t3);
        }
      } }]), t2;
    }();
    var bt = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
        var i2 = this.w;
        this.tConfig = i2.config.tooltip, this.tooltipUtil = new dt(this), this.tooltipLabels = new gt(this), this.tooltipPosition = new ut(this), this.marker = new pt(this), this.intersect = new ft(this), this.axesTooltip = new xt(this), this.showOnIntersect = this.tConfig.intersect, this.showTooltipTitle = this.tConfig.x.show, this.fixedTooltip = this.tConfig.fixed.enabled, this.xaxisTooltip = null, this.yaxisTTEls = null, this.isBarShared = !i2.globals.isBarHorizontal && this.tConfig.shared, this.lastHoverTime = Date.now();
      }
      return r(t2, [{ key: "getElTooltip", value: function(t3) {
        return t3 || (t3 = this), t3.w.globals.dom.baseEl ? t3.w.globals.dom.baseEl.querySelector(".apexcharts-tooltip") : null;
      } }, { key: "getElXCrosshairs", value: function() {
        return this.w.globals.dom.baseEl.querySelector(".apexcharts-xcrosshairs");
      } }, { key: "getElGrid", value: function() {
        return this.w.globals.dom.baseEl.querySelector(".apexcharts-grid");
      } }, { key: "drawTooltip", value: function(t3) {
        var e2 = this.w;
        this.xyRatios = t3, this.isXAxisTooltipEnabled = e2.config.xaxis.tooltip.enabled && e2.globals.axisCharts, this.yaxisTooltips = e2.config.yaxis.map(function(t4, i3) {
          return !!(t4.show && t4.tooltip.enabled && e2.globals.axisCharts);
        }), this.allTooltipSeriesGroups = [], e2.globals.axisCharts || (this.showTooltipTitle = false);
        var i2 = document.createElement("div");
        if (i2.classList.add("apexcharts-tooltip"), e2.config.tooltip.cssClass && i2.classList.add(e2.config.tooltip.cssClass), i2.classList.add("apexcharts-theme-".concat(this.tConfig.theme)), e2.globals.dom.elWrap.appendChild(i2), e2.globals.axisCharts) {
          this.axesTooltip.drawXaxisTooltip(), this.axesTooltip.drawYaxisTooltip(), this.axesTooltip.setXCrosshairWidth(), this.axesTooltip.handleYCrosshair();
          var a2 = new V(this.ctx);
          this.xAxisTicksPositions = a2.getXAxisTicksPositions();
        }
        if (!e2.globals.comboCharts && !this.tConfig.intersect && "rangeBar" !== e2.config.chart.type || this.tConfig.shared || (this.showOnIntersect = true), 0 !== e2.config.markers.size && 0 !== e2.globals.markers.largestSize || this.marker.drawDynamicPoints(this), e2.globals.collapsedSeries.length !== e2.globals.series.length) {
          this.dataPointsDividedHeight = e2.globals.gridHeight / e2.globals.dataPoints, this.dataPointsDividedWidth = e2.globals.gridWidth / e2.globals.dataPoints, this.showTooltipTitle && (this.tooltipTitle = document.createElement("div"), this.tooltipTitle.classList.add("apexcharts-tooltip-title"), this.tooltipTitle.style.fontFamily = this.tConfig.style.fontFamily || e2.config.chart.fontFamily, this.tooltipTitle.style.fontSize = this.tConfig.style.fontSize, i2.appendChild(this.tooltipTitle));
          var s2 = e2.globals.series.length;
          (e2.globals.xyCharts || e2.globals.comboCharts) && this.tConfig.shared && (s2 = this.showOnIntersect ? 1 : e2.globals.series.length), this.legendLabels = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-legend-text"), this.ttItems = this.createTTElements(s2), this.addSVGEvents();
        }
      } }, { key: "createTTElements", value: function(t3) {
        for (var e2 = this, i2 = this.w, a2 = [], s2 = this.getElTooltip(), r2 = function(r3) {
          var o3 = document.createElement("div");
          o3.classList.add("apexcharts-tooltip-series-group"), o3.style.order = i2.config.tooltip.inverseOrder ? t3 - r3 : r3 + 1, e2.tConfig.shared && e2.tConfig.enabledOnSeries && Array.isArray(e2.tConfig.enabledOnSeries) && e2.tConfig.enabledOnSeries.indexOf(r3) < 0 && o3.classList.add("apexcharts-tooltip-series-group-hidden");
          var n2 = document.createElement("span");
          n2.classList.add("apexcharts-tooltip-marker"), n2.style.backgroundColor = i2.globals.colors[r3], o3.appendChild(n2);
          var l2 = document.createElement("div");
          l2.classList.add("apexcharts-tooltip-text"), l2.style.fontFamily = e2.tConfig.style.fontFamily || i2.config.chart.fontFamily, l2.style.fontSize = e2.tConfig.style.fontSize, ["y", "goals", "z"].forEach(function(t4) {
            var e3 = document.createElement("div");
            e3.classList.add("apexcharts-tooltip-".concat(t4, "-group"));
            var i3 = document.createElement("span");
            i3.classList.add("apexcharts-tooltip-text-".concat(t4, "-label")), e3.appendChild(i3);
            var a3 = document.createElement("span");
            a3.classList.add("apexcharts-tooltip-text-".concat(t4, "-value")), e3.appendChild(a3), l2.appendChild(e3);
          }), o3.appendChild(l2), s2.appendChild(o3), a2.push(o3);
        }, o2 = 0; o2 < t3; o2++)
          r2(o2);
        return a2;
      } }, { key: "addSVGEvents", value: function() {
        var t3 = this.w, e2 = t3.config.chart.type, i2 = this.getElTooltip(), a2 = !("bar" !== e2 && "candlestick" !== e2 && "boxPlot" !== e2 && "rangeBar" !== e2), s2 = "area" === e2 || "line" === e2 || "scatter" === e2 || "bubble" === e2 || "radar" === e2, r2 = t3.globals.dom.Paper.node, o2 = this.getElGrid();
        o2 && (this.seriesBound = o2.getBoundingClientRect());
        var n2, l2 = [], h2 = [], c2 = { hoverArea: r2, elGrid: o2, tooltipEl: i2, tooltipY: l2, tooltipX: h2, ttItems: this.ttItems };
        if (t3.globals.axisCharts && (s2 ? n2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:longestSeries='true'] .apexcharts-marker") : a2 ? n2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-bar-area, .apexcharts-series .apexcharts-candlestick-area, .apexcharts-series .apexcharts-boxPlot-area, .apexcharts-series .apexcharts-rangebar-area") : "heatmap" !== e2 && "treemap" !== e2 || (n2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-heatmap, .apexcharts-series .apexcharts-treemap")), n2 && n2.length))
          for (var d2 = 0; d2 < n2.length; d2++)
            l2.push(n2[d2].getAttribute("cy")), h2.push(n2[d2].getAttribute("cx"));
        if (t3.globals.xyCharts && !this.showOnIntersect || t3.globals.comboCharts && !this.showOnIntersect || a2 && this.tooltipUtil.hasBars() && this.tConfig.shared)
          this.addPathsEventListeners([r2], c2);
        else if (a2 && !t3.globals.comboCharts || s2 && this.showOnIntersect)
          this.addDatapointEventsListeners(c2);
        else if (!t3.globals.axisCharts || "heatmap" === e2 || "treemap" === e2) {
          var g2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
          this.addPathsEventListeners(g2, c2);
        }
        if (this.showOnIntersect) {
          var u2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-line-series .apexcharts-marker, .apexcharts-area-series .apexcharts-marker");
          u2.length > 0 && this.addPathsEventListeners(u2, c2), this.tooltipUtil.hasBars() && !this.tConfig.shared && this.addDatapointEventsListeners(c2);
        }
      } }, { key: "drawFixedTooltipRect", value: function() {
        var t3 = this.w, e2 = this.getElTooltip(), i2 = e2.getBoundingClientRect(), a2 = i2.width + 10, s2 = i2.height + 10, r2 = this.tConfig.fixed.offsetX, o2 = this.tConfig.fixed.offsetY, n2 = this.tConfig.fixed.position.toLowerCase();
        return n2.indexOf("right") > -1 && (r2 = r2 + t3.globals.svgWidth - a2 + 10), n2.indexOf("bottom") > -1 && (o2 = o2 + t3.globals.svgHeight - s2 - 10), e2.style.left = r2 + "px", e2.style.top = o2 + "px", { x: r2, y: o2, ttWidth: a2, ttHeight: s2 };
      } }, { key: "addDatapointEventsListeners", value: function(t3) {
        var e2 = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers .apexcharts-marker, .apexcharts-bar-area, .apexcharts-candlestick-area, .apexcharts-boxPlot-area, .apexcharts-rangebar-area");
        this.addPathsEventListeners(e2, t3);
      } }, { key: "addPathsEventListeners", value: function(t3, e2) {
        for (var i2 = this, a2 = function(a3) {
          var s3 = { paths: t3[a3], tooltipEl: e2.tooltipEl, tooltipY: e2.tooltipY, tooltipX: e2.tooltipX, elGrid: e2.elGrid, hoverArea: e2.hoverArea, ttItems: e2.ttItems };
          ["mousemove", "mouseup", "touchmove", "mouseout", "touchend"].map(function(e3) {
            return t3[a3].addEventListener(e3, i2.onSeriesHover.bind(i2, s3), { capture: false, passive: true });
          });
        }, s2 = 0; s2 < t3.length; s2++)
          a2(s2);
      } }, { key: "onSeriesHover", value: function(t3, e2) {
        var i2 = this, a2 = Date.now() - this.lastHoverTime;
        a2 >= 100 ? this.seriesHover(t3, e2) : (clearTimeout(this.seriesHoverTimeout), this.seriesHoverTimeout = setTimeout(function() {
          i2.seriesHover(t3, e2);
        }, 100 - a2));
      } }, { key: "seriesHover", value: function(t3, e2) {
        var i2 = this;
        this.lastHoverTime = Date.now();
        var a2 = [], s2 = this.w;
        s2.config.chart.group && (a2 = this.ctx.getGroupedCharts()), s2.globals.axisCharts && (s2.globals.minX === -1 / 0 && s2.globals.maxX === 1 / 0 || 0 === s2.globals.dataPoints) || (a2.length ? a2.forEach(function(a3) {
          var s3 = i2.getElTooltip(a3), r2 = { paths: t3.paths, tooltipEl: s3, tooltipY: t3.tooltipY, tooltipX: t3.tooltipX, elGrid: t3.elGrid, hoverArea: t3.hoverArea, ttItems: a3.w.globals.tooltip.ttItems };
          a3.w.globals.minX === i2.w.globals.minX && a3.w.globals.maxX === i2.w.globals.maxX && a3.w.globals.tooltip.seriesHoverByContext({ chartCtx: a3, ttCtx: a3.w.globals.tooltip, opt: r2, e: e2 });
        }) : this.seriesHoverByContext({ chartCtx: this.ctx, ttCtx: this.w.globals.tooltip, opt: t3, e: e2 }));
      } }, { key: "seriesHoverByContext", value: function(t3) {
        var e2 = t3.chartCtx, i2 = t3.ttCtx, a2 = t3.opt, s2 = t3.e, r2 = e2.w, o2 = this.getElTooltip();
        if (o2) {
          if (i2.tooltipRect = { x: 0, y: 0, ttWidth: o2.getBoundingClientRect().width, ttHeight: o2.getBoundingClientRect().height }, i2.e = s2, i2.tooltipUtil.hasBars() && !r2.globals.comboCharts && !i2.isBarShared) {
            if (this.tConfig.onDatasetHover.highlightDataSeries)
              new N(e2).toggleSeriesOnHover(s2, s2.target.parentNode);
          }
          i2.fixedTooltip && i2.drawFixedTooltipRect(), r2.globals.axisCharts ? i2.axisChartsTooltips({ e: s2, opt: a2, tooltipRect: i2.tooltipRect }) : i2.nonAxisChartsTooltips({ e: s2, opt: a2, tooltipRect: i2.tooltipRect });
        }
      } }, { key: "axisChartsTooltips", value: function(t3) {
        var e2, i2, a2 = t3.e, s2 = t3.opt, r2 = this.w, o2 = s2.elGrid.getBoundingClientRect(), n2 = "touchmove" === a2.type ? a2.touches[0].clientX : a2.clientX, l2 = "touchmove" === a2.type ? a2.touches[0].clientY : a2.clientY;
        if (this.clientY = l2, this.clientX = n2, r2.globals.capturedSeriesIndex = -1, r2.globals.capturedDataPointIndex = -1, l2 < o2.top || l2 > o2.top + o2.height)
          this.handleMouseOut(s2);
        else {
          if (Array.isArray(this.tConfig.enabledOnSeries) && !r2.config.tooltip.shared) {
            var h2 = parseInt(s2.paths.getAttribute("index"), 10);
            if (this.tConfig.enabledOnSeries.indexOf(h2) < 0)
              return void this.handleMouseOut(s2);
          }
          var c2 = this.getElTooltip(), d2 = this.getElXCrosshairs(), g2 = r2.globals.xyCharts || "bar" === r2.config.chart.type && !r2.globals.isBarHorizontal && this.tooltipUtil.hasBars() && this.tConfig.shared || r2.globals.comboCharts && this.tooltipUtil.hasBars();
          if ("mousemove" === a2.type || "touchmove" === a2.type || "mouseup" === a2.type) {
            if (r2.globals.collapsedSeries.length + r2.globals.ancillaryCollapsedSeries.length === r2.globals.series.length)
              return;
            null !== d2 && d2.classList.add("apexcharts-active");
            var u2 = this.yaxisTooltips.filter(function(t4) {
              return true === t4;
            });
            if (null !== this.ycrosshairs && u2.length && this.ycrosshairs.classList.add("apexcharts-active"), g2 && !this.showOnIntersect)
              this.handleStickyTooltip(a2, n2, l2, s2);
            else if ("heatmap" === r2.config.chart.type || "treemap" === r2.config.chart.type) {
              var p2 = this.intersect.handleHeatTreeTooltip({ e: a2, opt: s2, x: e2, y: i2, type: r2.config.chart.type });
              e2 = p2.x, i2 = p2.y, c2.style.left = e2 + "px", c2.style.top = i2 + "px";
            } else
              this.tooltipUtil.hasBars() && this.intersect.handleBarTooltip({ e: a2, opt: s2 }), this.tooltipUtil.hasMarkers() && this.intersect.handleMarkerTooltip({ e: a2, opt: s2, x: e2, y: i2 });
            if (this.yaxisTooltips.length)
              for (var f2 = 0; f2 < r2.config.yaxis.length; f2++)
                this.axesTooltip.drawYaxisTooltipText(f2, l2, this.xyRatios);
            s2.tooltipEl.classList.add("apexcharts-active");
          } else
            "mouseout" !== a2.type && "touchend" !== a2.type || this.handleMouseOut(s2);
        }
      } }, { key: "nonAxisChartsTooltips", value: function(t3) {
        var e2 = t3.e, i2 = t3.opt, a2 = t3.tooltipRect, s2 = this.w, r2 = i2.paths.getAttribute("rel"), o2 = this.getElTooltip(), n2 = s2.globals.dom.elWrap.getBoundingClientRect();
        if ("mousemove" === e2.type || "touchmove" === e2.type) {
          o2.classList.add("apexcharts-active"), this.tooltipLabels.drawSeriesTexts({ ttItems: i2.ttItems, i: parseInt(r2, 10) - 1, shared: false });
          var l2 = s2.globals.clientX - n2.left - a2.ttWidth / 2, h2 = s2.globals.clientY - n2.top - a2.ttHeight - 10;
          if (o2.style.left = l2 + "px", o2.style.top = h2 + "px", s2.config.legend.tooltipHoverFormatter) {
            var c2 = r2 - 1, d2 = (0, s2.config.legend.tooltipHoverFormatter)(this.legendLabels[c2].getAttribute("data:default-text"), { seriesIndex: c2, dataPointIndex: c2, w: s2 });
            this.legendLabels[c2].innerHTML = d2;
          }
        } else
          "mouseout" !== e2.type && "touchend" !== e2.type || (o2.classList.remove("apexcharts-active"), s2.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function(t4) {
            var e3 = t4.getAttribute("data:default-text");
            t4.innerHTML = decodeURIComponent(e3);
          }));
      } }, { key: "handleStickyTooltip", value: function(t3, e2, i2, a2) {
        var s2 = this.w, r2 = this.tooltipUtil.getNearestValues({ context: this, hoverArea: a2.hoverArea, elGrid: a2.elGrid, clientX: e2, clientY: i2 }), o2 = r2.j, n2 = r2.capturedSeries;
        s2.globals.collapsedSeriesIndices.includes(n2) && (n2 = null);
        var l2 = a2.elGrid.getBoundingClientRect();
        if (r2.hoverX < 0 || r2.hoverX > l2.width)
          this.handleMouseOut(a2);
        else if (null !== n2)
          this.handleStickyCapturedSeries(t3, n2, a2, o2);
        else if (this.tooltipUtil.isXoverlap(o2) || s2.globals.isBarHorizontal) {
          var h2 = s2.globals.series.findIndex(function(t4, e3) {
            return !s2.globals.collapsedSeriesIndices.includes(e3);
          });
          this.create(t3, this, h2, o2, a2.ttItems);
        }
      } }, { key: "handleStickyCapturedSeries", value: function(t3, e2, i2, a2) {
        var s2 = this.w;
        if (!this.tConfig.shared && null === s2.globals.series[e2][a2])
          return void this.handleMouseOut(i2);
        if (void 0 !== s2.globals.series[e2][a2])
          this.tConfig.shared && this.tooltipUtil.isXoverlap(a2) && this.tooltipUtil.isInitialSeriesSameLen() ? this.create(t3, this, e2, a2, i2.ttItems) : this.create(t3, this, e2, a2, i2.ttItems, false);
        else if (this.tooltipUtil.isXoverlap(a2)) {
          var r2 = s2.globals.series.findIndex(function(t4, e3) {
            return !s2.globals.collapsedSeriesIndices.includes(e3);
          });
          this.create(t3, this, r2, a2, i2.ttItems);
        }
      } }, { key: "deactivateHoverFilter", value: function() {
        for (var t3 = this.w, e2 = new m(this.ctx), i2 = t3.globals.dom.Paper.select(".apexcharts-bar-area"), a2 = 0; a2 < i2.length; a2++)
          e2.pathMouseLeave(i2[a2]);
      } }, { key: "handleMouseOut", value: function(t3) {
        var e2 = this.w, i2 = this.getElXCrosshairs();
        if (t3.tooltipEl.classList.remove("apexcharts-active"), this.deactivateHoverFilter(), "bubble" !== e2.config.chart.type && this.marker.resetPointsSize(), null !== i2 && i2.classList.remove("apexcharts-active"), null !== this.ycrosshairs && this.ycrosshairs.classList.remove("apexcharts-active"), this.isXAxisTooltipEnabled && this.xaxisTooltip.classList.remove("apexcharts-active"), this.yaxisTooltips.length) {
          null === this.yaxisTTEls && (this.yaxisTTEls = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
          for (var a2 = 0; a2 < this.yaxisTTEls.length; a2++)
            this.yaxisTTEls[a2].classList.remove("apexcharts-active");
        }
        e2.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function(t4) {
          var e3 = t4.getAttribute("data:default-text");
          t4.innerHTML = decodeURIComponent(e3);
        });
      } }, { key: "markerClick", value: function(t3, e2, i2) {
        var a2 = this.w;
        "function" == typeof a2.config.chart.events.markerClick && a2.config.chart.events.markerClick(t3, this.ctx, { seriesIndex: e2, dataPointIndex: i2, w: a2 }), this.ctx.events.fireEvent("markerClick", [t3, this.ctx, { seriesIndex: e2, dataPointIndex: i2, w: a2 }]);
      } }, { key: "create", value: function(t3, i2, a2, s2, r2) {
        var o2, n2, l2, h2, c2, d2, g2, u2, p2, f2, x2, b2, v2, y2, w2, k2, A2 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null, S2 = this.w, C2 = i2;
        "mouseup" === t3.type && this.markerClick(t3, a2, s2), null === A2 && (A2 = this.tConfig.shared);
        var L2 = this.tooltipUtil.hasMarkers(a2), P2 = this.tooltipUtil.getElBars();
        if (S2.config.legend.tooltipHoverFormatter) {
          var I2 = S2.config.legend.tooltipHoverFormatter, T2 = Array.from(this.legendLabels);
          T2.forEach(function(t4) {
            var e2 = t4.getAttribute("data:default-text");
            t4.innerHTML = decodeURIComponent(e2);
          });
          for (var M2 = 0; M2 < T2.length; M2++) {
            var z2 = T2[M2], X2 = parseInt(z2.getAttribute("i"), 10), E2 = decodeURIComponent(z2.getAttribute("data:default-text")), Y2 = I2(E2, { seriesIndex: A2 ? X2 : a2, dataPointIndex: s2, w: S2 });
            if (A2)
              z2.innerHTML = S2.globals.collapsedSeriesIndices.indexOf(X2) < 0 ? Y2 : E2;
            else if (z2.innerHTML = X2 === a2 ? Y2 : E2, a2 === X2)
              break;
          }
        }
        var F2 = e(e({ ttItems: r2, i: a2, j: s2 }, void 0 !== (null === (o2 = S2.globals.seriesRange) || void 0 === o2 || null === (n2 = o2[a2]) || void 0 === n2 || null === (l2 = n2[s2]) || void 0 === l2 || null === (h2 = l2.y[0]) || void 0 === h2 ? void 0 : h2.y1) && { y1: null === (c2 = S2.globals.seriesRange) || void 0 === c2 || null === (d2 = c2[a2]) || void 0 === d2 || null === (g2 = d2[s2]) || void 0 === g2 || null === (u2 = g2.y[0]) || void 0 === u2 ? void 0 : u2.y1 }), void 0 !== (null === (p2 = S2.globals.seriesRange) || void 0 === p2 || null === (f2 = p2[a2]) || void 0 === f2 || null === (x2 = f2[s2]) || void 0 === x2 || null === (b2 = x2.y[0]) || void 0 === b2 ? void 0 : b2.y2) && { y2: null === (v2 = S2.globals.seriesRange) || void 0 === v2 || null === (y2 = v2[a2]) || void 0 === y2 || null === (w2 = y2[s2]) || void 0 === w2 || null === (k2 = w2.y[0]) || void 0 === k2 ? void 0 : k2.y2 });
        if (A2) {
          if (C2.tooltipLabels.drawSeriesTexts(e(e({}, F2), {}, { shared: !this.showOnIntersect && this.tConfig.shared })), L2)
            S2.globals.markers.largestSize > 0 ? C2.marker.enlargePoints(s2) : C2.tooltipPosition.moveDynamicPointsOnHover(s2);
          else if (this.tooltipUtil.hasBars() && (this.barSeriesHeight = this.tooltipUtil.getBarsHeight(P2), this.barSeriesHeight > 0)) {
            var R2 = new m(this.ctx), H2 = S2.globals.dom.Paper.select(".apexcharts-bar-area[j='".concat(s2, "']"));
            this.deactivateHoverFilter(), this.tooltipPosition.moveStickyTooltipOverBars(s2, a2);
            for (var D2 = 0; D2 < H2.length; D2++)
              R2.pathMouseEnter(H2[D2]);
          }
        } else
          C2.tooltipLabels.drawSeriesTexts(e({ shared: false }, F2)), this.tooltipUtil.hasBars() && C2.tooltipPosition.moveStickyTooltipOverBars(s2, a2), L2 && C2.tooltipPosition.moveMarkers(a2, s2);
      } }]), t2;
    }();
    var vt = function() {
      function t2(e2) {
        a(this, t2), this.w = e2.w, this.barCtx = e2, this.totalFormatter = this.w.config.plotOptions.bar.dataLabels.total.formatter, this.totalFormatter || (this.totalFormatter = this.w.config.dataLabels.formatter);
      }
      return r(t2, [{ key: "handleBarDataLabels", value: function(t3) {
        var e2 = t3.x, i2 = t3.y, a2 = t3.y1, s2 = t3.y2, r2 = t3.i, o2 = t3.j, n2 = t3.realIndex, l2 = t3.groupIndex, h2 = t3.series, c2 = t3.barHeight, d2 = t3.barWidth, g2 = t3.barXPosition, u2 = t3.barYPosition, p2 = t3.visibleSeries, f2 = t3.renderedPath, x2 = this.w, b2 = new m(this.barCtx.ctx), v2 = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[n2] : this.barCtx.strokeWidth, y2 = e2 + parseFloat(d2 * p2), w2 = i2 + parseFloat(c2 * p2);
        x2.globals.isXNumeric && !x2.globals.isBarHorizontal && (y2 = e2 + parseFloat(d2 * (p2 + 1)), w2 = i2 + parseFloat(c2 * (p2 + 1)) - v2);
        var k2, A2 = null, S2 = e2, C2 = i2, L2 = {}, P2 = x2.config.dataLabels, I2 = this.barCtx.barOptions.dataLabels, T2 = this.barCtx.barOptions.dataLabels.total;
        void 0 !== u2 && this.barCtx.isRangeBar && (w2 = u2, C2 = u2), void 0 !== g2 && this.barCtx.isVerticalGroupedRangeBar && (y2 = g2, S2 = g2);
        var M2 = P2.offsetX, z2 = P2.offsetY, X2 = { width: 0, height: 0 };
        if (x2.config.dataLabels.enabled) {
          var E2 = this.barCtx.series[r2][o2];
          X2 = b2.getTextRects(x2.globals.yLabelFormatters[0](E2), parseFloat(P2.style.fontSize));
        }
        var Y2 = { x: e2, y: i2, i: r2, j: o2, realIndex: n2, groupIndex: l2 || -1, renderedPath: f2, bcx: y2, bcy: w2, barHeight: c2, barWidth: d2, textRects: X2, strokeWidth: v2, dataLabelsX: S2, dataLabelsY: C2, dataLabelsConfig: P2, barDataLabelsConfig: I2, barTotalDataLabelsConfig: T2, offX: M2, offY: z2 };
        return L2 = this.barCtx.isHorizontal ? this.calculateBarsDataLabelsPosition(Y2) : this.calculateColumnsDataLabelsPosition(Y2), f2.attr({ cy: L2.bcy, cx: L2.bcx, j: o2, val: h2[r2][o2], barHeight: c2, barWidth: d2 }), k2 = this.drawCalculatedDataLabels({ x: L2.dataLabelsX, y: L2.dataLabelsY, val: this.barCtx.isRangeBar ? [a2, s2] : h2[r2][o2], i: n2, j: o2, barWidth: d2, barHeight: c2, textRects: X2, dataLabelsConfig: P2 }), x2.config.chart.stacked && T2.enabled && (A2 = this.drawTotalDataLabels({ x: L2.totalDataLabelsX, y: L2.totalDataLabelsY, realIndex: n2, textAnchor: L2.totalDataLabelsAnchor, val: this.getStackedTotalDataLabel({ realIndex: n2, j: o2 }), dataLabelsConfig: P2, barTotalDataLabelsConfig: T2 })), { dataLabels: k2, totalDataLabels: A2 };
      } }, { key: "getStackedTotalDataLabel", value: function(t3) {
        var i2 = t3.realIndex, a2 = t3.j, s2 = this.w, r2 = this.barCtx.stackedSeriesTotals[a2];
        return this.totalFormatter && (r2 = this.totalFormatter(r2, e(e({}, s2), {}, { seriesIndex: i2, dataPointIndex: a2, w: s2 }))), r2;
      } }, { key: "calculateColumnsDataLabelsPosition", value: function(t3) {
        var e2, i2, a2 = this.w, s2 = t3.i, r2 = t3.j, o2 = t3.realIndex, n2 = t3.groupIndex, l2 = t3.y, h2 = t3.bcx, c2 = t3.barWidth, d2 = t3.barHeight, g2 = t3.textRects, u2 = t3.dataLabelsX, p2 = t3.dataLabelsY, f2 = t3.dataLabelsConfig, x2 = t3.barDataLabelsConfig, b2 = t3.barTotalDataLabelsConfig, v2 = t3.strokeWidth, y2 = t3.offX, w2 = t3.offY;
        d2 = Math.abs(d2);
        var k2 = "vertical" === a2.config.plotOptions.bar.dataLabels.orientation, A2 = this.barCtx.barHelpers.getZeroValueEncounters({ i: s2, j: r2 }).zeroEncounters;
        h2 = h2 - v2 / 2 + (-1 !== n2 ? n2 * c2 : 0);
        var S2 = a2.globals.gridWidth / a2.globals.dataPoints;
        if (this.barCtx.isVerticalGroupedRangeBar ? u2 += c2 / 2 : (u2 = a2.globals.isXNumeric ? h2 - c2 / 2 + y2 : h2 - S2 + c2 / 2 + y2, A2 > 0 && a2.config.plotOptions.bar.hideZeroBarsWhenGrouped && (u2 -= c2 * A2)), k2) {
          u2 = u2 + g2.height / 2 - v2 / 2 - 2;
        }
        var C2 = this.barCtx.series[s2][r2] < 0, L2 = l2;
        switch (this.barCtx.isReversed && (L2 = l2 - d2 + (C2 ? 2 * d2 : 0), l2 -= d2), x2.position) {
          case "center":
            p2 = k2 ? C2 ? L2 - d2 / 2 + w2 : L2 + d2 / 2 - w2 : C2 ? L2 - d2 / 2 + g2.height / 2 + w2 : L2 + d2 / 2 + g2.height / 2 - w2;
            break;
          case "bottom":
            p2 = k2 ? C2 ? L2 - d2 + w2 : L2 + d2 - w2 : C2 ? L2 - d2 + g2.height + v2 + w2 : L2 + d2 - g2.height / 2 + v2 - w2;
            break;
          case "top":
            p2 = k2 ? C2 ? L2 + w2 : L2 - w2 : C2 ? L2 - g2.height / 2 - w2 : L2 + g2.height + w2;
        }
        if (this.barCtx.lastActiveBarSerieIndex === o2 && b2.enabled) {
          var P2 = new m(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({ realIndex: o2, j: r2 }), f2.fontSize);
          e2 = C2 ? L2 - P2.height / 2 - w2 - b2.offsetY + 18 : L2 + P2.height + w2 + b2.offsetY - 18, i2 = u2 + b2.offsetX;
        }
        return a2.config.chart.stacked || (p2 < 0 ? p2 = 0 + v2 : p2 + g2.height / 3 > a2.globals.gridHeight && (p2 = a2.globals.gridHeight - v2)), { bcx: h2, bcy: l2, dataLabelsX: u2, dataLabelsY: p2, totalDataLabelsX: i2, totalDataLabelsY: e2, totalDataLabelsAnchor: "middle" };
      } }, { key: "calculateBarsDataLabelsPosition", value: function(t3) {
        var e2 = this.w, i2 = t3.x, a2 = t3.i, s2 = t3.j, r2 = t3.realIndex, o2 = t3.groupIndex, n2 = t3.bcy, l2 = t3.barHeight, h2 = t3.barWidth, c2 = t3.textRects, d2 = t3.dataLabelsX, g2 = t3.strokeWidth, u2 = t3.dataLabelsConfig, p2 = t3.barDataLabelsConfig, f2 = t3.barTotalDataLabelsConfig, x2 = t3.offX, b2 = t3.offY, v2 = e2.globals.gridHeight / e2.globals.dataPoints;
        h2 = Math.abs(h2);
        var y2, w2, k2 = (n2 += -1 !== o2 ? o2 * l2 : 0) - (this.barCtx.isRangeBar ? 0 : v2) + l2 / 2 + c2.height / 2 + b2 - 3, A2 = "start", S2 = this.barCtx.series[a2][s2] < 0, C2 = i2;
        switch (this.barCtx.isReversed && (C2 = i2 + h2 - (S2 ? 2 * h2 : 0), i2 = e2.globals.gridWidth - h2), p2.position) {
          case "center":
            d2 = S2 ? C2 + h2 / 2 - x2 : Math.max(c2.width / 2, C2 - h2 / 2) + x2;
            break;
          case "bottom":
            d2 = S2 ? C2 + h2 - g2 - Math.round(c2.width / 2) - x2 : C2 - h2 + g2 + Math.round(c2.width / 2) + x2;
            break;
          case "top":
            d2 = S2 ? C2 - g2 + Math.round(c2.width / 2) - x2 : C2 - g2 - Math.round(c2.width / 2) + x2;
        }
        if (this.barCtx.lastActiveBarSerieIndex === r2 && f2.enabled) {
          var L2 = new m(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({ realIndex: r2, j: s2 }), u2.fontSize);
          S2 ? (y2 = C2 - g2 + Math.round(L2.width / 2) - x2 - f2.offsetX - 15, A2 = "end") : y2 = C2 - g2 - Math.round(L2.width / 2) + x2 + f2.offsetX + 15, w2 = k2 + f2.offsetY;
        }
        return e2.config.chart.stacked || (d2 < 0 ? d2 = d2 + c2.width + g2 : d2 + c2.width / 2 > e2.globals.gridWidth && (d2 = e2.globals.gridWidth - c2.width - g2)), { bcx: i2, bcy: n2, dataLabelsX: d2, dataLabelsY: k2, totalDataLabelsX: y2, totalDataLabelsY: w2, totalDataLabelsAnchor: A2 };
      } }, { key: "drawCalculatedDataLabels", value: function(t3) {
        var i2 = t3.x, a2 = t3.y, s2 = t3.val, r2 = t3.i, o2 = t3.j, n2 = t3.textRects, l2 = t3.barHeight, h2 = t3.barWidth, c2 = t3.dataLabelsConfig, d2 = this.w, g2 = "rotate(0)";
        "vertical" === d2.config.plotOptions.bar.dataLabels.orientation && (g2 = "rotate(-90, ".concat(i2, ", ").concat(a2, ")"));
        var u2 = new O(this.barCtx.ctx), p2 = new m(this.barCtx.ctx), f2 = c2.formatter, x2 = null, b2 = d2.globals.collapsedSeriesIndices.indexOf(r2) > -1;
        if (c2.enabled && !b2) {
          x2 = p2.group({ class: "apexcharts-data-labels", transform: g2 });
          var v2 = "";
          void 0 !== s2 && (v2 = f2(s2, e(e({}, d2), {}, { seriesIndex: r2, dataPointIndex: o2, w: d2 }))), !s2 && d2.config.plotOptions.bar.hideZeroBarsWhenGrouped && (v2 = "");
          var y2 = d2.globals.series[r2][o2] < 0, w2 = d2.config.plotOptions.bar.dataLabels.position;
          if ("vertical" === d2.config.plotOptions.bar.dataLabels.orientation && ("top" === w2 && (c2.textAnchor = y2 ? "end" : "start"), "center" === w2 && (c2.textAnchor = "middle"), "bottom" === w2 && (c2.textAnchor = y2 ? "end" : "start")), this.barCtx.isRangeBar && this.barCtx.barOptions.dataLabels.hideOverflowingLabels)
            h2 < p2.getTextRects(v2, parseFloat(c2.style.fontSize)).width && (v2 = "");
          d2.config.chart.stacked && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && (this.barCtx.isHorizontal ? n2.width / 1.6 > Math.abs(h2) && (v2 = "") : n2.height / 1.6 > Math.abs(l2) && (v2 = ""));
          var k2 = e({}, c2);
          this.barCtx.isHorizontal && s2 < 0 && ("start" === c2.textAnchor ? k2.textAnchor = "end" : "end" === c2.textAnchor && (k2.textAnchor = "start")), u2.plotDataLabelsText({ x: i2, y: a2, text: v2, i: r2, j: o2, parent: x2, dataLabelsConfig: k2, alwaysDrawDataLabel: true, offsetCorrection: true });
        }
        return x2;
      } }, { key: "drawTotalDataLabels", value: function(t3) {
        var e2, i2 = t3.x, a2 = t3.y, s2 = t3.val, r2 = t3.realIndex, o2 = t3.textAnchor, n2 = t3.barTotalDataLabelsConfig, l2 = new m(this.barCtx.ctx);
        return n2.enabled && void 0 !== i2 && void 0 !== a2 && this.barCtx.lastActiveBarSerieIndex === r2 && (e2 = l2.drawText({ x: i2, y: a2, foreColor: n2.style.color, text: s2, textAnchor: o2, fontFamily: n2.style.fontFamily, fontSize: n2.style.fontSize, fontWeight: n2.style.fontWeight })), e2;
      } }]), t2;
    }();
    var mt = function() {
      function t2(e2) {
        a(this, t2), this.w = e2.w, this.barCtx = e2;
      }
      return r(t2, [{ key: "initVariables", value: function(t3) {
        var e2 = this.w;
        this.barCtx.series = t3, this.barCtx.totalItems = 0, this.barCtx.seriesLen = 0, this.barCtx.visibleI = -1, this.barCtx.visibleItems = 1;
        for (var i2 = 0; i2 < t3.length; i2++)
          if (t3[i2].length > 0 && (this.barCtx.seriesLen = this.barCtx.seriesLen + 1, this.barCtx.totalItems += t3[i2].length), e2.globals.isXNumeric)
            for (var a2 = 0; a2 < t3[i2].length; a2++)
              e2.globals.seriesX[i2][a2] > e2.globals.minX && e2.globals.seriesX[i2][a2] < e2.globals.maxX && this.barCtx.visibleItems++;
          else
            this.barCtx.visibleItems = e2.globals.dataPoints;
        0 === this.barCtx.seriesLen && (this.barCtx.seriesLen = 1), this.barCtx.zeroSerieses = [], e2.globals.comboCharts || this.checkZeroSeries({ series: t3 });
      } }, { key: "initialPositions", value: function() {
        var t3, e2, i2, a2, s2, r2, o2, n2, l2 = this.w, h2 = l2.globals.dataPoints;
        this.barCtx.isRangeBar && (h2 = l2.globals.labels.length);
        var c2 = this.barCtx.seriesLen;
        if (l2.config.plotOptions.bar.rangeBarGroupRows && (c2 = 1), this.barCtx.isHorizontal)
          s2 = (i2 = l2.globals.gridHeight / h2) / c2, l2.globals.isXNumeric && (s2 = (i2 = l2.globals.gridHeight / this.barCtx.totalItems) / this.barCtx.seriesLen), s2 = s2 * parseInt(this.barCtx.barOptions.barHeight, 10) / 100, -1 === String(this.barCtx.barOptions.barHeight).indexOf("%") && (s2 = parseInt(this.barCtx.barOptions.barHeight, 10)), n2 = this.barCtx.baseLineInvertedY + l2.globals.padHorizontal + (this.barCtx.isReversed ? l2.globals.gridWidth : 0) - (this.barCtx.isReversed ? 2 * this.barCtx.baseLineInvertedY : 0), this.barCtx.isFunnel && (n2 = l2.globals.gridWidth / 2), e2 = (i2 - s2 * this.barCtx.seriesLen) / 2;
        else {
          if (a2 = l2.globals.gridWidth / this.barCtx.visibleItems, l2.config.xaxis.convertedCatToNumeric && (a2 = l2.globals.gridWidth / l2.globals.dataPoints), r2 = a2 / c2 * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100, l2.globals.isXNumeric) {
            var d2 = this.barCtx.xRatio;
            l2.config.xaxis.convertedCatToNumeric && (d2 = this.barCtx.initialXRatio), l2.globals.minXDiff && 0.5 !== l2.globals.minXDiff && l2.globals.minXDiff / d2 > 0 && (a2 = l2.globals.minXDiff / d2), (r2 = a2 / c2 * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100) < 1 && (r2 = 1);
          }
          -1 === String(this.barCtx.barOptions.columnWidth).indexOf("%") && (r2 = parseInt(this.barCtx.barOptions.columnWidth, 10)), o2 = l2.globals.gridHeight - this.barCtx.baseLineY[this.barCtx.yaxisIndex] - (this.barCtx.isReversed ? l2.globals.gridHeight : 0) + (this.barCtx.isReversed ? 2 * this.barCtx.baseLineY[this.barCtx.yaxisIndex] : 0), t3 = l2.globals.padHorizontal + (a2 - r2 * this.barCtx.seriesLen) / 2;
        }
        return { x: t3, y: e2, yDivision: i2, xDivision: a2, barHeight: s2, barWidth: r2, zeroH: o2, zeroW: n2 };
      } }, { key: "initializeStackedPrevVars", value: function(t3) {
        var e2 = t3.w;
        e2.globals.hasSeriesGroups ? e2.globals.seriesGroups.forEach(function(e3) {
          t3[e3] || (t3[e3] = {}), t3[e3].prevY = [], t3[e3].prevX = [], t3[e3].prevYF = [], t3[e3].prevXF = [], t3[e3].prevYVal = [], t3[e3].prevXVal = [];
        }) : (t3.prevY = [], t3.prevX = [], t3.prevYF = [], t3.prevXF = [], t3.prevYVal = [], t3.prevXVal = []);
      } }, { key: "initializeStackedXYVars", value: function(t3) {
        var e2 = t3.w;
        e2.globals.hasSeriesGroups ? e2.globals.seriesGroups.forEach(function(e3) {
          t3[e3] || (t3[e3] = {}), t3[e3].xArrj = [], t3[e3].xArrjF = [], t3[e3].xArrjVal = [], t3[e3].yArrj = [], t3[e3].yArrjF = [], t3[e3].yArrjVal = [];
        }) : (t3.xArrj = [], t3.xArrjF = [], t3.xArrjVal = [], t3.yArrj = [], t3.yArrjF = [], t3.yArrjVal = []);
      } }, { key: "getPathFillColor", value: function(t3, e2, i2, a2) {
        var s2, r2, o2, n2, l2 = this.w, h2 = new R(this.barCtx.ctx), c2 = null, d2 = this.barCtx.barOptions.distributed ? i2 : e2;
        this.barCtx.barOptions.colors.ranges.length > 0 && this.barCtx.barOptions.colors.ranges.map(function(a3) {
          t3[e2][i2] >= a3.from && t3[e2][i2] <= a3.to && (c2 = a3.color);
        });
        return l2.config.series[e2].data[i2] && l2.config.series[e2].data[i2].fillColor && (c2 = l2.config.series[e2].data[i2].fillColor), h2.fillPath({ seriesNumber: this.barCtx.barOptions.distributed ? d2 : a2, dataPointIndex: i2, color: c2, value: t3[e2][i2], fillConfig: null === (s2 = l2.config.series[e2].data[i2]) || void 0 === s2 ? void 0 : s2.fill, fillType: null !== (r2 = l2.config.series[e2].data[i2]) && void 0 !== r2 && null !== (o2 = r2.fill) && void 0 !== o2 && o2.type ? null === (n2 = l2.config.series[e2].data[i2]) || void 0 === n2 ? void 0 : n2.fill.type : l2.config.fill.type });
      } }, { key: "getStrokeWidth", value: function(t3, e2, i2) {
        var a2 = 0, s2 = this.w;
        return this.barCtx.series[t3][e2] ? this.barCtx.isNullValue = false : this.barCtx.isNullValue = true, s2.config.stroke.show && (this.barCtx.isNullValue || (a2 = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[i2] : this.barCtx.strokeWidth)), a2;
      } }, { key: "shouldApplyRadius", value: function(t3) {
        var e2 = this.w, i2 = false;
        return e2.config.plotOptions.bar.borderRadius > 0 && (e2.config.chart.stacked && "last" === e2.config.plotOptions.bar.borderRadiusWhenStacked ? this.barCtx.lastActiveBarSerieIndex === t3 && (i2 = true) : i2 = true), i2;
      } }, { key: "barBackground", value: function(t3) {
        var e2 = t3.j, i2 = t3.i, a2 = t3.x1, s2 = t3.x2, r2 = t3.y1, o2 = t3.y2, n2 = t3.elSeries, l2 = this.w, h2 = new m(this.barCtx.ctx), c2 = new N(this.barCtx.ctx).getActiveConfigSeriesIndex();
        if (this.barCtx.barOptions.colors.backgroundBarColors.length > 0 && c2 === i2) {
          e2 >= this.barCtx.barOptions.colors.backgroundBarColors.length && (e2 %= this.barCtx.barOptions.colors.backgroundBarColors.length);
          var d2 = this.barCtx.barOptions.colors.backgroundBarColors[e2], g2 = h2.drawRect(void 0 !== a2 ? a2 : 0, void 0 !== r2 ? r2 : 0, void 0 !== s2 ? s2 : l2.globals.gridWidth, void 0 !== o2 ? o2 : l2.globals.gridHeight, this.barCtx.barOptions.colors.backgroundBarRadius, d2, this.barCtx.barOptions.colors.backgroundBarOpacity);
          n2.add(g2), g2.node.classList.add("apexcharts-backgroundBar");
        }
      } }, { key: "getColumnPaths", value: function(t3) {
        var e2, i2 = t3.barWidth, a2 = t3.barXPosition, s2 = t3.y1, r2 = t3.y2, o2 = t3.strokeWidth, n2 = t3.seriesGroup, l2 = t3.realIndex, h2 = t3.i, c2 = t3.j, d2 = t3.w, g2 = new m(this.barCtx.ctx);
        (o2 = Array.isArray(o2) ? o2[l2] : o2) || (o2 = 0);
        var u2 = i2, p2 = a2;
        null !== (e2 = d2.config.series[l2].data[c2]) && void 0 !== e2 && e2.columnWidthOffset && (p2 = a2 - d2.config.series[l2].data[c2].columnWidthOffset / 2, u2 = i2 + d2.config.series[l2].data[c2].columnWidthOffset);
        var f2 = p2, x2 = p2 + u2;
        s2 += 1e-3, r2 += 1e-3;
        var b2 = g2.move(f2, s2), v2 = g2.move(f2, s2), y2 = g2.line(x2 - o2, s2);
        if (d2.globals.previousPaths.length > 0 && (v2 = this.barCtx.getPreviousPath(l2, c2, false)), b2 = b2 + g2.line(f2, r2) + g2.line(x2 - o2, r2) + g2.line(x2 - o2, s2) + ("around" === d2.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z"), v2 = v2 + g2.line(f2, s2) + y2 + y2 + y2 + y2 + y2 + g2.line(f2, s2) + ("around" === d2.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z"), this.shouldApplyRadius(l2) && (b2 = g2.roundPathCorners(b2, d2.config.plotOptions.bar.borderRadius)), d2.config.chart.stacked) {
          var w2 = this.barCtx;
          d2.globals.hasSeriesGroups && n2 && (w2 = this.barCtx[n2]), w2.yArrj.push(r2), w2.yArrjF.push(Math.abs(s2 - r2)), w2.yArrjVal.push(this.barCtx.series[h2][c2]);
        }
        return { pathTo: b2, pathFrom: v2 };
      } }, { key: "getBarpaths", value: function(t3) {
        var e2, i2 = t3.barYPosition, a2 = t3.barHeight, s2 = t3.x1, r2 = t3.x2, o2 = t3.strokeWidth, n2 = t3.seriesGroup, l2 = t3.realIndex, h2 = t3.i, c2 = t3.j, d2 = t3.w, g2 = new m(this.barCtx.ctx);
        (o2 = Array.isArray(o2) ? o2[l2] : o2) || (o2 = 0);
        var u2 = i2, p2 = a2;
        null !== (e2 = d2.config.series[l2].data[c2]) && void 0 !== e2 && e2.barHeightOffset && (u2 = i2 - d2.config.series[l2].data[c2].barHeightOffset / 2, p2 = a2 + d2.config.series[l2].data[c2].barHeightOffset);
        var f2 = u2, x2 = u2 + p2;
        s2 += 1e-3, r2 += 1e-3;
        var b2 = g2.move(s2, f2), v2 = g2.move(s2, f2);
        d2.globals.previousPaths.length > 0 && (v2 = this.barCtx.getPreviousPath(l2, c2, false));
        var y2 = g2.line(s2, x2 - o2);
        if (b2 = b2 + g2.line(r2, f2) + g2.line(r2, x2 - o2) + y2 + ("around" === d2.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z"), v2 = v2 + g2.line(s2, f2) + y2 + y2 + y2 + y2 + y2 + g2.line(s2, f2) + ("around" === d2.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z"), this.shouldApplyRadius(l2) && (b2 = g2.roundPathCorners(b2, d2.config.plotOptions.bar.borderRadius)), d2.config.chart.stacked) {
          var w2 = this.barCtx;
          d2.globals.hasSeriesGroups && n2 && (w2 = this.barCtx[n2]), w2.xArrj.push(r2), w2.xArrjF.push(Math.abs(s2 - r2)), w2.xArrjVal.push(this.barCtx.series[h2][c2]);
        }
        return { pathTo: b2, pathFrom: v2 };
      } }, { key: "checkZeroSeries", value: function(t3) {
        for (var e2 = t3.series, i2 = this.w, a2 = 0; a2 < e2.length; a2++) {
          for (var s2 = 0, r2 = 0; r2 < e2[i2.globals.maxValsInArrayIndex].length; r2++)
            s2 += e2[a2][r2];
          0 === s2 && this.barCtx.zeroSerieses.push(a2);
        }
      } }, { key: "getXForValue", value: function(t3, e2) {
        var i2 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2] ? e2 : null;
        return null != t3 && (i2 = e2 + t3 / this.barCtx.invertedYRatio - 2 * (this.barCtx.isReversed ? t3 / this.barCtx.invertedYRatio : 0)), i2;
      } }, { key: "getYForValue", value: function(t3, e2) {
        var i2 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2] ? e2 : null;
        return null != t3 && (i2 = e2 - t3 / this.barCtx.yRatio[this.barCtx.yaxisIndex] + 2 * (this.barCtx.isReversed ? t3 / this.barCtx.yRatio[this.barCtx.yaxisIndex] : 0)), i2;
      } }, { key: "getGoalValues", value: function(t3, i2, a2, s2, r2) {
        var n2 = this, l2 = this.w, h2 = [], c2 = function(e2, s3) {
          var r3;
          h2.push((o(r3 = {}, t3, "x" === t3 ? n2.getXForValue(e2, i2, false) : n2.getYForValue(e2, a2, false)), o(r3, "attrs", s3), r3));
        };
        if (l2.globals.seriesGoals[s2] && l2.globals.seriesGoals[s2][r2] && Array.isArray(l2.globals.seriesGoals[s2][r2]) && l2.globals.seriesGoals[s2][r2].forEach(function(t4) {
          c2(t4.value, t4);
        }), this.barCtx.barOptions.isDumbbell && l2.globals.seriesRange.length) {
          var d2 = this.barCtx.barOptions.dumbbellColors ? this.barCtx.barOptions.dumbbellColors : l2.globals.colors, g2 = { strokeHeight: "x" === t3 ? 0 : l2.globals.markers.size[s2], strokeWidth: "x" === t3 ? l2.globals.markers.size[s2] : 0, strokeDashArray: 0, strokeLineCap: "round", strokeColor: Array.isArray(d2[s2]) ? d2[s2][0] : d2[s2] };
          c2(l2.globals.seriesRangeStart[s2][r2], g2), c2(l2.globals.seriesRangeEnd[s2][r2], e(e({}, g2), {}, { strokeColor: Array.isArray(d2[s2]) ? d2[s2][1] : d2[s2] }));
        }
        return h2;
      } }, { key: "drawGoalLine", value: function(t3) {
        var e2 = t3.barXPosition, i2 = t3.barYPosition, a2 = t3.goalX, s2 = t3.goalY, r2 = t3.barWidth, o2 = t3.barHeight, n2 = new m(this.barCtx.ctx), l2 = n2.group({ className: "apexcharts-bar-goals-groups" });
        l2.node.classList.add("apexcharts-element-hidden"), this.barCtx.w.globals.delayedElements.push({ el: l2.node }), l2.attr("clip-path", "url(#gridRectMarkerMask".concat(this.barCtx.w.globals.cuid, ")"));
        var h2 = null;
        return this.barCtx.isHorizontal ? Array.isArray(a2) && a2.forEach(function(t4) {
          var e3 = void 0 !== t4.attrs.strokeHeight ? t4.attrs.strokeHeight : o2 / 2, a3 = i2 + e3 + o2 / 2;
          h2 = n2.drawLine(t4.x, a3 - 2 * e3, t4.x, a3, t4.attrs.strokeColor ? t4.attrs.strokeColor : void 0, t4.attrs.strokeDashArray, t4.attrs.strokeWidth ? t4.attrs.strokeWidth : 2, t4.attrs.strokeLineCap), l2.add(h2);
        }) : Array.isArray(s2) && s2.forEach(function(t4) {
          var i3 = void 0 !== t4.attrs.strokeWidth ? t4.attrs.strokeWidth : r2 / 2, a3 = e2 + i3 + r2 / 2;
          h2 = n2.drawLine(a3 - 2 * i3, t4.y, a3, t4.y, t4.attrs.strokeColor ? t4.attrs.strokeColor : void 0, t4.attrs.strokeDashArray, t4.attrs.strokeHeight ? t4.attrs.strokeHeight : 2, t4.attrs.strokeLineCap), l2.add(h2);
        }), l2;
      } }, { key: "drawBarShadow", value: function(t3) {
        var e2 = t3.prevPaths, i2 = t3.currPaths, a2 = t3.color, s2 = this.w, r2 = e2.x, o2 = e2.x1, n2 = e2.barYPosition, l2 = i2.x, h2 = i2.x1, c2 = i2.barYPosition, d2 = n2 + i2.barHeight, g2 = new m(this.barCtx.ctx), u2 = new x(), p2 = g2.move(o2, d2) + g2.line(r2, d2) + g2.line(l2, c2) + g2.line(h2, c2) + g2.line(o2, d2) + ("around" === s2.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z");
        return g2.drawPath({ d: p2, fill: u2.shadeColor(0.5, x.rgb2hex(a2)), stroke: "none", strokeWidth: 0, fillOpacity: 1, classes: "apexcharts-bar-shadows" });
      } }, { key: "getZeroValueEncounters", value: function(t3) {
        var e2 = t3.i, i2 = t3.j, a2 = this.w, s2 = 0, r2 = 0;
        return a2.globals.seriesPercent.forEach(function(t4, a3) {
          t4[i2] && s2++, a3 < e2 && 0 === t4[i2] && r2++;
        }), { nonZeroColumns: s2, zeroEncounters: r2 };
      } }]), t2;
    }();
    var yt = function() {
      function t2(e2, i2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
        var s2 = this.w;
        this.barOptions = s2.config.plotOptions.bar, this.isHorizontal = this.barOptions.horizontal, this.strokeWidth = s2.config.stroke.width, this.isNullValue = false, this.isRangeBar = s2.globals.seriesRange.length && this.isHorizontal, this.isVerticalGroupedRangeBar = !s2.globals.isBarHorizontal && s2.globals.seriesRange.length && s2.config.plotOptions.bar.rangeBarGroupRows, this.isFunnel = this.barOptions.isFunnel, this.xyRatios = i2, null !== this.xyRatios && (this.xRatio = i2.xRatio, this.initialXRatio = i2.initialXRatio, this.yRatio = i2.yRatio, this.invertedXRatio = i2.invertedXRatio, this.invertedYRatio = i2.invertedYRatio, this.baseLineY = i2.baseLineY, this.baseLineInvertedY = i2.baseLineInvertedY), this.yaxisIndex = 0, this.seriesLen = 0, this.pathArr = [];
        var r2 = new N(this.ctx);
        this.lastActiveBarSerieIndex = r2.getActiveConfigSeriesIndex("desc", ["bar", "column"]);
        var o2 = r2.getBarSeriesIndices(), n2 = new y(this.ctx);
        this.stackedSeriesTotals = n2.getStackedSeriesTotals(this.w.config.series.map(function(t3, e3) {
          return -1 === o2.indexOf(e3) ? e3 : -1;
        }).filter(function(t3) {
          return -1 !== t3;
        })), this.barHelpers = new mt(this);
      }
      return r(t2, [{ key: "draw", value: function(t3, i2) {
        var a2 = this.w, s2 = new m(this.ctx), r2 = new y(this.ctx, a2);
        t3 = r2.getLogSeries(t3), this.series = t3, this.yRatio = r2.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t3);
        var o2 = s2.group({ class: "apexcharts-bar-series apexcharts-plot-series" });
        a2.config.dataLabels.enabled && this.totalItems > this.barOptions.dataLabels.maxItems && console.warn("WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering - ApexCharts");
        for (var n2 = 0, l2 = 0; n2 < t3.length; n2++, l2++) {
          var h2, c2, d2, g2, u2 = void 0, p2 = void 0, f2 = [], b2 = [], v2 = a2.globals.comboCharts ? i2[n2] : n2, w2 = s2.group({ class: "apexcharts-series", rel: n2 + 1, seriesName: x.escapeString(a2.globals.seriesNames[v2]), "data:realIndex": v2 });
          this.ctx.series.addCollapsedClassToSeries(w2, v2), t3[n2].length > 0 && (this.visibleI = this.visibleI + 1);
          var k2 = 0, A2 = 0;
          this.yRatio.length > 1 && (this.yaxisIndex = v2), this.isReversed = a2.config.yaxis[this.yaxisIndex] && a2.config.yaxis[this.yaxisIndex].reversed;
          var S2 = this.barHelpers.initialPositions();
          p2 = S2.y, k2 = S2.barHeight, c2 = S2.yDivision, g2 = S2.zeroW, u2 = S2.x, A2 = S2.barWidth, h2 = S2.xDivision, d2 = S2.zeroH, this.horizontal || b2.push(u2 + A2 / 2);
          var C2 = s2.group({ class: "apexcharts-datalabels", "data:realIndex": v2 });
          a2.globals.delayedElements.push({ el: C2.node }), C2.node.classList.add("apexcharts-element-hidden");
          var L2 = s2.group({ class: "apexcharts-bar-goals-markers" }), P2 = s2.group({ class: "apexcharts-bar-shadows" });
          a2.globals.delayedElements.push({ el: P2.node }), P2.node.classList.add("apexcharts-element-hidden");
          for (var I2 = 0; I2 < a2.globals.dataPoints; I2++) {
            var T2 = this.barHelpers.getStrokeWidth(n2, I2, v2), M2 = null, z2 = { indexes: { i: n2, j: I2, realIndex: v2, bc: l2 }, x: u2, y: p2, strokeWidth: T2, elSeries: w2 };
            this.isHorizontal ? (M2 = this.drawBarPaths(e(e({}, z2), {}, { barHeight: k2, zeroW: g2, yDivision: c2 })), A2 = this.series[n2][I2] / this.invertedYRatio) : (M2 = this.drawColumnPaths(e(e({}, z2), {}, { xDivision: h2, barWidth: A2, zeroH: d2 })), k2 = this.series[n2][I2] / this.yRatio[this.yaxisIndex]);
            var X2 = this.barHelpers.getPathFillColor(t3, n2, I2, v2);
            if (this.isFunnel && this.barOptions.isFunnel3d && this.pathArr.length && I2 > 0) {
              var E2 = this.barHelpers.drawBarShadow({ color: "string" == typeof X2 && -1 === (null == X2 ? void 0 : X2.indexOf("url")) ? X2 : x.hexToRgba(a2.globals.colors[n2]), prevPaths: this.pathArr[this.pathArr.length - 1], currPaths: M2 });
              E2 && P2.add(E2);
            }
            this.pathArr.push(M2);
            var Y2 = this.barHelpers.drawGoalLine({ barXPosition: M2.barXPosition, barYPosition: M2.barYPosition, goalX: M2.goalX, goalY: M2.goalY, barHeight: k2, barWidth: A2 });
            Y2 && L2.add(Y2), p2 = M2.y, u2 = M2.x, I2 > 0 && b2.push(u2 + A2 / 2), f2.push(p2), this.renderSeries({ realIndex: v2, pathFill: X2, j: I2, i: n2, pathFrom: M2.pathFrom, pathTo: M2.pathTo, strokeWidth: T2, elSeries: w2, x: u2, y: p2, series: t3, barHeight: M2.barHeight ? M2.barHeight : k2, barWidth: M2.barWidth ? M2.barWidth : A2, elDataLabelsWrap: C2, elGoalsMarkers: L2, elBarShadows: P2, visibleSeries: this.visibleI, type: "bar" });
          }
          a2.globals.seriesXvalues[v2] = b2, a2.globals.seriesYvalues[v2] = f2, o2.add(w2);
        }
        return o2;
      } }, { key: "renderSeries", value: function(t3) {
        var e2 = t3.realIndex, i2 = t3.pathFill, a2 = t3.lineFill, s2 = t3.j, r2 = t3.i, o2 = t3.groupIndex, n2 = t3.pathFrom, l2 = t3.pathTo, h2 = t3.strokeWidth, c2 = t3.elSeries, d2 = t3.x, g2 = t3.y, u2 = t3.y1, p2 = t3.y2, f2 = t3.series, x2 = t3.barHeight, b2 = t3.barWidth, y2 = t3.barXPosition, w2 = t3.barYPosition, k2 = t3.elDataLabelsWrap, A2 = t3.elGoalsMarkers, S2 = t3.elBarShadows, C2 = t3.visibleSeries, L2 = t3.type, P2 = this.w, I2 = new m(this.ctx);
        a2 || (a2 = this.barOptions.distributed ? P2.globals.stroke.colors[s2] : P2.globals.stroke.colors[e2]), P2.config.series[r2].data[s2] && P2.config.series[r2].data[s2].strokeColor && (a2 = P2.config.series[r2].data[s2].strokeColor), this.isNullValue && (i2 = "none");
        var T2 = s2 / P2.config.chart.animations.animateGradually.delay * (P2.config.chart.animations.speed / P2.globals.dataPoints) / 2.4, M2 = I2.renderPaths({ i: r2, j: s2, realIndex: e2, pathFrom: n2, pathTo: l2, stroke: a2, strokeWidth: h2, strokeLineCap: P2.config.stroke.lineCap, fill: i2, animationDelay: T2, initialSpeed: P2.config.chart.animations.speed, dataChangeSpeed: P2.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-".concat(L2, "-area") });
        M2.attr("clip-path", "url(#gridRectMask".concat(P2.globals.cuid, ")"));
        var z2 = P2.config.forecastDataPoints;
        z2.count > 0 && s2 >= P2.globals.dataPoints - z2.count && (M2.node.setAttribute("stroke-dasharray", z2.dashArray), M2.node.setAttribute("stroke-width", z2.strokeWidth), M2.node.setAttribute("fill-opacity", z2.fillOpacity)), void 0 !== u2 && void 0 !== p2 && (M2.attr("data-range-y1", u2), M2.attr("data-range-y2", p2)), new v(this.ctx).setSelectionFilter(M2, e2, s2), c2.add(M2);
        var X2 = new vt(this).handleBarDataLabels({ x: d2, y: g2, y1: u2, y2: p2, i: r2, j: s2, series: f2, realIndex: e2, groupIndex: o2, barHeight: x2, barWidth: b2, barXPosition: y2, barYPosition: w2, renderedPath: M2, visibleSeries: C2 });
        return null !== X2.dataLabels && k2.add(X2.dataLabels), X2.totalDataLabels && k2.add(X2.totalDataLabels), c2.add(k2), A2 && c2.add(A2), S2 && c2.add(S2), c2;
      } }, { key: "drawBarPaths", value: function(t3) {
        var e2, i2 = t3.indexes, a2 = t3.barHeight, s2 = t3.strokeWidth, r2 = t3.zeroW, o2 = t3.x, n2 = t3.y, l2 = t3.yDivision, h2 = t3.elSeries, c2 = this.w, d2 = i2.i, g2 = i2.j;
        if (c2.globals.isXNumeric)
          e2 = (n2 = (c2.globals.seriesX[d2][g2] - c2.globals.minX) / this.invertedXRatio - a2) + a2 * this.visibleI;
        else if (c2.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
          var u2 = 0, p2 = 0;
          c2.globals.seriesPercent.forEach(function(t4, e3) {
            t4[g2] && u2++, e3 < d2 && 0 === t4[g2] && p2++;
          }), u2 > 0 && (a2 = this.seriesLen * a2 / u2), e2 = n2 + a2 * this.visibleI, e2 -= a2 * p2;
        } else
          e2 = n2 + a2 * this.visibleI;
        this.isFunnel && (r2 -= (this.barHelpers.getXForValue(this.series[d2][g2], r2) - r2) / 2), o2 = this.barHelpers.getXForValue(this.series[d2][g2], r2);
        var f2 = this.barHelpers.getBarpaths({ barYPosition: e2, barHeight: a2, x1: r2, x2: o2, strokeWidth: s2, series: this.series, realIndex: i2.realIndex, i: d2, j: g2, w: c2 });
        return c2.globals.isXNumeric || (n2 += l2), this.barHelpers.barBackground({ j: g2, i: d2, y1: e2 - a2 * this.visibleI, y2: a2 * this.seriesLen, elSeries: h2 }), { pathTo: f2.pathTo, pathFrom: f2.pathFrom, x1: r2, x: o2, y: n2, goalX: this.barHelpers.getGoalValues("x", r2, null, d2, g2), barYPosition: e2, barHeight: a2 };
      } }, { key: "drawColumnPaths", value: function(t3) {
        var e2, i2 = t3.indexes, a2 = t3.x, s2 = t3.y, r2 = t3.xDivision, o2 = t3.barWidth, n2 = t3.zeroH, l2 = t3.strokeWidth, h2 = t3.elSeries, c2 = this.w, d2 = i2.realIndex, g2 = i2.i, u2 = i2.j, p2 = i2.bc;
        if (c2.globals.isXNumeric) {
          var f2 = d2;
          c2.globals.seriesX[d2].length || (f2 = c2.globals.maxValsInArrayIndex), c2.globals.seriesX[f2][u2] && (a2 = (c2.globals.seriesX[f2][u2] - c2.globals.minX) / this.xRatio - o2 * this.seriesLen / 2), e2 = a2 + o2 * this.visibleI;
        } else if (c2.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
          var x2 = this.barHelpers.getZeroValueEncounters({ i: g2, j: u2 }), b2 = x2.nonZeroColumns, v2 = x2.zeroEncounters;
          b2 > 0 && (o2 = this.seriesLen * o2 / b2), e2 = a2 + o2 * this.visibleI, e2 -= o2 * v2;
        } else
          e2 = a2 + o2 * this.visibleI;
        s2 = this.barHelpers.getYForValue(this.series[g2][u2], n2);
        var m2 = this.barHelpers.getColumnPaths({ barXPosition: e2, barWidth: o2, y1: n2, y2: s2, strokeWidth: l2, series: this.series, realIndex: i2.realIndex, i: g2, j: u2, w: c2 });
        return c2.globals.isXNumeric || (a2 += r2), this.barHelpers.barBackground({ bc: p2, j: u2, i: g2, x1: e2 - l2 / 2 - o2 * this.visibleI, x2: o2 * this.seriesLen + l2 / 2, elSeries: h2 }), { pathTo: m2.pathTo, pathFrom: m2.pathFrom, x: a2, y: s2, goalY: this.barHelpers.getGoalValues("y", null, n2, g2, u2), barXPosition: e2, barWidth: o2 };
      } }, { key: "getPreviousPath", value: function(t3, e2) {
        for (var i2, a2 = this.w, s2 = 0; s2 < a2.globals.previousPaths.length; s2++) {
          var r2 = a2.globals.previousPaths[s2];
          r2.paths && r2.paths.length > 0 && parseInt(r2.realIndex, 10) === parseInt(t3, 10) && void 0 !== a2.globals.previousPaths[s2].paths[e2] && (i2 = a2.globals.previousPaths[s2].paths[e2].d);
        }
        return i2;
      } }]), t2;
    }();
    var wt = function(t2) {
      n(s2, yt);
      var i2 = d(s2);
      function s2() {
        return a(this, s2), i2.apply(this, arguments);
      }
      return r(s2, [{ key: "draw", value: function(t3, i3) {
        var a2 = this, s3 = this.w;
        this.graphics = new m(this.ctx), this.bar = new yt(this.ctx, this.xyRatios);
        var r2 = new y(this.ctx, s3);
        t3 = r2.getLogSeries(t3), this.yRatio = r2.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t3), "100%" === s3.config.chart.stackType && (t3 = s3.globals.seriesPercent.slice()), this.series = t3, this.barHelpers.initializeStackedPrevVars(this);
        for (var o2 = this.graphics.group({ class: "apexcharts-bar-series apexcharts-plot-series" }), n2 = 0, l2 = 0, h2 = function(r3, h3) {
          var c3 = void 0, d3 = void 0, g2 = void 0, u2 = void 0, p2 = -1;
          a2.groupCtx = a2, s3.globals.seriesGroups.forEach(function(t4, e2) {
            t4.indexOf(s3.config.series[r3].name) > -1 && (p2 = e2);
          }), -1 !== p2 && (a2.groupCtx = a2[s3.globals.seriesGroups[p2]]);
          var f2 = [], b2 = [], v2 = s3.globals.comboCharts ? i3[r3] : r3;
          a2.yRatio.length > 1 && (a2.yaxisIndex = v2), a2.isReversed = s3.config.yaxis[a2.yaxisIndex] && s3.config.yaxis[a2.yaxisIndex].reversed;
          var m2 = a2.graphics.group({ class: "apexcharts-series", seriesName: x.escapeString(s3.globals.seriesNames[v2]), rel: r3 + 1, "data:realIndex": v2 });
          a2.ctx.series.addCollapsedClassToSeries(m2, v2);
          var y2 = a2.graphics.group({ class: "apexcharts-datalabels", "data:realIndex": v2 }), w2 = a2.graphics.group({ class: "apexcharts-bar-goals-markers" }), k2 = 0, A2 = 0, S2 = a2.initialPositions(n2, l2, c3, d3, g2, u2);
          l2 = S2.y, k2 = S2.barHeight, d3 = S2.yDivision, u2 = S2.zeroW, n2 = S2.x, A2 = S2.barWidth, c3 = S2.xDivision, g2 = S2.zeroH, a2.barHelpers.initializeStackedXYVars(a2), 1 === a2.groupCtx.prevY.length && a2.groupCtx.prevY[0].every(function(t4) {
            return isNaN(t4);
          }) && (a2.groupCtx.prevY[0] = a2.groupCtx.prevY[0].map(function(t4) {
            return g2;
          }), a2.groupCtx.prevYF[0] = a2.groupCtx.prevYF[0].map(function(t4) {
            return 0;
          }));
          for (var C2 = 0; C2 < s3.globals.dataPoints; C2++) {
            var L2 = a2.barHelpers.getStrokeWidth(r3, C2, v2), P2 = { indexes: { i: r3, j: C2, realIndex: v2, bc: h3 }, strokeWidth: L2, x: n2, y: l2, elSeries: m2, groupIndex: p2, seriesGroup: s3.globals.seriesGroups[p2] }, I2 = null;
            a2.isHorizontal ? (I2 = a2.drawStackedBarPaths(e(e({}, P2), {}, { zeroW: u2, barHeight: k2, yDivision: d3 })), A2 = a2.series[r3][C2] / a2.invertedYRatio) : (I2 = a2.drawStackedColumnPaths(e(e({}, P2), {}, { xDivision: c3, barWidth: A2, zeroH: g2 })), k2 = a2.series[r3][C2] / a2.yRatio[a2.yaxisIndex]);
            var T2 = a2.barHelpers.drawGoalLine({ barXPosition: I2.barXPosition, barYPosition: I2.barYPosition, goalX: I2.goalX, goalY: I2.goalY, barHeight: k2, barWidth: A2 });
            T2 && w2.add(T2), l2 = I2.y, n2 = I2.x, f2.push(n2), b2.push(l2);
            var M2 = a2.barHelpers.getPathFillColor(t3, r3, C2, v2);
            m2 = a2.renderSeries({ realIndex: v2, pathFill: M2, j: C2, i: r3, groupIndex: p2, pathFrom: I2.pathFrom, pathTo: I2.pathTo, strokeWidth: L2, elSeries: m2, x: n2, y: l2, series: t3, barHeight: k2, barWidth: A2, elDataLabelsWrap: y2, elGoalsMarkers: w2, type: "bar", visibleSeries: 0 });
          }
          s3.globals.seriesXvalues[v2] = f2, s3.globals.seriesYvalues[v2] = b2, a2.groupCtx.prevY.push(a2.groupCtx.yArrj), a2.groupCtx.prevYF.push(a2.groupCtx.yArrjF), a2.groupCtx.prevYVal.push(a2.groupCtx.yArrjVal), a2.groupCtx.prevX.push(a2.groupCtx.xArrj), a2.groupCtx.prevXF.push(a2.groupCtx.xArrjF), a2.groupCtx.prevXVal.push(a2.groupCtx.xArrjVal), o2.add(m2);
        }, c2 = 0, d2 = 0; c2 < t3.length; c2++, d2++)
          h2(c2, d2);
        return o2;
      } }, { key: "initialPositions", value: function(t3, e2, i3, a2, s3, r2) {
        var o2, n2, l2, h2, c2 = this.w;
        return this.isHorizontal ? (l2 = (l2 = a2 = c2.globals.gridHeight / c2.globals.dataPoints) * parseInt(c2.config.plotOptions.bar.barHeight, 10) / 100, -1 === String(c2.config.plotOptions.bar.barHeight).indexOf("%") && (l2 = parseInt(c2.config.plotOptions.bar.barHeight, 10)), r2 = this.baseLineInvertedY + c2.globals.padHorizontal + (this.isReversed ? c2.globals.gridWidth : 0) - (this.isReversed ? 2 * this.baseLineInvertedY : 0), e2 = (a2 - l2) / 2) : (h2 = i3 = c2.globals.gridWidth / c2.globals.dataPoints, h2 = c2.globals.isXNumeric && c2.globals.dataPoints > 1 ? (i3 = c2.globals.minXDiff / this.xRatio) * parseInt(this.barOptions.columnWidth, 10) / 100 : h2 * parseInt(c2.config.plotOptions.bar.columnWidth, 10) / 100, -1 === String(c2.config.plotOptions.bar.columnWidth).indexOf("%") && (h2 = parseInt(c2.config.plotOptions.bar.columnWidth, 10)), s3 = c2.globals.gridHeight - this.baseLineY[this.yaxisIndex] - (this.isReversed ? c2.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0), t3 = c2.globals.padHorizontal + (i3 - h2) / 2), { x: t3, y: e2, yDivision: a2, xDivision: i3, barHeight: null !== (o2 = c2.globals.seriesGroups) && void 0 !== o2 && o2.length ? l2 / c2.globals.seriesGroups.length : l2, barWidth: null !== (n2 = c2.globals.seriesGroups) && void 0 !== n2 && n2.length ? h2 / c2.globals.seriesGroups.length : h2, zeroH: s3, zeroW: r2 };
      } }, { key: "drawStackedBarPaths", value: function(t3) {
        for (var e2, i3 = t3.indexes, a2 = t3.barHeight, s3 = t3.strokeWidth, r2 = t3.zeroW, o2 = t3.x, n2 = t3.y, l2 = t3.groupIndex, h2 = t3.seriesGroup, c2 = t3.yDivision, d2 = t3.elSeries, g2 = this.w, u2 = n2 + (-1 !== l2 ? l2 * a2 : 0), p2 = i3.i, f2 = i3.j, x2 = 0, b2 = 0; b2 < this.groupCtx.prevXF.length; b2++)
          x2 += this.groupCtx.prevXF[b2][f2];
        var v2 = p2;
        if (h2 && (v2 = h2.indexOf(g2.config.series[p2].name)), v2 > 0) {
          var m2 = r2;
          this.groupCtx.prevXVal[v2 - 1][f2] < 0 ? m2 = this.series[p2][f2] >= 0 ? this.groupCtx.prevX[v2 - 1][f2] + x2 - 2 * (this.isReversed ? x2 : 0) : this.groupCtx.prevX[v2 - 1][f2] : this.groupCtx.prevXVal[v2 - 1][f2] >= 0 && (m2 = this.series[p2][f2] >= 0 ? this.groupCtx.prevX[v2 - 1][f2] : this.groupCtx.prevX[v2 - 1][f2] - x2 + 2 * (this.isReversed ? x2 : 0)), e2 = m2;
        } else
          e2 = r2;
        o2 = null === this.series[p2][f2] ? e2 : e2 + this.series[p2][f2] / this.invertedYRatio - 2 * (this.isReversed ? this.series[p2][f2] / this.invertedYRatio : 0);
        var y2 = this.barHelpers.getBarpaths({ barYPosition: u2, barHeight: a2, x1: e2, x2: o2, strokeWidth: s3, series: this.series, realIndex: i3.realIndex, seriesGroup: h2, i: p2, j: f2, w: g2 });
        return this.barHelpers.barBackground({ j: f2, i: p2, y1: u2, y2: a2, elSeries: d2 }), n2 += c2, { pathTo: y2.pathTo, pathFrom: y2.pathFrom, goalX: this.barHelpers.getGoalValues("x", r2, null, p2, f2), barYPosition: u2, x: o2, y: n2 };
      } }, { key: "drawStackedColumnPaths", value: function(t3) {
        var e2 = t3.indexes, i3 = t3.x, a2 = t3.y, s3 = t3.xDivision, r2 = t3.barWidth, o2 = t3.zeroH, n2 = t3.groupIndex, l2 = t3.seriesGroup, h2 = t3.elSeries, c2 = this.w, d2 = e2.i, g2 = e2.j, u2 = e2.bc;
        if (c2.globals.isXNumeric) {
          var p2 = c2.globals.seriesX[d2][g2];
          p2 || (p2 = 0), i3 = (p2 - c2.globals.minX) / this.xRatio - r2 / 2, c2.globals.seriesGroups.length && (i3 = (p2 - c2.globals.minX) / this.xRatio - r2 / 2 * c2.globals.seriesGroups.length);
        }
        for (var f2, x2 = i3 + (-1 !== n2 ? n2 * r2 : 0), b2 = 0, v2 = 0; v2 < this.groupCtx.prevYF.length; v2++)
          b2 += isNaN(this.groupCtx.prevYF[v2][g2]) ? 0 : this.groupCtx.prevYF[v2][g2];
        var m2 = d2;
        if (l2 && (m2 = l2.indexOf(c2.config.series[d2].name)), m2 > 0 && !c2.globals.isXNumeric || m2 > 0 && c2.globals.isXNumeric && c2.globals.seriesX[d2 - 1][g2] === c2.globals.seriesX[d2][g2]) {
          var y2, w2, k2, A2 = Math.min(this.yRatio.length + 1, d2 + 1);
          if (void 0 !== this.groupCtx.prevY[m2 - 1] && this.groupCtx.prevY[m2 - 1].length)
            for (var S2 = 1; S2 < A2; S2++) {
              var C2;
              if (!isNaN(null === (C2 = this.groupCtx.prevY[m2 - S2]) || void 0 === C2 ? void 0 : C2[g2])) {
                k2 = this.groupCtx.prevY[m2 - S2][g2];
                break;
              }
            }
          for (var L2 = 1; L2 < A2; L2++) {
            var P2, I2;
            if ((null === (P2 = this.groupCtx.prevYVal[m2 - L2]) || void 0 === P2 ? void 0 : P2[g2]) < 0) {
              w2 = this.series[d2][g2] >= 0 ? k2 - b2 + 2 * (this.isReversed ? b2 : 0) : k2;
              break;
            }
            if ((null === (I2 = this.groupCtx.prevYVal[m2 - L2]) || void 0 === I2 ? void 0 : I2[g2]) >= 0) {
              w2 = this.series[d2][g2] >= 0 ? k2 : k2 + b2 - 2 * (this.isReversed ? b2 : 0);
              break;
            }
          }
          void 0 === w2 && (w2 = c2.globals.gridHeight), f2 = null !== (y2 = this.groupCtx.prevYF[0]) && void 0 !== y2 && y2.every(function(t4) {
            return 0 === t4;
          }) && this.groupCtx.prevYF.slice(1, m2).every(function(t4) {
            return t4.every(function(t5) {
              return isNaN(t5);
            });
          }) ? o2 : w2;
        } else
          f2 = o2;
        a2 = this.series[d2][g2] ? f2 - this.series[d2][g2] / this.yRatio[this.yaxisIndex] + 2 * (this.isReversed ? this.series[d2][g2] / this.yRatio[this.yaxisIndex] : 0) : f2;
        var T2 = this.barHelpers.getColumnPaths({ barXPosition: x2, barWidth: r2, y1: f2, y2: a2, yRatio: this.yRatio[this.yaxisIndex], strokeWidth: this.strokeWidth, series: this.series, seriesGroup: l2, realIndex: e2.realIndex, i: d2, j: g2, w: c2 });
        return this.barHelpers.barBackground({ bc: u2, j: g2, i: d2, x1: x2, x2: r2, elSeries: h2 }), i3 += s3, { pathTo: T2.pathTo, pathFrom: T2.pathFrom, goalY: this.barHelpers.getGoalValues("y", null, o2, d2, g2), barXPosition: x2, x: c2.globals.isXNumeric ? i3 - s3 : i3, y: a2 };
      } }]), s2;
    }();
    var kt = function(t2) {
      n(s2, yt);
      var i2 = d(s2);
      function s2() {
        return a(this, s2), i2.apply(this, arguments);
      }
      return r(s2, [{ key: "draw", value: function(t3, i3, a2) {
        var s3 = this, r2 = this.w, o2 = new m(this.ctx), n2 = r2.globals.comboCharts ? i3 : r2.config.chart.type, l2 = new R(this.ctx);
        this.candlestickOptions = this.w.config.plotOptions.candlestick, this.boxOptions = this.w.config.plotOptions.boxPlot, this.isHorizontal = r2.config.plotOptions.bar.horizontal;
        var h2 = new y(this.ctx, r2);
        t3 = h2.getLogSeries(t3), this.series = t3, this.yRatio = h2.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t3);
        for (var c2 = o2.group({ class: "apexcharts-".concat(n2, "-series apexcharts-plot-series") }), d2 = function(i4) {
          s3.isBoxPlot = "boxPlot" === r2.config.chart.type || "boxPlot" === r2.config.series[i4].type;
          var n3, h3, d3, g3, u2 = void 0, p2 = void 0, f2 = [], b2 = [], v2 = r2.globals.comboCharts ? a2[i4] : i4, m2 = o2.group({ class: "apexcharts-series", seriesName: x.escapeString(r2.globals.seriesNames[v2]), rel: i4 + 1, "data:realIndex": v2 });
          s3.ctx.series.addCollapsedClassToSeries(m2, v2), t3[i4].length > 0 && (s3.visibleI = s3.visibleI + 1);
          var y2, w2;
          s3.yRatio.length > 1 && (s3.yaxisIndex = v2);
          var k2 = s3.barHelpers.initialPositions();
          p2 = k2.y, y2 = k2.barHeight, h3 = k2.yDivision, g3 = k2.zeroW, u2 = k2.x, w2 = k2.barWidth, n3 = k2.xDivision, d3 = k2.zeroH, b2.push(u2 + w2 / 2);
          for (var A2 = o2.group({ class: "apexcharts-datalabels", "data:realIndex": v2 }), S2 = function(a3) {
            var o3 = s3.barHelpers.getStrokeWidth(i4, a3, v2), c3 = null, x2 = { indexes: { i: i4, j: a3, realIndex: v2 }, x: u2, y: p2, strokeWidth: o3, elSeries: m2 };
            c3 = s3.isHorizontal ? s3.drawHorizontalBoxPaths(e(e({}, x2), {}, { yDivision: h3, barHeight: y2, zeroW: g3 })) : s3.drawVerticalBoxPaths(e(e({}, x2), {}, { xDivision: n3, barWidth: w2, zeroH: d3 })), p2 = c3.y, u2 = c3.x, a3 > 0 && b2.push(u2 + w2 / 2), f2.push(p2), c3.pathTo.forEach(function(e2, n4) {
              var h4 = !s3.isBoxPlot && s3.candlestickOptions.wick.useFillColor ? c3.color[n4] : r2.globals.stroke.colors[i4], d4 = l2.fillPath({ seriesNumber: v2, dataPointIndex: a3, color: c3.color[n4], value: t3[i4][a3] });
              s3.renderSeries({ realIndex: v2, pathFill: d4, lineFill: h4, j: a3, i: i4, pathFrom: c3.pathFrom, pathTo: e2, strokeWidth: o3, elSeries: m2, x: u2, y: p2, series: t3, barHeight: y2, barWidth: w2, elDataLabelsWrap: A2, visibleSeries: s3.visibleI, type: r2.config.chart.type });
            });
          }, C2 = 0; C2 < r2.globals.dataPoints; C2++)
            S2(C2);
          r2.globals.seriesXvalues[v2] = b2, r2.globals.seriesYvalues[v2] = f2, c2.add(m2);
        }, g2 = 0; g2 < t3.length; g2++)
          d2(g2);
        return c2;
      } }, { key: "drawVerticalBoxPaths", value: function(t3) {
        var e2 = t3.indexes, i3 = t3.x;
        t3.y;
        var a2 = t3.xDivision, s3 = t3.barWidth, r2 = t3.zeroH, o2 = t3.strokeWidth, n2 = this.w, l2 = new m(this.ctx), h2 = e2.i, c2 = e2.j, d2 = true, g2 = n2.config.plotOptions.candlestick.colors.upward, u2 = n2.config.plotOptions.candlestick.colors.downward, p2 = "";
        this.isBoxPlot && (p2 = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
        var f2 = this.yRatio[this.yaxisIndex], x2 = e2.realIndex, b2 = this.getOHLCValue(x2, c2), v2 = r2, y2 = r2;
        b2.o > b2.c && (d2 = false);
        var w2 = Math.min(b2.o, b2.c), k2 = Math.max(b2.o, b2.c), A2 = b2.m;
        n2.globals.isXNumeric && (i3 = (n2.globals.seriesX[x2][c2] - n2.globals.minX) / this.xRatio - s3 / 2);
        var S2 = i3 + s3 * this.visibleI;
        void 0 === this.series[h2][c2] || null === this.series[h2][c2] ? (w2 = r2, k2 = r2) : (w2 = r2 - w2 / f2, k2 = r2 - k2 / f2, v2 = r2 - b2.h / f2, y2 = r2 - b2.l / f2, A2 = r2 - b2.m / f2);
        var C2 = l2.move(S2, r2), L2 = l2.move(S2 + s3 / 2, w2);
        return n2.globals.previousPaths.length > 0 && (L2 = this.getPreviousPath(x2, c2, true)), C2 = this.isBoxPlot ? [l2.move(S2, w2) + l2.line(S2 + s3 / 2, w2) + l2.line(S2 + s3 / 2, v2) + l2.line(S2 + s3 / 4, v2) + l2.line(S2 + s3 - s3 / 4, v2) + l2.line(S2 + s3 / 2, v2) + l2.line(S2 + s3 / 2, w2) + l2.line(S2 + s3, w2) + l2.line(S2 + s3, A2) + l2.line(S2, A2) + l2.line(S2, w2 + o2 / 2), l2.move(S2, A2) + l2.line(S2 + s3, A2) + l2.line(S2 + s3, k2) + l2.line(S2 + s3 / 2, k2) + l2.line(S2 + s3 / 2, y2) + l2.line(S2 + s3 - s3 / 4, y2) + l2.line(S2 + s3 / 4, y2) + l2.line(S2 + s3 / 2, y2) + l2.line(S2 + s3 / 2, k2) + l2.line(S2, k2) + l2.line(S2, A2) + "z"] : [l2.move(S2, k2) + l2.line(S2 + s3 / 2, k2) + l2.line(S2 + s3 / 2, v2) + l2.line(S2 + s3 / 2, k2) + l2.line(S2 + s3, k2) + l2.line(S2 + s3, w2) + l2.line(S2 + s3 / 2, w2) + l2.line(S2 + s3 / 2, y2) + l2.line(S2 + s3 / 2, w2) + l2.line(S2, w2) + l2.line(S2, k2 - o2 / 2)], L2 += l2.move(S2, w2), n2.globals.isXNumeric || (i3 += a2), { pathTo: C2, pathFrom: L2, x: i3, y: k2, barXPosition: S2, color: this.isBoxPlot ? p2 : d2 ? [g2] : [u2] };
      } }, { key: "drawHorizontalBoxPaths", value: function(t3) {
        var e2 = t3.indexes;
        t3.x;
        var i3 = t3.y, a2 = t3.yDivision, s3 = t3.barHeight, r2 = t3.zeroW, o2 = t3.strokeWidth, n2 = this.w, l2 = new m(this.ctx), h2 = e2.i, c2 = e2.j, d2 = this.boxOptions.colors.lower;
        this.isBoxPlot && (d2 = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
        var g2 = this.invertedYRatio, u2 = e2.realIndex, p2 = this.getOHLCValue(u2, c2), f2 = r2, x2 = r2, b2 = Math.min(p2.o, p2.c), v2 = Math.max(p2.o, p2.c), y2 = p2.m;
        n2.globals.isXNumeric && (i3 = (n2.globals.seriesX[u2][c2] - n2.globals.minX) / this.invertedXRatio - s3 / 2);
        var w2 = i3 + s3 * this.visibleI;
        void 0 === this.series[h2][c2] || null === this.series[h2][c2] ? (b2 = r2, v2 = r2) : (b2 = r2 + b2 / g2, v2 = r2 + v2 / g2, f2 = r2 + p2.h / g2, x2 = r2 + p2.l / g2, y2 = r2 + p2.m / g2);
        var k2 = l2.move(r2, w2), A2 = l2.move(b2, w2 + s3 / 2);
        return n2.globals.previousPaths.length > 0 && (A2 = this.getPreviousPath(u2, c2, true)), k2 = [l2.move(b2, w2) + l2.line(b2, w2 + s3 / 2) + l2.line(f2, w2 + s3 / 2) + l2.line(f2, w2 + s3 / 2 - s3 / 4) + l2.line(f2, w2 + s3 / 2 + s3 / 4) + l2.line(f2, w2 + s3 / 2) + l2.line(b2, w2 + s3 / 2) + l2.line(b2, w2 + s3) + l2.line(y2, w2 + s3) + l2.line(y2, w2) + l2.line(b2 + o2 / 2, w2), l2.move(y2, w2) + l2.line(y2, w2 + s3) + l2.line(v2, w2 + s3) + l2.line(v2, w2 + s3 / 2) + l2.line(x2, w2 + s3 / 2) + l2.line(x2, w2 + s3 - s3 / 4) + l2.line(x2, w2 + s3 / 4) + l2.line(x2, w2 + s3 / 2) + l2.line(v2, w2 + s3 / 2) + l2.line(v2, w2) + l2.line(y2, w2) + "z"], A2 += l2.move(b2, w2), n2.globals.isXNumeric || (i3 += a2), { pathTo: k2, pathFrom: A2, x: v2, y: i3, barYPosition: w2, color: d2 };
      } }, { key: "getOHLCValue", value: function(t3, e2) {
        var i3 = this.w;
        return { o: this.isBoxPlot ? i3.globals.seriesCandleH[t3][e2] : i3.globals.seriesCandleO[t3][e2], h: this.isBoxPlot ? i3.globals.seriesCandleO[t3][e2] : i3.globals.seriesCandleH[t3][e2], m: i3.globals.seriesCandleM[t3][e2], l: this.isBoxPlot ? i3.globals.seriesCandleC[t3][e2] : i3.globals.seriesCandleL[t3][e2], c: this.isBoxPlot ? i3.globals.seriesCandleL[t3][e2] : i3.globals.seriesCandleC[t3][e2] };
      } }]), s2;
    }();
    var At = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
      }
      return r(t2, [{ key: "checkColorRange", value: function() {
        var t3 = this.w, e2 = false, i2 = t3.config.plotOptions[t3.config.chart.type];
        return i2.colorScale.ranges.length > 0 && i2.colorScale.ranges.map(function(t4, i3) {
          t4.from <= 0 && (e2 = true);
        }), e2;
      } }, { key: "getShadeColor", value: function(t3, e2, i2, a2) {
        var s2 = this.w, r2 = 1, o2 = s2.config.plotOptions[t3].shadeIntensity, n2 = this.determineColor(t3, e2, i2);
        s2.globals.hasNegs || a2 ? r2 = s2.config.plotOptions[t3].reverseNegativeShade ? n2.percent < 0 ? n2.percent / 100 * (1.25 * o2) : (1 - n2.percent / 100) * (1.25 * o2) : n2.percent <= 0 ? 1 - (1 + n2.percent / 100) * o2 : (1 - n2.percent / 100) * o2 : (r2 = 1 - n2.percent / 100, "treemap" === t3 && (r2 = (1 - n2.percent / 100) * (1.25 * o2)));
        var l2 = n2.color, h2 = new x();
        return s2.config.plotOptions[t3].enableShades && (l2 = "dark" === this.w.config.theme.mode ? x.hexToRgba(h2.shadeColor(-1 * r2, n2.color), s2.config.fill.opacity) : x.hexToRgba(h2.shadeColor(r2, n2.color), s2.config.fill.opacity)), { color: l2, colorProps: n2 };
      } }, { key: "determineColor", value: function(t3, e2, i2) {
        var a2 = this.w, s2 = a2.globals.series[e2][i2], r2 = a2.config.plotOptions[t3], o2 = r2.colorScale.inverse ? i2 : e2;
        r2.distributed && "treemap" === a2.config.chart.type && (o2 = i2);
        var n2 = a2.globals.colors[o2], l2 = null, h2 = Math.min.apply(Math, u(a2.globals.series[e2])), c2 = Math.max.apply(Math, u(a2.globals.series[e2]));
        r2.distributed || "heatmap" !== t3 || (h2 = a2.globals.minY, c2 = a2.globals.maxY), void 0 !== r2.colorScale.min && (h2 = r2.colorScale.min < a2.globals.minY ? r2.colorScale.min : a2.globals.minY, c2 = r2.colorScale.max > a2.globals.maxY ? r2.colorScale.max : a2.globals.maxY);
        var d2 = Math.abs(c2) + Math.abs(h2), g2 = 100 * s2 / (0 === d2 ? d2 - 1e-6 : d2);
        r2.colorScale.ranges.length > 0 && r2.colorScale.ranges.map(function(t4, e3) {
          if (s2 >= t4.from && s2 <= t4.to) {
            n2 = t4.color, l2 = t4.foreColor ? t4.foreColor : null, h2 = t4.from, c2 = t4.to;
            var i3 = Math.abs(c2) + Math.abs(h2);
            g2 = 100 * s2 / (0 === i3 ? i3 - 1e-6 : i3);
          }
        });
        return { color: n2, foreColor: l2, percent: g2 };
      } }, { key: "calculateDataLabels", value: function(t3) {
        var e2 = t3.text, i2 = t3.x, a2 = t3.y, s2 = t3.i, r2 = t3.j, o2 = t3.colorProps, n2 = t3.fontSize, l2 = this.w.config.dataLabels, h2 = new m(this.ctx), c2 = new O(this.ctx), d2 = null;
        if (l2.enabled) {
          d2 = h2.group({ class: "apexcharts-data-labels" });
          var g2 = l2.offsetX, u2 = l2.offsetY, p2 = i2 + g2, f2 = a2 + parseFloat(l2.style.fontSize) / 3 + u2;
          c2.plotDataLabelsText({ x: p2, y: f2, text: e2, i: s2, j: r2, color: o2.foreColor, parent: d2, fontSize: n2, dataLabelsConfig: l2 });
        }
        return d2;
      } }, { key: "addListeners", value: function(t3) {
        var e2 = new m(this.ctx);
        t3.node.addEventListener("mouseenter", e2.pathMouseEnter.bind(this, t3)), t3.node.addEventListener("mouseleave", e2.pathMouseLeave.bind(this, t3)), t3.node.addEventListener("mousedown", e2.pathMouseDown.bind(this, t3));
      } }]), t2;
    }();
    var St = function() {
      function t2(e2, i2) {
        a(this, t2), this.ctx = e2, this.w = e2.w, this.xRatio = i2.xRatio, this.yRatio = i2.yRatio, this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.helpers = new At(e2), this.rectRadius = this.w.config.plotOptions.heatmap.radius, this.strokeWidth = this.w.config.stroke.show ? this.w.config.stroke.width : 0;
      }
      return r(t2, [{ key: "draw", value: function(t3) {
        var e2 = this.w, i2 = new m(this.ctx), a2 = i2.group({ class: "apexcharts-heatmap" });
        a2.attr("clip-path", "url(#gridRectMask".concat(e2.globals.cuid, ")"));
        var s2 = e2.globals.gridWidth / e2.globals.dataPoints, r2 = e2.globals.gridHeight / e2.globals.series.length, o2 = 0, n2 = false;
        this.negRange = this.helpers.checkColorRange();
        var l2 = t3.slice();
        e2.config.yaxis[0].reversed && (n2 = true, l2.reverse());
        for (var h2 = n2 ? 0 : l2.length - 1; n2 ? h2 < l2.length : h2 >= 0; n2 ? h2++ : h2--) {
          var c2 = i2.group({ class: "apexcharts-series apexcharts-heatmap-series", seriesName: x.escapeString(e2.globals.seriesNames[h2]), rel: h2 + 1, "data:realIndex": h2 });
          if (this.ctx.series.addCollapsedClassToSeries(c2, h2), e2.config.chart.dropShadow.enabled) {
            var d2 = e2.config.chart.dropShadow;
            new v(this.ctx).dropShadow(c2, d2, h2);
          }
          for (var g2 = 0, u2 = e2.config.plotOptions.heatmap.shadeIntensity, p2 = 0; p2 < l2[h2].length; p2++) {
            var f2 = this.helpers.getShadeColor(e2.config.chart.type, h2, p2, this.negRange), b2 = f2.color, y2 = f2.colorProps;
            if ("image" === e2.config.fill.type)
              b2 = new R(this.ctx).fillPath({ seriesNumber: h2, dataPointIndex: p2, opacity: e2.globals.hasNegs ? y2.percent < 0 ? 1 - (1 + y2.percent / 100) : u2 + y2.percent / 100 : y2.percent / 100, patternID: x.randomId(), width: e2.config.fill.image.width ? e2.config.fill.image.width : s2, height: e2.config.fill.image.height ? e2.config.fill.image.height : r2 });
            var w2 = this.rectRadius, k2 = i2.drawRect(g2, o2, s2, r2, w2);
            if (k2.attr({ cx: g2, cy: o2 }), k2.node.classList.add("apexcharts-heatmap-rect"), c2.add(k2), k2.attr({ fill: b2, i: h2, index: h2, j: p2, val: l2[h2][p2], "stroke-width": this.strokeWidth, stroke: e2.config.plotOptions.heatmap.useFillColorAsStroke ? b2 : e2.globals.stroke.colors[0], color: b2 }), this.helpers.addListeners(k2), e2.config.chart.animations.enabled && !e2.globals.dataChanged) {
              var A2 = 1;
              e2.globals.resized || (A2 = e2.config.chart.animations.speed), this.animateHeatMap(k2, g2, o2, s2, r2, A2);
            }
            if (e2.globals.dataChanged) {
              var S2 = 1;
              if (this.dynamicAnim.enabled && e2.globals.shouldAnimate) {
                S2 = this.dynamicAnim.speed;
                var C2 = e2.globals.previousPaths[h2] && e2.globals.previousPaths[h2][p2] && e2.globals.previousPaths[h2][p2].color;
                C2 || (C2 = "rgba(255, 255, 255, 0)"), this.animateHeatColor(k2, x.isColorHex(C2) ? C2 : x.rgb2hex(C2), x.isColorHex(b2) ? b2 : x.rgb2hex(b2), S2);
              }
            }
            var L2 = (0, e2.config.dataLabels.formatter)(e2.globals.series[h2][p2], { value: e2.globals.series[h2][p2], seriesIndex: h2, dataPointIndex: p2, w: e2 }), P2 = this.helpers.calculateDataLabels({ text: L2, x: g2 + s2 / 2, y: o2 + r2 / 2, i: h2, j: p2, colorProps: y2, series: l2 });
            null !== P2 && c2.add(P2), g2 += s2;
          }
          o2 += r2, a2.add(c2);
        }
        var I2 = e2.globals.yAxisScale[0].result.slice();
        return e2.config.yaxis[0].reversed ? I2.unshift("") : I2.push(""), e2.globals.yAxisScale[0].result = I2, a2;
      } }, { key: "animateHeatMap", value: function(t3, e2, i2, a2, s2, r2) {
        var o2 = new b(this.ctx);
        o2.animateRect(t3, { x: e2 + a2 / 2, y: i2 + s2 / 2, width: 0, height: 0 }, { x: e2, y: i2, width: a2, height: s2 }, r2, function() {
          o2.animationCompleted(t3);
        });
      } }, { key: "animateHeatColor", value: function(t3, e2, i2, a2) {
        t3.attr({ fill: e2 }).animate(a2).attr({ fill: i2 });
      } }]), t2;
    }();
    var Ct = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
      }
      return r(t2, [{ key: "drawYAxisTexts", value: function(t3, e2, i2, a2) {
        var s2 = this.w, r2 = s2.config.yaxis[0], o2 = s2.globals.yLabelFormatters[0];
        return new m(this.ctx).drawText({ x: t3 + r2.labels.offsetX, y: e2 + r2.labels.offsetY, text: o2(a2, i2), textAnchor: "middle", fontSize: r2.labels.style.fontSize, fontFamily: r2.labels.style.fontFamily, foreColor: Array.isArray(r2.labels.style.colors) ? r2.labels.style.colors[i2] : r2.labels.style.colors });
      } }]), t2;
    }();
    var Lt = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
        var i2 = this.w;
        this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animBeginArr = [0], this.animDur = 0, this.donutDataLabels = this.w.config.plotOptions.pie.donut.labels, this.lineColorArr = void 0 !== i2.globals.stroke.colors ? i2.globals.stroke.colors : i2.globals.colors, this.defaultSize = Math.min(i2.globals.gridWidth, i2.globals.gridHeight), this.centerY = this.defaultSize / 2, this.centerX = i2.globals.gridWidth / 2, "radialBar" === i2.config.chart.type ? this.fullAngle = 360 : this.fullAngle = Math.abs(i2.config.plotOptions.pie.endAngle - i2.config.plotOptions.pie.startAngle), this.initialAngle = i2.config.plotOptions.pie.startAngle % this.fullAngle, i2.globals.radialSize = this.defaultSize / 2.05 - i2.config.stroke.width - (i2.config.chart.sparkline.enabled ? 0 : i2.config.chart.dropShadow.blur), this.donutSize = i2.globals.radialSize * parseInt(i2.config.plotOptions.pie.donut.size, 10) / 100, this.maxY = 0, this.sliceLabels = [], this.sliceSizes = [], this.prevSectorAngleArr = [];
      }
      return r(t2, [{ key: "draw", value: function(t3) {
        var e2 = this, i2 = this.w, a2 = new m(this.ctx);
        if (this.ret = a2.group({ class: "apexcharts-pie" }), i2.globals.noData)
          return this.ret;
        for (var s2 = 0, r2 = 0; r2 < t3.length; r2++)
          s2 += x.negToZero(t3[r2]);
        var o2 = [], n2 = a2.group();
        0 === s2 && (s2 = 1e-5), t3.forEach(function(t4) {
          e2.maxY = Math.max(e2.maxY, t4);
        }), i2.config.yaxis[0].max && (this.maxY = i2.config.yaxis[0].max), "back" === i2.config.grid.position && "polarArea" === this.chartType && this.drawPolarElements(this.ret);
        for (var l2 = 0; l2 < t3.length; l2++) {
          var h2 = this.fullAngle * x.negToZero(t3[l2]) / s2;
          o2.push(h2), "polarArea" === this.chartType ? (o2[l2] = this.fullAngle / t3.length, this.sliceSizes.push(i2.globals.radialSize * t3[l2] / this.maxY)) : this.sliceSizes.push(i2.globals.radialSize);
        }
        if (i2.globals.dataChanged) {
          for (var c2, d2 = 0, g2 = 0; g2 < i2.globals.previousPaths.length; g2++)
            d2 += x.negToZero(i2.globals.previousPaths[g2]);
          for (var u2 = 0; u2 < i2.globals.previousPaths.length; u2++)
            c2 = this.fullAngle * x.negToZero(i2.globals.previousPaths[u2]) / d2, this.prevSectorAngleArr.push(c2);
        }
        this.donutSize < 0 && (this.donutSize = 0);
        var p2 = i2.config.plotOptions.pie.customScale, f2 = i2.globals.gridWidth / 2, b2 = i2.globals.gridHeight / 2, v2 = f2 - i2.globals.gridWidth / 2 * p2, y2 = b2 - i2.globals.gridHeight / 2 * p2;
        if ("donut" === this.chartType) {
          var w2 = a2.drawCircle(this.donutSize);
          w2.attr({ cx: this.centerX, cy: this.centerY, fill: i2.config.plotOptions.pie.donut.background ? i2.config.plotOptions.pie.donut.background : "transparent" }), n2.add(w2);
        }
        var k2 = this.drawArcs(o2, t3);
        if (this.sliceLabels.forEach(function(t4) {
          k2.add(t4);
        }), n2.attr({ transform: "translate(".concat(v2, ", ").concat(y2, ") scale(").concat(p2, ")") }), n2.add(k2), this.ret.add(n2), this.donutDataLabels.show) {
          var A2 = this.renderInnerDataLabels(this.donutDataLabels, { hollowSize: this.donutSize, centerX: this.centerX, centerY: this.centerY, opacity: this.donutDataLabels.show, translateX: v2, translateY: y2 });
          this.ret.add(A2);
        }
        return "front" === i2.config.grid.position && "polarArea" === this.chartType && this.drawPolarElements(this.ret), this.ret;
      } }, { key: "drawArcs", value: function(t3, e2) {
        var i2 = this.w, a2 = new v(this.ctx), s2 = new m(this.ctx), r2 = new R(this.ctx), o2 = s2.group({ class: "apexcharts-slices" }), n2 = this.initialAngle, l2 = this.initialAngle, h2 = this.initialAngle, c2 = this.initialAngle;
        this.strokeWidth = i2.config.stroke.show ? i2.config.stroke.width : 0;
        for (var d2 = 0; d2 < t3.length; d2++) {
          var g2 = s2.group({ class: "apexcharts-series apexcharts-pie-series", seriesName: x.escapeString(i2.globals.seriesNames[d2]), rel: d2 + 1, "data:realIndex": d2 });
          o2.add(g2), l2 = c2, h2 = (n2 = h2) + t3[d2], c2 = l2 + this.prevSectorAngleArr[d2];
          var u2 = h2 < n2 ? this.fullAngle + h2 - n2 : h2 - n2, p2 = r2.fillPath({ seriesNumber: d2, size: this.sliceSizes[d2], value: e2[d2] }), f2 = this.getChangedPath(l2, c2), b2 = s2.drawPath({ d: f2, stroke: Array.isArray(this.lineColorArr) ? this.lineColorArr[d2] : this.lineColorArr, strokeWidth: 0, fill: p2, fillOpacity: i2.config.fill.opacity, classes: "apexcharts-pie-area apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(d2) });
          if (b2.attr({ index: 0, j: d2 }), a2.setSelectionFilter(b2, 0, d2), i2.config.chart.dropShadow.enabled) {
            var y2 = i2.config.chart.dropShadow;
            a2.dropShadow(b2, y2, d2);
          }
          this.addListeners(b2, this.donutDataLabels), m.setAttrs(b2.node, { "data:angle": u2, "data:startAngle": n2, "data:strokeWidth": this.strokeWidth, "data:value": e2[d2] });
          var w2 = { x: 0, y: 0 };
          "pie" === this.chartType || "polarArea" === this.chartType ? w2 = x.polarToCartesian(this.centerX, this.centerY, i2.globals.radialSize / 1.25 + i2.config.plotOptions.pie.dataLabels.offset, (n2 + u2 / 2) % this.fullAngle) : "donut" === this.chartType && (w2 = x.polarToCartesian(this.centerX, this.centerY, (i2.globals.radialSize + this.donutSize) / 2 + i2.config.plotOptions.pie.dataLabels.offset, (n2 + u2 / 2) % this.fullAngle)), g2.add(b2);
          var k2 = 0;
          if (!this.initialAnim || i2.globals.resized || i2.globals.dataChanged ? this.animBeginArr.push(0) : (0 === (k2 = u2 / this.fullAngle * i2.config.chart.animations.speed) && (k2 = 1), this.animDur = k2 + this.animDur, this.animBeginArr.push(this.animDur)), this.dynamicAnim && i2.globals.dataChanged ? this.animatePaths(b2, { size: this.sliceSizes[d2], endAngle: h2, startAngle: n2, prevStartAngle: l2, prevEndAngle: c2, animateStartingPos: true, i: d2, animBeginArr: this.animBeginArr, shouldSetPrevPaths: true, dur: i2.config.chart.animations.dynamicAnimation.speed }) : this.animatePaths(b2, { size: this.sliceSizes[d2], endAngle: h2, startAngle: n2, i: d2, totalItems: t3.length - 1, animBeginArr: this.animBeginArr, dur: k2 }), i2.config.plotOptions.pie.expandOnClick && "polarArea" !== this.chartType && b2.click(this.pieClicked.bind(this, d2)), void 0 !== i2.globals.selectedDataPoints[0] && i2.globals.selectedDataPoints[0].indexOf(d2) > -1 && this.pieClicked(d2), i2.config.dataLabels.enabled) {
            var A2 = w2.x, S2 = w2.y, C2 = 100 * u2 / this.fullAngle + "%";
            if (0 !== u2 && i2.config.plotOptions.pie.dataLabels.minAngleToShowLabel < t3[d2]) {
              var L2 = i2.config.dataLabels.formatter;
              void 0 !== L2 && (C2 = L2(i2.globals.seriesPercent[d2][0], { seriesIndex: d2, w: i2 }));
              var P2 = i2.globals.dataLabels.style.colors[d2], I2 = s2.group({ class: "apexcharts-datalabels" }), T2 = s2.drawText({ x: A2, y: S2, text: C2, textAnchor: "middle", fontSize: i2.config.dataLabels.style.fontSize, fontFamily: i2.config.dataLabels.style.fontFamily, fontWeight: i2.config.dataLabels.style.fontWeight, foreColor: P2 });
              if (I2.add(T2), i2.config.dataLabels.dropShadow.enabled) {
                var M2 = i2.config.dataLabels.dropShadow;
                a2.dropShadow(T2, M2);
              }
              T2.node.classList.add("apexcharts-pie-label"), i2.config.chart.animations.animate && false === i2.globals.resized && (T2.node.classList.add("apexcharts-pie-label-delay"), T2.node.style.animationDelay = i2.config.chart.animations.speed / 940 + "s"), this.sliceLabels.push(I2);
            }
          }
        }
        return o2;
      } }, { key: "addListeners", value: function(t3, e2) {
        var i2 = new m(this.ctx);
        t3.node.addEventListener("mouseenter", i2.pathMouseEnter.bind(this, t3)), t3.node.addEventListener("mouseleave", i2.pathMouseLeave.bind(this, t3)), t3.node.addEventListener("mouseleave", this.revertDataLabelsInner.bind(this, t3.node, e2)), t3.node.addEventListener("mousedown", i2.pathMouseDown.bind(this, t3)), this.donutDataLabels.total.showAlways || (t3.node.addEventListener("mouseenter", this.printDataLabelsInner.bind(this, t3.node, e2)), t3.node.addEventListener("mousedown", this.printDataLabelsInner.bind(this, t3.node, e2)));
      } }, { key: "animatePaths", value: function(t3, e2) {
        var i2 = this.w, a2 = e2.endAngle < e2.startAngle ? this.fullAngle + e2.endAngle - e2.startAngle : e2.endAngle - e2.startAngle, s2 = a2, r2 = e2.startAngle, o2 = e2.startAngle;
        void 0 !== e2.prevStartAngle && void 0 !== e2.prevEndAngle && (r2 = e2.prevEndAngle, s2 = e2.prevEndAngle < e2.prevStartAngle ? this.fullAngle + e2.prevEndAngle - e2.prevStartAngle : e2.prevEndAngle - e2.prevStartAngle), e2.i === i2.config.series.length - 1 && (a2 + o2 > this.fullAngle ? e2.endAngle = e2.endAngle - (a2 + o2) : a2 + o2 < this.fullAngle && (e2.endAngle = e2.endAngle + (this.fullAngle - (a2 + o2)))), a2 === this.fullAngle && (a2 = this.fullAngle - 0.01), this.animateArc(t3, r2, o2, a2, s2, e2);
      } }, { key: "animateArc", value: function(t3, e2, i2, a2, s2, r2) {
        var o2, n2 = this, l2 = this.w, h2 = new b(this.ctx), c2 = r2.size;
        (isNaN(e2) || isNaN(s2)) && (e2 = i2, s2 = a2, r2.dur = 0);
        var d2 = a2, g2 = i2, u2 = e2 < i2 ? this.fullAngle + e2 - i2 : e2 - i2;
        l2.globals.dataChanged && r2.shouldSetPrevPaths && r2.prevEndAngle && (o2 = n2.getPiePath({ me: n2, startAngle: r2.prevStartAngle, angle: r2.prevEndAngle < r2.prevStartAngle ? this.fullAngle + r2.prevEndAngle - r2.prevStartAngle : r2.prevEndAngle - r2.prevStartAngle, size: c2 }), t3.attr({ d: o2 })), 0 !== r2.dur ? t3.animate(r2.dur, l2.globals.easing, r2.animBeginArr[r2.i]).afterAll(function() {
          "pie" !== n2.chartType && "donut" !== n2.chartType && "polarArea" !== n2.chartType || this.animate(l2.config.chart.animations.dynamicAnimation.speed).attr({ "stroke-width": n2.strokeWidth }), r2.i === l2.config.series.length - 1 && h2.animationCompleted(t3);
        }).during(function(l3) {
          d2 = u2 + (a2 - u2) * l3, r2.animateStartingPos && (d2 = s2 + (a2 - s2) * l3, g2 = e2 - s2 + (i2 - (e2 - s2)) * l3), o2 = n2.getPiePath({ me: n2, startAngle: g2, angle: d2, size: c2 }), t3.node.setAttribute("data:pathOrig", o2), t3.attr({ d: o2 });
        }) : (o2 = n2.getPiePath({ me: n2, startAngle: g2, angle: a2, size: c2 }), r2.isTrack || (l2.globals.animationEnded = true), t3.node.setAttribute("data:pathOrig", o2), t3.attr({ d: o2, "stroke-width": n2.strokeWidth }));
      } }, { key: "pieClicked", value: function(t3) {
        var e2, i2 = this.w, a2 = this, s2 = a2.sliceSizes[t3] + (i2.config.plotOptions.pie.expandOnClick ? 4 : 0), r2 = i2.globals.dom.Paper.select(".apexcharts-".concat(a2.chartType.toLowerCase(), "-slice-").concat(t3)).members[0];
        if ("true" !== r2.attr("data:pieClicked")) {
          var o2 = i2.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area");
          Array.prototype.forEach.call(o2, function(t4) {
            t4.setAttribute("data:pieClicked", "false");
            var e3 = t4.getAttribute("data:pathOrig");
            e3 && t4.setAttribute("d", e3);
          }), r2.attr("data:pieClicked", "true");
          var n2 = parseInt(r2.attr("data:startAngle"), 10), l2 = parseInt(r2.attr("data:angle"), 10);
          e2 = a2.getPiePath({ me: a2, startAngle: n2, angle: l2, size: s2 }), 360 !== l2 && r2.plot(e2);
        } else {
          r2.attr({ "data:pieClicked": "false" }), this.revertDataLabelsInner(r2.node, this.donutDataLabels);
          var h2 = r2.attr("data:pathOrig");
          r2.attr({ d: h2 });
        }
      } }, { key: "getChangedPath", value: function(t3, e2) {
        var i2 = "";
        return this.dynamicAnim && this.w.globals.dataChanged && (i2 = this.getPiePath({ me: this, startAngle: t3, angle: e2 - t3, size: this.size })), i2;
      } }, { key: "getPiePath", value: function(t3) {
        var e2 = t3.me, i2 = t3.startAngle, a2 = t3.angle, s2 = t3.size, r2 = i2, o2 = Math.PI * (r2 - 90) / 180, n2 = a2 + i2;
        Math.ceil(n2) >= this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle && (n2 = this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle - 0.01), Math.ceil(n2) > this.fullAngle && (n2 -= this.fullAngle);
        var l2 = Math.PI * (n2 - 90) / 180, h2 = e2.centerX + s2 * Math.cos(o2), c2 = e2.centerY + s2 * Math.sin(o2), d2 = e2.centerX + s2 * Math.cos(l2), g2 = e2.centerY + s2 * Math.sin(l2), u2 = x.polarToCartesian(e2.centerX, e2.centerY, e2.donutSize, n2), p2 = x.polarToCartesian(e2.centerX, e2.centerY, e2.donutSize, r2), f2 = a2 > 180 ? 1 : 0, b2 = ["M", h2, c2, "A", s2, s2, 0, f2, 1, d2, g2];
        return "donut" === e2.chartType ? [].concat(b2, ["L", u2.x, u2.y, "A", e2.donutSize, e2.donutSize, 0, f2, 0, p2.x, p2.y, "L", h2, c2, "z"]).join(" ") : "pie" === e2.chartType || "polarArea" === e2.chartType ? [].concat(b2, ["L", e2.centerX, e2.centerY, "L", h2, c2]).join(" ") : [].concat(b2).join(" ");
      } }, { key: "drawPolarElements", value: function(t3) {
        var e2 = this.w, i2 = new _(this.ctx), a2 = new m(this.ctx), s2 = new Ct(this.ctx), r2 = a2.group(), o2 = a2.group(), n2 = i2.niceScale(0, Math.ceil(this.maxY), e2.config.yaxis[0].tickAmount, 0, true), l2 = n2.result.reverse(), h2 = n2.result.length;
        this.maxY = n2.niceMax;
        for (var c2 = e2.globals.radialSize, d2 = c2 / (h2 - 1), g2 = 0; g2 < h2 - 1; g2++) {
          var u2 = a2.drawCircle(c2);
          if (u2.attr({ cx: this.centerX, cy: this.centerY, fill: "none", "stroke-width": e2.config.plotOptions.polarArea.rings.strokeWidth, stroke: e2.config.plotOptions.polarArea.rings.strokeColor }), e2.config.yaxis[0].show) {
            var p2 = s2.drawYAxisTexts(this.centerX, this.centerY - c2 + parseInt(e2.config.yaxis[0].labels.style.fontSize, 10) / 2, g2, l2[g2]);
            o2.add(p2);
          }
          r2.add(u2), c2 -= d2;
        }
        this.drawSpokes(t3), t3.add(r2), t3.add(o2);
      } }, { key: "renderInnerDataLabels", value: function(t3, e2) {
        var i2 = this.w, a2 = new m(this.ctx), s2 = a2.group({ class: "apexcharts-datalabels-group", transform: "translate(".concat(e2.translateX ? e2.translateX : 0, ", ").concat(e2.translateY ? e2.translateY : 0, ") scale(").concat(i2.config.plotOptions.pie.customScale, ")") }), r2 = t3.total.show;
        s2.node.style.opacity = e2.opacity;
        var o2, n2, l2 = e2.centerX, h2 = e2.centerY;
        o2 = void 0 === t3.name.color ? i2.globals.colors[0] : t3.name.color;
        var c2 = t3.name.fontSize, d2 = t3.name.fontFamily, g2 = t3.name.fontWeight;
        n2 = void 0 === t3.value.color ? i2.config.chart.foreColor : t3.value.color;
        var u2 = t3.value.formatter, p2 = "", f2 = "";
        if (r2 ? (o2 = t3.total.color, c2 = t3.total.fontSize, d2 = t3.total.fontFamily, g2 = t3.total.fontWeight, f2 = t3.total.label, p2 = t3.total.formatter(i2)) : 1 === i2.globals.series.length && (p2 = u2(i2.globals.series[0], i2), f2 = i2.globals.seriesNames[0]), f2 && (f2 = t3.name.formatter(f2, t3.total.show, i2)), t3.name.show) {
          var x2 = a2.drawText({ x: l2, y: h2 + parseFloat(t3.name.offsetY), text: f2, textAnchor: "middle", foreColor: o2, fontSize: c2, fontWeight: g2, fontFamily: d2 });
          x2.node.classList.add("apexcharts-datalabel-label"), s2.add(x2);
        }
        if (t3.value.show) {
          var b2 = t3.name.show ? parseFloat(t3.value.offsetY) + 16 : t3.value.offsetY, v2 = a2.drawText({ x: l2, y: h2 + b2, text: p2, textAnchor: "middle", foreColor: n2, fontWeight: t3.value.fontWeight, fontSize: t3.value.fontSize, fontFamily: t3.value.fontFamily });
          v2.node.classList.add("apexcharts-datalabel-value"), s2.add(v2);
        }
        return s2;
      } }, { key: "printInnerLabels", value: function(t3, e2, i2, a2) {
        var s2, r2 = this.w;
        a2 ? s2 = void 0 === t3.name.color ? r2.globals.colors[parseInt(a2.parentNode.getAttribute("rel"), 10) - 1] : t3.name.color : r2.globals.series.length > 1 && t3.total.show && (s2 = t3.total.color);
        var o2 = r2.globals.dom.baseEl.querySelector(".apexcharts-datalabel-label"), n2 = r2.globals.dom.baseEl.querySelector(".apexcharts-datalabel-value");
        i2 = (0, t3.value.formatter)(i2, r2), a2 || "function" != typeof t3.total.formatter || (i2 = t3.total.formatter(r2));
        var l2 = e2 === t3.total.label;
        e2 = t3.name.formatter(e2, l2, r2), null !== o2 && (o2.textContent = e2), null !== n2 && (n2.textContent = i2), null !== o2 && (o2.style.fill = s2);
      } }, { key: "printDataLabelsInner", value: function(t3, e2) {
        var i2 = this.w, a2 = t3.getAttribute("data:value"), s2 = i2.globals.seriesNames[parseInt(t3.parentNode.getAttribute("rel"), 10) - 1];
        i2.globals.series.length > 1 && this.printInnerLabels(e2, s2, a2, t3);
        var r2 = i2.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group");
        null !== r2 && (r2.style.opacity = 1);
      } }, { key: "drawSpokes", value: function(t3) {
        var e2 = this, i2 = this.w, a2 = new m(this.ctx), s2 = i2.config.plotOptions.polarArea.spokes;
        if (0 !== s2.strokeWidth) {
          for (var r2 = [], o2 = 360 / i2.globals.series.length, n2 = 0; n2 < i2.globals.series.length; n2++)
            r2.push(x.polarToCartesian(this.centerX, this.centerY, i2.globals.radialSize, i2.config.plotOptions.pie.startAngle + o2 * n2));
          r2.forEach(function(i3, r3) {
            var o3 = a2.drawLine(i3.x, i3.y, e2.centerX, e2.centerY, Array.isArray(s2.connectorColors) ? s2.connectorColors[r3] : s2.connectorColors);
            t3.add(o3);
          });
        }
      } }, { key: "revertDataLabelsInner", value: function(t3, e2, i2) {
        var a2 = this, s2 = this.w, r2 = s2.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group"), o2 = false, n2 = s2.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area"), l2 = function(t4) {
          var i3 = t4.makeSliceOut, s3 = t4.printLabel;
          Array.prototype.forEach.call(n2, function(t5) {
            "true" === t5.getAttribute("data:pieClicked") && (i3 && (o2 = true), s3 && a2.printDataLabelsInner(t5, e2));
          });
        };
        if (l2({ makeSliceOut: true, printLabel: false }), e2.total.show && s2.globals.series.length > 1)
          o2 && !e2.total.showAlways ? l2({ makeSliceOut: false, printLabel: true }) : this.printInnerLabels(e2, e2.total.label, e2.total.formatter(s2));
        else if (l2({ makeSliceOut: false, printLabel: true }), !o2)
          if (s2.globals.selectedDataPoints.length && s2.globals.series.length > 1)
            if (s2.globals.selectedDataPoints[0].length > 0) {
              var h2 = s2.globals.selectedDataPoints[0], c2 = s2.globals.dom.baseEl.querySelector(".apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(h2));
              this.printDataLabelsInner(c2, e2);
            } else
              r2 && s2.globals.selectedDataPoints.length && 0 === s2.globals.selectedDataPoints[0].length && (r2.style.opacity = 0);
          else
            r2 && s2.globals.series.length > 1 && (r2.style.opacity = 0);
      } }]), t2;
    }();
    var Pt = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w, this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animDur = 0;
        var i2 = this.w;
        this.graphics = new m(this.ctx), this.lineColorArr = void 0 !== i2.globals.stroke.colors ? i2.globals.stroke.colors : i2.globals.colors, this.defaultSize = i2.globals.svgHeight < i2.globals.svgWidth ? i2.globals.gridHeight + 1.5 * i2.globals.goldenPadding : i2.globals.gridWidth, this.isLog = i2.config.yaxis[0].logarithmic, this.coreUtils = new y(this.ctx), this.maxValue = this.isLog ? this.coreUtils.getLogVal(i2.globals.maxY, 0) : i2.globals.maxY, this.minValue = this.isLog ? this.coreUtils.getLogVal(this.w.globals.minY, 0) : i2.globals.minY, this.polygons = i2.config.plotOptions.radar.polygons, this.strokeWidth = i2.config.stroke.show ? i2.config.stroke.width : 0, this.size = this.defaultSize / 2.1 - this.strokeWidth - i2.config.chart.dropShadow.blur, i2.config.xaxis.labels.show && (this.size = this.size - i2.globals.xAxisLabelsWidth / 1.75), void 0 !== i2.config.plotOptions.radar.size && (this.size = i2.config.plotOptions.radar.size), this.dataRadiusOfPercent = [], this.dataRadius = [], this.angleArr = [], this.yaxisLabelsTextsPos = [];
      }
      return r(t2, [{ key: "draw", value: function(t3) {
        var i2 = this, a2 = this.w, s2 = new R(this.ctx), r2 = [], o2 = new O(this.ctx);
        t3.length && (this.dataPointsLen = t3[a2.globals.maxValsInArrayIndex].length), this.disAngle = 2 * Math.PI / this.dataPointsLen;
        var n2 = a2.globals.gridWidth / 2, l2 = a2.globals.gridHeight / 2, h2 = n2 + a2.config.plotOptions.radar.offsetX, c2 = l2 + a2.config.plotOptions.radar.offsetY, d2 = this.graphics.group({ class: "apexcharts-radar-series apexcharts-plot-series", transform: "translate(".concat(h2 || 0, ", ").concat(c2 || 0, ")") }), g2 = [], u2 = null, p2 = null;
        if (this.yaxisLabels = this.graphics.group({ class: "apexcharts-yaxis" }), t3.forEach(function(t4, n3) {
          var l3 = t4.length === a2.globals.dataPoints, h3 = i2.graphics.group().attr({ class: "apexcharts-series", "data:longestSeries": l3, seriesName: x.escapeString(a2.globals.seriesNames[n3]), rel: n3 + 1, "data:realIndex": n3 });
          i2.dataRadiusOfPercent[n3] = [], i2.dataRadius[n3] = [], i2.angleArr[n3] = [], t4.forEach(function(t5, e2) {
            var a3 = Math.abs(i2.maxValue - i2.minValue);
            t5 += Math.abs(i2.minValue), i2.isLog && (t5 = i2.coreUtils.getLogVal(t5, 0)), i2.dataRadiusOfPercent[n3][e2] = t5 / a3, i2.dataRadius[n3][e2] = i2.dataRadiusOfPercent[n3][e2] * i2.size, i2.angleArr[n3][e2] = e2 * i2.disAngle;
          }), g2 = i2.getDataPointsPos(i2.dataRadius[n3], i2.angleArr[n3]);
          var c3 = i2.createPaths(g2, { x: 0, y: 0 });
          u2 = i2.graphics.group({ class: "apexcharts-series-markers-wrap apexcharts-element-hidden" }), p2 = i2.graphics.group({ class: "apexcharts-datalabels", "data:realIndex": n3 }), a2.globals.delayedElements.push({ el: u2.node, index: n3 });
          var d3 = { i: n3, realIndex: n3, animationDelay: n3, initialSpeed: a2.config.chart.animations.speed, dataChangeSpeed: a2.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-radar", shouldClipToGrid: false, bindEventsOnPaths: false, stroke: a2.globals.stroke.colors[n3], strokeLineCap: a2.config.stroke.lineCap }, f3 = null;
          a2.globals.previousPaths.length > 0 && (f3 = i2.getPreviousPath(n3));
          for (var b2 = 0; b2 < c3.linePathsTo.length; b2++) {
            var m2 = i2.graphics.renderPaths(e(e({}, d3), {}, { pathFrom: null === f3 ? c3.linePathsFrom[b2] : f3, pathTo: c3.linePathsTo[b2], strokeWidth: Array.isArray(i2.strokeWidth) ? i2.strokeWidth[n3] : i2.strokeWidth, fill: "none", drawShadow: false }));
            h3.add(m2);
            var y2 = s2.fillPath({ seriesNumber: n3 }), w2 = i2.graphics.renderPaths(e(e({}, d3), {}, { pathFrom: null === f3 ? c3.areaPathsFrom[b2] : f3, pathTo: c3.areaPathsTo[b2], strokeWidth: 0, fill: y2, drawShadow: false }));
            if (a2.config.chart.dropShadow.enabled) {
              var k2 = new v(i2.ctx), A2 = a2.config.chart.dropShadow;
              k2.dropShadow(w2, Object.assign({}, A2, { noUserSpaceOnUse: true }), n3);
            }
            h3.add(w2);
          }
          t4.forEach(function(t5, s3) {
            var r3 = new H(i2.ctx).getMarkerConfig({ cssClass: "apexcharts-marker", seriesIndex: n3, dataPointIndex: s3 }), l4 = i2.graphics.drawMarker(g2[s3].x, g2[s3].y, r3);
            l4.attr("rel", s3), l4.attr("j", s3), l4.attr("index", n3), l4.node.setAttribute("default-marker-size", r3.pSize);
            var c4 = i2.graphics.group({ class: "apexcharts-series-markers" });
            c4 && c4.add(l4), u2.add(c4), h3.add(u2);
            var d4 = a2.config.dataLabels;
            if (d4.enabled) {
              var f4 = d4.formatter(a2.globals.series[n3][s3], { seriesIndex: n3, dataPointIndex: s3, w: a2 });
              o2.plotDataLabelsText({ x: g2[s3].x, y: g2[s3].y, text: f4, textAnchor: "middle", i: n3, j: n3, parent: p2, offsetCorrection: false, dataLabelsConfig: e({}, d4) });
            }
            h3.add(p2);
          }), r2.push(h3);
        }), this.drawPolygons({ parent: d2 }), a2.config.xaxis.labels.show) {
          var f2 = this.drawXAxisTexts();
          d2.add(f2);
        }
        return r2.forEach(function(t4) {
          d2.add(t4);
        }), d2.add(this.yaxisLabels), d2;
      } }, { key: "drawPolygons", value: function(t3) {
        for (var e2 = this, i2 = this.w, a2 = t3.parent, s2 = new Ct(this.ctx), r2 = i2.globals.yAxisScale[0].result.reverse(), o2 = r2.length, n2 = [], l2 = this.size / (o2 - 1), h2 = 0; h2 < o2; h2++)
          n2[h2] = l2 * h2;
        n2.reverse();
        var c2 = [], d2 = [];
        n2.forEach(function(t4, i3) {
          var a3 = x.getPolygonPos(t4, e2.dataPointsLen), s3 = "";
          a3.forEach(function(t5, a4) {
            if (0 === i3) {
              var r3 = e2.graphics.drawLine(t5.x, t5.y, 0, 0, Array.isArray(e2.polygons.connectorColors) ? e2.polygons.connectorColors[a4] : e2.polygons.connectorColors);
              d2.push(r3);
            }
            0 === a4 && e2.yaxisLabelsTextsPos.push({ x: t5.x, y: t5.y }), s3 += t5.x + "," + t5.y + " ";
          }), c2.push(s3);
        }), c2.forEach(function(t4, s3) {
          var r3 = e2.polygons.strokeColors, o3 = e2.polygons.strokeWidth, n3 = e2.graphics.drawPolygon(t4, Array.isArray(r3) ? r3[s3] : r3, Array.isArray(o3) ? o3[s3] : o3, i2.globals.radarPolygons.fill.colors[s3]);
          a2.add(n3);
        }), d2.forEach(function(t4) {
          a2.add(t4);
        }), i2.config.yaxis[0].show && this.yaxisLabelsTextsPos.forEach(function(t4, i3) {
          var a3 = s2.drawYAxisTexts(t4.x, t4.y, i3, r2[i3]);
          e2.yaxisLabels.add(a3);
        });
      } }, { key: "drawXAxisTexts", value: function() {
        var t3 = this, i2 = this.w, a2 = i2.config.xaxis.labels, s2 = this.graphics.group({ class: "apexcharts-xaxis" }), r2 = x.getPolygonPos(this.size, this.dataPointsLen);
        return i2.globals.labels.forEach(function(o2, n2) {
          var l2 = i2.config.xaxis.labels.formatter, h2 = new O(t3.ctx);
          if (r2[n2]) {
            var c2 = t3.getTextPos(r2[n2], t3.size), d2 = l2(o2, { seriesIndex: -1, dataPointIndex: n2, w: i2 });
            h2.plotDataLabelsText({ x: c2.newX, y: c2.newY, text: d2, textAnchor: c2.textAnchor, i: n2, j: n2, parent: s2, color: Array.isArray(a2.style.colors) && a2.style.colors[n2] ? a2.style.colors[n2] : "#a8a8a8", dataLabelsConfig: e({ textAnchor: c2.textAnchor, dropShadow: { enabled: false } }, a2), offsetCorrection: false });
          }
        }), s2;
      } }, { key: "createPaths", value: function(t3, e2) {
        var i2 = this, a2 = [], s2 = [], r2 = [], o2 = [];
        if (t3.length) {
          s2 = [this.graphics.move(e2.x, e2.y)], o2 = [this.graphics.move(e2.x, e2.y)];
          var n2 = this.graphics.move(t3[0].x, t3[0].y), l2 = this.graphics.move(t3[0].x, t3[0].y);
          t3.forEach(function(e3, a3) {
            n2 += i2.graphics.line(e3.x, e3.y), l2 += i2.graphics.line(e3.x, e3.y), a3 === t3.length - 1 && (n2 += "Z", l2 += "Z");
          }), a2.push(n2), r2.push(l2);
        }
        return { linePathsFrom: s2, linePathsTo: a2, areaPathsFrom: o2, areaPathsTo: r2 };
      } }, { key: "getTextPos", value: function(t3, e2) {
        var i2 = "middle", a2 = t3.x, s2 = t3.y;
        return Math.abs(t3.x) >= 10 ? t3.x > 0 ? (i2 = "start", a2 += 10) : t3.x < 0 && (i2 = "end", a2 -= 10) : i2 = "middle", Math.abs(t3.y) >= e2 - 10 && (t3.y < 0 ? s2 -= 10 : t3.y > 0 && (s2 += 10)), { textAnchor: i2, newX: a2, newY: s2 };
      } }, { key: "getPreviousPath", value: function(t3) {
        for (var e2 = this.w, i2 = null, a2 = 0; a2 < e2.globals.previousPaths.length; a2++) {
          var s2 = e2.globals.previousPaths[a2];
          s2.paths.length > 0 && parseInt(s2.realIndex, 10) === parseInt(t3, 10) && void 0 !== e2.globals.previousPaths[a2].paths[0] && (i2 = e2.globals.previousPaths[a2].paths[0].d);
        }
        return i2;
      } }, { key: "getDataPointsPos", value: function(t3, e2) {
        var i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.dataPointsLen;
        t3 = t3 || [], e2 = e2 || [];
        for (var a2 = [], s2 = 0; s2 < i2; s2++) {
          var r2 = {};
          r2.x = t3[s2] * Math.sin(e2[s2]), r2.y = -t3[s2] * Math.cos(e2[s2]), a2.push(r2);
        }
        return a2;
      } }]), t2;
    }();
    var It = function(t2) {
      n(i2, Lt);
      var e2 = d(i2);
      function i2(t3) {
        var s2;
        a(this, i2), (s2 = e2.call(this, t3)).ctx = t3, s2.w = t3.w, s2.animBeginArr = [0], s2.animDur = 0;
        var r2 = s2.w;
        return s2.startAngle = r2.config.plotOptions.radialBar.startAngle, s2.endAngle = r2.config.plotOptions.radialBar.endAngle, s2.totalAngle = Math.abs(r2.config.plotOptions.radialBar.endAngle - r2.config.plotOptions.radialBar.startAngle), s2.trackStartAngle = r2.config.plotOptions.radialBar.track.startAngle, s2.trackEndAngle = r2.config.plotOptions.radialBar.track.endAngle, s2.donutDataLabels = s2.w.config.plotOptions.radialBar.dataLabels, s2.radialDataLabels = s2.donutDataLabels, s2.trackStartAngle || (s2.trackStartAngle = s2.startAngle), s2.trackEndAngle || (s2.trackEndAngle = s2.endAngle), 360 === s2.endAngle && (s2.endAngle = 359.99), s2.margin = parseInt(r2.config.plotOptions.radialBar.track.margin, 10), s2;
      }
      return r(i2, [{ key: "draw", value: function(t3) {
        var e3 = this.w, i3 = new m(this.ctx), a2 = i3.group({ class: "apexcharts-radialbar" });
        if (e3.globals.noData)
          return a2;
        var s2 = i3.group(), r2 = this.defaultSize / 2, o2 = e3.globals.gridWidth / 2, n2 = this.defaultSize / 2.05;
        e3.config.chart.sparkline.enabled || (n2 = n2 - e3.config.stroke.width - e3.config.chart.dropShadow.blur);
        var l2 = e3.globals.fill.colors;
        if (e3.config.plotOptions.radialBar.track.show) {
          var h2 = this.drawTracks({ size: n2, centerX: o2, centerY: r2, colorArr: l2, series: t3 });
          s2.add(h2);
        }
        var c2 = this.drawArcs({ size: n2, centerX: o2, centerY: r2, colorArr: l2, series: t3 }), d2 = 360;
        e3.config.plotOptions.radialBar.startAngle < 0 && (d2 = this.totalAngle);
        var g2 = (360 - d2) / 360;
        if (e3.globals.radialSize = n2 - n2 * g2, this.radialDataLabels.value.show) {
          var u2 = Math.max(this.radialDataLabels.value.offsetY, this.radialDataLabels.name.offsetY);
          e3.globals.radialSize += u2 * g2;
        }
        return s2.add(c2.g), "front" === e3.config.plotOptions.radialBar.hollow.position && (c2.g.add(c2.elHollow), c2.dataLabels && c2.g.add(c2.dataLabels)), a2.add(s2), a2;
      } }, { key: "drawTracks", value: function(t3) {
        var e3 = this.w, i3 = new m(this.ctx), a2 = i3.group({ class: "apexcharts-tracks" }), s2 = new v(this.ctx), r2 = new R(this.ctx), o2 = this.getStrokeWidth(t3);
        t3.size = t3.size - o2 / 2;
        for (var n2 = 0; n2 < t3.series.length; n2++) {
          var l2 = i3.group({ class: "apexcharts-radialbar-track apexcharts-track" });
          a2.add(l2), l2.attr({ rel: n2 + 1 }), t3.size = t3.size - o2 - this.margin;
          var h2 = e3.config.plotOptions.radialBar.track, c2 = r2.fillPath({ seriesNumber: 0, size: t3.size, fillColors: Array.isArray(h2.background) ? h2.background[n2] : h2.background, solid: true }), d2 = this.trackStartAngle, g2 = this.trackEndAngle;
          Math.abs(g2) + Math.abs(d2) >= 360 && (g2 = 360 - Math.abs(this.startAngle) - 0.1);
          var u2 = i3.drawPath({ d: "", stroke: c2, strokeWidth: o2 * parseInt(h2.strokeWidth, 10) / 100, fill: "none", strokeOpacity: h2.opacity, classes: "apexcharts-radialbar-area" });
          if (h2.dropShadow.enabled) {
            var p2 = h2.dropShadow;
            s2.dropShadow(u2, p2);
          }
          l2.add(u2), u2.attr("id", "apexcharts-radialbarTrack-" + n2), this.animatePaths(u2, { centerX: t3.centerX, centerY: t3.centerY, endAngle: g2, startAngle: d2, size: t3.size, i: n2, totalItems: 2, animBeginArr: 0, dur: 0, isTrack: true, easing: e3.globals.easing });
        }
        return a2;
      } }, { key: "drawArcs", value: function(t3) {
        var e3 = this.w, i3 = new m(this.ctx), a2 = new R(this.ctx), s2 = new v(this.ctx), r2 = i3.group(), o2 = this.getStrokeWidth(t3);
        t3.size = t3.size - o2 / 2;
        var n2 = e3.config.plotOptions.radialBar.hollow.background, l2 = t3.size - o2 * t3.series.length - this.margin * t3.series.length - o2 * parseInt(e3.config.plotOptions.radialBar.track.strokeWidth, 10) / 100 / 2, h2 = l2 - e3.config.plotOptions.radialBar.hollow.margin;
        void 0 !== e3.config.plotOptions.radialBar.hollow.image && (n2 = this.drawHollowImage(t3, r2, l2, n2));
        var c2 = this.drawHollow({ size: h2, centerX: t3.centerX, centerY: t3.centerY, fill: n2 || "transparent" });
        if (e3.config.plotOptions.radialBar.hollow.dropShadow.enabled) {
          var d2 = e3.config.plotOptions.radialBar.hollow.dropShadow;
          s2.dropShadow(c2, d2);
        }
        var g2 = 1;
        !this.radialDataLabels.total.show && e3.globals.series.length > 1 && (g2 = 0);
        var u2 = null;
        this.radialDataLabels.show && (u2 = this.renderInnerDataLabels(this.radialDataLabels, { hollowSize: l2, centerX: t3.centerX, centerY: t3.centerY, opacity: g2 })), "back" === e3.config.plotOptions.radialBar.hollow.position && (r2.add(c2), u2 && r2.add(u2));
        var p2 = false;
        e3.config.plotOptions.radialBar.inverseOrder && (p2 = true);
        for (var f2 = p2 ? t3.series.length - 1 : 0; p2 ? f2 >= 0 : f2 < t3.series.length; p2 ? f2-- : f2++) {
          var b2 = i3.group({ class: "apexcharts-series apexcharts-radial-series", seriesName: x.escapeString(e3.globals.seriesNames[f2]) });
          r2.add(b2), b2.attr({ rel: f2 + 1, "data:realIndex": f2 }), this.ctx.series.addCollapsedClassToSeries(b2, f2), t3.size = t3.size - o2 - this.margin;
          var y2 = a2.fillPath({ seriesNumber: f2, size: t3.size, value: t3.series[f2] }), w2 = this.startAngle, k2 = void 0, A2 = x.negToZero(t3.series[f2] > 100 ? 100 : t3.series[f2]) / 100, S2 = Math.round(this.totalAngle * A2) + this.startAngle, C2 = void 0;
          e3.globals.dataChanged && (k2 = this.startAngle, C2 = Math.round(this.totalAngle * x.negToZero(e3.globals.previousPaths[f2]) / 100) + k2), Math.abs(S2) + Math.abs(w2) >= 360 && (S2 -= 0.01), Math.abs(C2) + Math.abs(k2) >= 360 && (C2 -= 0.01);
          var L2 = S2 - w2, P2 = Array.isArray(e3.config.stroke.dashArray) ? e3.config.stroke.dashArray[f2] : e3.config.stroke.dashArray, I2 = i3.drawPath({ d: "", stroke: y2, strokeWidth: o2, fill: "none", fillOpacity: e3.config.fill.opacity, classes: "apexcharts-radialbar-area apexcharts-radialbar-slice-" + f2, strokeDashArray: P2 });
          if (m.setAttrs(I2.node, { "data:angle": L2, "data:value": t3.series[f2] }), e3.config.chart.dropShadow.enabled) {
            var T2 = e3.config.chart.dropShadow;
            s2.dropShadow(I2, T2, f2);
          }
          s2.setSelectionFilter(I2, 0, f2), this.addListeners(I2, this.radialDataLabels), b2.add(I2), I2.attr({ index: 0, j: f2 });
          var M2 = 0;
          !this.initialAnim || e3.globals.resized || e3.globals.dataChanged || (M2 = e3.config.chart.animations.speed), e3.globals.dataChanged && (M2 = e3.config.chart.animations.dynamicAnimation.speed), this.animDur = M2 / (1.2 * t3.series.length) + this.animDur, this.animBeginArr.push(this.animDur), this.animatePaths(I2, { centerX: t3.centerX, centerY: t3.centerY, endAngle: S2, startAngle: w2, prevEndAngle: C2, prevStartAngle: k2, size: t3.size, i: f2, totalItems: 2, animBeginArr: this.animBeginArr, dur: M2, shouldSetPrevPaths: true, easing: e3.globals.easing });
        }
        return { g: r2, elHollow: c2, dataLabels: u2 };
      } }, { key: "drawHollow", value: function(t3) {
        var e3 = new m(this.ctx).drawCircle(2 * t3.size);
        return e3.attr({ class: "apexcharts-radialbar-hollow", cx: t3.centerX, cy: t3.centerY, r: t3.size, fill: t3.fill }), e3;
      } }, { key: "drawHollowImage", value: function(t3, e3, i3, a2) {
        var s2 = this.w, r2 = new R(this.ctx), o2 = x.randomId(), n2 = s2.config.plotOptions.radialBar.hollow.image;
        if (s2.config.plotOptions.radialBar.hollow.imageClipped)
          r2.clippedImgArea({ width: i3, height: i3, image: n2, patternID: "pattern".concat(s2.globals.cuid).concat(o2) }), a2 = "url(#pattern".concat(s2.globals.cuid).concat(o2, ")");
        else {
          var l2 = s2.config.plotOptions.radialBar.hollow.imageWidth, h2 = s2.config.plotOptions.radialBar.hollow.imageHeight;
          if (void 0 === l2 && void 0 === h2) {
            var c2 = s2.globals.dom.Paper.image(n2).loaded(function(e4) {
              this.move(t3.centerX - e4.width / 2 + s2.config.plotOptions.radialBar.hollow.imageOffsetX, t3.centerY - e4.height / 2 + s2.config.plotOptions.radialBar.hollow.imageOffsetY);
            });
            e3.add(c2);
          } else {
            var d2 = s2.globals.dom.Paper.image(n2).loaded(function(e4) {
              this.move(t3.centerX - l2 / 2 + s2.config.plotOptions.radialBar.hollow.imageOffsetX, t3.centerY - h2 / 2 + s2.config.plotOptions.radialBar.hollow.imageOffsetY), this.size(l2, h2);
            });
            e3.add(d2);
          }
        }
        return a2;
      } }, { key: "getStrokeWidth", value: function(t3) {
        var e3 = this.w;
        return t3.size * (100 - parseInt(e3.config.plotOptions.radialBar.hollow.size, 10)) / 100 / (t3.series.length + 1) - this.margin;
      } }]), i2;
    }();
    var Tt = function(t2) {
      n(s2, yt);
      var i2 = d(s2);
      function s2() {
        return a(this, s2), i2.apply(this, arguments);
      }
      return r(s2, [{ key: "draw", value: function(t3, i3) {
        var a2 = this.w, s3 = new m(this.ctx);
        this.rangeBarOptions = this.w.config.plotOptions.rangeBar, this.series = t3, this.seriesRangeStart = a2.globals.seriesRangeStart, this.seriesRangeEnd = a2.globals.seriesRangeEnd, this.barHelpers.initVariables(t3);
        for (var r2 = s3.group({ class: "apexcharts-rangebar-series apexcharts-plot-series" }), n2 = 0; n2 < t3.length; n2++) {
          var l2, h2, c2, d2, g2 = void 0, u2 = void 0, p2 = a2.globals.comboCharts ? i3[n2] : n2, f2 = s3.group({ class: "apexcharts-series", seriesName: x.escapeString(a2.globals.seriesNames[p2]), rel: n2 + 1, "data:realIndex": p2 });
          this.ctx.series.addCollapsedClassToSeries(f2, p2), t3[n2].length > 0 && (this.visibleI = this.visibleI + 1);
          var b2 = 0, v2 = 0;
          this.yRatio.length > 1 && (this.yaxisIndex = p2);
          var y2 = this.barHelpers.initialPositions();
          u2 = y2.y, d2 = y2.zeroW, g2 = y2.x, v2 = y2.barWidth, b2 = y2.barHeight, l2 = y2.xDivision, h2 = y2.yDivision, c2 = y2.zeroH;
          for (var w2 = s3.group({ class: "apexcharts-datalabels", "data:realIndex": p2 }), k2 = s3.group({ class: "apexcharts-rangebar-goals-markers" }), A2 = 0; A2 < a2.globals.dataPoints; A2++) {
            var S2, C2 = this.barHelpers.getStrokeWidth(n2, A2, p2), L2 = this.seriesRangeStart[n2][A2], P2 = this.seriesRangeEnd[n2][A2], I2 = null, T2 = null, M2 = null, z2 = { x: g2, y: u2, strokeWidth: C2, elSeries: f2 }, X2 = this.seriesLen;
            if (a2.config.plotOptions.bar.rangeBarGroupRows && (X2 = 1), void 0 === a2.config.series[n2].data[A2])
              break;
            if (this.isHorizontal) {
              M2 = u2 + b2 * this.visibleI;
              var E2 = (h2 - b2 * X2) / 2;
              if (a2.config.series[n2].data[A2].x) {
                var Y2 = this.detectOverlappingBars({ i: n2, j: A2, barYPosition: M2, srty: E2, barHeight: b2, yDivision: h2, initPositions: y2 });
                b2 = Y2.barHeight, M2 = Y2.barYPosition;
              }
              v2 = (I2 = this.drawRangeBarPaths(e({ indexes: { i: n2, j: A2, realIndex: p2 }, barHeight: b2, barYPosition: M2, zeroW: d2, yDivision: h2, y1: L2, y2: P2 }, z2))).barWidth;
            } else {
              a2.globals.isXNumeric && (g2 = (a2.globals.seriesX[n2][A2] - a2.globals.minX) / this.xRatio - v2 / 2), T2 = g2 + v2 * this.visibleI;
              var F2 = (l2 - v2 * X2) / 2;
              if (a2.config.series[n2].data[A2].x) {
                var R2 = this.detectOverlappingBars({ i: n2, j: A2, barXPosition: T2, srtx: F2, barWidth: v2, xDivision: l2, initPositions: y2 });
                v2 = R2.barWidth, T2 = R2.barXPosition;
              }
              b2 = (I2 = this.drawRangeColumnPaths(e({ indexes: { i: n2, j: A2, realIndex: p2 }, barWidth: v2, barXPosition: T2, zeroH: c2, xDivision: l2 }, z2))).barHeight;
            }
            var H2 = this.barHelpers.drawGoalLine({ barXPosition: I2.barXPosition, barYPosition: M2, goalX: I2.goalX, goalY: I2.goalY, barHeight: b2, barWidth: v2 });
            H2 && k2.add(H2), u2 = I2.y, g2 = I2.x;
            var D2 = this.barHelpers.getPathFillColor(t3, n2, A2, p2), O2 = a2.globals.stroke.colors[p2];
            this.renderSeries((o(S2 = { realIndex: p2, pathFill: D2, lineFill: O2, j: A2, i: n2, x: g2, y: u2, y1: L2, y2: P2, pathFrom: I2.pathFrom, pathTo: I2.pathTo, strokeWidth: C2, elSeries: f2, series: t3, barHeight: b2, barWidth: v2, barXPosition: T2, barYPosition: M2 }, "barWidth", v2), o(S2, "elDataLabelsWrap", w2), o(S2, "elGoalsMarkers", k2), o(S2, "visibleSeries", this.visibleI), o(S2, "type", "rangebar"), S2));
          }
          r2.add(f2);
        }
        return r2;
      } }, { key: "detectOverlappingBars", value: function(t3) {
        var e2 = t3.i, i3 = t3.j, a2 = t3.barYPosition, s3 = t3.barXPosition, r2 = t3.srty, o2 = t3.srtx, n2 = t3.barHeight, l2 = t3.barWidth, h2 = t3.yDivision, c2 = t3.xDivision, d2 = t3.initPositions, g2 = this.w, u2 = [], p2 = g2.config.series[e2].data[i3].rangeName, f2 = g2.config.series[e2].data[i3].x, x2 = Array.isArray(f2) ? f2.join(" ") : f2, b2 = g2.globals.labels.map(function(t4) {
          return Array.isArray(t4) ? t4.join(" ") : t4;
        }).indexOf(x2), v2 = g2.globals.seriesRange[e2].findIndex(function(t4) {
          return t4.x === x2 && t4.overlaps.length > 0;
        });
        return this.isHorizontal ? (a2 = g2.config.plotOptions.bar.rangeBarGroupRows ? r2 + h2 * b2 : r2 + n2 * this.visibleI + h2 * b2, v2 > -1 && !g2.config.plotOptions.bar.rangeBarOverlap && (u2 = g2.globals.seriesRange[e2][v2].overlaps).indexOf(p2) > -1 && (a2 = (n2 = d2.barHeight / u2.length) * this.visibleI + h2 * (100 - parseInt(this.barOptions.barHeight, 10)) / 100 / 2 + n2 * (this.visibleI + u2.indexOf(p2)) + h2 * b2)) : (b2 > -1 && (s3 = g2.config.plotOptions.bar.rangeBarGroupRows ? o2 + c2 * b2 : o2 + l2 * this.visibleI + c2 * b2), v2 > -1 && !g2.config.plotOptions.bar.rangeBarOverlap && (u2 = g2.globals.seriesRange[e2][v2].overlaps).indexOf(p2) > -1 && (s3 = (l2 = d2.barWidth / u2.length) * this.visibleI + c2 * (100 - parseInt(this.barOptions.barWidth, 10)) / 100 / 2 + l2 * (this.visibleI + u2.indexOf(p2)) + c2 * b2)), { barYPosition: a2, barXPosition: s3, barHeight: n2, barWidth: l2 };
      } }, { key: "drawRangeColumnPaths", value: function(t3) {
        var e2 = t3.indexes, i3 = t3.x, a2 = t3.xDivision, s3 = t3.barWidth, r2 = t3.barXPosition, o2 = t3.zeroH, n2 = this.w, l2 = e2.i, h2 = e2.j, c2 = this.yRatio[this.yaxisIndex], d2 = e2.realIndex, g2 = this.getRangeValue(d2, h2), u2 = Math.min(g2.start, g2.end), p2 = Math.max(g2.start, g2.end);
        void 0 === this.series[l2][h2] || null === this.series[l2][h2] ? u2 = o2 : (u2 = o2 - u2 / c2, p2 = o2 - p2 / c2);
        var f2 = Math.abs(p2 - u2), x2 = this.barHelpers.getColumnPaths({ barXPosition: r2, barWidth: s3, y1: u2, y2: p2, strokeWidth: this.strokeWidth, series: this.seriesRangeEnd, realIndex: e2.realIndex, i: d2, j: h2, w: n2 });
        return n2.globals.isXNumeric || (i3 += a2), { pathTo: x2.pathTo, pathFrom: x2.pathFrom, barHeight: f2, x: i3, y: p2, goalY: this.barHelpers.getGoalValues("y", null, o2, l2, h2), barXPosition: r2 };
      } }, { key: "drawRangeBarPaths", value: function(t3) {
        var e2 = t3.indexes, i3 = t3.y, a2 = t3.y1, s3 = t3.y2, r2 = t3.yDivision, o2 = t3.barHeight, n2 = t3.barYPosition, l2 = t3.zeroW, h2 = this.w, c2 = l2 + a2 / this.invertedYRatio, d2 = l2 + s3 / this.invertedYRatio, g2 = Math.abs(d2 - c2), u2 = this.barHelpers.getBarpaths({ barYPosition: n2, barHeight: o2, x1: c2, x2: d2, strokeWidth: this.strokeWidth, series: this.seriesRangeEnd, i: e2.realIndex, realIndex: e2.realIndex, j: e2.j, w: h2 });
        return h2.globals.isXNumeric || (i3 += r2), { pathTo: u2.pathTo, pathFrom: u2.pathFrom, barWidth: g2, x: d2, goalX: this.barHelpers.getGoalValues("x", l2, null, e2.realIndex, e2.j), y: i3 };
      } }, { key: "getRangeValue", value: function(t3, e2) {
        var i3 = this.w;
        return { start: i3.globals.seriesRangeStart[t3][e2], end: i3.globals.seriesRangeEnd[t3][e2] };
      } }]), s2;
    }();
    var Mt = function() {
      function t2(e2) {
        a(this, t2), this.w = e2.w, this.lineCtx = e2;
      }
      return r(t2, [{ key: "sameValueSeriesFix", value: function(t3, e2) {
        var i2 = this.w;
        if (("gradient" === i2.config.fill.type || "gradient" === i2.config.fill.type[t3]) && new y(this.lineCtx.ctx, i2).seriesHaveSameValues(t3)) {
          var a2 = e2[t3].slice();
          a2[a2.length - 1] = a2[a2.length - 1] + 1e-6, e2[t3] = a2;
        }
        return e2;
      } }, { key: "calculatePoints", value: function(t3) {
        var e2 = t3.series, i2 = t3.realIndex, a2 = t3.x, s2 = t3.y, r2 = t3.i, o2 = t3.j, n2 = t3.prevY, l2 = this.w, h2 = [], c2 = [];
        if (0 === o2) {
          var d2 = this.lineCtx.categoryAxisCorrection + l2.config.markers.offsetX;
          l2.globals.isXNumeric && (d2 = (l2.globals.seriesX[i2][0] - l2.globals.minX) / this.lineCtx.xRatio + l2.config.markers.offsetX), h2.push(d2), c2.push(x.isNumber(e2[r2][0]) ? n2 + l2.config.markers.offsetY : null), h2.push(a2 + l2.config.markers.offsetX), c2.push(x.isNumber(e2[r2][o2 + 1]) ? s2 + l2.config.markers.offsetY : null);
        } else
          h2.push(a2 + l2.config.markers.offsetX), c2.push(x.isNumber(e2[r2][o2 + 1]) ? s2 + l2.config.markers.offsetY : null);
        return { x: h2, y: c2 };
      } }, { key: "checkPreviousPaths", value: function(t3) {
        for (var e2 = t3.pathFromLine, i2 = t3.pathFromArea, a2 = t3.realIndex, s2 = this.w, r2 = 0; r2 < s2.globals.previousPaths.length; r2++) {
          var o2 = s2.globals.previousPaths[r2];
          ("line" === o2.type || "area" === o2.type) && o2.paths.length > 0 && parseInt(o2.realIndex, 10) === parseInt(a2, 10) && ("line" === o2.type ? (this.lineCtx.appendPathFrom = false, e2 = s2.globals.previousPaths[r2].paths[0].d) : "area" === o2.type && (this.lineCtx.appendPathFrom = false, i2 = s2.globals.previousPaths[r2].paths[0].d, s2.config.stroke.show && s2.globals.previousPaths[r2].paths[1] && (e2 = s2.globals.previousPaths[r2].paths[1].d)));
        }
        return { pathFromLine: e2, pathFromArea: i2 };
      } }, { key: "determineFirstPrevY", value: function(t3) {
        var e2, i2 = t3.i, a2 = t3.series, s2 = t3.prevY, r2 = t3.lineYPosition, o2 = this.w;
        if (void 0 !== (null === (e2 = a2[i2]) || void 0 === e2 ? void 0 : e2[0]))
          s2 = (r2 = o2.config.chart.stacked && i2 > 0 ? this.lineCtx.prevSeriesY[i2 - 1][0] : this.lineCtx.zeroY) - a2[i2][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] + 2 * (this.lineCtx.isReversed ? a2[i2][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] : 0);
        else if (o2.config.chart.stacked && i2 > 0 && void 0 === a2[i2][0]) {
          for (var n2 = i2 - 1; n2 >= 0; n2--)
            if (null !== a2[n2][0] && void 0 !== a2[n2][0]) {
              s2 = r2 = this.lineCtx.prevSeriesY[n2][0];
              break;
            }
        }
        return { prevY: s2, lineYPosition: r2 };
      } }]), t2;
    }();
    var zt = function(t2) {
      for (var e2, i2, a2, s2, r2 = function(t3) {
        for (var e3 = [], i3 = t3[0], a3 = t3[1], s3 = e3[0] = Yt(i3, a3), r3 = 1, o3 = t3.length - 1; r3 < o3; r3++)
          i3 = a3, a3 = t3[r3 + 1], e3[r3] = 0.5 * (s3 + (s3 = Yt(i3, a3)));
        return e3[r3] = s3, e3;
      }(t2), o2 = t2.length - 1, n2 = [], l2 = 0; l2 < o2; l2++)
        a2 = Yt(t2[l2], t2[l2 + 1]), Math.abs(a2) < 1e-6 ? r2[l2] = r2[l2 + 1] = 0 : (s2 = (e2 = r2[l2] / a2) * e2 + (i2 = r2[l2 + 1] / a2) * i2) > 9 && (s2 = 3 * a2 / Math.sqrt(s2), r2[l2] = s2 * e2, r2[l2 + 1] = s2 * i2);
      for (var h2 = 0; h2 <= o2; h2++)
        s2 = (t2[Math.min(o2, h2 + 1)][0] - t2[Math.max(0, h2 - 1)][0]) / (6 * (1 + r2[h2] * r2[h2])), n2.push([s2 || 0, r2[h2] * s2 || 0]);
      return n2;
    };
    var Xt = function(t2) {
      for (var e2 = "", i2 = 0; i2 < t2.length; i2++) {
        var a2 = t2[i2], s2 = a2.length;
        s2 > 4 ? (e2 += "C".concat(a2[0], ", ").concat(a2[1]), e2 += ", ".concat(a2[2], ", ").concat(a2[3]), e2 += ", ".concat(a2[4], ", ").concat(a2[5])) : s2 > 2 && (e2 += "S".concat(a2[0], ", ").concat(a2[1]), e2 += ", ".concat(a2[2], ", ").concat(a2[3]));
      }
      return e2;
    };
    var Et = function(t2) {
      var e2 = zt(t2), i2 = t2[1], a2 = t2[0], s2 = [], r2 = e2[1], o2 = e2[0];
      s2.push(a2, [a2[0] + o2[0], a2[1] + o2[1], i2[0] - r2[0], i2[1] - r2[1], i2[0], i2[1]]);
      for (var n2 = 2, l2 = e2.length; n2 < l2; n2++) {
        var h2 = t2[n2], c2 = e2[n2];
        s2.push([h2[0] - c2[0], h2[1] - c2[1], h2[0], h2[1]]);
      }
      return s2;
    };
    function Yt(t2, e2) {
      return (e2[1] - t2[1]) / (e2[0] - t2[0]);
    }
    var Ft = function() {
      function t2(e2, i2, s2) {
        a(this, t2), this.ctx = e2, this.w = e2.w, this.xyRatios = i2, this.pointsChart = !("bubble" !== this.w.config.chart.type && "scatter" !== this.w.config.chart.type) || s2, this.scatter = new D(this.ctx), this.noNegatives = this.w.globals.minX === Number.MAX_VALUE, this.lineHelpers = new Mt(this), this.markers = new H(this.ctx), this.prevSeriesY = [], this.categoryAxisCorrection = 0, this.yaxisIndex = 0;
      }
      return r(t2, [{ key: "draw", value: function(t3, i2, a2, s2) {
        var r2 = this.w, o2 = new m(this.ctx), n2 = r2.globals.comboCharts ? i2 : r2.config.chart.type, l2 = o2.group({ class: "apexcharts-".concat(n2, "-series apexcharts-plot-series") }), h2 = new y(this.ctx, r2);
        this.yRatio = this.xyRatios.yRatio, this.zRatio = this.xyRatios.zRatio, this.xRatio = this.xyRatios.xRatio, this.baseLineY = this.xyRatios.baseLineY, t3 = h2.getLogSeries(t3), this.yRatio = h2.getLogYRatios(this.yRatio);
        for (var c2 = [], d2 = 0; d2 < t3.length; d2++) {
          t3 = this.lineHelpers.sameValueSeriesFix(d2, t3);
          var g2 = r2.globals.comboCharts ? a2[d2] : d2;
          this._initSerieVariables(t3, d2, g2);
          var u2 = [], p2 = [], f2 = [], x2 = r2.globals.padHorizontal + this.categoryAxisCorrection;
          this.ctx.series.addCollapsedClassToSeries(this.elSeries, g2), r2.globals.isXNumeric && r2.globals.seriesX.length > 0 && (x2 = (r2.globals.seriesX[g2][0] - r2.globals.minX) / this.xRatio), f2.push(x2);
          var b2 = x2, v2 = this.zeroY, w2 = this.zeroY;
          v2 = this.lineHelpers.determineFirstPrevY({ i: d2, series: t3, prevY: v2, lineYPosition: 0 }).prevY, "smooth" === r2.config.stroke.curve && null === t3[d2][0] ? u2.push(null) : u2.push(v2);
          "rangeArea" === n2 && (w2 = this.lineHelpers.determineFirstPrevY({ i: d2, series: s2, prevY: w2, lineYPosition: 0 }).prevY, p2.push(w2));
          var k2 = { type: n2, series: t3, realIndex: g2, i: d2, x: x2, y: 1, pathsFrom: this._calculatePathsFrom({ type: n2, series: t3, i: d2, realIndex: g2, prevX: b2, prevY: v2, prevY2: w2 }), linePaths: [], areaPaths: [], seriesIndex: a2, lineYPosition: 0, xArrj: f2, yArrj: u2, y2Arrj: p2, seriesRangeEnd: s2 }, A2 = this._iterateOverDataPoints(e(e({}, k2), {}, { iterations: "rangeArea" === n2 ? t3[d2].length - 1 : void 0, isRangeStart: true }));
          if ("rangeArea" === n2) {
            var S2 = this._calculatePathsFrom({ series: s2, i: d2, realIndex: g2, prevX: b2, prevY: w2 }), C2 = this._iterateOverDataPoints(e(e({}, k2), {}, { series: s2, pathsFrom: S2, iterations: s2[d2].length - 1, isRangeStart: false }));
            A2.linePaths[0] = C2.linePath + A2.linePath, A2.pathFromLine = C2.pathFromLine + A2.pathFromLine;
          }
          this._handlePaths({ type: n2, realIndex: g2, i: d2, paths: A2 }), this.elSeries.add(this.elPointsMain), this.elSeries.add(this.elDataLabelsWrap), c2.push(this.elSeries);
        }
        if (r2.config.chart.stacked)
          for (var L2 = c2.length; L2 > 0; L2--)
            l2.add(c2[L2 - 1]);
        else
          for (var P2 = 0; P2 < c2.length; P2++)
            l2.add(c2[P2]);
        return l2;
      } }, { key: "_initSerieVariables", value: function(t3, e2, i2) {
        var a2 = this.w, s2 = new m(this.ctx);
        this.xDivision = a2.globals.gridWidth / (a2.globals.dataPoints - ("on" === a2.config.xaxis.tickPlacement ? 1 : 0)), this.strokeWidth = Array.isArray(a2.config.stroke.width) ? a2.config.stroke.width[i2] : a2.config.stroke.width, this.yRatio.length > 1 && (this.yaxisIndex = i2), this.isReversed = a2.config.yaxis[this.yaxisIndex] && a2.config.yaxis[this.yaxisIndex].reversed, this.zeroY = a2.globals.gridHeight - this.baseLineY[this.yaxisIndex] - (this.isReversed ? a2.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0), this.areaBottomY = this.zeroY, (this.zeroY > a2.globals.gridHeight || "end" === a2.config.plotOptions.area.fillTo) && (this.areaBottomY = a2.globals.gridHeight), this.categoryAxisCorrection = this.xDivision / 2, this.elSeries = s2.group({ class: "apexcharts-series", seriesName: x.escapeString(a2.globals.seriesNames[i2]) }), this.elPointsMain = s2.group({ class: "apexcharts-series-markers-wrap", "data:realIndex": i2 }), this.elDataLabelsWrap = s2.group({ class: "apexcharts-datalabels", "data:realIndex": i2 });
        var r2 = t3[e2].length === a2.globals.dataPoints;
        this.elSeries.attr({ "data:longestSeries": r2, rel: e2 + 1, "data:realIndex": i2 }), this.appendPathFrom = true;
      } }, { key: "_calculatePathsFrom", value: function(t3) {
        var e2, i2, a2, s2, r2 = t3.type, o2 = t3.series, n2 = t3.i, l2 = t3.realIndex, h2 = t3.prevX, c2 = t3.prevY, d2 = t3.prevY2, g2 = this.w, u2 = new m(this.ctx);
        if (null === o2[n2][0]) {
          for (var p2 = 0; p2 < o2[n2].length; p2++)
            if (null !== o2[n2][p2]) {
              h2 = this.xDivision * p2, c2 = this.zeroY - o2[n2][p2] / this.yRatio[this.yaxisIndex], e2 = u2.move(h2, c2), i2 = u2.move(h2, this.areaBottomY);
              break;
            }
        } else
          e2 = u2.move(h2, c2), "rangeArea" === r2 && (e2 = u2.move(h2, d2) + u2.line(h2, c2)), i2 = u2.move(h2, this.areaBottomY) + u2.line(h2, c2);
        if (a2 = u2.move(-1, this.zeroY) + u2.line(-1, this.zeroY), s2 = u2.move(-1, this.zeroY) + u2.line(-1, this.zeroY), g2.globals.previousPaths.length > 0) {
          var f2 = this.lineHelpers.checkPreviousPaths({ pathFromLine: a2, pathFromArea: s2, realIndex: l2 });
          a2 = f2.pathFromLine, s2 = f2.pathFromArea;
        }
        return { prevX: h2, prevY: c2, linePath: e2, areaPath: i2, pathFromLine: a2, pathFromArea: s2 };
      } }, { key: "_handlePaths", value: function(t3) {
        var i2 = t3.type, a2 = t3.realIndex, s2 = t3.i, r2 = t3.paths, o2 = this.w, n2 = new m(this.ctx), l2 = new R(this.ctx);
        this.prevSeriesY.push(r2.yArrj), o2.globals.seriesXvalues[a2] = r2.xArrj, o2.globals.seriesYvalues[a2] = r2.yArrj;
        var h2 = o2.config.forecastDataPoints;
        if (h2.count > 0 && "rangeArea" !== i2) {
          var c2 = o2.globals.seriesXvalues[a2][o2.globals.seriesXvalues[a2].length - h2.count - 1], d2 = n2.drawRect(c2, 0, o2.globals.gridWidth, o2.globals.gridHeight, 0);
          o2.globals.dom.elForecastMask.appendChild(d2.node);
          var g2 = n2.drawRect(0, 0, c2, o2.globals.gridHeight, 0);
          o2.globals.dom.elNonForecastMask.appendChild(g2.node);
        }
        this.pointsChart || o2.globals.delayedElements.push({ el: this.elPointsMain.node, index: a2 });
        var u2 = { i: s2, realIndex: a2, animationDelay: s2, initialSpeed: o2.config.chart.animations.speed, dataChangeSpeed: o2.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-".concat(i2) };
        if ("area" === i2)
          for (var p2 = l2.fillPath({ seriesNumber: a2 }), f2 = 0; f2 < r2.areaPaths.length; f2++) {
            var x2 = n2.renderPaths(e(e({}, u2), {}, { pathFrom: r2.pathFromArea, pathTo: r2.areaPaths[f2], stroke: "none", strokeWidth: 0, strokeLineCap: null, fill: p2 }));
            this.elSeries.add(x2);
          }
        if (o2.config.stroke.show && !this.pointsChart) {
          var b2 = null;
          if ("line" === i2)
            b2 = l2.fillPath({ seriesNumber: a2, i: s2 });
          else if ("solid" === o2.config.stroke.fill.type)
            b2 = o2.globals.stroke.colors[a2];
          else {
            var v2 = o2.config.fill;
            o2.config.fill = o2.config.stroke.fill, b2 = l2.fillPath({ seriesNumber: a2, i: s2 }), o2.config.fill = v2;
          }
          for (var y2 = 0; y2 < r2.linePaths.length; y2++) {
            var w2 = b2;
            "rangeArea" === i2 && (w2 = l2.fillPath({ seriesNumber: a2 }));
            var k2 = e(e({}, u2), {}, { pathFrom: r2.pathFromLine, pathTo: r2.linePaths[y2], stroke: b2, strokeWidth: this.strokeWidth, strokeLineCap: o2.config.stroke.lineCap, fill: "rangeArea" === i2 ? w2 : "none" }), A2 = n2.renderPaths(k2);
            if (this.elSeries.add(A2), A2.attr("fill-rule", "evenodd"), h2.count > 0 && "rangeArea" !== i2) {
              var S2 = n2.renderPaths(k2);
              S2.node.setAttribute("stroke-dasharray", h2.dashArray), h2.strokeWidth && S2.node.setAttribute("stroke-width", h2.strokeWidth), this.elSeries.add(S2), S2.attr("clip-path", "url(#forecastMask".concat(o2.globals.cuid, ")")), A2.attr("clip-path", "url(#nonForecastMask".concat(o2.globals.cuid, ")"));
            }
          }
        }
      } }, { key: "_iterateOverDataPoints", value: function(t3) {
        var e2 = this, i2 = t3.type, a2 = t3.series, s2 = t3.iterations, r2 = t3.realIndex, o2 = t3.i, n2 = t3.x, l2 = t3.y, h2 = t3.pathsFrom, c2 = t3.linePaths, d2 = t3.areaPaths, g2 = t3.seriesIndex, u2 = t3.lineYPosition, p2 = t3.xArrj, f2 = t3.yArrj, b2 = t3.y2Arrj, v2 = t3.isRangeStart, y2 = t3.seriesRangeEnd, w2 = this.w, k2 = new m(this.ctx), A2 = this.yRatio, S2 = h2.prevY, C2 = h2.linePath, L2 = h2.areaPath, P2 = h2.pathFromLine, I2 = h2.pathFromArea, T2 = x.isNumber(w2.globals.minYArr[r2]) ? w2.globals.minYArr[r2] : w2.globals.minY;
        s2 || (s2 = w2.globals.dataPoints > 1 ? w2.globals.dataPoints - 1 : w2.globals.dataPoints);
        for (var M2 = function(t4, i3) {
          return i3 - t4 / A2[e2.yaxisIndex] + 2 * (e2.isReversed ? t4 / A2[e2.yaxisIndex] : 0);
        }, z2 = l2, X2 = 0; X2 < s2; X2++) {
          var E2 = void 0 === a2[o2][X2 + 1] || null === a2[o2][X2 + 1];
          if (w2.globals.isXNumeric) {
            var Y2 = w2.globals.seriesX[r2][X2 + 1];
            void 0 === w2.globals.seriesX[r2][X2 + 1] && (Y2 = w2.globals.seriesX[r2][s2 - 1]), n2 = (Y2 - w2.globals.minX) / this.xRatio;
          } else
            n2 += this.xDivision;
          if (w2.config.chart.stacked)
            if (o2 > 0 && w2.globals.collapsedSeries.length < w2.config.series.length - 1) {
              u2 = this.prevSeriesY[function(t4) {
                for (var e3 = t4, i3 = 0; i3 < w2.globals.series.length; i3++)
                  if (w2.globals.collapsedSeriesIndices.indexOf(t4) > -1) {
                    e3--;
                    break;
                  }
                return e3 >= 0 ? e3 : 0;
              }(o2 - 1)][X2 + 1];
            } else
              u2 = this.zeroY;
          else
            u2 = this.zeroY;
          E2 ? l2 = M2(T2, u2) : (l2 = M2(a2[o2][X2 + 1], u2), "rangeArea" === i2 && (z2 = M2(y2[o2][X2 + 1], u2))), p2.push(n2), E2 && "smooth" === w2.config.stroke.curve ? f2.push(null) : f2.push(l2), b2.push(z2);
          var F2 = this.lineHelpers.calculatePoints({ series: a2, x: n2, y: l2, realIndex: r2, i: o2, j: X2, prevY: S2 }), R2 = this._createPaths({ type: i2, series: a2, i: o2, realIndex: r2, j: X2, x: n2, y: l2, y2: z2, xArrj: p2, yArrj: f2, y2Arrj: b2, linePath: C2, areaPath: L2, linePaths: c2, areaPaths: d2, seriesIndex: g2, isRangeStart: v2 });
          d2 = R2.areaPaths, c2 = R2.linePaths, L2 = R2.areaPath, C2 = R2.linePath, !this.appendPathFrom || "smooth" === w2.config.stroke.curve && "rangeArea" === i2 || (P2 += k2.line(n2, this.zeroY), I2 += k2.line(n2, this.zeroY)), this.handleNullDataPoints(a2, F2, o2, X2, r2), this._handleMarkersAndLabels({ type: i2, pointsPos: F2, i: o2, j: X2, realIndex: r2, isRangeStart: v2 });
        }
        return { yArrj: f2, xArrj: p2, pathFromArea: I2, areaPaths: d2, pathFromLine: P2, linePaths: c2, linePath: C2, areaPath: L2 };
      } }, { key: "_handleMarkersAndLabels", value: function(t3) {
        var e2 = t3.type, i2 = t3.pointsPos, a2 = t3.isRangeStart, s2 = t3.i, r2 = t3.j, o2 = t3.realIndex, n2 = this.w, l2 = new O(this.ctx);
        if (this.pointsChart)
          this.scatter.draw(this.elSeries, r2, { realIndex: o2, pointsPos: i2, zRatio: this.zRatio, elParent: this.elPointsMain });
        else {
          n2.globals.series[s2].length > 1 && this.elPointsMain.node.classList.add("apexcharts-element-hidden");
          var h2 = this.markers.plotChartMarkers(i2, o2, r2 + 1);
          null !== h2 && this.elPointsMain.add(h2);
        }
        var c2 = l2.drawDataLabel({ type: e2, isRangeStart: a2, pos: i2, i: o2, j: r2 + 1 });
        null !== c2 && this.elDataLabelsWrap.add(c2);
      } }, { key: "_createPaths", value: function(t3) {
        var e2 = t3.type, i2 = t3.series, a2 = t3.i, s2 = t3.realIndex, r2 = t3.j, o2 = t3.x, n2 = t3.y, l2 = t3.xArrj, h2 = t3.yArrj, c2 = t3.y2, d2 = t3.y2Arrj, g2 = t3.linePath, u2 = t3.areaPath, p2 = t3.linePaths, f2 = t3.areaPaths, x2 = t3.seriesIndex, b2 = t3.isRangeStart, v2 = this.w, y2 = new m(this.ctx), w2 = v2.config.stroke.curve, k2 = this.areaBottomY;
        if (Array.isArray(v2.config.stroke.curve) && (w2 = Array.isArray(x2) ? v2.config.stroke.curve[x2[a2]] : v2.config.stroke.curve[a2]), "rangeArea" === e2 && (v2.globals.hasNullValues || v2.config.forecastDataPoints.count > 0) && "smooth" === w2 && (w2 = "straight"), "smooth" === w2) {
          if ("rangeArea" === e2 ? l2.length === v2.globals.dataPoints : r2 === i2[a2].length - 2) {
            var A2 = l2.map(function(t4, e3) {
              return [l2[e3], h2[e3]];
            }).filter(function(t4) {
              return null !== t4[1];
            }), S2 = Et(A2);
            if (g2 += Xt(S2), null === i2[a2][0] ? u2 = g2 : u2 += Xt(S2), "rangeArea" === e2 && b2) {
              g2 += y2.line(l2[l2.length - 1], d2[d2.length - 1]);
              var C2 = l2.slice().reverse(), L2 = d2.slice().reverse(), P2 = C2.map(function(t4, e3) {
                return [C2[e3], L2[e3]];
              }), I2 = Et(P2);
              u2 = g2 += Xt(I2);
            } else
              u2 += y2.line(A2[A2.length - 1][0], k2) + y2.line(A2[0][0], k2) + y2.move(A2[0][0], A2[0][1]) + "z";
            p2.push(g2), f2.push(u2);
          }
        } else {
          if (null === i2[a2][r2 + 1]) {
            g2 += y2.move(o2, n2);
            var T2 = v2.globals.isXNumeric ? (v2.globals.seriesX[s2][r2] - v2.globals.minX) / this.xRatio : o2 - this.xDivision;
            u2 = u2 + y2.line(T2, k2) + y2.move(o2, n2) + "z";
          }
          null === i2[a2][r2] && (g2 += y2.move(o2, n2), u2 += y2.move(o2, k2)), "stepline" === w2 ? (g2 = g2 + y2.line(o2, null, "H") + y2.line(null, n2, "V"), u2 = u2 + y2.line(o2, null, "H") + y2.line(null, n2, "V")) : "straight" === w2 && (g2 += y2.line(o2, n2), u2 += y2.line(o2, n2)), r2 === i2[a2].length - 2 && (u2 = u2 + y2.line(o2, k2) + y2.move(o2, n2) + "z", "rangeArea" === e2 && b2 ? g2 = g2 + y2.line(o2, c2) + y2.move(o2, c2) + "z" : (p2.push(g2), f2.push(u2)));
        }
        return { linePaths: p2, areaPaths: f2, linePath: g2, areaPath: u2 };
      } }, { key: "handleNullDataPoints", value: function(t3, e2, i2, a2, s2) {
        var r2 = this.w;
        if (null === t3[i2][a2] && r2.config.markers.showNullDataPoints || 1 === t3[i2].length) {
          var o2 = this.markers.plotChartMarkers(e2, s2, a2 + 1, this.strokeWidth - r2.config.markers.strokeWidth / 2, true);
          null !== o2 && this.elPointsMain.add(o2);
        }
      } }]), t2;
    }();
    window.TreemapSquared = {}, window.TreemapSquared.generate = function() {
      function t2(e3, i3, a3, s3) {
        this.xoffset = e3, this.yoffset = i3, this.height = s3, this.width = a3, this.shortestEdge = function() {
          return Math.min(this.height, this.width);
        }, this.getCoordinates = function(t3) {
          var e4, i4 = [], a4 = this.xoffset, s4 = this.yoffset, o3 = r2(t3) / this.height, n2 = r2(t3) / this.width;
          if (this.width >= this.height)
            for (e4 = 0; e4 < t3.length; e4++)
              i4.push([a4, s4, a4 + o3, s4 + t3[e4] / o3]), s4 += t3[e4] / o3;
          else
            for (e4 = 0; e4 < t3.length; e4++)
              i4.push([a4, s4, a4 + t3[e4] / n2, s4 + n2]), a4 += t3[e4] / n2;
          return i4;
        }, this.cutArea = function(e4) {
          var i4;
          if (this.width >= this.height) {
            var a4 = e4 / this.height, s4 = this.width - a4;
            i4 = new t2(this.xoffset + a4, this.yoffset, s4, this.height);
          } else {
            var r3 = e4 / this.width, o3 = this.height - r3;
            i4 = new t2(this.xoffset, this.yoffset + r3, this.width, o3);
          }
          return i4;
        };
      }
      function e2(e3, a3, s3, o3, n2) {
        o3 = void 0 === o3 ? 0 : o3, n2 = void 0 === n2 ? 0 : n2;
        var l2 = i2(function(t3, e4) {
          var i3, a4 = [], s4 = e4 / r2(t3);
          for (i3 = 0; i3 < t3.length; i3++)
            a4[i3] = t3[i3] * s4;
          return a4;
        }(e3, a3 * s3), [], new t2(o3, n2, a3, s3), []);
        return function(t3) {
          var e4, i3, a4 = [];
          for (e4 = 0; e4 < t3.length; e4++)
            for (i3 = 0; i3 < t3[e4].length; i3++)
              a4.push(t3[e4][i3]);
          return a4;
        }(l2);
      }
      function i2(t3, e3, s3, o3) {
        var n2, l2, h2;
        if (0 !== t3.length)
          return n2 = s3.shortestEdge(), function(t4, e4, i3) {
            var s4;
            if (0 === t4.length)
              return true;
            (s4 = t4.slice()).push(e4);
            var r3 = a2(t4, i3), o4 = a2(s4, i3);
            return r3 >= o4;
          }(e3, l2 = t3[0], n2) ? (e3.push(l2), i2(t3.slice(1), e3, s3, o3)) : (h2 = s3.cutArea(r2(e3), o3), o3.push(s3.getCoordinates(e3)), i2(t3, [], h2, o3)), o3;
        o3.push(s3.getCoordinates(e3));
      }
      function a2(t3, e3) {
        var i3 = Math.min.apply(Math, t3), a3 = Math.max.apply(Math, t3), s3 = r2(t3);
        return Math.max(Math.pow(e3, 2) * a3 / Math.pow(s3, 2), Math.pow(s3, 2) / (Math.pow(e3, 2) * i3));
      }
      function s2(t3) {
        return t3 && t3.constructor === Array;
      }
      function r2(t3) {
        var e3, i3 = 0;
        for (e3 = 0; e3 < t3.length; e3++)
          i3 += t3[e3];
        return i3;
      }
      function o2(t3) {
        var e3, i3 = 0;
        if (s2(t3[0]))
          for (e3 = 0; e3 < t3.length; e3++)
            i3 += o2(t3[e3]);
        else
          i3 = r2(t3);
        return i3;
      }
      return function t3(i3, a3, r3, n2, l2) {
        n2 = void 0 === n2 ? 0 : n2, l2 = void 0 === l2 ? 0 : l2;
        var h2, c2, d2 = [], g2 = [];
        if (s2(i3[0])) {
          for (c2 = 0; c2 < i3.length; c2++)
            d2[c2] = o2(i3[c2]);
          for (h2 = e2(d2, a3, r3, n2, l2), c2 = 0; c2 < i3.length; c2++)
            g2.push(t3(i3[c2], h2[c2][2] - h2[c2][0], h2[c2][3] - h2[c2][1], h2[c2][0], h2[c2][1]));
        } else
          g2 = e2(i3, a3, r3, n2, l2);
        return g2;
      };
    }();
    var Rt;
    var Ht;
    var Dt = function() {
      function t2(e2, i2) {
        a(this, t2), this.ctx = e2, this.w = e2.w, this.strokeWidth = this.w.config.stroke.width, this.helpers = new At(e2), this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.labels = [];
      }
      return r(t2, [{ key: "draw", value: function(t3) {
        var e2 = this, i2 = this.w, a2 = new m(this.ctx), s2 = new R(this.ctx), r2 = a2.group({ class: "apexcharts-treemap" });
        if (i2.globals.noData)
          return r2;
        var o2 = [];
        return t3.forEach(function(t4) {
          var e3 = t4.map(function(t5) {
            return Math.abs(t5);
          });
          o2.push(e3);
        }), this.negRange = this.helpers.checkColorRange(), i2.config.series.forEach(function(t4, i3) {
          t4.data.forEach(function(t5) {
            Array.isArray(e2.labels[i3]) || (e2.labels[i3] = []), e2.labels[i3].push(t5.x);
          });
        }), window.TreemapSquared.generate(o2, i2.globals.gridWidth, i2.globals.gridHeight).forEach(function(o3, n2) {
          var l2 = a2.group({ class: "apexcharts-series apexcharts-treemap-series", seriesName: x.escapeString(i2.globals.seriesNames[n2]), rel: n2 + 1, "data:realIndex": n2 });
          if (i2.config.chart.dropShadow.enabled) {
            var h2 = i2.config.chart.dropShadow;
            new v(e2.ctx).dropShadow(r2, h2, n2);
          }
          var c2 = a2.group({ class: "apexcharts-data-labels" });
          o3.forEach(function(r3, o4) {
            var h3 = r3[0], c3 = r3[1], d2 = r3[2], g2 = r3[3], u2 = a2.drawRect(h3, c3, d2 - h3, g2 - c3, 0, "#fff", 1, e2.strokeWidth, i2.config.plotOptions.treemap.useFillColorAsStroke ? f2 : i2.globals.stroke.colors[n2]);
            u2.attr({ cx: h3, cy: c3, index: n2, i: n2, j: o4, width: d2 - h3, height: g2 - c3 });
            var p2 = e2.helpers.getShadeColor(i2.config.chart.type, n2, o4, e2.negRange), f2 = p2.color;
            void 0 !== i2.config.series[n2].data[o4] && i2.config.series[n2].data[o4].fillColor && (f2 = i2.config.series[n2].data[o4].fillColor);
            var x2 = s2.fillPath({ color: f2, seriesNumber: n2, dataPointIndex: o4 });
            u2.node.classList.add("apexcharts-treemap-rect"), u2.attr({ fill: x2 }), e2.helpers.addListeners(u2);
            var b2 = { x: h3 + (d2 - h3) / 2, y: c3 + (g2 - c3) / 2, width: 0, height: 0 }, v2 = { x: h3, y: c3, width: d2 - h3, height: g2 - c3 };
            if (i2.config.chart.animations.enabled && !i2.globals.dataChanged) {
              var m2 = 1;
              i2.globals.resized || (m2 = i2.config.chart.animations.speed), e2.animateTreemap(u2, b2, v2, m2);
            }
            if (i2.globals.dataChanged) {
              var y2 = 1;
              e2.dynamicAnim.enabled && i2.globals.shouldAnimate && (y2 = e2.dynamicAnim.speed, i2.globals.previousPaths[n2] && i2.globals.previousPaths[n2][o4] && i2.globals.previousPaths[n2][o4].rect && (b2 = i2.globals.previousPaths[n2][o4].rect), e2.animateTreemap(u2, b2, v2, y2));
            }
            var w2 = e2.getFontSize(r3), k2 = i2.config.dataLabels.formatter(e2.labels[n2][o4], { value: i2.globals.series[n2][o4], seriesIndex: n2, dataPointIndex: o4, w: i2 });
            "truncate" === i2.config.plotOptions.treemap.dataLabels.format && (w2 = parseInt(i2.config.dataLabels.style.fontSize, 10), k2 = e2.truncateLabels(k2, w2, h3, c3, d2, g2));
            var A2 = e2.helpers.calculateDataLabels({ text: k2, x: (h3 + d2) / 2, y: (c3 + g2) / 2 + e2.strokeWidth / 2 + w2 / 3, i: n2, j: o4, colorProps: p2, fontSize: w2, series: t3 });
            i2.config.dataLabels.enabled && A2 && e2.rotateToFitLabel(A2, w2, k2, h3, c3, d2, g2), l2.add(u2), null !== A2 && l2.add(A2);
          }), l2.add(c2), r2.add(l2);
        }), r2;
      } }, { key: "getFontSize", value: function(t3) {
        var e2 = this.w;
        var i2, a2, s2, r2, o2 = function t4(e3) {
          var i3, a3 = 0;
          if (Array.isArray(e3[0]))
            for (i3 = 0; i3 < e3.length; i3++)
              a3 += t4(e3[i3]);
          else
            for (i3 = 0; i3 < e3.length; i3++)
              a3 += e3[i3].length;
          return a3;
        }(this.labels) / function t4(e3) {
          var i3, a3 = 0;
          if (Array.isArray(e3[0]))
            for (i3 = 0; i3 < e3.length; i3++)
              a3 += t4(e3[i3]);
          else
            for (i3 = 0; i3 < e3.length; i3++)
              a3 += 1;
          return a3;
        }(this.labels);
        return i2 = t3[2] - t3[0], a2 = t3[3] - t3[1], s2 = i2 * a2, r2 = Math.pow(s2, 0.5), Math.min(r2 / o2, parseInt(e2.config.dataLabels.style.fontSize, 10));
      } }, { key: "rotateToFitLabel", value: function(t3, e2, i2, a2, s2, r2, o2) {
        var n2 = new m(this.ctx), l2 = n2.getTextRects(i2, e2);
        if (l2.width + this.w.config.stroke.width + 5 > r2 - a2 && l2.width <= o2 - s2) {
          var h2 = n2.rotateAroundCenter(t3.node);
          t3.node.setAttribute("transform", "rotate(-90 ".concat(h2.x, " ").concat(h2.y, ") translate(").concat(l2.height / 3, ")"));
        }
      } }, { key: "truncateLabels", value: function(t3, e2, i2, a2, s2, r2) {
        var o2 = new m(this.ctx), n2 = o2.getTextRects(t3, e2).width + this.w.config.stroke.width + 5 > s2 - i2 && r2 - a2 > s2 - i2 ? r2 - a2 : s2 - i2, l2 = o2.getTextBasedOnMaxWidth({ text: t3, maxWidth: n2, fontSize: e2 });
        return t3.length !== l2.length && n2 / e2 < 5 ? "" : l2;
      } }, { key: "animateTreemap", value: function(t3, e2, i2, a2) {
        var s2 = new b(this.ctx);
        s2.animateRect(t3, { x: e2.x, y: e2.y, width: e2.width, height: e2.height }, { x: i2.x, y: i2.y, width: i2.width, height: i2.height }, a2, function() {
          s2.animationCompleted(t3);
        });
      } }]), t2;
    }();
    var Ot = 86400;
    var Nt = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w, this.timeScaleArray = [], this.utc = this.w.config.xaxis.labels.datetimeUTC;
      }
      return r(t2, [{ key: "calculateTimeScaleTicks", value: function(t3, i2) {
        var a2 = this, s2 = this.w;
        if (s2.globals.allSeriesCollapsed)
          return s2.globals.labels = [], s2.globals.timescaleLabels = [], [];
        var r2 = new I(this.ctx), o2 = (i2 - t3) / 864e5;
        this.determineInterval(o2), s2.globals.disableZoomIn = false, s2.globals.disableZoomOut = false, o2 < 11574074074074075e-20 ? s2.globals.disableZoomIn = true : o2 > 5e4 && (s2.globals.disableZoomOut = true);
        var n2 = r2.getTimeUnitsfromTimestamp(t3, i2, this.utc), l2 = s2.globals.gridWidth / o2, h2 = l2 / 24, c2 = h2 / 60, d2 = c2 / 60, g2 = Math.floor(24 * o2), u2 = Math.floor(1440 * o2), p2 = Math.floor(o2 * Ot), f2 = Math.floor(o2), x2 = Math.floor(o2 / 30), b2 = Math.floor(o2 / 365), v2 = { minMillisecond: n2.minMillisecond, minSecond: n2.minSecond, minMinute: n2.minMinute, minHour: n2.minHour, minDate: n2.minDate, minMonth: n2.minMonth, minYear: n2.minYear }, m2 = { firstVal: v2, currentMillisecond: v2.minMillisecond, currentSecond: v2.minSecond, currentMinute: v2.minMinute, currentHour: v2.minHour, currentMonthDate: v2.minDate, currentDate: v2.minDate, currentMonth: v2.minMonth, currentYear: v2.minYear, daysWidthOnXAxis: l2, hoursWidthOnXAxis: h2, minutesWidthOnXAxis: c2, secondsWidthOnXAxis: d2, numberOfSeconds: p2, numberOfMinutes: u2, numberOfHours: g2, numberOfDays: f2, numberOfMonths: x2, numberOfYears: b2 };
        switch (this.tickInterval) {
          case "years":
            this.generateYearScale(m2);
            break;
          case "months":
          case "half_year":
            this.generateMonthScale(m2);
            break;
          case "months_days":
          case "months_fortnight":
          case "days":
          case "week_days":
            this.generateDayScale(m2);
            break;
          case "hours":
            this.generateHourScale(m2);
            break;
          case "minutes_fives":
          case "minutes":
            this.generateMinuteScale(m2);
            break;
          case "seconds_tens":
          case "seconds_fives":
          case "seconds":
            this.generateSecondScale(m2);
        }
        var y2 = this.timeScaleArray.map(function(t4) {
          var i3 = { position: t4.position, unit: t4.unit, year: t4.year, day: t4.day ? t4.day : 1, hour: t4.hour ? t4.hour : 0, month: t4.month + 1 };
          return "month" === t4.unit ? e(e({}, i3), {}, { day: 1, value: t4.value + 1 }) : "day" === t4.unit || "hour" === t4.unit ? e(e({}, i3), {}, { value: t4.value }) : "minute" === t4.unit ? e(e({}, i3), {}, { value: t4.value, minute: t4.value }) : "second" === t4.unit ? e(e({}, i3), {}, { value: t4.value, minute: t4.minute, second: t4.second }) : t4;
        });
        return y2.filter(function(t4) {
          var e2 = 1, i3 = Math.ceil(s2.globals.gridWidth / 120), r3 = t4.value;
          void 0 !== s2.config.xaxis.tickAmount && (i3 = s2.config.xaxis.tickAmount), y2.length > i3 && (e2 = Math.floor(y2.length / i3));
          var o3 = false, n3 = false;
          switch (a2.tickInterval) {
            case "years":
              "year" === t4.unit && (o3 = true);
              break;
            case "half_year":
              e2 = 7, "year" === t4.unit && (o3 = true);
              break;
            case "months":
              e2 = 1, "year" === t4.unit && (o3 = true);
              break;
            case "months_fortnight":
              e2 = 15, "year" !== t4.unit && "month" !== t4.unit || (o3 = true), 30 === r3 && (n3 = true);
              break;
            case "months_days":
              e2 = 10, "month" === t4.unit && (o3 = true), 30 === r3 && (n3 = true);
              break;
            case "week_days":
              e2 = 8, "month" === t4.unit && (o3 = true);
              break;
            case "days":
              e2 = 1, "month" === t4.unit && (o3 = true);
              break;
            case "hours":
              "day" === t4.unit && (o3 = true);
              break;
            case "minutes_fives":
            case "seconds_fives":
              r3 % 5 != 0 && (n3 = true);
              break;
            case "seconds_tens":
              r3 % 10 != 0 && (n3 = true);
          }
          if ("hours" === a2.tickInterval || "minutes_fives" === a2.tickInterval || "seconds_tens" === a2.tickInterval || "seconds_fives" === a2.tickInterval) {
            if (!n3)
              return true;
          } else if ((r3 % e2 == 0 || o3) && !n3)
            return true;
        });
      } }, { key: "recalcDimensionsBasedOnFormat", value: function(t3, e2) {
        var i2 = this.w, a2 = this.formatDates(t3), s2 = this.removeOverlappingTS(a2);
        i2.globals.timescaleLabels = s2.slice(), new ot(this.ctx).plotCoords();
      } }, { key: "determineInterval", value: function(t3) {
        var e2 = 24 * t3, i2 = 60 * e2;
        switch (true) {
          case t3 / 365 > 5:
            this.tickInterval = "years";
            break;
          case t3 > 800:
            this.tickInterval = "half_year";
            break;
          case t3 > 180:
            this.tickInterval = "months";
            break;
          case t3 > 90:
            this.tickInterval = "months_fortnight";
            break;
          case t3 > 60:
            this.tickInterval = "months_days";
            break;
          case t3 > 30:
            this.tickInterval = "week_days";
            break;
          case t3 > 2:
            this.tickInterval = "days";
            break;
          case e2 > 2.4:
            this.tickInterval = "hours";
            break;
          case i2 > 15:
            this.tickInterval = "minutes_fives";
            break;
          case i2 > 5:
            this.tickInterval = "minutes";
            break;
          case i2 > 1:
            this.tickInterval = "seconds_tens";
            break;
          case 60 * i2 > 20:
            this.tickInterval = "seconds_fives";
            break;
          default:
            this.tickInterval = "seconds";
        }
      } }, { key: "generateYearScale", value: function(t3) {
        var e2 = t3.firstVal, i2 = t3.currentMonth, a2 = t3.currentYear, s2 = t3.daysWidthOnXAxis, r2 = t3.numberOfYears, o2 = e2.minYear, n2 = 0, l2 = new I(this.ctx), h2 = "year";
        if (e2.minDate > 1 || e2.minMonth > 0) {
          var c2 = l2.determineRemainingDaysOfYear(e2.minYear, e2.minMonth, e2.minDate);
          n2 = (l2.determineDaysOfYear(e2.minYear) - c2 + 1) * s2, o2 = e2.minYear + 1, this.timeScaleArray.push({ position: n2, value: o2, unit: h2, year: o2, month: x.monthMod(i2 + 1) });
        } else
          1 === e2.minDate && 0 === e2.minMonth && this.timeScaleArray.push({ position: n2, value: o2, unit: h2, year: a2, month: x.monthMod(i2 + 1) });
        for (var d2 = o2, g2 = n2, u2 = 0; u2 < r2; u2++)
          d2++, g2 = l2.determineDaysOfYear(d2 - 1) * s2 + g2, this.timeScaleArray.push({ position: g2, value: d2, unit: h2, year: d2, month: 1 });
      } }, { key: "generateMonthScale", value: function(t3) {
        var e2 = t3.firstVal, i2 = t3.currentMonthDate, a2 = t3.currentMonth, s2 = t3.currentYear, r2 = t3.daysWidthOnXAxis, o2 = t3.numberOfMonths, n2 = a2, l2 = 0, h2 = new I(this.ctx), c2 = "month", d2 = 0;
        if (e2.minDate > 1) {
          l2 = (h2.determineDaysOfMonths(a2 + 1, e2.minYear) - i2 + 1) * r2, n2 = x.monthMod(a2 + 1);
          var g2 = s2 + d2, u2 = x.monthMod(n2), p2 = n2;
          0 === n2 && (c2 = "year", p2 = g2, u2 = 1, g2 += d2 += 1), this.timeScaleArray.push({ position: l2, value: p2, unit: c2, year: g2, month: u2 });
        } else
          this.timeScaleArray.push({ position: l2, value: n2, unit: c2, year: s2, month: x.monthMod(a2) });
        for (var f2 = n2 + 1, b2 = l2, v2 = 0, m2 = 1; v2 < o2; v2++, m2++) {
          0 === (f2 = x.monthMod(f2)) ? (c2 = "year", d2 += 1) : c2 = "month";
          var y2 = this._getYear(s2, f2, d2);
          b2 = h2.determineDaysOfMonths(f2, y2) * r2 + b2;
          var w2 = 0 === f2 ? y2 : f2;
          this.timeScaleArray.push({ position: b2, value: w2, unit: c2, year: y2, month: 0 === f2 ? 1 : f2 }), f2++;
        }
      } }, { key: "generateDayScale", value: function(t3) {
        var e2 = t3.firstVal, i2 = t3.currentMonth, a2 = t3.currentYear, s2 = t3.hoursWidthOnXAxis, r2 = t3.numberOfDays, o2 = new I(this.ctx), n2 = "day", l2 = e2.minDate + 1, h2 = l2, c2 = function(t4, e3, i3) {
          return t4 > o2.determineDaysOfMonths(e3 + 1, i3) ? (h2 = 1, n2 = "month", g2 = e3 += 1, e3) : e3;
        }, d2 = (24 - e2.minHour) * s2, g2 = l2, u2 = c2(h2, i2, a2);
        0 === e2.minHour && 1 === e2.minDate ? (d2 = 0, g2 = x.monthMod(e2.minMonth), n2 = "month", h2 = e2.minDate) : 1 !== e2.minDate && 0 === e2.minHour && 0 === e2.minMinute && (d2 = 0, l2 = e2.minDate, g2 = l2, u2 = c2(h2 = l2, i2, a2)), this.timeScaleArray.push({ position: d2, value: g2, unit: n2, year: this._getYear(a2, u2, 0), month: x.monthMod(u2), day: h2 });
        for (var p2 = d2, f2 = 0; f2 < r2; f2++) {
          n2 = "day", u2 = c2(h2 += 1, u2, this._getYear(a2, u2, 0));
          var b2 = this._getYear(a2, u2, 0);
          p2 = 24 * s2 + p2;
          var v2 = 1 === h2 ? x.monthMod(u2) : h2;
          this.timeScaleArray.push({ position: p2, value: v2, unit: n2, year: b2, month: x.monthMod(u2), day: v2 });
        }
      } }, { key: "generateHourScale", value: function(t3) {
        var e2 = t3.firstVal, i2 = t3.currentDate, a2 = t3.currentMonth, s2 = t3.currentYear, r2 = t3.minutesWidthOnXAxis, o2 = t3.numberOfHours, n2 = new I(this.ctx), l2 = "hour", h2 = function(t4, e3) {
          return t4 > n2.determineDaysOfMonths(e3 + 1, s2) && (f2 = 1, e3 += 1), { month: e3, date: f2 };
        }, c2 = function(t4, e3) {
          return t4 > n2.determineDaysOfMonths(e3 + 1, s2) ? e3 += 1 : e3;
        }, d2 = 60 - (e2.minMinute + e2.minSecond / 60), g2 = d2 * r2, u2 = e2.minHour + 1, p2 = u2;
        60 === d2 && (g2 = 0, p2 = (u2 = e2.minHour) + 1);
        var f2 = i2;
        p2 >= 24 && (p2 = 0, f2 += 1, l2 = "day");
        var b2 = h2(f2, a2).month;
        b2 = c2(f2, b2), this.timeScaleArray.push({ position: g2, value: u2, unit: l2, day: f2, hour: p2, year: s2, month: x.monthMod(b2) }), p2++;
        for (var v2 = g2, m2 = 0; m2 < o2; m2++) {
          if (l2 = "hour", p2 >= 24)
            p2 = 0, l2 = "day", b2 = h2(f2 += 1, b2).month, b2 = c2(f2, b2);
          var y2 = this._getYear(s2, b2, 0);
          v2 = 60 * r2 + v2;
          var w2 = 0 === p2 ? f2 : p2;
          this.timeScaleArray.push({ position: v2, value: w2, unit: l2, hour: p2, day: f2, year: y2, month: x.monthMod(b2) }), p2++;
        }
      } }, { key: "generateMinuteScale", value: function(t3) {
        for (var e2 = t3.currentMillisecond, i2 = t3.currentSecond, a2 = t3.currentMinute, s2 = t3.currentHour, r2 = t3.currentDate, o2 = t3.currentMonth, n2 = t3.currentYear, l2 = t3.minutesWidthOnXAxis, h2 = t3.secondsWidthOnXAxis, c2 = t3.numberOfMinutes, d2 = a2 + 1, g2 = r2, u2 = o2, p2 = n2, f2 = s2, b2 = (60 - i2 - e2 / 1e3) * h2, v2 = 0; v2 < c2; v2++)
          d2 >= 60 && (d2 = 0, 24 === (f2 += 1) && (f2 = 0)), this.timeScaleArray.push({ position: b2, value: d2, unit: "minute", hour: f2, minute: d2, day: g2, year: this._getYear(p2, u2, 0), month: x.monthMod(u2) }), b2 += l2, d2++;
      } }, { key: "generateSecondScale", value: function(t3) {
        for (var e2 = t3.currentMillisecond, i2 = t3.currentSecond, a2 = t3.currentMinute, s2 = t3.currentHour, r2 = t3.currentDate, o2 = t3.currentMonth, n2 = t3.currentYear, l2 = t3.secondsWidthOnXAxis, h2 = t3.numberOfSeconds, c2 = i2 + 1, d2 = a2, g2 = r2, u2 = o2, p2 = n2, f2 = s2, b2 = (1e3 - e2) / 1e3 * l2, v2 = 0; v2 < h2; v2++)
          c2 >= 60 && (c2 = 0, ++d2 >= 60 && (d2 = 0, 24 === ++f2 && (f2 = 0))), this.timeScaleArray.push({ position: b2, value: c2, unit: "second", hour: f2, minute: d2, second: c2, day: g2, year: this._getYear(p2, u2, 0), month: x.monthMod(u2) }), b2 += l2, c2++;
      } }, { key: "createRawDateString", value: function(t3, e2) {
        var i2 = t3.year;
        return 0 === t3.month && (t3.month = 1), i2 += "-" + ("0" + t3.month.toString()).slice(-2), "day" === t3.unit ? i2 += "day" === t3.unit ? "-" + ("0" + e2).slice(-2) : "-01" : i2 += "-" + ("0" + (t3.day ? t3.day : "1")).slice(-2), "hour" === t3.unit ? i2 += "hour" === t3.unit ? "T" + ("0" + e2).slice(-2) : "T00" : i2 += "T" + ("0" + (t3.hour ? t3.hour : "0")).slice(-2), "minute" === t3.unit ? i2 += ":" + ("0" + e2).slice(-2) : i2 += ":" + (t3.minute ? ("0" + t3.minute).slice(-2) : "00"), "second" === t3.unit ? i2 += ":" + ("0" + e2).slice(-2) : i2 += ":00", this.utc && (i2 += ".000Z"), i2;
      } }, { key: "formatDates", value: function(t3) {
        var e2 = this, i2 = this.w;
        return t3.map(function(t4) {
          var a2 = t4.value.toString(), s2 = new I(e2.ctx), r2 = e2.createRawDateString(t4, a2), o2 = s2.getDate(s2.parseDate(r2));
          if (e2.utc || (o2 = s2.getDate(s2.parseDateWithTimezone(r2))), void 0 === i2.config.xaxis.labels.format) {
            var n2 = "dd MMM", l2 = i2.config.xaxis.labels.datetimeFormatter;
            "year" === t4.unit && (n2 = l2.year), "month" === t4.unit && (n2 = l2.month), "day" === t4.unit && (n2 = l2.day), "hour" === t4.unit && (n2 = l2.hour), "minute" === t4.unit && (n2 = l2.minute), "second" === t4.unit && (n2 = l2.second), a2 = s2.formatDate(o2, n2);
          } else
            a2 = s2.formatDate(o2, i2.config.xaxis.labels.format);
          return { dateString: r2, position: t4.position, value: a2, unit: t4.unit, year: t4.year, month: t4.month };
        });
      } }, { key: "removeOverlappingTS", value: function(t3) {
        var e2, i2 = this, a2 = new m(this.ctx), s2 = false;
        t3.length > 0 && t3[0].value && t3.every(function(e3) {
          return e3.value.length === t3[0].value.length;
        }) && (s2 = true, e2 = a2.getTextRects(t3[0].value).width);
        var r2 = 0, o2 = t3.map(function(o3, n2) {
          if (n2 > 0 && i2.w.config.xaxis.labels.hideOverlappingLabels) {
            var l2 = s2 ? e2 : a2.getTextRects(t3[r2].value).width, h2 = t3[r2].position;
            return o3.position > h2 + l2 + 10 ? (r2 = n2, o3) : null;
          }
          return o3;
        });
        return o2 = o2.filter(function(t4) {
          return null !== t4;
        });
      } }, { key: "_getYear", value: function(t3, e2, i2) {
        return t3 + Math.floor(e2 / 12) + i2;
      } }]), t2;
    }();
    var Wt = function() {
      function t2(e2, i2) {
        a(this, t2), this.ctx = i2, this.w = i2.w, this.el = e2;
      }
      return r(t2, [{ key: "setupElements", value: function() {
        var t3 = this.w.globals, e2 = this.w.config, i2 = e2.chart.type;
        t3.axisCharts = ["line", "area", "bar", "rangeBar", "rangeArea", "candlestick", "boxPlot", "scatter", "bubble", "radar", "heatmap", "treemap"].indexOf(i2) > -1, t3.xyCharts = ["line", "area", "bar", "rangeBar", "rangeArea", "candlestick", "boxPlot", "scatter", "bubble"].indexOf(i2) > -1, t3.isBarHorizontal = ("bar" === e2.chart.type || "rangeBar" === e2.chart.type || "boxPlot" === e2.chart.type) && e2.plotOptions.bar.horizontal, t3.chartClass = ".apexcharts" + t3.chartID, t3.dom.baseEl = this.el, t3.dom.elWrap = document.createElement("div"), m.setAttrs(t3.dom.elWrap, { id: t3.chartClass.substring(1), class: "apexcharts-canvas " + t3.chartClass.substring(1) }), this.el.appendChild(t3.dom.elWrap), t3.dom.Paper = new window.SVG.Doc(t3.dom.elWrap), t3.dom.Paper.attr({ class: "apexcharts-svg", "xmlns:data": "ApexChartsNS", transform: "translate(".concat(e2.chart.offsetX, ", ").concat(e2.chart.offsetY, ")") }), t3.dom.Paper.node.style.background = "dark" === e2.theme.mode && "transparent" === e2.chart.background ? "rgba(0, 0, 0, 0.8)" : e2.chart.background, this.setSVGDimensions(), t3.dom.elLegendForeign = document.createElementNS(t3.SVGNS, "foreignObject"), m.setAttrs(t3.dom.elLegendForeign, { x: 0, y: 0, width: t3.svgWidth, height: t3.svgHeight }), t3.dom.elLegendWrap = document.createElement("div"), t3.dom.elLegendWrap.classList.add("apexcharts-legend"), t3.dom.elLegendWrap.setAttribute("xmlns", "http://www.w3.org/1999/xhtml"), t3.dom.elLegendForeign.appendChild(t3.dom.elLegendWrap), t3.dom.Paper.node.appendChild(t3.dom.elLegendForeign), t3.dom.elGraphical = t3.dom.Paper.group().attr({ class: "apexcharts-inner apexcharts-graphical" }), t3.dom.elDefs = t3.dom.Paper.defs(), t3.dom.Paper.add(t3.dom.elGraphical), t3.dom.elGraphical.add(t3.dom.elDefs);
      } }, { key: "plotChartType", value: function(t3, e2) {
        var i2 = this.w, a2 = i2.config, s2 = i2.globals, r2 = { series: [], i: [] }, o2 = { series: [], i: [] }, n2 = { series: [], i: [] }, l2 = { series: [], i: [] }, h2 = { series: [], i: [] }, c2 = { series: [], i: [] }, d2 = { series: [], i: [] }, g2 = { series: [], i: [] }, u2 = { series: [], seriesRangeEnd: [], i: [] };
        s2.series.map(function(e3, p3) {
          var f3 = 0;
          void 0 !== t3[p3].type ? ("column" === t3[p3].type || "bar" === t3[p3].type ? (s2.series.length > 1 && a2.plotOptions.bar.horizontal && console.warn("Horizontal bars are not supported in a mixed/combo chart. Please turn off `plotOptions.bar.horizontal`"), h2.series.push(e3), h2.i.push(p3), f3++, i2.globals.columnSeries = h2.series) : "area" === t3[p3].type ? (o2.series.push(e3), o2.i.push(p3), f3++) : "line" === t3[p3].type ? (r2.series.push(e3), r2.i.push(p3), f3++) : "scatter" === t3[p3].type ? (n2.series.push(e3), n2.i.push(p3)) : "bubble" === t3[p3].type ? (l2.series.push(e3), l2.i.push(p3), f3++) : "candlestick" === t3[p3].type ? (c2.series.push(e3), c2.i.push(p3), f3++) : "boxPlot" === t3[p3].type ? (d2.series.push(e3), d2.i.push(p3), f3++) : "rangeBar" === t3[p3].type ? (g2.series.push(e3), g2.i.push(p3), f3++) : "rangeArea" === t3[p3].type ? (u2.series.push(s2.seriesRangeStart[p3]), u2.seriesRangeEnd.push(s2.seriesRangeEnd[p3]), u2.i.push(p3), f3++) : console.warn("You have specified an unrecognized chart type. Available types for this property are line/area/column/bar/scatter/bubble/candlestick/boxPlot/rangeBar/rangeArea"), f3 > 1 && (s2.comboCharts = true)) : (r2.series.push(e3), r2.i.push(p3));
        });
        var p2 = new Ft(this.ctx, e2), f2 = new kt(this.ctx, e2);
        this.ctx.pie = new Lt(this.ctx);
        var x2 = new It(this.ctx);
        this.ctx.rangeBar = new Tt(this.ctx, e2);
        var b2 = new Pt(this.ctx), v2 = [];
        if (s2.comboCharts) {
          if (o2.series.length > 0 && v2.push(p2.draw(o2.series, "area", o2.i)), h2.series.length > 0)
            if (i2.config.chart.stacked) {
              var m2 = new wt(this.ctx, e2);
              v2.push(m2.draw(h2.series, h2.i));
            } else
              this.ctx.bar = new yt(this.ctx, e2), v2.push(this.ctx.bar.draw(h2.series, h2.i));
          if (u2.series.length > 0 && v2.push(p2.draw(u2.series, "rangeArea", u2.i, u2.seriesRangeEnd)), r2.series.length > 0 && v2.push(p2.draw(r2.series, "line", r2.i)), c2.series.length > 0 && v2.push(f2.draw(c2.series, "candlestick", c2.i)), d2.series.length > 0 && v2.push(f2.draw(d2.series, "boxPlot", d2.i)), g2.series.length > 0 && v2.push(this.ctx.rangeBar.draw(g2.series, g2.i)), n2.series.length > 0) {
            var y2 = new Ft(this.ctx, e2, true);
            v2.push(y2.draw(n2.series, "scatter", n2.i));
          }
          if (l2.series.length > 0) {
            var w2 = new Ft(this.ctx, e2, true);
            v2.push(w2.draw(l2.series, "bubble", l2.i));
          }
        } else
          switch (a2.chart.type) {
            case "line":
              v2 = p2.draw(s2.series, "line");
              break;
            case "area":
              v2 = p2.draw(s2.series, "area");
              break;
            case "bar":
              if (a2.chart.stacked)
                v2 = new wt(this.ctx, e2).draw(s2.series);
              else
                this.ctx.bar = new yt(this.ctx, e2), v2 = this.ctx.bar.draw(s2.series);
              break;
            case "candlestick":
              v2 = new kt(this.ctx, e2).draw(s2.series, "candlestick");
              break;
            case "boxPlot":
              v2 = new kt(this.ctx, e2).draw(s2.series, a2.chart.type);
              break;
            case "rangeBar":
              v2 = this.ctx.rangeBar.draw(s2.series);
              break;
            case "rangeArea":
              v2 = p2.draw(s2.seriesRangeStart, "rangeArea", void 0, s2.seriesRangeEnd);
              break;
            case "heatmap":
              v2 = new St(this.ctx, e2).draw(s2.series);
              break;
            case "treemap":
              v2 = new Dt(this.ctx, e2).draw(s2.series);
              break;
            case "pie":
            case "donut":
            case "polarArea":
              v2 = this.ctx.pie.draw(s2.series);
              break;
            case "radialBar":
              v2 = x2.draw(s2.series);
              break;
            case "radar":
              v2 = b2.draw(s2.series);
              break;
            default:
              v2 = p2.draw(s2.series);
          }
        return v2;
      } }, { key: "setSVGDimensions", value: function() {
        var t3 = this.w.globals, e2 = this.w.config;
        t3.svgWidth = e2.chart.width, t3.svgHeight = e2.chart.height;
        var i2 = x.getDimensions(this.el), a2 = e2.chart.width.toString().split(/[0-9]+/g).pop();
        "%" === a2 ? x.isNumber(i2[0]) && (0 === i2[0].width && (i2 = x.getDimensions(this.el.parentNode)), t3.svgWidth = i2[0] * parseInt(e2.chart.width, 10) / 100) : "px" !== a2 && "" !== a2 || (t3.svgWidth = parseInt(e2.chart.width, 10));
        var s2 = e2.chart.height.toString().split(/[0-9]+/g).pop();
        if ("auto" !== t3.svgHeight && "" !== t3.svgHeight)
          if ("%" === s2) {
            var r2 = x.getDimensions(this.el.parentNode);
            t3.svgHeight = r2[1] * parseInt(e2.chart.height, 10) / 100;
          } else
            t3.svgHeight = parseInt(e2.chart.height, 10);
        else
          t3.axisCharts ? t3.svgHeight = t3.svgWidth / 1.61 : t3.svgHeight = t3.svgWidth / 1.2;
        if (t3.svgWidth < 0 && (t3.svgWidth = 0), t3.svgHeight < 0 && (t3.svgHeight = 0), m.setAttrs(t3.dom.Paper.node, { width: t3.svgWidth, height: t3.svgHeight }), "%" !== s2) {
          var o2 = e2.chart.sparkline.enabled ? 0 : t3.axisCharts ? e2.chart.parentHeightOffset : 0;
          t3.dom.Paper.node.parentNode.parentNode.style.minHeight = t3.svgHeight + o2 + "px";
        }
        t3.dom.elWrap.style.width = t3.svgWidth + "px", t3.dom.elWrap.style.height = t3.svgHeight + "px";
      } }, { key: "shiftGraphPosition", value: function() {
        var t3 = this.w.globals, e2 = t3.translateY, i2 = { transform: "translate(" + t3.translateX + ", " + e2 + ")" };
        m.setAttrs(t3.dom.elGraphical.node, i2);
      } }, { key: "resizeNonAxisCharts", value: function() {
        var t3 = this.w, e2 = t3.globals, i2 = 0, a2 = t3.config.chart.sparkline.enabled ? 1 : 15;
        a2 += t3.config.grid.padding.bottom, "top" !== t3.config.legend.position && "bottom" !== t3.config.legend.position || !t3.config.legend.show || t3.config.legend.floating || (i2 = new lt(this.ctx).legendHelpers.getLegendBBox().clwh + 10);
        var s2 = t3.globals.dom.baseEl.querySelector(".apexcharts-radialbar, .apexcharts-pie"), r2 = 2.05 * t3.globals.radialSize;
        if (s2 && !t3.config.chart.sparkline.enabled && 0 !== t3.config.plotOptions.radialBar.startAngle) {
          var o2 = x.getBoundingClientRect(s2);
          r2 = o2.bottom;
          var n2 = o2.bottom - o2.top;
          r2 = Math.max(2.05 * t3.globals.radialSize, n2);
        }
        var l2 = r2 + e2.translateY + i2 + a2;
        e2.dom.elLegendForeign && e2.dom.elLegendForeign.setAttribute("height", l2), t3.config.chart.height && String(t3.config.chart.height).indexOf("%") > 0 || (e2.dom.elWrap.style.height = l2 + "px", m.setAttrs(e2.dom.Paper.node, { height: l2 }), e2.dom.Paper.node.parentNode.parentNode.style.minHeight = l2 + "px");
      } }, { key: "coreCalculations", value: function() {
        new U(this.ctx).init();
      } }, { key: "resetGlobals", value: function() {
        var t3 = this, e2 = function() {
          return t3.w.config.series.map(function(t4) {
            return [];
          });
        }, i2 = new Y(), a2 = this.w.globals;
        i2.initGlobalVars(a2), a2.seriesXvalues = e2(), a2.seriesYvalues = e2();
      } }, { key: "isMultipleY", value: function() {
        if (this.w.config.yaxis.constructor === Array && this.w.config.yaxis.length > 1)
          return this.w.globals.isMultipleYAxis = true, true;
      } }, { key: "xySettings", value: function() {
        var t3 = null, e2 = this.w;
        if (e2.globals.axisCharts) {
          if ("back" === e2.config.xaxis.crosshairs.position)
            new Q(this.ctx).drawXCrosshairs();
          if ("back" === e2.config.yaxis[0].crosshairs.position)
            new Q(this.ctx).drawYCrosshairs();
          if ("datetime" === e2.config.xaxis.type && void 0 === e2.config.xaxis.labels.formatter) {
            this.ctx.timeScale = new Nt(this.ctx);
            var i2 = [];
            isFinite(e2.globals.minX) && isFinite(e2.globals.maxX) && !e2.globals.isBarHorizontal ? i2 = this.ctx.timeScale.calculateTimeScaleTicks(e2.globals.minX, e2.globals.maxX) : e2.globals.isBarHorizontal && (i2 = this.ctx.timeScale.calculateTimeScaleTicks(e2.globals.minY, e2.globals.maxY)), this.ctx.timeScale.recalcDimensionsBasedOnFormat(i2);
          }
          t3 = new y(this.ctx).getCalculatedRatios();
        }
        return t3;
      } }, { key: "updateSourceChart", value: function(t3) {
        this.ctx.w.globals.selection = void 0, this.ctx.updateHelpers._updateOptions({ chart: { selection: { xaxis: { min: t3.w.globals.minX, max: t3.w.globals.maxX } } } }, false, false);
      } }, { key: "setupBrushHandler", value: function() {
        var t3 = this, i2 = this.w;
        if (i2.config.chart.brush.enabled && "function" != typeof i2.config.chart.events.selection) {
          var a2 = Array.isArray(i2.config.chart.brush.targets) || [i2.config.chart.brush.target];
          a2.forEach(function(e2) {
            var i3 = ApexCharts.getChartByID(e2);
            i3.w.globals.brushSource = t3.ctx, "function" != typeof i3.w.config.chart.events.zoomed && (i3.w.config.chart.events.zoomed = function() {
              t3.updateSourceChart(i3);
            }), "function" != typeof i3.w.config.chart.events.scrolled && (i3.w.config.chart.events.scrolled = function() {
              t3.updateSourceChart(i3);
            });
          }), i2.config.chart.events.selection = function(t4, s2) {
            a2.forEach(function(t5) {
              var a3 = ApexCharts.getChartByID(t5), r2 = x.clone(i2.config.yaxis);
              if (i2.config.chart.brush.autoScaleYaxis && 1 === a3.w.globals.series.length) {
                var o2 = new _(a3);
                r2 = o2.autoScaleY(a3, r2, s2);
              }
              var n2 = a3.w.config.yaxis.reduce(function(t6, i3, s3) {
                return [].concat(u(t6), [e(e({}, a3.w.config.yaxis[s3]), {}, { min: r2[0].min, max: r2[0].max })]);
              }, []);
              a3.ctx.updateHelpers._updateOptions({ xaxis: { min: s2.xaxis.min, max: s2.xaxis.max }, yaxis: n2 }, false, false, false, false);
            });
          };
        }
      } }]), t2;
    }();
    var Bt = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
      }
      return r(t2, [{ key: "_updateOptions", value: function(t3) {
        var e2 = this, a2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], s2 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], r2 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3], o2 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
        return new Promise(function(n2) {
          var l2 = [e2.ctx];
          r2 && (l2 = e2.ctx.getSyncedCharts()), e2.ctx.w.globals.isExecCalled && (l2 = [e2.ctx], e2.ctx.w.globals.isExecCalled = false), l2.forEach(function(r3, h2) {
            var c2 = r3.w;
            if (c2.globals.shouldAnimate = s2, a2 || (c2.globals.resized = true, c2.globals.dataChanged = true, s2 && r3.series.getPreviousPaths()), t3 && "object" === i(t3) && (r3.config = new E(t3), t3 = y.extendArrayProps(r3.config, t3, c2), r3.w.globals.chartID !== e2.ctx.w.globals.chartID && delete t3.series, c2.config = x.extend(c2.config, t3), o2 && (c2.globals.lastXAxis = t3.xaxis ? x.clone(t3.xaxis) : [], c2.globals.lastYAxis = t3.yaxis ? x.clone(t3.yaxis) : [], c2.globals.initialConfig = x.extend({}, c2.config), c2.globals.initialSeries = x.clone(c2.config.series), t3.series))) {
              for (var d2 = 0; d2 < c2.globals.collapsedSeriesIndices.length; d2++) {
                var g2 = c2.config.series[c2.globals.collapsedSeriesIndices[d2]];
                c2.globals.collapsedSeries[d2].data = c2.globals.axisCharts ? g2.data.slice() : g2;
              }
              for (var u2 = 0; u2 < c2.globals.ancillaryCollapsedSeriesIndices.length; u2++) {
                var p2 = c2.config.series[c2.globals.ancillaryCollapsedSeriesIndices[u2]];
                c2.globals.ancillaryCollapsedSeries[u2].data = c2.globals.axisCharts ? p2.data.slice() : p2;
              }
              r3.series.emptyCollapsedSeries(c2.config.series);
            }
            return r3.update(t3).then(function() {
              h2 === l2.length - 1 && n2(r3);
            });
          });
        });
      } }, { key: "_updateSeries", value: function(t3, e2) {
        var i2 = this, a2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        return new Promise(function(s2) {
          var r2, o2 = i2.w;
          return o2.globals.shouldAnimate = e2, o2.globals.dataChanged = true, e2 && i2.ctx.series.getPreviousPaths(), o2.globals.axisCharts ? (0 === (r2 = t3.map(function(t4, e3) {
            return i2._extendSeries(t4, e3);
          })).length && (r2 = [{ data: [] }]), o2.config.series = r2) : o2.config.series = t3.slice(), a2 && (o2.globals.initialConfig.series = x.clone(o2.config.series), o2.globals.initialSeries = x.clone(o2.config.series)), i2.ctx.update().then(function() {
            s2(i2.ctx);
          });
        });
      } }, { key: "_extendSeries", value: function(t3, i2) {
        var a2 = this.w, s2 = a2.config.series[i2];
        return e(e({}, a2.config.series[i2]), {}, { name: t3.name ? t3.name : s2 && s2.name, color: t3.color ? t3.color : s2 && s2.color, type: t3.type ? t3.type : s2 && s2.type, group: t3.group ? t3.group : s2 && s2.group, data: t3.data ? t3.data : s2 && s2.data });
      } }, { key: "toggleDataPointSelection", value: function(t3, e2) {
        var i2 = this.w, a2 = null, s2 = ".apexcharts-series[data\\:realIndex='".concat(t3, "']");
        return i2.globals.axisCharts ? a2 = i2.globals.dom.Paper.select("".concat(s2, " path[j='").concat(e2, "'], ").concat(s2, " circle[j='").concat(e2, "'], ").concat(s2, " rect[j='").concat(e2, "']")).members[0] : void 0 === e2 && (a2 = i2.globals.dom.Paper.select("".concat(s2, " path[j='").concat(t3, "']")).members[0], "pie" !== i2.config.chart.type && "polarArea" !== i2.config.chart.type && "donut" !== i2.config.chart.type || this.ctx.pie.pieClicked(t3)), a2 ? (new m(this.ctx).pathMouseDown(a2, null), a2.node ? a2.node : null) : (console.warn("toggleDataPointSelection: Element not found"), null);
      } }, { key: "forceXAxisUpdate", value: function(t3) {
        var e2 = this.w;
        if (["min", "max"].forEach(function(i3) {
          void 0 !== t3.xaxis[i3] && (e2.config.xaxis[i3] = t3.xaxis[i3], e2.globals.lastXAxis[i3] = t3.xaxis[i3]);
        }), t3.xaxis.categories && t3.xaxis.categories.length && (e2.config.xaxis.categories = t3.xaxis.categories), e2.config.xaxis.convertedCatToNumeric) {
          var i2 = new X(t3);
          t3 = i2.convertCatToNumericXaxis(t3, this.ctx);
        }
        return t3;
      } }, { key: "forceYAxisUpdate", value: function(t3) {
        return t3.chart && t3.chart.stacked && "100%" === t3.chart.stackType && (Array.isArray(t3.yaxis) ? t3.yaxis.forEach(function(e2, i2) {
          t3.yaxis[i2].min = 0, t3.yaxis[i2].max = 100;
        }) : (t3.yaxis.min = 0, t3.yaxis.max = 100)), t3;
      } }, { key: "revertDefaultAxisMinMax", value: function(t3) {
        var e2 = this, i2 = this.w, a2 = i2.globals.lastXAxis, s2 = i2.globals.lastYAxis;
        t3 && t3.xaxis && (a2 = t3.xaxis), t3 && t3.yaxis && (s2 = t3.yaxis), i2.config.xaxis.min = a2.min, i2.config.xaxis.max = a2.max;
        var r2 = function(t4) {
          void 0 !== s2[t4] && (i2.config.yaxis[t4].min = s2[t4].min, i2.config.yaxis[t4].max = s2[t4].max);
        };
        i2.config.yaxis.map(function(t4, a3) {
          i2.globals.zoomed || void 0 !== s2[a3] ? r2(a3) : void 0 !== e2.ctx.opts.yaxis[a3] && (t4.min = e2.ctx.opts.yaxis[a3].min, t4.max = e2.ctx.opts.yaxis[a3].max);
        });
      } }]), t2;
    }();
    Rt = "undefined" != typeof window ? window : void 0, Ht = function(t2, e2) {
      var a2 = (void 0 !== this ? this : t2).SVG = function(t3) {
        if (a2.supported)
          return t3 = new a2.Doc(t3), a2.parser.draw || a2.prepare(), t3;
      };
      if (a2.ns = "http://www.w3.org/2000/svg", a2.xmlns = "http://www.w3.org/2000/xmlns/", a2.xlink = "http://www.w3.org/1999/xlink", a2.svgjs = "http://svgjs.dev", a2.supported = true, !a2.supported)
        return false;
      a2.did = 1e3, a2.eid = function(t3) {
        return "Svgjs" + d2(t3) + a2.did++;
      }, a2.create = function(t3) {
        var i2 = e2.createElementNS(this.ns, t3);
        return i2.setAttribute("id", this.eid(t3)), i2;
      }, a2.extend = function() {
        var t3, e3;
        e3 = (t3 = [].slice.call(arguments)).pop();
        for (var i2 = t3.length - 1; i2 >= 0; i2--)
          if (t3[i2])
            for (var s3 in e3)
              t3[i2].prototype[s3] = e3[s3];
        a2.Set && a2.Set.inherit && a2.Set.inherit();
      }, a2.invent = function(t3) {
        var e3 = "function" == typeof t3.create ? t3.create : function() {
          this.constructor.call(this, a2.create(t3.create));
        };
        return t3.inherit && (e3.prototype = new t3.inherit()), t3.extend && a2.extend(e3, t3.extend), t3.construct && a2.extend(t3.parent || a2.Container, t3.construct), e3;
      }, a2.adopt = function(e3) {
        return e3 ? e3.instance ? e3.instance : ((i2 = "svg" == e3.nodeName ? e3.parentNode instanceof t2.SVGElement ? new a2.Nested() : new a2.Doc() : "linearGradient" == e3.nodeName ? new a2.Gradient("linear") : "radialGradient" == e3.nodeName ? new a2.Gradient("radial") : a2[d2(e3.nodeName)] ? new a2[d2(e3.nodeName)]() : new a2.Element(e3)).type = e3.nodeName, i2.node = e3, e3.instance = i2, i2 instanceof a2.Doc && i2.namespace().defs(), i2.setData(JSON.parse(e3.getAttribute("svgjs:data")) || {}), i2) : null;
        var i2;
      }, a2.prepare = function() {
        var t3 = e2.getElementsByTagName("body")[0], i2 = (t3 ? new a2.Doc(t3) : a2.adopt(e2.documentElement).nested()).size(2, 0);
        a2.parser = { body: t3 || e2.documentElement, draw: i2.style("opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden").node, poly: i2.polyline().node, path: i2.path().node, native: a2.create("svg") };
      }, a2.parser = { native: a2.create("svg") }, e2.addEventListener("DOMContentLoaded", function() {
        a2.parser.draw || a2.prepare();
      }, false), a2.regex = { numberAndUnit: /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i, hex: /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i, rgb: /rgb\((\d+),(\d+),(\d+)\)/, reference: /#([a-z0-9\-_]+)/i, transforms: /\)\s*,?\s*/, whitespace: /\s/g, isHex: /^#[a-f0-9]{3,6}$/i, isRgb: /^rgb\(/, isCss: /[^:]+:[^;]+;?/, isBlank: /^(\s+)?$/, isNumber: /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, isPercent: /^-?[\d\.]+%$/, isImage: /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i, delimiter: /[\s,]+/, hyphen: /([^e])\-/gi, pathLetters: /[MLHVCSQTAZ]/gi, isPathLetter: /[MLHVCSQTAZ]/i, numbersWithDots: /((\d?\.\d+(?:e[+-]?\d+)?)((?:\.\d+(?:e[+-]?\d+)?)+))+/gi, dots: /\./g }, a2.utils = { map: function(t3, e3) {
        for (var i2 = t3.length, a3 = [], s3 = 0; s3 < i2; s3++)
          a3.push(e3(t3[s3]));
        return a3;
      }, filter: function(t3, e3) {
        for (var i2 = t3.length, a3 = [], s3 = 0; s3 < i2; s3++)
          e3(t3[s3]) && a3.push(t3[s3]);
        return a3;
      }, filterSVGElements: function(e3) {
        return this.filter(e3, function(e4) {
          return e4 instanceof t2.SVGElement;
        });
      } }, a2.defaults = { attrs: { "fill-opacity": 1, "stroke-opacity": 1, "stroke-width": 0, "stroke-linejoin": "miter", "stroke-linecap": "butt", fill: "#000000", stroke: "#000000", opacity: 1, x: 0, y: 0, cx: 0, cy: 0, width: 0, height: 0, r: 0, rx: 0, ry: 0, offset: 0, "stop-opacity": 1, "stop-color": "#000000", "font-size": 16, "font-family": "Helvetica, Arial, sans-serif", "text-anchor": "start" } }, a2.Color = function(t3) {
        var e3, s3;
        this.r = 0, this.g = 0, this.b = 0, t3 && ("string" == typeof t3 ? a2.regex.isRgb.test(t3) ? (e3 = a2.regex.rgb.exec(t3.replace(a2.regex.whitespace, "")), this.r = parseInt(e3[1]), this.g = parseInt(e3[2]), this.b = parseInt(e3[3])) : a2.regex.isHex.test(t3) && (e3 = a2.regex.hex.exec(4 == (s3 = t3).length ? ["#", s3.substring(1, 2), s3.substring(1, 2), s3.substring(2, 3), s3.substring(2, 3), s3.substring(3, 4), s3.substring(3, 4)].join("") : s3), this.r = parseInt(e3[1], 16), this.g = parseInt(e3[2], 16), this.b = parseInt(e3[3], 16)) : "object" === i(t3) && (this.r = t3.r, this.g = t3.g, this.b = t3.b));
      }, a2.extend(a2.Color, { toString: function() {
        return this.toHex();
      }, toHex: function() {
        return "#" + g2(this.r) + g2(this.g) + g2(this.b);
      }, toRgb: function() {
        return "rgb(" + [this.r, this.g, this.b].join() + ")";
      }, brightness: function() {
        return this.r / 255 * 0.3 + this.g / 255 * 0.59 + this.b / 255 * 0.11;
      }, morph: function(t3) {
        return this.destination = new a2.Color(t3), this;
      }, at: function(t3) {
        return this.destination ? (t3 = t3 < 0 ? 0 : t3 > 1 ? 1 : t3, new a2.Color({ r: ~~(this.r + (this.destination.r - this.r) * t3), g: ~~(this.g + (this.destination.g - this.g) * t3), b: ~~(this.b + (this.destination.b - this.b) * t3) })) : this;
      } }), a2.Color.test = function(t3) {
        return t3 += "", a2.regex.isHex.test(t3) || a2.regex.isRgb.test(t3);
      }, a2.Color.isRgb = function(t3) {
        return t3 && "number" == typeof t3.r && "number" == typeof t3.g && "number" == typeof t3.b;
      }, a2.Color.isColor = function(t3) {
        return a2.Color.isRgb(t3) || a2.Color.test(t3);
      }, a2.Array = function(t3, e3) {
        0 == (t3 = (t3 || []).valueOf()).length && e3 && (t3 = e3.valueOf()), this.value = this.parse(t3);
      }, a2.extend(a2.Array, { toString: function() {
        return this.value.join(" ");
      }, valueOf: function() {
        return this.value;
      }, parse: function(t3) {
        return t3 = t3.valueOf(), Array.isArray(t3) ? t3 : this.split(t3);
      } }), a2.PointArray = function(t3, e3) {
        a2.Array.call(this, t3, e3 || [[0, 0]]);
      }, a2.PointArray.prototype = new a2.Array(), a2.PointArray.prototype.constructor = a2.PointArray;
      for (var s2 = { M: function(t3, e3, i2) {
        return e3.x = i2.x = t3[0], e3.y = i2.y = t3[1], ["M", e3.x, e3.y];
      }, L: function(t3, e3) {
        return e3.x = t3[0], e3.y = t3[1], ["L", t3[0], t3[1]];
      }, H: function(t3, e3) {
        return e3.x = t3[0], ["H", t3[0]];
      }, V: function(t3, e3) {
        return e3.y = t3[0], ["V", t3[0]];
      }, C: function(t3, e3) {
        return e3.x = t3[4], e3.y = t3[5], ["C", t3[0], t3[1], t3[2], t3[3], t3[4], t3[5]];
      }, Q: function(t3, e3) {
        return e3.x = t3[2], e3.y = t3[3], ["Q", t3[0], t3[1], t3[2], t3[3]];
      }, S: function(t3, e3) {
        return e3.x = t3[2], e3.y = t3[3], ["S", t3[0], t3[1], t3[2], t3[3]];
      }, Z: function(t3, e3, i2) {
        return e3.x = i2.x, e3.y = i2.y, ["Z"];
      } }, r2 = "mlhvqtcsaz".split(""), o2 = 0, n2 = r2.length; o2 < n2; ++o2)
        s2[r2[o2]] = function(t3) {
          return function(e3, i2, a3) {
            if ("H" == t3)
              e3[0] = e3[0] + i2.x;
            else if ("V" == t3)
              e3[0] = e3[0] + i2.y;
            else if ("A" == t3)
              e3[5] = e3[5] + i2.x, e3[6] = e3[6] + i2.y;
            else
              for (var r3 = 0, o3 = e3.length; r3 < o3; ++r3)
                e3[r3] = e3[r3] + (r3 % 2 ? i2.y : i2.x);
            if (s2 && "function" == typeof s2[t3])
              return s2[t3](e3, i2, a3);
          };
        }(r2[o2].toUpperCase());
      a2.PathArray = function(t3, e3) {
        a2.Array.call(this, t3, e3 || [["M", 0, 0]]);
      }, a2.PathArray.prototype = new a2.Array(), a2.PathArray.prototype.constructor = a2.PathArray, a2.extend(a2.PathArray, { toString: function() {
        return function(t3) {
          for (var e3 = 0, i2 = t3.length, a3 = ""; e3 < i2; e3++)
            a3 += t3[e3][0], null != t3[e3][1] && (a3 += t3[e3][1], null != t3[e3][2] && (a3 += " ", a3 += t3[e3][2], null != t3[e3][3] && (a3 += " ", a3 += t3[e3][3], a3 += " ", a3 += t3[e3][4], null != t3[e3][5] && (a3 += " ", a3 += t3[e3][5], a3 += " ", a3 += t3[e3][6], null != t3[e3][7] && (a3 += " ", a3 += t3[e3][7])))));
          return a3 + " ";
        }(this.value);
      }, move: function(t3, e3) {
        var i2 = this.bbox();
        return i2.x, i2.y, this;
      }, at: function(t3) {
        if (!this.destination)
          return this;
        for (var e3 = this.value, i2 = this.destination.value, s3 = [], r3 = new a2.PathArray(), o3 = 0, n3 = e3.length; o3 < n3; o3++) {
          s3[o3] = [e3[o3][0]];
          for (var l3 = 1, h3 = e3[o3].length; l3 < h3; l3++)
            s3[o3][l3] = e3[o3][l3] + (i2[o3][l3] - e3[o3][l3]) * t3;
          "A" === s3[o3][0] && (s3[o3][4] = +(0 != s3[o3][4]), s3[o3][5] = +(0 != s3[o3][5]));
        }
        return r3.value = s3, r3;
      }, parse: function(t3) {
        if (t3 instanceof a2.PathArray)
          return t3.valueOf();
        var e3, i2 = { M: 2, L: 2, H: 1, V: 1, C: 6, S: 4, Q: 4, T: 2, A: 7, Z: 0 };
        t3 = "string" == typeof t3 ? t3.replace(a2.regex.numbersWithDots, h2).replace(a2.regex.pathLetters, " $& ").replace(a2.regex.hyphen, "$1 -").trim().split(a2.regex.delimiter) : t3.reduce(function(t4, e4) {
          return [].concat.call(t4, e4);
        }, []);
        var r3 = [], o3 = new a2.Point(), n3 = new a2.Point(), l3 = 0, c3 = t3.length;
        do {
          a2.regex.isPathLetter.test(t3[l3]) ? (e3 = t3[l3], ++l3) : "M" == e3 ? e3 = "L" : "m" == e3 && (e3 = "l"), r3.push(s2[e3].call(null, t3.slice(l3, l3 += i2[e3.toUpperCase()]).map(parseFloat), o3, n3));
        } while (c3 > l3);
        return r3;
      }, bbox: function() {
        return a2.parser.draw || a2.prepare(), a2.parser.path.setAttribute("d", this.toString()), a2.parser.path.getBBox();
      } }), a2.Number = a2.invent({ create: function(t3, e3) {
        this.value = 0, this.unit = e3 || "", "number" == typeof t3 ? this.value = isNaN(t3) ? 0 : isFinite(t3) ? t3 : t3 < 0 ? -34e37 : 34e37 : "string" == typeof t3 ? (e3 = t3.match(a2.regex.numberAndUnit)) && (this.value = parseFloat(e3[1]), "%" == e3[5] ? this.value /= 100 : "s" == e3[5] && (this.value *= 1e3), this.unit = e3[5]) : t3 instanceof a2.Number && (this.value = t3.valueOf(), this.unit = t3.unit);
      }, extend: { toString: function() {
        return ("%" == this.unit ? ~~(1e8 * this.value) / 1e6 : "s" == this.unit ? this.value / 1e3 : this.value) + this.unit;
      }, toJSON: function() {
        return this.toString();
      }, valueOf: function() {
        return this.value;
      }, plus: function(t3) {
        return t3 = new a2.Number(t3), new a2.Number(this + t3, this.unit || t3.unit);
      }, minus: function(t3) {
        return t3 = new a2.Number(t3), new a2.Number(this - t3, this.unit || t3.unit);
      }, times: function(t3) {
        return t3 = new a2.Number(t3), new a2.Number(this * t3, this.unit || t3.unit);
      }, divide: function(t3) {
        return t3 = new a2.Number(t3), new a2.Number(this / t3, this.unit || t3.unit);
      }, to: function(t3) {
        var e3 = new a2.Number(this);
        return "string" == typeof t3 && (e3.unit = t3), e3;
      }, morph: function(t3) {
        return this.destination = new a2.Number(t3), t3.relative && (this.destination.value += this.value), this;
      }, at: function(t3) {
        return this.destination ? new a2.Number(this.destination).minus(this).times(t3).plus(this) : this;
      } } }), a2.Element = a2.invent({ create: function(t3) {
        this._stroke = a2.defaults.attrs.stroke, this._event = null, this.dom = {}, (this.node = t3) && (this.type = t3.nodeName, this.node.instance = this, this._stroke = t3.getAttribute("stroke") || this._stroke);
      }, extend: { x: function(t3) {
        return this.attr("x", t3);
      }, y: function(t3) {
        return this.attr("y", t3);
      }, cx: function(t3) {
        return null == t3 ? this.x() + this.width() / 2 : this.x(t3 - this.width() / 2);
      }, cy: function(t3) {
        return null == t3 ? this.y() + this.height() / 2 : this.y(t3 - this.height() / 2);
      }, move: function(t3, e3) {
        return this.x(t3).y(e3);
      }, center: function(t3, e3) {
        return this.cx(t3).cy(e3);
      }, width: function(t3) {
        return this.attr("width", t3);
      }, height: function(t3) {
        return this.attr("height", t3);
      }, size: function(t3, e3) {
        var i2 = u2(this, t3, e3);
        return this.width(new a2.Number(i2.width)).height(new a2.Number(i2.height));
      }, clone: function(t3) {
        this.writeDataToDom();
        var e3 = x2(this.node.cloneNode(true));
        return t3 ? t3.add(e3) : this.after(e3), e3;
      }, remove: function() {
        return this.parent() && this.parent().removeElement(this), this;
      }, replace: function(t3) {
        return this.after(t3).remove(), t3;
      }, addTo: function(t3) {
        return t3.put(this);
      }, putIn: function(t3) {
        return t3.add(this);
      }, id: function(t3) {
        return this.attr("id", t3);
      }, show: function() {
        return this.style("display", "");
      }, hide: function() {
        return this.style("display", "none");
      }, visible: function() {
        return "none" != this.style("display");
      }, toString: function() {
        return this.attr("id");
      }, classes: function() {
        var t3 = this.attr("class");
        return null == t3 ? [] : t3.trim().split(a2.regex.delimiter);
      }, hasClass: function(t3) {
        return -1 != this.classes().indexOf(t3);
      }, addClass: function(t3) {
        if (!this.hasClass(t3)) {
          var e3 = this.classes();
          e3.push(t3), this.attr("class", e3.join(" "));
        }
        return this;
      }, removeClass: function(t3) {
        return this.hasClass(t3) && this.attr("class", this.classes().filter(function(e3) {
          return e3 != t3;
        }).join(" ")), this;
      }, toggleClass: function(t3) {
        return this.hasClass(t3) ? this.removeClass(t3) : this.addClass(t3);
      }, reference: function(t3) {
        return a2.get(this.attr(t3));
      }, parent: function(e3) {
        var i2 = this;
        if (!i2.node.parentNode)
          return null;
        if (i2 = a2.adopt(i2.node.parentNode), !e3)
          return i2;
        for (; i2 && i2.node instanceof t2.SVGElement; ) {
          if ("string" == typeof e3 ? i2.matches(e3) : i2 instanceof e3)
            return i2;
          if (!i2.node.parentNode || "#document" == i2.node.parentNode.nodeName)
            return null;
          i2 = a2.adopt(i2.node.parentNode);
        }
      }, doc: function() {
        return this instanceof a2.Doc ? this : this.parent(a2.Doc);
      }, parents: function(t3) {
        var e3 = [], i2 = this;
        do {
          if (!(i2 = i2.parent(t3)) || !i2.node)
            break;
          e3.push(i2);
        } while (i2.parent);
        return e3;
      }, matches: function(t3) {
        return function(t4, e3) {
          return (t4.matches || t4.matchesSelector || t4.msMatchesSelector || t4.mozMatchesSelector || t4.webkitMatchesSelector || t4.oMatchesSelector).call(t4, e3);
        }(this.node, t3);
      }, native: function() {
        return this.node;
      }, svg: function(t3) {
        var i2 = e2.createElement("svg");
        if (!(t3 && this instanceof a2.Parent))
          return i2.appendChild(t3 = e2.createElement("svg")), this.writeDataToDom(), t3.appendChild(this.node.cloneNode(true)), i2.innerHTML.replace(/^<svg>/, "").replace(/<\/svg>$/, "");
        i2.innerHTML = "<svg>" + t3.replace(/\n/, "").replace(/<([\w:-]+)([^<]+?)\/>/g, "<$1$2></$1>") + "</svg>";
        for (var s3 = 0, r3 = i2.firstChild.childNodes.length; s3 < r3; s3++)
          this.node.appendChild(i2.firstChild.firstChild);
        return this;
      }, writeDataToDom: function() {
        return (this.each || this.lines) && (this.each ? this : this.lines()).each(function() {
          this.writeDataToDom();
        }), this.node.removeAttribute("svgjs:data"), Object.keys(this.dom).length && this.node.setAttribute("svgjs:data", JSON.stringify(this.dom)), this;
      }, setData: function(t3) {
        return this.dom = t3, this;
      }, is: function(t3) {
        return function(t4, e3) {
          return t4 instanceof e3;
        }(this, t3);
      } } }), a2.easing = { "-": function(t3) {
        return t3;
      }, "<>": function(t3) {
        return -Math.cos(t3 * Math.PI) / 2 + 0.5;
      }, ">": function(t3) {
        return Math.sin(t3 * Math.PI / 2);
      }, "<": function(t3) {
        return 1 - Math.cos(t3 * Math.PI / 2);
      } }, a2.morph = function(t3) {
        return function(e3, i2) {
          return new a2.MorphObj(e3, i2).at(t3);
        };
      }, a2.Situation = a2.invent({ create: function(t3) {
        this.init = false, this.reversed = false, this.reversing = false, this.duration = new a2.Number(t3.duration).valueOf(), this.delay = new a2.Number(t3.delay).valueOf(), this.start = +new Date() + this.delay, this.finish = this.start + this.duration, this.ease = t3.ease, this.loop = 0, this.loops = false, this.animations = {}, this.attrs = {}, this.styles = {}, this.transforms = [], this.once = {};
      } }), a2.FX = a2.invent({ create: function(t3) {
        this._target = t3, this.situations = [], this.active = false, this.situation = null, this.paused = false, this.lastPos = 0, this.pos = 0, this.absPos = 0, this._speed = 1;
      }, extend: { animate: function(t3, e3, s3) {
        "object" === i(t3) && (e3 = t3.ease, s3 = t3.delay, t3 = t3.duration);
        var r3 = new a2.Situation({ duration: t3 || 1e3, delay: s3 || 0, ease: a2.easing[e3 || "-"] || e3 });
        return this.queue(r3), this;
      }, target: function(t3) {
        return t3 && t3 instanceof a2.Element ? (this._target = t3, this) : this._target;
      }, timeToAbsPos: function(t3) {
        return (t3 - this.situation.start) / (this.situation.duration / this._speed);
      }, absPosToTime: function(t3) {
        return this.situation.duration / this._speed * t3 + this.situation.start;
      }, startAnimFrame: function() {
        this.stopAnimFrame(), this.animationFrame = t2.requestAnimationFrame(function() {
          this.step();
        }.bind(this));
      }, stopAnimFrame: function() {
        t2.cancelAnimationFrame(this.animationFrame);
      }, start: function() {
        return !this.active && this.situation && (this.active = true, this.startCurrent()), this;
      }, startCurrent: function() {
        return this.situation.start = +new Date() + this.situation.delay / this._speed, this.situation.finish = this.situation.start + this.situation.duration / this._speed, this.initAnimations().step();
      }, queue: function(t3) {
        return ("function" == typeof t3 || t3 instanceof a2.Situation) && this.situations.push(t3), this.situation || (this.situation = this.situations.shift()), this;
      }, dequeue: function() {
        return this.stop(), this.situation = this.situations.shift(), this.situation && (this.situation instanceof a2.Situation ? this.start() : this.situation.call(this)), this;
      }, initAnimations: function() {
        var t3, e3 = this.situation;
        if (e3.init)
          return this;
        for (var i2 in e3.animations) {
          t3 = this.target()[i2](), Array.isArray(t3) || (t3 = [t3]), Array.isArray(e3.animations[i2]) || (e3.animations[i2] = [e3.animations[i2]]);
          for (var s3 = t3.length; s3--; )
            e3.animations[i2][s3] instanceof a2.Number && (t3[s3] = new a2.Number(t3[s3])), e3.animations[i2][s3] = t3[s3].morph(e3.animations[i2][s3]);
        }
        for (var i2 in e3.attrs)
          e3.attrs[i2] = new a2.MorphObj(this.target().attr(i2), e3.attrs[i2]);
        for (var i2 in e3.styles)
          e3.styles[i2] = new a2.MorphObj(this.target().style(i2), e3.styles[i2]);
        return e3.initialTransformation = this.target().matrixify(), e3.init = true, this;
      }, clearQueue: function() {
        return this.situations = [], this;
      }, clearCurrent: function() {
        return this.situation = null, this;
      }, stop: function(t3, e3) {
        var i2 = this.active;
        return this.active = false, e3 && this.clearQueue(), t3 && this.situation && (!i2 && this.startCurrent(), this.atEnd()), this.stopAnimFrame(), this.clearCurrent();
      }, after: function(t3) {
        var e3 = this.last();
        return this.target().on("finished.fx", function i2(a3) {
          a3.detail.situation == e3 && (t3.call(this, e3), this.off("finished.fx", i2));
        }), this._callStart();
      }, during: function(t3) {
        var e3 = this.last(), i2 = function(i3) {
          i3.detail.situation == e3 && t3.call(this, i3.detail.pos, a2.morph(i3.detail.pos), i3.detail.eased, e3);
        };
        return this.target().off("during.fx", i2).on("during.fx", i2), this.after(function() {
          this.off("during.fx", i2);
        }), this._callStart();
      }, afterAll: function(t3) {
        var e3 = function e4(i2) {
          t3.call(this), this.off("allfinished.fx", e4);
        };
        return this.target().off("allfinished.fx", e3).on("allfinished.fx", e3), this._callStart();
      }, last: function() {
        return this.situations.length ? this.situations[this.situations.length - 1] : this.situation;
      }, add: function(t3, e3, i2) {
        return this.last()[i2 || "animations"][t3] = e3, this._callStart();
      }, step: function(t3) {
        var e3, i2, a3;
        t3 || (this.absPos = this.timeToAbsPos(+new Date())), false !== this.situation.loops ? (e3 = Math.max(this.absPos, 0), i2 = Math.floor(e3), true === this.situation.loops || i2 < this.situation.loops ? (this.pos = e3 - i2, a3 = this.situation.loop, this.situation.loop = i2) : (this.absPos = this.situation.loops, this.pos = 1, a3 = this.situation.loop - 1, this.situation.loop = this.situation.loops), this.situation.reversing && (this.situation.reversed = this.situation.reversed != Boolean((this.situation.loop - a3) % 2))) : (this.absPos = Math.min(this.absPos, 1), this.pos = this.absPos), this.pos < 0 && (this.pos = 0), this.situation.reversed && (this.pos = 1 - this.pos);
        var s3 = this.situation.ease(this.pos);
        for (var r3 in this.situation.once)
          r3 > this.lastPos && r3 <= s3 && (this.situation.once[r3].call(this.target(), this.pos, s3), delete this.situation.once[r3]);
        return this.active && this.target().fire("during", { pos: this.pos, eased: s3, fx: this, situation: this.situation }), this.situation ? (this.eachAt(), 1 == this.pos && !this.situation.reversed || this.situation.reversed && 0 == this.pos ? (this.stopAnimFrame(), this.target().fire("finished", { fx: this, situation: this.situation }), this.situations.length || (this.target().fire("allfinished"), this.situations.length || (this.target().off(".fx"), this.active = false)), this.active ? this.dequeue() : this.clearCurrent()) : !this.paused && this.active && this.startAnimFrame(), this.lastPos = s3, this) : this;
      }, eachAt: function() {
        var t3, e3 = this, i2 = this.target(), s3 = this.situation;
        for (var r3 in s3.animations)
          t3 = [].concat(s3.animations[r3]).map(function(t4) {
            return "string" != typeof t4 && t4.at ? t4.at(s3.ease(e3.pos), e3.pos) : t4;
          }), i2[r3].apply(i2, t3);
        for (var r3 in s3.attrs)
          t3 = [r3].concat(s3.attrs[r3]).map(function(t4) {
            return "string" != typeof t4 && t4.at ? t4.at(s3.ease(e3.pos), e3.pos) : t4;
          }), i2.attr.apply(i2, t3);
        for (var r3 in s3.styles)
          t3 = [r3].concat(s3.styles[r3]).map(function(t4) {
            return "string" != typeof t4 && t4.at ? t4.at(s3.ease(e3.pos), e3.pos) : t4;
          }), i2.style.apply(i2, t3);
        if (s3.transforms.length) {
          t3 = s3.initialTransformation, r3 = 0;
          for (var o3 = s3.transforms.length; r3 < o3; r3++) {
            var n3 = s3.transforms[r3];
            n3 instanceof a2.Matrix ? t3 = n3.relative ? t3.multiply(new a2.Matrix().morph(n3).at(s3.ease(this.pos))) : t3.morph(n3).at(s3.ease(this.pos)) : (n3.relative || n3.undo(t3.extract()), t3 = t3.multiply(n3.at(s3.ease(this.pos))));
          }
          i2.matrix(t3);
        }
        return this;
      }, once: function(t3, e3, i2) {
        var a3 = this.last();
        return i2 || (t3 = a3.ease(t3)), a3.once[t3] = e3, this;
      }, _callStart: function() {
        return setTimeout(function() {
          this.start();
        }.bind(this), 0), this;
      } }, parent: a2.Element, construct: { animate: function(t3, e3, i2) {
        return (this.fx || (this.fx = new a2.FX(this))).animate(t3, e3, i2);
      }, delay: function(t3) {
        return (this.fx || (this.fx = new a2.FX(this))).delay(t3);
      }, stop: function(t3, e3) {
        return this.fx && this.fx.stop(t3, e3), this;
      }, finish: function() {
        return this.fx && this.fx.finish(), this;
      } } }), a2.MorphObj = a2.invent({ create: function(t3, e3) {
        return a2.Color.isColor(e3) ? new a2.Color(t3).morph(e3) : a2.regex.delimiter.test(t3) ? a2.regex.pathLetters.test(t3) ? new a2.PathArray(t3).morph(e3) : new a2.Array(t3).morph(e3) : a2.regex.numberAndUnit.test(e3) ? new a2.Number(t3).morph(e3) : (this.value = t3, void (this.destination = e3));
      }, extend: { at: function(t3, e3) {
        return e3 < 1 ? this.value : this.destination;
      }, valueOf: function() {
        return this.value;
      } } }), a2.extend(a2.FX, { attr: function(t3, e3, a3) {
        if ("object" === i(t3))
          for (var s3 in t3)
            this.attr(s3, t3[s3]);
        else
          this.add(t3, e3, "attrs");
        return this;
      }, plot: function(t3, e3, i2, a3) {
        return 4 == arguments.length ? this.plot([t3, e3, i2, a3]) : this.add("plot", new (this.target()).morphArray(t3));
      } }), a2.Box = a2.invent({ create: function(t3, e3, s3, r3) {
        if (!("object" !== i(t3) || t3 instanceof a2.Element))
          return a2.Box.call(this, null != t3.left ? t3.left : t3.x, null != t3.top ? t3.top : t3.y, t3.width, t3.height);
        var o3;
        4 == arguments.length && (this.x = t3, this.y = e3, this.width = s3, this.height = r3), null == (o3 = this).x && (o3.x = 0, o3.y = 0, o3.width = 0, o3.height = 0), o3.w = o3.width, o3.h = o3.height, o3.x2 = o3.x + o3.width, o3.y2 = o3.y + o3.height, o3.cx = o3.x + o3.width / 2, o3.cy = o3.y + o3.height / 2;
      } }), a2.BBox = a2.invent({ create: function(t3) {
        if (a2.Box.apply(this, [].slice.call(arguments)), t3 instanceof a2.Element) {
          var i2;
          try {
            if (!e2.documentElement.contains) {
              for (var s3 = t3.node; s3.parentNode; )
                s3 = s3.parentNode;
              if (s3 != e2)
                throw new Error("Element not in the dom");
            }
            i2 = t3.node.getBBox();
          } catch (e3) {
            if (t3 instanceof a2.Shape) {
              a2.parser.draw || a2.prepare();
              var r3 = t3.clone(a2.parser.draw.instance).show();
              r3 && r3.node && "function" == typeof r3.node.getBBox && (i2 = r3.node.getBBox()), r3 && "function" == typeof r3.remove && r3.remove();
            } else
              i2 = { x: t3.node.clientLeft, y: t3.node.clientTop, width: t3.node.clientWidth, height: t3.node.clientHeight };
          }
          a2.Box.call(this, i2);
        }
      }, inherit: a2.Box, parent: a2.Element, construct: { bbox: function() {
        return new a2.BBox(this);
      } } }), a2.BBox.prototype.constructor = a2.BBox, a2.Matrix = a2.invent({ create: function(t3) {
        var e3 = f2([1, 0, 0, 1, 0, 0]);
        t3 = null === t3 ? e3 : t3 instanceof a2.Element ? t3.matrixify() : "string" == typeof t3 ? f2(t3.split(a2.regex.delimiter).map(parseFloat)) : 6 == arguments.length ? f2([].slice.call(arguments)) : Array.isArray(t3) ? f2(t3) : t3 && "object" === i(t3) ? t3 : e3;
        for (var s3 = v2.length - 1; s3 >= 0; --s3)
          this[v2[s3]] = null != t3[v2[s3]] ? t3[v2[s3]] : e3[v2[s3]];
      }, extend: { extract: function() {
        var t3 = p2(this, 0, 1);
        p2(this, 1, 0);
        var e3 = 180 / Math.PI * Math.atan2(t3.y, t3.x) - 90;
        return { x: this.e, y: this.f, transformedX: (this.e * Math.cos(e3 * Math.PI / 180) + this.f * Math.sin(e3 * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b), transformedY: (this.f * Math.cos(e3 * Math.PI / 180) + this.e * Math.sin(-e3 * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d), rotation: e3, a: this.a, b: this.b, c: this.c, d: this.d, e: this.e, f: this.f, matrix: new a2.Matrix(this) };
      }, clone: function() {
        return new a2.Matrix(this);
      }, morph: function(t3) {
        return this.destination = new a2.Matrix(t3), this;
      }, multiply: function(t3) {
        return new a2.Matrix(this.native().multiply(function(t4) {
          return t4 instanceof a2.Matrix || (t4 = new a2.Matrix(t4)), t4;
        }(t3).native()));
      }, inverse: function() {
        return new a2.Matrix(this.native().inverse());
      }, translate: function(t3, e3) {
        return new a2.Matrix(this.native().translate(t3 || 0, e3 || 0));
      }, native: function() {
        for (var t3 = a2.parser.native.createSVGMatrix(), e3 = v2.length - 1; e3 >= 0; e3--)
          t3[v2[e3]] = this[v2[e3]];
        return t3;
      }, toString: function() {
        return "matrix(" + b2(this.a) + "," + b2(this.b) + "," + b2(this.c) + "," + b2(this.d) + "," + b2(this.e) + "," + b2(this.f) + ")";
      } }, parent: a2.Element, construct: { ctm: function() {
        return new a2.Matrix(this.node.getCTM());
      }, screenCTM: function() {
        if (this instanceof a2.Nested) {
          var t3 = this.rect(1, 1), e3 = t3.node.getScreenCTM();
          return t3.remove(), new a2.Matrix(e3);
        }
        return new a2.Matrix(this.node.getScreenCTM());
      } } }), a2.Point = a2.invent({ create: function(t3, e3) {
        var a3;
        a3 = Array.isArray(t3) ? { x: t3[0], y: t3[1] } : "object" === i(t3) ? { x: t3.x, y: t3.y } : null != t3 ? { x: t3, y: null != e3 ? e3 : t3 } : { x: 0, y: 0 }, this.x = a3.x, this.y = a3.y;
      }, extend: { clone: function() {
        return new a2.Point(this);
      }, morph: function(t3, e3) {
        return this.destination = new a2.Point(t3, e3), this;
      } } }), a2.extend(a2.Element, { point: function(t3, e3) {
        return new a2.Point(t3, e3).transform(this.screenCTM().inverse());
      } }), a2.extend(a2.Element, { attr: function(t3, e3, s3) {
        if (null == t3) {
          for (t3 = {}, s3 = (e3 = this.node.attributes).length - 1; s3 >= 0; s3--)
            t3[e3[s3].nodeName] = a2.regex.isNumber.test(e3[s3].nodeValue) ? parseFloat(e3[s3].nodeValue) : e3[s3].nodeValue;
          return t3;
        }
        if ("object" === i(t3))
          for (var r3 in t3)
            this.attr(r3, t3[r3]);
        else if (null === e3)
          this.node.removeAttribute(t3);
        else {
          if (null == e3)
            return null == (e3 = this.node.getAttribute(t3)) ? a2.defaults.attrs[t3] : a2.regex.isNumber.test(e3) ? parseFloat(e3) : e3;
          "stroke-width" == t3 ? this.attr("stroke", parseFloat(e3) > 0 ? this._stroke : null) : "stroke" == t3 && (this._stroke = e3), "fill" != t3 && "stroke" != t3 || (a2.regex.isImage.test(e3) && (e3 = this.doc().defs().image(e3, 0, 0)), e3 instanceof a2.Image && (e3 = this.doc().defs().pattern(0, 0, function() {
            this.add(e3);
          }))), "number" == typeof e3 ? e3 = new a2.Number(e3) : a2.Color.isColor(e3) ? e3 = new a2.Color(e3) : Array.isArray(e3) && (e3 = new a2.Array(e3)), "leading" == t3 ? this.leading && this.leading(e3) : "string" == typeof s3 ? this.node.setAttributeNS(s3, t3, e3.toString()) : this.node.setAttribute(t3, e3.toString()), !this.rebuild || "font-size" != t3 && "x" != t3 || this.rebuild(t3, e3);
        }
        return this;
      } }), a2.extend(a2.Element, { transform: function(t3, e3) {
        var s3;
        return "object" !== i(t3) ? (s3 = new a2.Matrix(this).extract(), "string" == typeof t3 ? s3[t3] : s3) : (s3 = new a2.Matrix(this), e3 = !!e3 || !!t3.relative, null != t3.a && (s3 = e3 ? s3.multiply(new a2.Matrix(t3)) : new a2.Matrix(t3)), this.attr("transform", s3));
      } }), a2.extend(a2.Element, { untransform: function() {
        return this.attr("transform", null);
      }, matrixify: function() {
        return (this.attr("transform") || "").split(a2.regex.transforms).slice(0, -1).map(function(t3) {
          var e3 = t3.trim().split("(");
          return [e3[0], e3[1].split(a2.regex.delimiter).map(function(t4) {
            return parseFloat(t4);
          })];
        }).reduce(function(t3, e3) {
          return "matrix" == e3[0] ? t3.multiply(f2(e3[1])) : t3[e3[0]].apply(t3, e3[1]);
        }, new a2.Matrix());
      }, toParent: function(t3) {
        if (this == t3)
          return this;
        var e3 = this.screenCTM(), i2 = t3.screenCTM().inverse();
        return this.addTo(t3).untransform().transform(i2.multiply(e3)), this;
      }, toDoc: function() {
        return this.toParent(this.doc());
      } }), a2.Transformation = a2.invent({ create: function(t3, e3) {
        if (arguments.length > 1 && "boolean" != typeof e3)
          return this.constructor.call(this, [].slice.call(arguments));
        if (Array.isArray(t3))
          for (var a3 = 0, s3 = this.arguments.length; a3 < s3; ++a3)
            this[this.arguments[a3]] = t3[a3];
        else if (t3 && "object" === i(t3))
          for (a3 = 0, s3 = this.arguments.length; a3 < s3; ++a3)
            this[this.arguments[a3]] = t3[this.arguments[a3]];
        this.inversed = false, true === e3 && (this.inversed = true);
      } }), a2.Translate = a2.invent({ parent: a2.Matrix, inherit: a2.Transformation, create: function(t3, e3) {
        this.constructor.apply(this, [].slice.call(arguments));
      }, extend: { arguments: ["transformedX", "transformedY"], method: "translate" } }), a2.extend(a2.Element, { style: function(t3, e3) {
        if (0 == arguments.length)
          return this.node.style.cssText || "";
        if (arguments.length < 2)
          if ("object" === i(t3))
            for (var s3 in t3)
              this.style(s3, t3[s3]);
          else {
            if (!a2.regex.isCss.test(t3))
              return this.node.style[c2(t3)];
            for (t3 = t3.split(/\s*;\s*/).filter(function(t4) {
              return !!t4;
            }).map(function(t4) {
              return t4.split(/\s*:\s*/);
            }); e3 = t3.pop(); )
              this.style(e3[0], e3[1]);
          }
        else
          this.node.style[c2(t3)] = null === e3 || a2.regex.isBlank.test(e3) ? "" : e3;
        return this;
      } }), a2.Parent = a2.invent({ create: function(t3) {
        this.constructor.call(this, t3);
      }, inherit: a2.Element, extend: { children: function() {
        return a2.utils.map(a2.utils.filterSVGElements(this.node.childNodes), function(t3) {
          return a2.adopt(t3);
        });
      }, add: function(t3, e3) {
        return null == e3 ? this.node.appendChild(t3.node) : t3.node != this.node.childNodes[e3] && this.node.insertBefore(t3.node, this.node.childNodes[e3]), this;
      }, put: function(t3, e3) {
        return this.add(t3, e3), t3;
      }, has: function(t3) {
        return this.index(t3) >= 0;
      }, index: function(t3) {
        return [].slice.call(this.node.childNodes).indexOf(t3.node);
      }, get: function(t3) {
        return a2.adopt(this.node.childNodes[t3]);
      }, first: function() {
        return this.get(0);
      }, last: function() {
        return this.get(this.node.childNodes.length - 1);
      }, each: function(t3, e3) {
        for (var i2 = this.children(), s3 = 0, r3 = i2.length; s3 < r3; s3++)
          i2[s3] instanceof a2.Element && t3.apply(i2[s3], [s3, i2]), e3 && i2[s3] instanceof a2.Container && i2[s3].each(t3, e3);
        return this;
      }, removeElement: function(t3) {
        return this.node.removeChild(t3.node), this;
      }, clear: function() {
        for (; this.node.hasChildNodes(); )
          this.node.removeChild(this.node.lastChild);
        return delete this._defs, this;
      }, defs: function() {
        return this.doc().defs();
      } } }), a2.extend(a2.Parent, { ungroup: function(t3, e3) {
        return 0 === e3 || this instanceof a2.Defs || this.node == a2.parser.draw || (t3 = t3 || (this instanceof a2.Doc ? this : this.parent(a2.Parent)), e3 = e3 || 1 / 0, this.each(function() {
          return this instanceof a2.Defs ? this : this instanceof a2.Parent ? this.ungroup(t3, e3 - 1) : this.toParent(t3);
        }), this.node.firstChild || this.remove()), this;
      }, flatten: function(t3, e3) {
        return this.ungroup(t3, e3);
      } }), a2.Container = a2.invent({ create: function(t3) {
        this.constructor.call(this, t3);
      }, inherit: a2.Parent }), a2.ViewBox = a2.invent({ parent: a2.Container, construct: {} }), ["click", "dblclick", "mousedown", "mouseup", "mouseover", "mouseout", "mousemove", "touchstart", "touchmove", "touchleave", "touchend", "touchcancel"].forEach(function(t3) {
        a2.Element.prototype[t3] = function(e3) {
          return a2.on(this.node, t3, e3), this;
        };
      }), a2.listeners = [], a2.handlerMap = [], a2.listenerId = 0, a2.on = function(t3, e3, i2, s3, r3) {
        var o3 = i2.bind(s3 || t3.instance || t3), n3 = (a2.handlerMap.indexOf(t3) + 1 || a2.handlerMap.push(t3)) - 1, l3 = e3.split(".")[0], h3 = e3.split(".")[1] || "*";
        a2.listeners[n3] = a2.listeners[n3] || {}, a2.listeners[n3][l3] = a2.listeners[n3][l3] || {}, a2.listeners[n3][l3][h3] = a2.listeners[n3][l3][h3] || {}, i2._svgjsListenerId || (i2._svgjsListenerId = ++a2.listenerId), a2.listeners[n3][l3][h3][i2._svgjsListenerId] = o3, t3.addEventListener(l3, o3, r3 || { passive: true });
      }, a2.off = function(t3, e3, i2) {
        var s3 = a2.handlerMap.indexOf(t3), r3 = e3 && e3.split(".")[0], o3 = e3 && e3.split(".")[1], n3 = "";
        if (-1 != s3)
          if (i2) {
            if ("function" == typeof i2 && (i2 = i2._svgjsListenerId), !i2)
              return;
            a2.listeners[s3][r3] && a2.listeners[s3][r3][o3 || "*"] && (t3.removeEventListener(r3, a2.listeners[s3][r3][o3 || "*"][i2], false), delete a2.listeners[s3][r3][o3 || "*"][i2]);
          } else if (o3 && r3) {
            if (a2.listeners[s3][r3] && a2.listeners[s3][r3][o3]) {
              for (var l3 in a2.listeners[s3][r3][o3])
                a2.off(t3, [r3, o3].join("."), l3);
              delete a2.listeners[s3][r3][o3];
            }
          } else if (o3)
            for (var h3 in a2.listeners[s3])
              for (var n3 in a2.listeners[s3][h3])
                o3 === n3 && a2.off(t3, [h3, o3].join("."));
          else if (r3) {
            if (a2.listeners[s3][r3]) {
              for (var n3 in a2.listeners[s3][r3])
                a2.off(t3, [r3, n3].join("."));
              delete a2.listeners[s3][r3];
            }
          } else {
            for (var h3 in a2.listeners[s3])
              a2.off(t3, h3);
            delete a2.listeners[s3], delete a2.handlerMap[s3];
          }
      }, a2.extend(a2.Element, { on: function(t3, e3, i2, s3) {
        return a2.on(this.node, t3, e3, i2, s3), this;
      }, off: function(t3, e3) {
        return a2.off(this.node, t3, e3), this;
      }, fire: function(e3, i2) {
        return e3 instanceof t2.Event ? this.node.dispatchEvent(e3) : this.node.dispatchEvent(e3 = new a2.CustomEvent(e3, { detail: i2, cancelable: true })), this._event = e3, this;
      }, event: function() {
        return this._event;
      } }), a2.Defs = a2.invent({ create: "defs", inherit: a2.Container }), a2.G = a2.invent({ create: "g", inherit: a2.Container, extend: { x: function(t3) {
        return null == t3 ? this.transform("x") : this.transform({ x: t3 - this.x() }, true);
      } }, construct: { group: function() {
        return this.put(new a2.G());
      } } }), a2.Doc = a2.invent({ create: function(t3) {
        t3 && ("svg" == (t3 = "string" == typeof t3 ? e2.getElementById(t3) : t3).nodeName ? this.constructor.call(this, t3) : (this.constructor.call(this, a2.create("svg")), t3.appendChild(this.node), this.size("100%", "100%")), this.namespace().defs());
      }, inherit: a2.Container, extend: { namespace: function() {
        return this.attr({ xmlns: a2.ns, version: "1.1" }).attr("xmlns:xlink", a2.xlink, a2.xmlns).attr("xmlns:svgjs", a2.svgjs, a2.xmlns);
      }, defs: function() {
        var t3;
        return this._defs || ((t3 = this.node.getElementsByTagName("defs")[0]) ? this._defs = a2.adopt(t3) : this._defs = new a2.Defs(), this.node.appendChild(this._defs.node)), this._defs;
      }, parent: function() {
        return this.node.parentNode && "#document" != this.node.parentNode.nodeName ? this.node.parentNode : null;
      }, remove: function() {
        return this.parent() && this.parent().removeChild(this.node), this;
      }, clear: function() {
        for (; this.node.hasChildNodes(); )
          this.node.removeChild(this.node.lastChild);
        return delete this._defs, a2.parser.draw && !a2.parser.draw.parentNode && this.node.appendChild(a2.parser.draw), this;
      }, clone: function(t3) {
        this.writeDataToDom();
        var e3 = this.node, i2 = x2(e3.cloneNode(true));
        return t3 ? (t3.node || t3).appendChild(i2.node) : e3.parentNode.insertBefore(i2.node, e3.nextSibling), i2;
      } } }), a2.extend(a2.Element, {}), a2.Gradient = a2.invent({ create: function(t3) {
        this.constructor.call(this, a2.create(t3 + "Gradient")), this.type = t3;
      }, inherit: a2.Container, extend: { at: function(t3, e3, i2) {
        return this.put(new a2.Stop()).update(t3, e3, i2);
      }, update: function(t3) {
        return this.clear(), "function" == typeof t3 && t3.call(this, this), this;
      }, fill: function() {
        return "url(#" + this.id() + ")";
      }, toString: function() {
        return this.fill();
      }, attr: function(t3, e3, i2) {
        return "transform" == t3 && (t3 = "gradientTransform"), a2.Container.prototype.attr.call(this, t3, e3, i2);
      } }, construct: { gradient: function(t3, e3) {
        return this.defs().gradient(t3, e3);
      } } }), a2.extend(a2.Gradient, a2.FX, { from: function(t3, e3) {
        return "radial" == (this._target || this).type ? this.attr({ fx: new a2.Number(t3), fy: new a2.Number(e3) }) : this.attr({ x1: new a2.Number(t3), y1: new a2.Number(e3) });
      }, to: function(t3, e3) {
        return "radial" == (this._target || this).type ? this.attr({ cx: new a2.Number(t3), cy: new a2.Number(e3) }) : this.attr({ x2: new a2.Number(t3), y2: new a2.Number(e3) });
      } }), a2.extend(a2.Defs, { gradient: function(t3, e3) {
        return this.put(new a2.Gradient(t3)).update(e3);
      } }), a2.Stop = a2.invent({ create: "stop", inherit: a2.Element, extend: { update: function(t3) {
        return ("number" == typeof t3 || t3 instanceof a2.Number) && (t3 = { offset: arguments[0], color: arguments[1], opacity: arguments[2] }), null != t3.opacity && this.attr("stop-opacity", t3.opacity), null != t3.color && this.attr("stop-color", t3.color), null != t3.offset && this.attr("offset", new a2.Number(t3.offset)), this;
      } } }), a2.Pattern = a2.invent({ create: "pattern", inherit: a2.Container, extend: { fill: function() {
        return "url(#" + this.id() + ")";
      }, update: function(t3) {
        return this.clear(), "function" == typeof t3 && t3.call(this, this), this;
      }, toString: function() {
        return this.fill();
      }, attr: function(t3, e3, i2) {
        return "transform" == t3 && (t3 = "patternTransform"), a2.Container.prototype.attr.call(this, t3, e3, i2);
      } }, construct: { pattern: function(t3, e3, i2) {
        return this.defs().pattern(t3, e3, i2);
      } } }), a2.extend(a2.Defs, { pattern: function(t3, e3, i2) {
        return this.put(new a2.Pattern()).update(i2).attr({ x: 0, y: 0, width: t3, height: e3, patternUnits: "userSpaceOnUse" });
      } }), a2.Shape = a2.invent({ create: function(t3) {
        this.constructor.call(this, t3);
      }, inherit: a2.Element }), a2.Symbol = a2.invent({ create: "symbol", inherit: a2.Container, construct: { symbol: function() {
        return this.put(new a2.Symbol());
      } } }), a2.Use = a2.invent({ create: "use", inherit: a2.Shape, extend: { element: function(t3, e3) {
        return this.attr("href", (e3 || "") + "#" + t3, a2.xlink);
      } }, construct: { use: function(t3, e3) {
        return this.put(new a2.Use()).element(t3, e3);
      } } }), a2.Rect = a2.invent({ create: "rect", inherit: a2.Shape, construct: { rect: function(t3, e3) {
        return this.put(new a2.Rect()).size(t3, e3);
      } } }), a2.Circle = a2.invent({ create: "circle", inherit: a2.Shape, construct: { circle: function(t3) {
        return this.put(new a2.Circle()).rx(new a2.Number(t3).divide(2)).move(0, 0);
      } } }), a2.extend(a2.Circle, a2.FX, { rx: function(t3) {
        return this.attr("r", t3);
      }, ry: function(t3) {
        return this.rx(t3);
      } }), a2.Ellipse = a2.invent({ create: "ellipse", inherit: a2.Shape, construct: { ellipse: function(t3, e3) {
        return this.put(new a2.Ellipse()).size(t3, e3).move(0, 0);
      } } }), a2.extend(a2.Ellipse, a2.Rect, a2.FX, { rx: function(t3) {
        return this.attr("rx", t3);
      }, ry: function(t3) {
        return this.attr("ry", t3);
      } }), a2.extend(a2.Circle, a2.Ellipse, { x: function(t3) {
        return null == t3 ? this.cx() - this.rx() : this.cx(t3 + this.rx());
      }, y: function(t3) {
        return null == t3 ? this.cy() - this.ry() : this.cy(t3 + this.ry());
      }, cx: function(t3) {
        return null == t3 ? this.attr("cx") : this.attr("cx", t3);
      }, cy: function(t3) {
        return null == t3 ? this.attr("cy") : this.attr("cy", t3);
      }, width: function(t3) {
        return null == t3 ? 2 * this.rx() : this.rx(new a2.Number(t3).divide(2));
      }, height: function(t3) {
        return null == t3 ? 2 * this.ry() : this.ry(new a2.Number(t3).divide(2));
      }, size: function(t3, e3) {
        var i2 = u2(this, t3, e3);
        return this.rx(new a2.Number(i2.width).divide(2)).ry(new a2.Number(i2.height).divide(2));
      } }), a2.Line = a2.invent({ create: "line", inherit: a2.Shape, extend: { array: function() {
        return new a2.PointArray([[this.attr("x1"), this.attr("y1")], [this.attr("x2"), this.attr("y2")]]);
      }, plot: function(t3, e3, i2, s3) {
        return null == t3 ? this.array() : (t3 = void 0 !== e3 ? { x1: t3, y1: e3, x2: i2, y2: s3 } : new a2.PointArray(t3).toLine(), this.attr(t3));
      }, move: function(t3, e3) {
        return this.attr(this.array().move(t3, e3).toLine());
      }, size: function(t3, e3) {
        var i2 = u2(this, t3, e3);
        return this.attr(this.array().size(i2.width, i2.height).toLine());
      } }, construct: { line: function(t3, e3, i2, s3) {
        return a2.Line.prototype.plot.apply(this.put(new a2.Line()), null != t3 ? [t3, e3, i2, s3] : [0, 0, 0, 0]);
      } } }), a2.Polyline = a2.invent({ create: "polyline", inherit: a2.Shape, construct: { polyline: function(t3) {
        return this.put(new a2.Polyline()).plot(t3 || new a2.PointArray());
      } } }), a2.Polygon = a2.invent({ create: "polygon", inherit: a2.Shape, construct: { polygon: function(t3) {
        return this.put(new a2.Polygon()).plot(t3 || new a2.PointArray());
      } } }), a2.extend(a2.Polyline, a2.Polygon, { array: function() {
        return this._array || (this._array = new a2.PointArray(this.attr("points")));
      }, plot: function(t3) {
        return null == t3 ? this.array() : this.clear().attr("points", "string" == typeof t3 ? t3 : this._array = new a2.PointArray(t3));
      }, clear: function() {
        return delete this._array, this;
      }, move: function(t3, e3) {
        return this.attr("points", this.array().move(t3, e3));
      }, size: function(t3, e3) {
        var i2 = u2(this, t3, e3);
        return this.attr("points", this.array().size(i2.width, i2.height));
      } }), a2.extend(a2.Line, a2.Polyline, a2.Polygon, { morphArray: a2.PointArray, x: function(t3) {
        return null == t3 ? this.bbox().x : this.move(t3, this.bbox().y);
      }, y: function(t3) {
        return null == t3 ? this.bbox().y : this.move(this.bbox().x, t3);
      }, width: function(t3) {
        var e3 = this.bbox();
        return null == t3 ? e3.width : this.size(t3, e3.height);
      }, height: function(t3) {
        var e3 = this.bbox();
        return null == t3 ? e3.height : this.size(e3.width, t3);
      } }), a2.Path = a2.invent({ create: "path", inherit: a2.Shape, extend: { morphArray: a2.PathArray, array: function() {
        return this._array || (this._array = new a2.PathArray(this.attr("d")));
      }, plot: function(t3) {
        return null == t3 ? this.array() : this.clear().attr("d", "string" == typeof t3 ? t3 : this._array = new a2.PathArray(t3));
      }, clear: function() {
        return delete this._array, this;
      } }, construct: { path: function(t3) {
        return this.put(new a2.Path()).plot(t3 || new a2.PathArray());
      } } }), a2.Image = a2.invent({ create: "image", inherit: a2.Shape, extend: { load: function(e3) {
        if (!e3)
          return this;
        var i2 = this, s3 = new t2.Image();
        return a2.on(s3, "load", function() {
          a2.off(s3);
          var t3 = i2.parent(a2.Pattern);
          null !== t3 && (0 == i2.width() && 0 == i2.height() && i2.size(s3.width, s3.height), t3 && 0 == t3.width() && 0 == t3.height() && t3.size(i2.width(), i2.height()), "function" == typeof i2._loaded && i2._loaded.call(i2, { width: s3.width, height: s3.height, ratio: s3.width / s3.height, url: e3 }));
        }), a2.on(s3, "error", function(t3) {
          a2.off(s3), "function" == typeof i2._error && i2._error.call(i2, t3);
        }), this.attr("href", s3.src = this.src = e3, a2.xlink);
      }, loaded: function(t3) {
        return this._loaded = t3, this;
      }, error: function(t3) {
        return this._error = t3, this;
      } }, construct: { image: function(t3, e3, i2) {
        return this.put(new a2.Image()).load(t3).size(e3 || 0, i2 || e3 || 0);
      } } }), a2.Text = a2.invent({ create: function() {
        this.constructor.call(this, a2.create("text")), this.dom.leading = new a2.Number(1.3), this._rebuild = true, this._build = false, this.attr("font-family", a2.defaults.attrs["font-family"]);
      }, inherit: a2.Shape, extend: { x: function(t3) {
        return null == t3 ? this.attr("x") : this.attr("x", t3);
      }, text: function(t3) {
        if (void 0 === t3) {
          t3 = "";
          for (var e3 = this.node.childNodes, i2 = 0, s3 = e3.length; i2 < s3; ++i2)
            0 != i2 && 3 != e3[i2].nodeType && 1 == a2.adopt(e3[i2]).dom.newLined && (t3 += "\n"), t3 += e3[i2].textContent;
          return t3;
        }
        if (this.clear().build(true), "function" == typeof t3)
          t3.call(this, this);
        else {
          i2 = 0;
          for (var r3 = (t3 = t3.split("\n")).length; i2 < r3; i2++)
            this.tspan(t3[i2]).newLine();
        }
        return this.build(false).rebuild();
      }, size: function(t3) {
        return this.attr("font-size", t3).rebuild();
      }, leading: function(t3) {
        return null == t3 ? this.dom.leading : (this.dom.leading = new a2.Number(t3), this.rebuild());
      }, lines: function() {
        var t3 = (this.textPath && this.textPath() || this).node, e3 = a2.utils.map(a2.utils.filterSVGElements(t3.childNodes), function(t4) {
          return a2.adopt(t4);
        });
        return new a2.Set(e3);
      }, rebuild: function(t3) {
        if ("boolean" == typeof t3 && (this._rebuild = t3), this._rebuild) {
          var e3 = this, i2 = 0, s3 = this.dom.leading * new a2.Number(this.attr("font-size"));
          this.lines().each(function() {
            this.dom.newLined && (e3.textPath() || this.attr("x", e3.attr("x")), "\n" == this.text() ? i2 += s3 : (this.attr("dy", s3 + i2), i2 = 0));
          }), this.fire("rebuild");
        }
        return this;
      }, build: function(t3) {
        return this._build = !!t3, this;
      }, setData: function(t3) {
        return this.dom = t3, this.dom.leading = new a2.Number(t3.leading || 1.3), this;
      } }, construct: { text: function(t3) {
        return this.put(new a2.Text()).text(t3);
      }, plain: function(t3) {
        return this.put(new a2.Text()).plain(t3);
      } } }), a2.Tspan = a2.invent({ create: "tspan", inherit: a2.Shape, extend: { text: function(t3) {
        return null == t3 ? this.node.textContent + (this.dom.newLined ? "\n" : "") : ("function" == typeof t3 ? t3.call(this, this) : this.plain(t3), this);
      }, dx: function(t3) {
        return this.attr("dx", t3);
      }, dy: function(t3) {
        return this.attr("dy", t3);
      }, newLine: function() {
        var t3 = this.parent(a2.Text);
        return this.dom.newLined = true, this.dy(t3.dom.leading * t3.attr("font-size")).attr("x", t3.x());
      } } }), a2.extend(a2.Text, a2.Tspan, { plain: function(t3) {
        return false === this._build && this.clear(), this.node.appendChild(e2.createTextNode(t3)), this;
      }, tspan: function(t3) {
        var e3 = (this.textPath && this.textPath() || this).node, i2 = new a2.Tspan();
        return false === this._build && this.clear(), e3.appendChild(i2.node), i2.text(t3);
      }, clear: function() {
        for (var t3 = (this.textPath && this.textPath() || this).node; t3.hasChildNodes(); )
          t3.removeChild(t3.lastChild);
        return this;
      }, length: function() {
        return this.node.getComputedTextLength();
      } }), a2.TextPath = a2.invent({ create: "textPath", inherit: a2.Parent, parent: a2.Text, construct: { morphArray: a2.PathArray, array: function() {
        var t3 = this.track();
        return t3 ? t3.array() : null;
      }, plot: function(t3) {
        var e3 = this.track(), i2 = null;
        return e3 && (i2 = e3.plot(t3)), null == t3 ? i2 : this;
      }, track: function() {
        var t3 = this.textPath();
        if (t3)
          return t3.reference("href");
      }, textPath: function() {
        if (this.node.firstChild && "textPath" == this.node.firstChild.nodeName)
          return a2.adopt(this.node.firstChild);
      } } }), a2.Nested = a2.invent({ create: function() {
        this.constructor.call(this, a2.create("svg")), this.style("overflow", "visible");
      }, inherit: a2.Container, construct: { nested: function() {
        return this.put(new a2.Nested());
      } } });
      var l2 = { stroke: ["color", "width", "opacity", "linecap", "linejoin", "miterlimit", "dasharray", "dashoffset"], fill: ["color", "opacity", "rule"], prefix: function(t3, e3) {
        return "color" == e3 ? t3 : t3 + "-" + e3;
      } };
      function h2(t3, e3, i2, s3) {
        return i2 + s3.replace(a2.regex.dots, " .");
      }
      function c2(t3) {
        return t3.toLowerCase().replace(/-(.)/g, function(t4, e3) {
          return e3.toUpperCase();
        });
      }
      function d2(t3) {
        return t3.charAt(0).toUpperCase() + t3.slice(1);
      }
      function g2(t3) {
        var e3 = t3.toString(16);
        return 1 == e3.length ? "0" + e3 : e3;
      }
      function u2(t3, e3, i2) {
        if (null == e3 || null == i2) {
          var a3 = t3.bbox();
          null == e3 ? e3 = a3.width / a3.height * i2 : null == i2 && (i2 = a3.height / a3.width * e3);
        }
        return { width: e3, height: i2 };
      }
      function p2(t3, e3, i2) {
        return { x: e3 * t3.a + i2 * t3.c + 0, y: e3 * t3.b + i2 * t3.d + 0 };
      }
      function f2(t3) {
        return { a: t3[0], b: t3[1], c: t3[2], d: t3[3], e: t3[4], f: t3[5] };
      }
      function x2(e3) {
        for (var i2 = e3.childNodes.length - 1; i2 >= 0; i2--)
          e3.childNodes[i2] instanceof t2.SVGElement && x2(e3.childNodes[i2]);
        return a2.adopt(e3).id(a2.eid(e3.nodeName));
      }
      function b2(t3) {
        return Math.abs(t3) > 1e-37 ? t3 : 0;
      }
      ["fill", "stroke"].forEach(function(t3) {
        var e3 = {};
        e3[t3] = function(e4) {
          if (void 0 === e4)
            return this;
          if ("string" == typeof e4 || a2.Color.isRgb(e4) || e4 && "function" == typeof e4.fill)
            this.attr(t3, e4);
          else
            for (var i2 = l2[t3].length - 1; i2 >= 0; i2--)
              null != e4[l2[t3][i2]] && this.attr(l2.prefix(t3, l2[t3][i2]), e4[l2[t3][i2]]);
          return this;
        }, a2.extend(a2.Element, a2.FX, e3);
      }), a2.extend(a2.Element, a2.FX, { translate: function(t3, e3) {
        return this.transform({ x: t3, y: e3 });
      }, matrix: function(t3) {
        return this.attr("transform", new a2.Matrix(6 == arguments.length ? [].slice.call(arguments) : t3));
      }, opacity: function(t3) {
        return this.attr("opacity", t3);
      }, dx: function(t3) {
        return this.x(new a2.Number(t3).plus(this instanceof a2.FX ? 0 : this.x()), true);
      }, dy: function(t3) {
        return this.y(new a2.Number(t3).plus(this instanceof a2.FX ? 0 : this.y()), true);
      } }), a2.extend(a2.Path, { length: function() {
        return this.node.getTotalLength();
      }, pointAt: function(t3) {
        return this.node.getPointAtLength(t3);
      } }), a2.Set = a2.invent({ create: function(t3) {
        Array.isArray(t3) ? this.members = t3 : this.clear();
      }, extend: { add: function() {
        for (var t3 = [].slice.call(arguments), e3 = 0, i2 = t3.length; e3 < i2; e3++)
          this.members.push(t3[e3]);
        return this;
      }, remove: function(t3) {
        var e3 = this.index(t3);
        return e3 > -1 && this.members.splice(e3, 1), this;
      }, each: function(t3) {
        for (var e3 = 0, i2 = this.members.length; e3 < i2; e3++)
          t3.apply(this.members[e3], [e3, this.members]);
        return this;
      }, clear: function() {
        return this.members = [], this;
      }, length: function() {
        return this.members.length;
      }, has: function(t3) {
        return this.index(t3) >= 0;
      }, index: function(t3) {
        return this.members.indexOf(t3);
      }, get: function(t3) {
        return this.members[t3];
      }, first: function() {
        return this.get(0);
      }, last: function() {
        return this.get(this.members.length - 1);
      }, valueOf: function() {
        return this.members;
      } }, construct: { set: function(t3) {
        return new a2.Set(t3);
      } } }), a2.FX.Set = a2.invent({ create: function(t3) {
        this.set = t3;
      } }), a2.Set.inherit = function() {
        var t3 = [];
        for (var e3 in a2.Shape.prototype)
          "function" == typeof a2.Shape.prototype[e3] && "function" != typeof a2.Set.prototype[e3] && t3.push(e3);
        for (var e3 in t3.forEach(function(t4) {
          a2.Set.prototype[t4] = function() {
            for (var e4 = 0, i2 = this.members.length; e4 < i2; e4++)
              this.members[e4] && "function" == typeof this.members[e4][t4] && this.members[e4][t4].apply(this.members[e4], arguments);
            return "animate" == t4 ? this.fx || (this.fx = new a2.FX.Set(this)) : this;
          };
        }), t3 = [], a2.FX.prototype)
          "function" == typeof a2.FX.prototype[e3] && "function" != typeof a2.FX.Set.prototype[e3] && t3.push(e3);
        t3.forEach(function(t4) {
          a2.FX.Set.prototype[t4] = function() {
            for (var e4 = 0, i2 = this.set.members.length; e4 < i2; e4++)
              this.set.members[e4].fx[t4].apply(this.set.members[e4].fx, arguments);
            return this;
          };
        });
      }, a2.extend(a2.Element, {}), a2.extend(a2.Element, { remember: function(t3, e3) {
        if ("object" === i(arguments[0]))
          for (var a3 in t3)
            this.remember(a3, t3[a3]);
        else {
          if (1 == arguments.length)
            return this.memory()[t3];
          this.memory()[t3] = e3;
        }
        return this;
      }, forget: function() {
        if (0 == arguments.length)
          this._memory = {};
        else
          for (var t3 = arguments.length - 1; t3 >= 0; t3--)
            delete this.memory()[arguments[t3]];
        return this;
      }, memory: function() {
        return this._memory || (this._memory = {});
      } }), a2.get = function(t3) {
        var i2 = e2.getElementById(function(t4) {
          var e3 = (t4 || "").toString().match(a2.regex.reference);
          if (e3)
            return e3[1];
        }(t3) || t3);
        return a2.adopt(i2);
      }, a2.select = function(t3, i2) {
        return new a2.Set(a2.utils.map((i2 || e2).querySelectorAll(t3), function(t4) {
          return a2.adopt(t4);
        }));
      }, a2.extend(a2.Parent, { select: function(t3) {
        return a2.select(t3, this.node);
      } });
      var v2 = "abcdef".split("");
      if ("function" != typeof t2.CustomEvent) {
        var m2 = function(t3, i2) {
          i2 = i2 || { bubbles: false, cancelable: false, detail: void 0 };
          var a3 = e2.createEvent("CustomEvent");
          return a3.initCustomEvent(t3, i2.bubbles, i2.cancelable, i2.detail), a3;
        };
        m2.prototype = t2.Event.prototype, a2.CustomEvent = m2;
      } else
        a2.CustomEvent = t2.CustomEvent;
      return a2;
    }, "function" == typeof define && define.amd ? define(function() {
      return Ht(Rt, Rt.document);
    }) : "object" === ("undefined" == typeof exports ? "undefined" : i(exports)) && "undefined" != typeof module ? module.exports = Rt.document ? Ht(Rt, Rt.document) : function(t2) {
      return Ht(t2, t2.document);
    } : Rt.SVG = Ht(Rt, Rt.document), function() {
      SVG.Filter = SVG.invent({ create: "filter", inherit: SVG.Parent, extend: { source: "SourceGraphic", sourceAlpha: "SourceAlpha", background: "BackgroundImage", backgroundAlpha: "BackgroundAlpha", fill: "FillPaint", stroke: "StrokePaint", autoSetIn: true, put: function(t3, e3) {
        return this.add(t3, e3), !t3.attr("in") && this.autoSetIn && t3.attr("in", this.source), t3.attr("result") || t3.attr("result", t3), t3;
      }, blend: function(t3, e3, i3) {
        return this.put(new SVG.BlendEffect(t3, e3, i3));
      }, colorMatrix: function(t3, e3) {
        return this.put(new SVG.ColorMatrixEffect(t3, e3));
      }, convolveMatrix: function(t3) {
        return this.put(new SVG.ConvolveMatrixEffect(t3));
      }, componentTransfer: function(t3) {
        return this.put(new SVG.ComponentTransferEffect(t3));
      }, composite: function(t3, e3, i3) {
        return this.put(new SVG.CompositeEffect(t3, e3, i3));
      }, flood: function(t3, e3) {
        return this.put(new SVG.FloodEffect(t3, e3));
      }, offset: function(t3, e3) {
        return this.put(new SVG.OffsetEffect(t3, e3));
      }, image: function(t3) {
        return this.put(new SVG.ImageEffect(t3));
      }, merge: function() {
        var t3 = [void 0];
        for (var e3 in arguments)
          t3.push(arguments[e3]);
        return this.put(new (SVG.MergeEffect.bind.apply(SVG.MergeEffect, t3))());
      }, gaussianBlur: function(t3, e3) {
        return this.put(new SVG.GaussianBlurEffect(t3, e3));
      }, morphology: function(t3, e3) {
        return this.put(new SVG.MorphologyEffect(t3, e3));
      }, diffuseLighting: function(t3, e3, i3) {
        return this.put(new SVG.DiffuseLightingEffect(t3, e3, i3));
      }, displacementMap: function(t3, e3, i3, a3, s3) {
        return this.put(new SVG.DisplacementMapEffect(t3, e3, i3, a3, s3));
      }, specularLighting: function(t3, e3, i3, a3) {
        return this.put(new SVG.SpecularLightingEffect(t3, e3, i3, a3));
      }, tile: function() {
        return this.put(new SVG.TileEffect());
      }, turbulence: function(t3, e3, i3, a3, s3) {
        return this.put(new SVG.TurbulenceEffect(t3, e3, i3, a3, s3));
      }, toString: function() {
        return "url(#" + this.attr("id") + ")";
      } } }), SVG.extend(SVG.Defs, { filter: function(t3) {
        var e3 = this.put(new SVG.Filter());
        return "function" == typeof t3 && t3.call(e3, e3), e3;
      } }), SVG.extend(SVG.Container, { filter: function(t3) {
        return this.defs().filter(t3);
      } }), SVG.extend(SVG.Element, SVG.G, SVG.Nested, { filter: function(t3) {
        return this.filterer = t3 instanceof SVG.Element ? t3 : this.doc().filter(t3), this.doc() && this.filterer.doc() !== this.doc() && this.doc().defs().add(this.filterer), this.attr("filter", this.filterer), this.filterer;
      }, unfilter: function(t3) {
        return this.filterer && true === t3 && this.filterer.remove(), delete this.filterer, this.attr("filter", null);
      } }), SVG.Effect = SVG.invent({ create: function() {
        this.constructor.call(this);
      }, inherit: SVG.Element, extend: { in: function(t3) {
        return null == t3 ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", t3);
      }, result: function(t3) {
        return null == t3 ? this.attr("result") : this.attr("result", t3);
      }, toString: function() {
        return this.result();
      } } }), SVG.ParentEffect = SVG.invent({ create: function() {
        this.constructor.call(this);
      }, inherit: SVG.Parent, extend: { in: function(t3) {
        return null == t3 ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", t3);
      }, result: function(t3) {
        return null == t3 ? this.attr("result") : this.attr("result", t3);
      }, toString: function() {
        return this.result();
      } } });
      var t2 = { blend: function(t3, e3) {
        return this.parent() && this.parent().blend(this, t3, e3);
      }, colorMatrix: function(t3, e3) {
        return this.parent() && this.parent().colorMatrix(t3, e3).in(this);
      }, convolveMatrix: function(t3) {
        return this.parent() && this.parent().convolveMatrix(t3).in(this);
      }, componentTransfer: function(t3) {
        return this.parent() && this.parent().componentTransfer(t3).in(this);
      }, composite: function(t3, e3) {
        return this.parent() && this.parent().composite(this, t3, e3);
      }, flood: function(t3, e3) {
        return this.parent() && this.parent().flood(t3, e3);
      }, offset: function(t3, e3) {
        return this.parent() && this.parent().offset(t3, e3).in(this);
      }, image: function(t3) {
        return this.parent() && this.parent().image(t3);
      }, merge: function() {
        return this.parent() && this.parent().merge.apply(this.parent(), [this].concat(arguments));
      }, gaussianBlur: function(t3, e3) {
        return this.parent() && this.parent().gaussianBlur(t3, e3).in(this);
      }, morphology: function(t3, e3) {
        return this.parent() && this.parent().morphology(t3, e3).in(this);
      }, diffuseLighting: function(t3, e3, i3) {
        return this.parent() && this.parent().diffuseLighting(t3, e3, i3).in(this);
      }, displacementMap: function(t3, e3, i3, a3) {
        return this.parent() && this.parent().displacementMap(this, t3, e3, i3, a3);
      }, specularLighting: function(t3, e3, i3, a3) {
        return this.parent() && this.parent().specularLighting(t3, e3, i3, a3).in(this);
      }, tile: function() {
        return this.parent() && this.parent().tile().in(this);
      }, turbulence: function(t3, e3, i3, a3, s3) {
        return this.parent() && this.parent().turbulence(t3, e3, i3, a3, s3).in(this);
      } };
      SVG.extend(SVG.Effect, t2), SVG.extend(SVG.ParentEffect, t2), SVG.ChildEffect = SVG.invent({ create: function() {
        this.constructor.call(this);
      }, inherit: SVG.Element, extend: { in: function(t3) {
        this.attr("in", t3);
      } } });
      var e2 = { blend: function(t3, e3, i3) {
        this.attr({ in: t3, in2: e3, mode: i3 || "normal" });
      }, colorMatrix: function(t3, e3) {
        "matrix" == t3 && (e3 = s2(e3)), this.attr({ type: t3, values: void 0 === e3 ? null : e3 });
      }, convolveMatrix: function(t3) {
        t3 = s2(t3), this.attr({ order: Math.sqrt(t3.split(" ").length), kernelMatrix: t3 });
      }, composite: function(t3, e3, i3) {
        this.attr({ in: t3, in2: e3, operator: i3 });
      }, flood: function(t3, e3) {
        this.attr("flood-color", t3), null != e3 && this.attr("flood-opacity", e3);
      }, offset: function(t3, e3) {
        this.attr({ dx: t3, dy: e3 });
      }, image: function(t3) {
        this.attr("href", t3, SVG.xlink);
      }, displacementMap: function(t3, e3, i3, a3, s3) {
        this.attr({ in: t3, in2: e3, scale: i3, xChannelSelector: a3, yChannelSelector: s3 });
      }, gaussianBlur: function(t3, e3) {
        null != t3 || null != e3 ? this.attr("stdDeviation", function(t4) {
          if (!Array.isArray(t4))
            return t4;
          for (var e4 = 0, i3 = t4.length, a3 = []; e4 < i3; e4++)
            a3.push(t4[e4]);
          return a3.join(" ");
        }(Array.prototype.slice.call(arguments))) : this.attr("stdDeviation", "0 0");
      }, morphology: function(t3, e3) {
        this.attr({ operator: t3, radius: e3 });
      }, tile: function() {
      }, turbulence: function(t3, e3, i3, a3, s3) {
        this.attr({ numOctaves: e3, seed: i3, stitchTiles: a3, baseFrequency: t3, type: s3 });
      } }, i2 = { merge: function() {
        var t3;
        if (arguments[0] instanceof SVG.Set) {
          var e3 = this;
          arguments[0].each(function(t4) {
            this instanceof SVG.MergeNode ? e3.put(this) : (this instanceof SVG.Effect || this instanceof SVG.ParentEffect) && e3.put(new SVG.MergeNode(this));
          });
        } else {
          t3 = Array.isArray(arguments[0]) ? arguments[0] : arguments;
          for (var i3 = 0; i3 < t3.length; i3++)
            t3[i3] instanceof SVG.MergeNode ? this.put(t3[i3]) : this.put(new SVG.MergeNode(t3[i3]));
        }
      }, componentTransfer: function(t3) {
        if (this.rgb = new SVG.Set(), ["r", "g", "b", "a"].forEach(function(t4) {
          this[t4] = new SVG["Func" + t4.toUpperCase()]("identity"), this.rgb.add(this[t4]), this.node.appendChild(this[t4].node);
        }.bind(this)), t3)
          for (var e3 in t3.rgb && (["r", "g", "b"].forEach(function(e4) {
            this[e4].attr(t3.rgb);
          }.bind(this)), delete t3.rgb), t3)
            this[e3].attr(t3[e3]);
      }, diffuseLighting: function(t3, e3, i3) {
        this.attr({ surfaceScale: t3, diffuseConstant: e3, kernelUnitLength: i3 });
      }, specularLighting: function(t3, e3, i3, a3) {
        this.attr({ surfaceScale: t3, diffuseConstant: e3, specularExponent: i3, kernelUnitLength: a3 });
      } }, a2 = { distantLight: function(t3, e3) {
        this.attr({ azimuth: t3, elevation: e3 });
      }, pointLight: function(t3, e3, i3) {
        this.attr({ x: t3, y: e3, z: i3 });
      }, spotLight: function(t3, e3, i3, a3, s3, r3) {
        this.attr({ x: t3, y: e3, z: i3, pointsAtX: a3, pointsAtY: s3, pointsAtZ: r3 });
      }, mergeNode: function(t3) {
        this.attr("in", t3);
      } };
      function s2(t3) {
        return Array.isArray(t3) && (t3 = new SVG.Array(t3)), t3.toString().replace(/^\s+/, "").replace(/\s+$/, "").replace(/\s+/g, " ");
      }
      function r2() {
        var t3 = function() {
        };
        for (var e3 in "function" == typeof arguments[arguments.length - 1] && (t3 = arguments[arguments.length - 1], Array.prototype.splice.call(arguments, arguments.length - 1, 1)), arguments)
          for (var i3 in arguments[e3])
            t3(arguments[e3][i3], i3, arguments[e3]);
      }
      ["r", "g", "b", "a"].forEach(function(t3) {
        a2["Func" + t3.toUpperCase()] = function(t4) {
          switch (this.attr("type", t4), t4) {
            case "table":
              this.attr("tableValues", arguments[1]);
              break;
            case "linear":
              this.attr("slope", arguments[1]), this.attr("intercept", arguments[2]);
              break;
            case "gamma":
              this.attr("amplitude", arguments[1]), this.attr("exponent", arguments[2]), this.attr("offset", arguments[2]);
          }
        };
      }), r2(e2, function(t3, e3) {
        var i3 = e3.charAt(0).toUpperCase() + e3.slice(1);
        SVG[i3 + "Effect"] = SVG.invent({ create: function() {
          this.constructor.call(this, SVG.create("fe" + i3)), t3.apply(this, arguments), this.result(this.attr("id") + "Out");
        }, inherit: SVG.Effect, extend: {} });
      }), r2(i2, function(t3, e3) {
        var i3 = e3.charAt(0).toUpperCase() + e3.slice(1);
        SVG[i3 + "Effect"] = SVG.invent({ create: function() {
          this.constructor.call(this, SVG.create("fe" + i3)), t3.apply(this, arguments), this.result(this.attr("id") + "Out");
        }, inherit: SVG.ParentEffect, extend: {} });
      }), r2(a2, function(t3, e3) {
        var i3 = e3.charAt(0).toUpperCase() + e3.slice(1);
        SVG[i3] = SVG.invent({ create: function() {
          this.constructor.call(this, SVG.create("fe" + i3)), t3.apply(this, arguments);
        }, inherit: SVG.ChildEffect, extend: {} });
      }), SVG.extend(SVG.MergeEffect, { in: function(t3) {
        return t3 instanceof SVG.MergeNode ? this.add(t3, 0) : this.add(new SVG.MergeNode(t3), 0), this;
      } }), SVG.extend(SVG.CompositeEffect, SVG.BlendEffect, SVG.DisplacementMapEffect, { in2: function(t3) {
        return null == t3 ? this.parent() && this.parent().select('[result="' + this.attr("in2") + '"]').get(0) || this.attr("in2") : this.attr("in2", t3);
      } }), SVG.filter = { sepiatone: [0.343, 0.669, 0.119, 0, 0, 0.249, 0.626, 0.13, 0, 0, 0.172, 0.334, 0.111, 0, 0, 0, 0, 0, 1, 0] };
    }.call(void 0), function() {
      function t2(t3, s3, r2, o2, n2, l2, h2) {
        for (var c2 = t3.slice(s3, r2 || h2), d2 = o2.slice(n2, l2 || h2), g2 = 0, u2 = { pos: [0, 0], start: [0, 0] }, p2 = { pos: [0, 0], start: [0, 0] }; ; ) {
          if (c2[g2] = e2.call(u2, c2[g2]), d2[g2] = e2.call(p2, d2[g2]), c2[g2][0] != d2[g2][0] || "M" == c2[g2][0] || "A" == c2[g2][0] && (c2[g2][4] != d2[g2][4] || c2[g2][5] != d2[g2][5]) ? (Array.prototype.splice.apply(c2, [g2, 1].concat(a2.call(u2, c2[g2]))), Array.prototype.splice.apply(d2, [g2, 1].concat(a2.call(p2, d2[g2])))) : (c2[g2] = i2.call(u2, c2[g2]), d2[g2] = i2.call(p2, d2[g2])), ++g2 == c2.length && g2 == d2.length)
            break;
          g2 == c2.length && c2.push(["C", u2.pos[0], u2.pos[1], u2.pos[0], u2.pos[1], u2.pos[0], u2.pos[1]]), g2 == d2.length && d2.push(["C", p2.pos[0], p2.pos[1], p2.pos[0], p2.pos[1], p2.pos[0], p2.pos[1]]);
        }
        return { start: c2, dest: d2 };
      }
      function e2(t3) {
        switch (t3[0]) {
          case "z":
          case "Z":
            t3[0] = "L", t3[1] = this.start[0], t3[2] = this.start[1];
            break;
          case "H":
            t3[0] = "L", t3[2] = this.pos[1];
            break;
          case "V":
            t3[0] = "L", t3[2] = t3[1], t3[1] = this.pos[0];
            break;
          case "T":
            t3[0] = "Q", t3[3] = t3[1], t3[4] = t3[2], t3[1] = this.reflection[1], t3[2] = this.reflection[0];
            break;
          case "S":
            t3[0] = "C", t3[6] = t3[4], t3[5] = t3[3], t3[4] = t3[2], t3[3] = t3[1], t3[2] = this.reflection[1], t3[1] = this.reflection[0];
        }
        return t3;
      }
      function i2(t3) {
        var e3 = t3.length;
        return this.pos = [t3[e3 - 2], t3[e3 - 1]], -1 != "SCQT".indexOf(t3[0]) && (this.reflection = [2 * this.pos[0] - t3[e3 - 4], 2 * this.pos[1] - t3[e3 - 3]]), t3;
      }
      function a2(t3) {
        var e3 = [t3];
        switch (t3[0]) {
          case "M":
            return this.pos = this.start = [t3[1], t3[2]], e3;
          case "L":
            t3[5] = t3[3] = t3[1], t3[6] = t3[4] = t3[2], t3[1] = this.pos[0], t3[2] = this.pos[1];
            break;
          case "Q":
            t3[6] = t3[4], t3[5] = t3[3], t3[4] = 1 * t3[4] / 3 + 2 * t3[2] / 3, t3[3] = 1 * t3[3] / 3 + 2 * t3[1] / 3, t3[2] = 1 * this.pos[1] / 3 + 2 * t3[2] / 3, t3[1] = 1 * this.pos[0] / 3 + 2 * t3[1] / 3;
            break;
          case "A":
            e3 = function(t4, e4) {
              var i3, a3, s3, r2, o2, n2, l2, h2, c2, d2, g2, u2, p2, f2, x2, b2, v2, m2, y2, w2, k2, A2, S2, C2, L2, P2, I2 = Math.abs(e4[1]), T2 = Math.abs(e4[2]), M2 = e4[3] % 360, z2 = e4[4], X2 = e4[5], E2 = e4[6], Y2 = e4[7], F2 = new SVG.Point(t4), R2 = new SVG.Point(E2, Y2), H2 = [];
              if (0 === I2 || 0 === T2 || F2.x === R2.x && F2.y === R2.y)
                return [["C", F2.x, F2.y, R2.x, R2.y, R2.x, R2.y]];
              i3 = new SVG.Point((F2.x - R2.x) / 2, (F2.y - R2.y) / 2).transform(new SVG.Matrix().rotate(M2)), (a3 = i3.x * i3.x / (I2 * I2) + i3.y * i3.y / (T2 * T2)) > 1 && (I2 *= a3 = Math.sqrt(a3), T2 *= a3);
              s3 = new SVG.Matrix().rotate(M2).scale(1 / I2, 1 / T2).rotate(-M2), F2 = F2.transform(s3), R2 = R2.transform(s3), r2 = [R2.x - F2.x, R2.y - F2.y], n2 = r2[0] * r2[0] + r2[1] * r2[1], o2 = Math.sqrt(n2), r2[0] /= o2, r2[1] /= o2, l2 = n2 < 4 ? Math.sqrt(1 - n2 / 4) : 0, z2 === X2 && (l2 *= -1);
              h2 = new SVG.Point((R2.x + F2.x) / 2 + l2 * -r2[1], (R2.y + F2.y) / 2 + l2 * r2[0]), c2 = new SVG.Point(F2.x - h2.x, F2.y - h2.y), d2 = new SVG.Point(R2.x - h2.x, R2.y - h2.y), g2 = Math.acos(c2.x / Math.sqrt(c2.x * c2.x + c2.y * c2.y)), c2.y < 0 && (g2 *= -1);
              u2 = Math.acos(d2.x / Math.sqrt(d2.x * d2.x + d2.y * d2.y)), d2.y < 0 && (u2 *= -1);
              X2 && g2 > u2 && (u2 += 2 * Math.PI);
              !X2 && g2 < u2 && (u2 -= 2 * Math.PI);
              for (f2 = Math.ceil(2 * Math.abs(g2 - u2) / Math.PI), b2 = [], v2 = g2, p2 = (u2 - g2) / f2, x2 = 4 * Math.tan(p2 / 4) / 3, k2 = 0; k2 <= f2; k2++)
                y2 = Math.cos(v2), m2 = Math.sin(v2), w2 = new SVG.Point(h2.x + y2, h2.y + m2), b2[k2] = [new SVG.Point(w2.x + x2 * m2, w2.y - x2 * y2), w2, new SVG.Point(w2.x - x2 * m2, w2.y + x2 * y2)], v2 += p2;
              for (b2[0][0] = b2[0][1].clone(), b2[b2.length - 1][2] = b2[b2.length - 1][1].clone(), s3 = new SVG.Matrix().rotate(M2).scale(I2, T2).rotate(-M2), k2 = 0, A2 = b2.length; k2 < A2; k2++)
                b2[k2][0] = b2[k2][0].transform(s3), b2[k2][1] = b2[k2][1].transform(s3), b2[k2][2] = b2[k2][2].transform(s3);
              for (k2 = 1, A2 = b2.length; k2 < A2; k2++)
                S2 = (w2 = b2[k2 - 1][2]).x, C2 = w2.y, L2 = (w2 = b2[k2][0]).x, P2 = w2.y, E2 = (w2 = b2[k2][1]).x, Y2 = w2.y, H2.push(["C", S2, C2, L2, P2, E2, Y2]);
              return H2;
            }(this.pos, t3), t3 = e3[0];
        }
        return t3[0] = "C", this.pos = [t3[5], t3[6]], this.reflection = [2 * t3[5] - t3[3], 2 * t3[6] - t3[4]], e3;
      }
      function s2(t3, e3) {
        if (false === e3)
          return false;
        for (var i3 = e3, a3 = t3.length; i3 < a3; ++i3)
          if ("M" == t3[i3][0])
            return i3;
        return false;
      }
      SVG.extend(SVG.PathArray, { morph: function(e3) {
        for (var i3 = this.value, a3 = this.parse(e3), r2 = 0, o2 = 0, n2 = false, l2 = false; false !== r2 || false !== o2; ) {
          var h2;
          n2 = s2(i3, false !== r2 && r2 + 1), l2 = s2(a3, false !== o2 && o2 + 1), false === r2 && (r2 = 0 == (h2 = new SVG.PathArray(c2.start).bbox()).height || 0 == h2.width ? i3.push(i3[0]) - 1 : i3.push(["M", h2.x + h2.width / 2, h2.y + h2.height / 2]) - 1), false === o2 && (o2 = 0 == (h2 = new SVG.PathArray(c2.dest).bbox()).height || 0 == h2.width ? a3.push(a3[0]) - 1 : a3.push(["M", h2.x + h2.width / 2, h2.y + h2.height / 2]) - 1);
          var c2 = t2(i3, r2, n2, a3, o2, l2);
          i3 = i3.slice(0, r2).concat(c2.start, false === n2 ? [] : i3.slice(n2)), a3 = a3.slice(0, o2).concat(c2.dest, false === l2 ? [] : a3.slice(l2)), r2 = false !== n2 && r2 + c2.start.length, o2 = false !== l2 && o2 + c2.dest.length;
        }
        return this.value = i3, this.destination = new SVG.PathArray(), this.destination.value = a3, this;
      } });
    }(), function() {
      function t2(t3) {
        t3.remember("_draggable", this), this.el = t3;
      }
      t2.prototype.init = function(t3, e2) {
        var i2 = this;
        this.constraint = t3, this.value = e2, this.el.on("mousedown.drag", function(t4) {
          i2.start(t4);
        }), this.el.on("touchstart.drag", function(t4) {
          i2.start(t4);
        });
      }, t2.prototype.transformPoint = function(t3, e2) {
        var i2 = (t3 = t3 || window.event).changedTouches && t3.changedTouches[0] || t3;
        return this.p.x = i2.clientX - (e2 || 0), this.p.y = i2.clientY, this.p.matrixTransform(this.m);
      }, t2.prototype.getBBox = function() {
        var t3 = this.el.bbox();
        return this.el instanceof SVG.Nested && (t3 = this.el.rbox()), (this.el instanceof SVG.G || this.el instanceof SVG.Use || this.el instanceof SVG.Nested) && (t3.x = this.el.x(), t3.y = this.el.y()), t3;
      }, t2.prototype.start = function(t3) {
        if ("click" != t3.type && "mousedown" != t3.type && "mousemove" != t3.type || 1 == (t3.which || t3.buttons)) {
          var e2 = this;
          if (this.el.fire("beforedrag", { event: t3, handler: this }), !this.el.event().defaultPrevented) {
            t3.preventDefault(), t3.stopPropagation(), this.parent = this.parent || this.el.parent(SVG.Nested) || this.el.parent(SVG.Doc), this.p = this.parent.node.createSVGPoint(), this.m = this.el.node.getScreenCTM().inverse();
            var i2, a2 = this.getBBox();
            if (this.el instanceof SVG.Text)
              switch (i2 = this.el.node.getComputedTextLength(), this.el.attr("text-anchor")) {
                case "middle":
                  i2 /= 2;
                  break;
                case "start":
                  i2 = 0;
              }
            this.startPoints = { point: this.transformPoint(t3, i2), box: a2, transform: this.el.transform() }, SVG.on(window, "mousemove.drag", function(t4) {
              e2.drag(t4);
            }), SVG.on(window, "touchmove.drag", function(t4) {
              e2.drag(t4);
            }), SVG.on(window, "mouseup.drag", function(t4) {
              e2.end(t4);
            }), SVG.on(window, "touchend.drag", function(t4) {
              e2.end(t4);
            }), this.el.fire("dragstart", { event: t3, p: this.startPoints.point, m: this.m, handler: this });
          }
        }
      }, t2.prototype.drag = function(t3) {
        var e2 = this.getBBox(), i2 = this.transformPoint(t3), a2 = this.startPoints.box.x + i2.x - this.startPoints.point.x, s2 = this.startPoints.box.y + i2.y - this.startPoints.point.y, r2 = this.constraint, o2 = i2.x - this.startPoints.point.x, n2 = i2.y - this.startPoints.point.y;
        if (this.el.fire("dragmove", { event: t3, p: i2, m: this.m, handler: this }), this.el.event().defaultPrevented)
          return i2;
        if ("function" == typeof r2) {
          var l2 = r2.call(this.el, a2, s2, this.m);
          "boolean" == typeof l2 && (l2 = { x: l2, y: l2 }), true === l2.x ? this.el.x(a2) : false !== l2.x && this.el.x(l2.x), true === l2.y ? this.el.y(s2) : false !== l2.y && this.el.y(l2.y);
        } else
          "object" == typeof r2 && (null != r2.minX && a2 < r2.minX ? o2 = (a2 = r2.minX) - this.startPoints.box.x : null != r2.maxX && a2 > r2.maxX - e2.width && (o2 = (a2 = r2.maxX - e2.width) - this.startPoints.box.x), null != r2.minY && s2 < r2.minY ? n2 = (s2 = r2.minY) - this.startPoints.box.y : null != r2.maxY && s2 > r2.maxY - e2.height && (n2 = (s2 = r2.maxY - e2.height) - this.startPoints.box.y), null != r2.snapToGrid && (a2 -= a2 % r2.snapToGrid, s2 -= s2 % r2.snapToGrid, o2 -= o2 % r2.snapToGrid, n2 -= n2 % r2.snapToGrid), this.el instanceof SVG.G ? this.el.matrix(this.startPoints.transform).transform({ x: o2, y: n2 }, true) : this.el.move(a2, s2));
        return i2;
      }, t2.prototype.end = function(t3) {
        var e2 = this.drag(t3);
        this.el.fire("dragend", { event: t3, p: e2, m: this.m, handler: this }), SVG.off(window, "mousemove.drag"), SVG.off(window, "touchmove.drag"), SVG.off(window, "mouseup.drag"), SVG.off(window, "touchend.drag");
      }, SVG.extend(SVG.Element, { draggable: function(e2, i2) {
        "function" != typeof e2 && "object" != typeof e2 || (i2 = e2, e2 = true);
        var a2 = this.remember("_draggable") || new t2(this);
        return (e2 = void 0 === e2 || e2) ? a2.init(i2 || {}, e2) : (this.off("mousedown.drag"), this.off("touchstart.drag")), this;
      } });
    }.call(void 0), function() {
      function t2(t3) {
        this.el = t3, t3.remember("_selectHandler", this), this.pointSelection = { isSelected: false }, this.rectSelection = { isSelected: false }, this.pointsList = { lt: [0, 0], rt: ["width", 0], rb: ["width", "height"], lb: [0, "height"], t: ["width", 0], r: ["width", "height"], b: ["width", "height"], l: [0, "height"] }, this.pointCoord = function(t4, e2, i2) {
          var a2 = "string" != typeof t4 ? t4 : e2[t4];
          return i2 ? a2 / 2 : a2;
        }, this.pointCoords = function(t4, e2) {
          var i2 = this.pointsList[t4];
          return { x: this.pointCoord(i2[0], e2, "t" === t4 || "b" === t4), y: this.pointCoord(i2[1], e2, "r" === t4 || "l" === t4) };
        };
      }
      t2.prototype.init = function(t3, e2) {
        var i2 = this.el.bbox();
        this.options = {};
        var a2 = this.el.selectize.defaults.points;
        for (var s2 in this.el.selectize.defaults)
          this.options[s2] = this.el.selectize.defaults[s2], void 0 !== e2[s2] && (this.options[s2] = e2[s2]);
        var r2 = ["points", "pointsExclude"];
        for (var s2 in r2) {
          var o2 = this.options[r2[s2]];
          "string" == typeof o2 ? o2 = o2.length > 0 ? o2.split(/\s*,\s*/i) : [] : "boolean" == typeof o2 && "points" === r2[s2] && (o2 = o2 ? a2 : []), this.options[r2[s2]] = o2;
        }
        this.options.points = [a2, this.options.points].reduce(function(t4, e3) {
          return t4.filter(function(t5) {
            return e3.indexOf(t5) > -1;
          });
        }), this.options.points = [this.options.points, this.options.pointsExclude].reduce(function(t4, e3) {
          return t4.filter(function(t5) {
            return e3.indexOf(t5) < 0;
          });
        }), this.parent = this.el.parent(), this.nested = this.nested || this.parent.group(), this.nested.matrix(new SVG.Matrix(this.el).translate(i2.x, i2.y)), this.options.deepSelect && -1 !== ["line", "polyline", "polygon"].indexOf(this.el.type) ? this.selectPoints(t3) : this.selectRect(t3), this.observe(), this.cleanup();
      }, t2.prototype.selectPoints = function(t3) {
        return this.pointSelection.isSelected = t3, this.pointSelection.set || (this.pointSelection.set = this.parent.set(), this.drawPoints()), this;
      }, t2.prototype.getPointArray = function() {
        var t3 = this.el.bbox();
        return this.el.array().valueOf().map(function(e2) {
          return [e2[0] - t3.x, e2[1] - t3.y];
        });
      }, t2.prototype.drawPoints = function() {
        for (var t3 = this, e2 = this.getPointArray(), i2 = 0, a2 = e2.length; i2 < a2; ++i2) {
          var s2 = function(e3) {
            return function(i3) {
              (i3 = i3 || window.event).preventDefault ? i3.preventDefault() : i3.returnValue = false, i3.stopPropagation();
              var a3 = i3.pageX || i3.touches[0].pageX, s3 = i3.pageY || i3.touches[0].pageY;
              t3.el.fire("point", { x: a3, y: s3, i: e3, event: i3 });
            };
          }(i2), r2 = this.drawPoint(e2[i2][0], e2[i2][1]).addClass(this.options.classPoints).addClass(this.options.classPoints + "_point").on("touchstart", s2).on("mousedown", s2);
          this.pointSelection.set.add(r2);
        }
      }, t2.prototype.drawPoint = function(t3, e2) {
        var i2 = this.options.pointType;
        switch (i2) {
          case "circle":
            return this.drawCircle(t3, e2);
          case "rect":
            return this.drawRect(t3, e2);
          default:
            if ("function" == typeof i2)
              return i2.call(this, t3, e2);
            throw new Error("Unknown " + i2 + " point type!");
        }
      }, t2.prototype.drawCircle = function(t3, e2) {
        return this.nested.circle(this.options.pointSize).center(t3, e2);
      }, t2.prototype.drawRect = function(t3, e2) {
        return this.nested.rect(this.options.pointSize, this.options.pointSize).center(t3, e2);
      }, t2.prototype.updatePointSelection = function() {
        var t3 = this.getPointArray();
        this.pointSelection.set.each(function(e2) {
          this.cx() === t3[e2][0] && this.cy() === t3[e2][1] || this.center(t3[e2][0], t3[e2][1]);
        });
      }, t2.prototype.updateRectSelection = function() {
        var t3 = this, e2 = this.el.bbox();
        if (this.rectSelection.set.get(0).attr({ width: e2.width, height: e2.height }), this.options.points.length && this.options.points.map(function(i3, a2) {
          var s2 = t3.pointCoords(i3, e2);
          t3.rectSelection.set.get(a2 + 1).center(s2.x, s2.y);
        }), this.options.rotationPoint) {
          var i2 = this.rectSelection.set.length();
          this.rectSelection.set.get(i2 - 1).center(e2.width / 2, 20);
        }
      }, t2.prototype.selectRect = function(t3) {
        var e2 = this, i2 = this.el.bbox();
        function a2(t4) {
          return function(i3) {
            (i3 = i3 || window.event).preventDefault ? i3.preventDefault() : i3.returnValue = false, i3.stopPropagation();
            var a3 = i3.pageX || i3.touches[0].pageX, s3 = i3.pageY || i3.touches[0].pageY;
            e2.el.fire(t4, { x: a3, y: s3, event: i3 });
          };
        }
        if (this.rectSelection.isSelected = t3, this.rectSelection.set = this.rectSelection.set || this.parent.set(), this.rectSelection.set.get(0) || this.rectSelection.set.add(this.nested.rect(i2.width, i2.height).addClass(this.options.classRect)), this.options.points.length && this.rectSelection.set.length() < 2) {
          this.options.points.map(function(t4, s3) {
            var r3 = e2.pointCoords(t4, i2), o2 = e2.drawPoint(r3.x, r3.y).attr("class", e2.options.classPoints + "_" + t4).on("mousedown", a2(t4)).on("touchstart", a2(t4));
            e2.rectSelection.set.add(o2);
          }), this.rectSelection.set.each(function() {
            this.addClass(e2.options.classPoints);
          });
        }
        if (this.options.rotationPoint && (this.options.points && !this.rectSelection.set.get(9) || !this.options.points && !this.rectSelection.set.get(1))) {
          var s2 = function(t4) {
            (t4 = t4 || window.event).preventDefault ? t4.preventDefault() : t4.returnValue = false, t4.stopPropagation();
            var i3 = t4.pageX || t4.touches[0].pageX, a3 = t4.pageY || t4.touches[0].pageY;
            e2.el.fire("rot", { x: i3, y: a3, event: t4 });
          }, r2 = this.drawPoint(i2.width / 2, 20).attr("class", this.options.classPoints + "_rot").on("touchstart", s2).on("mousedown", s2);
          this.rectSelection.set.add(r2);
        }
      }, t2.prototype.handler = function() {
        var t3 = this.el.bbox();
        this.nested.matrix(new SVG.Matrix(this.el).translate(t3.x, t3.y)), this.rectSelection.isSelected && this.updateRectSelection(), this.pointSelection.isSelected && this.updatePointSelection();
      }, t2.prototype.observe = function() {
        var t3 = this;
        if (MutationObserver)
          if (this.rectSelection.isSelected || this.pointSelection.isSelected)
            this.observerInst = this.observerInst || new MutationObserver(function() {
              t3.handler();
            }), this.observerInst.observe(this.el.node, { attributes: true });
          else
            try {
              this.observerInst.disconnect(), delete this.observerInst;
            } catch (t4) {
            }
        else
          this.el.off("DOMAttrModified.select"), (this.rectSelection.isSelected || this.pointSelection.isSelected) && this.el.on("DOMAttrModified.select", function() {
            t3.handler();
          });
      }, t2.prototype.cleanup = function() {
        !this.rectSelection.isSelected && this.rectSelection.set && (this.rectSelection.set.each(function() {
          this.remove();
        }), this.rectSelection.set.clear(), delete this.rectSelection.set), !this.pointSelection.isSelected && this.pointSelection.set && (this.pointSelection.set.each(function() {
          this.remove();
        }), this.pointSelection.set.clear(), delete this.pointSelection.set), this.pointSelection.isSelected || this.rectSelection.isSelected || (this.nested.remove(), delete this.nested);
      }, SVG.extend(SVG.Element, { selectize: function(e2, i2) {
        return "object" == typeof e2 && (i2 = e2, e2 = true), (this.remember("_selectHandler") || new t2(this)).init(void 0 === e2 || e2, i2 || {}), this;
      } }), SVG.Element.prototype.selectize.defaults = { points: ["lt", "rt", "rb", "lb", "t", "r", "b", "l"], pointsExclude: [], classRect: "svg_select_boundingRect", classPoints: "svg_select_points", pointSize: 7, rotationPoint: true, deepSelect: false, pointType: "circle" };
    }(), function() {
      (function() {
        function t2(t3) {
          t3.remember("_resizeHandler", this), this.el = t3, this.parameters = {}, this.lastUpdateCall = null, this.p = t3.doc().node.createSVGPoint();
        }
        t2.prototype.transformPoint = function(t3, e2, i2) {
          return this.p.x = t3 - (this.offset.x - window.pageXOffset), this.p.y = e2 - (this.offset.y - window.pageYOffset), this.p.matrixTransform(i2 || this.m);
        }, t2.prototype._extractPosition = function(t3) {
          return { x: null != t3.clientX ? t3.clientX : t3.touches[0].clientX, y: null != t3.clientY ? t3.clientY : t3.touches[0].clientY };
        }, t2.prototype.init = function(t3) {
          var e2 = this;
          if (this.stop(), "stop" !== t3) {
            for (var i2 in this.options = {}, this.el.resize.defaults)
              this.options[i2] = this.el.resize.defaults[i2], void 0 !== t3[i2] && (this.options[i2] = t3[i2]);
            this.el.on("lt.resize", function(t4) {
              e2.resize(t4 || window.event);
            }), this.el.on("rt.resize", function(t4) {
              e2.resize(t4 || window.event);
            }), this.el.on("rb.resize", function(t4) {
              e2.resize(t4 || window.event);
            }), this.el.on("lb.resize", function(t4) {
              e2.resize(t4 || window.event);
            }), this.el.on("t.resize", function(t4) {
              e2.resize(t4 || window.event);
            }), this.el.on("r.resize", function(t4) {
              e2.resize(t4 || window.event);
            }), this.el.on("b.resize", function(t4) {
              e2.resize(t4 || window.event);
            }), this.el.on("l.resize", function(t4) {
              e2.resize(t4 || window.event);
            }), this.el.on("rot.resize", function(t4) {
              e2.resize(t4 || window.event);
            }), this.el.on("point.resize", function(t4) {
              e2.resize(t4 || window.event);
            }), this.update();
          }
        }, t2.prototype.stop = function() {
          return this.el.off("lt.resize"), this.el.off("rt.resize"), this.el.off("rb.resize"), this.el.off("lb.resize"), this.el.off("t.resize"), this.el.off("r.resize"), this.el.off("b.resize"), this.el.off("l.resize"), this.el.off("rot.resize"), this.el.off("point.resize"), this;
        }, t2.prototype.resize = function(t3) {
          var e2 = this;
          this.m = this.el.node.getScreenCTM().inverse(), this.offset = { x: window.pageXOffset, y: window.pageYOffset };
          var i2 = this._extractPosition(t3.detail.event);
          if (this.parameters = { type: this.el.type, p: this.transformPoint(i2.x, i2.y), x: t3.detail.x, y: t3.detail.y, box: this.el.bbox(), rotation: this.el.transform().rotation }, "text" === this.el.type && (this.parameters.fontSize = this.el.attr()["font-size"]), void 0 !== t3.detail.i) {
            var a2 = this.el.array().valueOf();
            this.parameters.i = t3.detail.i, this.parameters.pointCoords = [a2[t3.detail.i][0], a2[t3.detail.i][1]];
          }
          switch (t3.type) {
            case "lt":
              this.calc = function(t4, e3) {
                var i3 = this.snapToGrid(t4, e3);
                if (this.parameters.box.width - i3[0] > 0 && this.parameters.box.height - i3[1] > 0) {
                  if ("text" === this.parameters.type)
                    return this.el.move(this.parameters.box.x + i3[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize - i3[0]);
                  i3 = this.checkAspectRatio(i3), this.el.move(this.parameters.box.x + i3[0], this.parameters.box.y + i3[1]).size(this.parameters.box.width - i3[0], this.parameters.box.height - i3[1]);
                }
              };
              break;
            case "rt":
              this.calc = function(t4, e3) {
                var i3 = this.snapToGrid(t4, e3, 2);
                if (this.parameters.box.width + i3[0] > 0 && this.parameters.box.height - i3[1] > 0) {
                  if ("text" === this.parameters.type)
                    return this.el.move(this.parameters.box.x - i3[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize + i3[0]);
                  i3 = this.checkAspectRatio(i3, true), this.el.move(this.parameters.box.x, this.parameters.box.y + i3[1]).size(this.parameters.box.width + i3[0], this.parameters.box.height - i3[1]);
                }
              };
              break;
            case "rb":
              this.calc = function(t4, e3) {
                var i3 = this.snapToGrid(t4, e3, 0);
                if (this.parameters.box.width + i3[0] > 0 && this.parameters.box.height + i3[1] > 0) {
                  if ("text" === this.parameters.type)
                    return this.el.move(this.parameters.box.x - i3[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize + i3[0]);
                  i3 = this.checkAspectRatio(i3), this.el.move(this.parameters.box.x, this.parameters.box.y).size(this.parameters.box.width + i3[0], this.parameters.box.height + i3[1]);
                }
              };
              break;
            case "lb":
              this.calc = function(t4, e3) {
                var i3 = this.snapToGrid(t4, e3, 1);
                if (this.parameters.box.width - i3[0] > 0 && this.parameters.box.height + i3[1] > 0) {
                  if ("text" === this.parameters.type)
                    return this.el.move(this.parameters.box.x + i3[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize - i3[0]);
                  i3 = this.checkAspectRatio(i3, true), this.el.move(this.parameters.box.x + i3[0], this.parameters.box.y).size(this.parameters.box.width - i3[0], this.parameters.box.height + i3[1]);
                }
              };
              break;
            case "t":
              this.calc = function(t4, e3) {
                var i3 = this.snapToGrid(t4, e3, 2);
                if (this.parameters.box.height - i3[1] > 0) {
                  if ("text" === this.parameters.type)
                    return;
                  this.el.move(this.parameters.box.x, this.parameters.box.y + i3[1]).height(this.parameters.box.height - i3[1]);
                }
              };
              break;
            case "r":
              this.calc = function(t4, e3) {
                var i3 = this.snapToGrid(t4, e3, 0);
                if (this.parameters.box.width + i3[0] > 0) {
                  if ("text" === this.parameters.type)
                    return;
                  this.el.move(this.parameters.box.x, this.parameters.box.y).width(this.parameters.box.width + i3[0]);
                }
              };
              break;
            case "b":
              this.calc = function(t4, e3) {
                var i3 = this.snapToGrid(t4, e3, 0);
                if (this.parameters.box.height + i3[1] > 0) {
                  if ("text" === this.parameters.type)
                    return;
                  this.el.move(this.parameters.box.x, this.parameters.box.y).height(this.parameters.box.height + i3[1]);
                }
              };
              break;
            case "l":
              this.calc = function(t4, e3) {
                var i3 = this.snapToGrid(t4, e3, 1);
                if (this.parameters.box.width - i3[0] > 0) {
                  if ("text" === this.parameters.type)
                    return;
                  this.el.move(this.parameters.box.x + i3[0], this.parameters.box.y).width(this.parameters.box.width - i3[0]);
                }
              };
              break;
            case "rot":
              this.calc = function(t4, e3) {
                var i3 = t4 + this.parameters.p.x, a3 = e3 + this.parameters.p.y, s2 = Math.atan2(this.parameters.p.y - this.parameters.box.y - this.parameters.box.height / 2, this.parameters.p.x - this.parameters.box.x - this.parameters.box.width / 2), r2 = Math.atan2(a3 - this.parameters.box.y - this.parameters.box.height / 2, i3 - this.parameters.box.x - this.parameters.box.width / 2), o2 = this.parameters.rotation + 180 * (r2 - s2) / Math.PI + this.options.snapToAngle / 2;
                this.el.center(this.parameters.box.cx, this.parameters.box.cy).rotate(o2 - o2 % this.options.snapToAngle, this.parameters.box.cx, this.parameters.box.cy);
              };
              break;
            case "point":
              this.calc = function(t4, e3) {
                var i3 = this.snapToGrid(t4, e3, this.parameters.pointCoords[0], this.parameters.pointCoords[1]), a3 = this.el.array().valueOf();
                a3[this.parameters.i][0] = this.parameters.pointCoords[0] + i3[0], a3[this.parameters.i][1] = this.parameters.pointCoords[1] + i3[1], this.el.plot(a3);
              };
          }
          this.el.fire("resizestart", { dx: this.parameters.x, dy: this.parameters.y, event: t3 }), SVG.on(window, "touchmove.resize", function(t4) {
            e2.update(t4 || window.event);
          }), SVG.on(window, "touchend.resize", function() {
            e2.done();
          }), SVG.on(window, "mousemove.resize", function(t4) {
            e2.update(t4 || window.event);
          }), SVG.on(window, "mouseup.resize", function() {
            e2.done();
          });
        }, t2.prototype.update = function(t3) {
          if (t3) {
            var e2 = this._extractPosition(t3), i2 = this.transformPoint(e2.x, e2.y), a2 = i2.x - this.parameters.p.x, s2 = i2.y - this.parameters.p.y;
            this.lastUpdateCall = [a2, s2], this.calc(a2, s2), this.el.fire("resizing", { dx: a2, dy: s2, event: t3 });
          } else
            this.lastUpdateCall && this.calc(this.lastUpdateCall[0], this.lastUpdateCall[1]);
        }, t2.prototype.done = function() {
          this.lastUpdateCall = null, SVG.off(window, "mousemove.resize"), SVG.off(window, "mouseup.resize"), SVG.off(window, "touchmove.resize"), SVG.off(window, "touchend.resize"), this.el.fire("resizedone");
        }, t2.prototype.snapToGrid = function(t3, e2, i2, a2) {
          var s2;
          return void 0 !== a2 ? s2 = [(i2 + t3) % this.options.snapToGrid, (a2 + e2) % this.options.snapToGrid] : (i2 = null == i2 ? 3 : i2, s2 = [(this.parameters.box.x + t3 + (1 & i2 ? 0 : this.parameters.box.width)) % this.options.snapToGrid, (this.parameters.box.y + e2 + (2 & i2 ? 0 : this.parameters.box.height)) % this.options.snapToGrid]), t3 < 0 && (s2[0] -= this.options.snapToGrid), e2 < 0 && (s2[1] -= this.options.snapToGrid), t3 -= Math.abs(s2[0]) < this.options.snapToGrid / 2 ? s2[0] : s2[0] - (t3 < 0 ? -this.options.snapToGrid : this.options.snapToGrid), e2 -= Math.abs(s2[1]) < this.options.snapToGrid / 2 ? s2[1] : s2[1] - (e2 < 0 ? -this.options.snapToGrid : this.options.snapToGrid), this.constraintToBox(t3, e2, i2, a2);
        }, t2.prototype.constraintToBox = function(t3, e2, i2, a2) {
          var s2, r2, o2 = this.options.constraint || {};
          return void 0 !== a2 ? (s2 = i2, r2 = a2) : (s2 = this.parameters.box.x + (1 & i2 ? 0 : this.parameters.box.width), r2 = this.parameters.box.y + (2 & i2 ? 0 : this.parameters.box.height)), void 0 !== o2.minX && s2 + t3 < o2.minX && (t3 = o2.minX - s2), void 0 !== o2.maxX && s2 + t3 > o2.maxX && (t3 = o2.maxX - s2), void 0 !== o2.minY && r2 + e2 < o2.minY && (e2 = o2.minY - r2), void 0 !== o2.maxY && r2 + e2 > o2.maxY && (e2 = o2.maxY - r2), [t3, e2];
        }, t2.prototype.checkAspectRatio = function(t3, e2) {
          if (!this.options.saveAspectRatio)
            return t3;
          var i2 = t3.slice(), a2 = this.parameters.box.width / this.parameters.box.height, s2 = this.parameters.box.width + t3[0], r2 = this.parameters.box.height - t3[1], o2 = s2 / r2;
          return o2 < a2 ? (i2[1] = s2 / a2 - this.parameters.box.height, e2 && (i2[1] = -i2[1])) : o2 > a2 && (i2[0] = this.parameters.box.width - r2 * a2, e2 && (i2[0] = -i2[0])), i2;
        }, SVG.extend(SVG.Element, { resize: function(e2) {
          return (this.remember("_resizeHandler") || new t2(this)).init(e2 || {}), this;
        } }), SVG.Element.prototype.resize.defaults = { snapToAngle: 0.1, snapToGrid: 1, constraint: {}, saveAspectRatio: false };
      }).call(this);
    }(), void 0 === window.Apex && (window.Apex = {});
    var Gt = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
      }
      return r(t2, [{ key: "initModules", value: function() {
        this.ctx.publicMethods = ["updateOptions", "updateSeries", "appendData", "appendSeries", "isSeriesHidden", "toggleSeries", "showSeries", "hideSeries", "setLocale", "resetSeries", "zoomX", "toggleDataPointSelection", "dataURI", "exportToCSV", "addXaxisAnnotation", "addYaxisAnnotation", "addPointAnnotation", "clearAnnotations", "removeAnnotation", "paper", "destroy"], this.ctx.eventList = ["click", "mousedown", "mousemove", "mouseleave", "touchstart", "touchmove", "touchleave", "mouseup", "touchend"], this.ctx.animations = new b(this.ctx), this.ctx.axes = new J(this.ctx), this.ctx.core = new Wt(this.ctx.el, this.ctx), this.ctx.config = new E({}), this.ctx.data = new W(this.ctx), this.ctx.grid = new j(this.ctx), this.ctx.graphics = new m(this.ctx), this.ctx.coreUtils = new y(this.ctx), this.ctx.crosshairs = new Q(this.ctx), this.ctx.events = new Z(this.ctx), this.ctx.exports = new G(this.ctx), this.ctx.localization = new $(this.ctx), this.ctx.options = new L(), this.ctx.responsive = new K(this.ctx), this.ctx.series = new N(this.ctx), this.ctx.theme = new tt(this.ctx), this.ctx.formatters = new T(this.ctx), this.ctx.titleSubtitle = new et(this.ctx), this.ctx.legend = new lt(this.ctx), this.ctx.toolbar = new ht(this.ctx), this.ctx.tooltip = new bt(this.ctx), this.ctx.dimensions = new ot(this.ctx), this.ctx.updateHelpers = new Bt(this.ctx), this.ctx.zoomPanSelection = new ct(this.ctx), this.ctx.w.globals.tooltip = new bt(this.ctx);
      } }]), t2;
    }();
    var Vt = function() {
      function t2(e2) {
        a(this, t2), this.ctx = e2, this.w = e2.w;
      }
      return r(t2, [{ key: "clear", value: function(t3) {
        var e2 = t3.isUpdating;
        this.ctx.zoomPanSelection && this.ctx.zoomPanSelection.destroy(), this.ctx.toolbar && this.ctx.toolbar.destroy(), this.ctx.animations = null, this.ctx.axes = null, this.ctx.annotations = null, this.ctx.core = null, this.ctx.data = null, this.ctx.grid = null, this.ctx.series = null, this.ctx.responsive = null, this.ctx.theme = null, this.ctx.formatters = null, this.ctx.titleSubtitle = null, this.ctx.legend = null, this.ctx.dimensions = null, this.ctx.options = null, this.ctx.crosshairs = null, this.ctx.zoomPanSelection = null, this.ctx.updateHelpers = null, this.ctx.toolbar = null, this.ctx.localization = null, this.ctx.w.globals.tooltip = null, this.clearDomElements({ isUpdating: e2 });
      } }, { key: "killSVG", value: function(t3) {
        t3.each(function(t4, e2) {
          this.removeClass("*"), this.off(), this.stop();
        }, true), t3.ungroup(), t3.clear();
      } }, { key: "clearDomElements", value: function(t3) {
        var e2 = this, i2 = t3.isUpdating, a2 = this.w.globals.dom.Paper.node;
        a2.parentNode && a2.parentNode.parentNode && !i2 && (a2.parentNode.parentNode.style.minHeight = "unset");
        var s2 = this.w.globals.dom.baseEl;
        s2 && this.ctx.eventList.forEach(function(t4) {
          s2.removeEventListener(t4, e2.ctx.events.documentEvent);
        });
        var r2 = this.w.globals.dom;
        if (null !== this.ctx.el)
          for (; this.ctx.el.firstChild; )
            this.ctx.el.removeChild(this.ctx.el.firstChild);
        this.killSVG(r2.Paper), r2.Paper.remove(), r2.elWrap = null, r2.elGraphical = null, r2.elLegendWrap = null, r2.elLegendForeign = null, r2.baseEl = null, r2.elGridRect = null, r2.elGridRectMask = null, r2.elGridRectMarkerMask = null, r2.elForecastMask = null, r2.elNonForecastMask = null, r2.elDefs = null;
      } }]), t2;
    }();
    var jt = /* @__PURE__ */ new WeakMap();
    var _t = function() {
      function t2(e2, i2) {
        a(this, t2), this.opts = i2, this.ctx = this, this.w = new F(i2).init(), this.el = e2, this.w.globals.cuid = x.randomId(), this.w.globals.chartID = this.w.config.chart.id ? x.escapeString(this.w.config.chart.id) : this.w.globals.cuid, new Gt(this).initModules(), this.create = x.bind(this.create, this), this.windowResizeHandler = this._windowResizeHandler.bind(this), this.parentResizeHandler = this._parentResizeCallback.bind(this);
      }
      return r(t2, [{ key: "render", value: function() {
        var t3 = this;
        return new Promise(function(e2, i2) {
          if (null !== t3.el) {
            void 0 === Apex._chartInstances && (Apex._chartInstances = []), t3.w.config.chart.id && Apex._chartInstances.push({ id: t3.w.globals.chartID, group: t3.w.config.chart.group, chart: t3 }), t3.setLocale(t3.w.config.chart.defaultLocale);
            var a2 = t3.w.config.chart.events.beforeMount;
            if ("function" == typeof a2 && a2(t3, t3.w), t3.events.fireEvent("beforeMount", [t3, t3.w]), window.addEventListener("resize", t3.windowResizeHandler), function(t4, e3) {
              var i3 = false;
              if (t4.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
                var a3 = t4.getBoundingClientRect();
                "none" !== t4.style.display && 0 !== a3.width || (i3 = true);
              }
              var s3 = new ResizeObserver(function(a4) {
                i3 && e3.call(t4, a4), i3 = true;
              });
              t4.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? Array.from(t4.children).forEach(function(t5) {
                return s3.observe(t5);
              }) : s3.observe(t4), jt.set(e3, s3);
            }(t3.el.parentNode, t3.parentResizeHandler), !t3.css) {
              var s2 = t3.el.getRootNode && t3.el.getRootNode(), r2 = x.is("ShadowRoot", s2), o2 = t3.el.ownerDocument, n2 = o2.getElementById("apexcharts-css");
              !r2 && n2 || (t3.css = document.createElement("style"), t3.css.id = "apexcharts-css", t3.css.textContent = '@keyframes opaque {\n  0% {\n      opacity: 0\n  }\n\n  to {\n      opacity: 1\n  }\n}\n\n@keyframes resizeanim {\n  0%,to {\n      opacity: 0\n  }\n}\n\n.apexcharts-canvas {\n  position: relative;\n  user-select: none\n}\n\n.apexcharts-canvas ::-webkit-scrollbar {\n  -webkit-appearance: none;\n  width: 6px\n}\n\n.apexcharts-canvas ::-webkit-scrollbar-thumb {\n  border-radius: 4px;\n  background-color: rgba(0,0,0,.5);\n  box-shadow: 0 0 1px rgba(255,255,255,.5);\n  -webkit-box-shadow: 0 0 1px rgba(255,255,255,.5)\n}\n\n.apexcharts-inner {\n  position: relative\n}\n\n.apexcharts-text tspan {\n  font-family: inherit\n}\n\n.legend-mouseover-inactive {\n  transition: .15s ease all;\n  opacity: .2\n}\n\n.apexcharts-legend-text {\n  padding-left: 15px;\n  margin-left: -15px;\n}\n\n.apexcharts-series-collapsed {\n  opacity: 0\n}\n\n.apexcharts-tooltip {\n  border-radius: 5px;\n  box-shadow: 2px 2px 6px -4px #999;\n  cursor: default;\n  font-size: 14px;\n  left: 62px;\n  opacity: 0;\n  pointer-events: none;\n  position: absolute;\n  top: 20px;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  white-space: nowrap;\n  z-index: 12;\n  transition: .15s ease all\n}\n\n.apexcharts-tooltip.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-tooltip.apexcharts-theme-light {\n  border: 1px solid #e3e3e3;\n  background: rgba(255,255,255,.96)\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark {\n  color: #fff;\n  background: rgba(30,30,30,.8)\n}\n\n.apexcharts-tooltip * {\n  font-family: inherit\n}\n\n.apexcharts-tooltip-title {\n  padding: 6px;\n  font-size: 15px;\n  margin-bottom: 4px\n}\n\n.apexcharts-tooltip.apexcharts-theme-light .apexcharts-tooltip-title {\n  background: #eceff1;\n  border-bottom: 1px solid #ddd\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark .apexcharts-tooltip-title {\n  background: rgba(0,0,0,.7);\n  border-bottom: 1px solid #333\n}\n\n.apexcharts-tooltip-text-goals-value,.apexcharts-tooltip-text-y-value,.apexcharts-tooltip-text-z-value {\n  display: inline-block;\n  margin-left: 5px;\n  font-weight: 600\n}\n\n.apexcharts-tooltip-text-goals-label:empty,.apexcharts-tooltip-text-goals-value:empty,.apexcharts-tooltip-text-y-label:empty,.apexcharts-tooltip-text-y-value:empty,.apexcharts-tooltip-text-z-value:empty,.apexcharts-tooltip-title:empty {\n  display: none\n}\n\n.apexcharts-tooltip-text-goals-label,.apexcharts-tooltip-text-goals-value {\n  padding: 6px 0 5px\n}\n\n.apexcharts-tooltip-goals-group,.apexcharts-tooltip-text-goals-label,.apexcharts-tooltip-text-goals-value {\n  display: flex\n}\n\n.apexcharts-tooltip-text-goals-label:not(:empty),.apexcharts-tooltip-text-goals-value:not(:empty) {\n  margin-top: -6px\n}\n\n.apexcharts-tooltip-marker {\n  width: 12px;\n  height: 12px;\n  position: relative;\n  top: 0;\n  margin-right: 10px;\n  border-radius: 50%\n}\n\n.apexcharts-tooltip-series-group {\n  padding: 0 10px;\n  display: none;\n  text-align: left;\n  justify-content: left;\n  align-items: center\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active .apexcharts-tooltip-marker {\n  opacity: 1\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active,.apexcharts-tooltip-series-group:last-child {\n  padding-bottom: 4px\n}\n\n.apexcharts-tooltip-series-group-hidden {\n  opacity: 0;\n  height: 0;\n  line-height: 0;\n  padding: 0!important\n}\n\n.apexcharts-tooltip-y-group {\n  padding: 6px 0 5px\n}\n\n.apexcharts-custom-tooltip,.apexcharts-tooltip-box {\n  padding: 4px 8px\n}\n\n.apexcharts-tooltip-boxPlot {\n  display: flex;\n  flex-direction: column-reverse\n}\n\n.apexcharts-tooltip-box>div {\n  margin: 4px 0\n}\n\n.apexcharts-tooltip-box span.value {\n  font-weight: 700\n}\n\n.apexcharts-tooltip-rangebar {\n  padding: 5px 8px\n}\n\n.apexcharts-tooltip-rangebar .category {\n  font-weight: 600;\n  color: #777\n}\n\n.apexcharts-tooltip-rangebar .series-name {\n  font-weight: 700;\n  display: block;\n  margin-bottom: 5px\n}\n\n.apexcharts-xaxistooltip,.apexcharts-yaxistooltip {\n  opacity: 0;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n  background: #eceff1;\n  border: 1px solid #90a4ae\n}\n\n.apexcharts-xaxistooltip {\n  padding: 9px 10px;\n  transition: .15s ease all\n}\n\n.apexcharts-xaxistooltip.apexcharts-theme-dark {\n  background: rgba(0,0,0,.7);\n  border: 1px solid rgba(0,0,0,.5);\n  color: #fff\n}\n\n.apexcharts-xaxistooltip:after,.apexcharts-xaxistooltip:before {\n  left: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none\n}\n\n.apexcharts-xaxistooltip:after {\n  border-color: transparent;\n  border-width: 6px;\n  margin-left: -6px\n}\n\n.apexcharts-xaxistooltip:before {\n  border-color: transparent;\n  border-width: 7px;\n  margin-left: -7px\n}\n\n.apexcharts-xaxistooltip-bottom:after,.apexcharts-xaxistooltip-bottom:before {\n  bottom: 100%\n}\n\n.apexcharts-xaxistooltip-top:after,.apexcharts-xaxistooltip-top:before {\n  top: 100%\n}\n\n.apexcharts-xaxistooltip-bottom:after {\n  border-bottom-color: #eceff1\n}\n\n.apexcharts-xaxistooltip-bottom:before {\n  border-bottom-color: #90a4ae\n}\n\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:after,.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:before {\n  border-bottom-color: rgba(0,0,0,.5)\n}\n\n.apexcharts-xaxistooltip-top:after {\n  border-top-color: #eceff1\n}\n\n.apexcharts-xaxistooltip-top:before {\n  border-top-color: #90a4ae\n}\n\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:after,.apexcharts-xaxistooltip-top.apexcharts-theme-dark:before {\n  border-top-color: rgba(0,0,0,.5)\n}\n\n.apexcharts-xaxistooltip.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-yaxistooltip {\n  padding: 4px 10px\n}\n\n.apexcharts-yaxistooltip.apexcharts-theme-dark {\n  background: rgba(0,0,0,.7);\n  border: 1px solid rgba(0,0,0,.5);\n  color: #fff\n}\n\n.apexcharts-yaxistooltip:after,.apexcharts-yaxistooltip:before {\n  top: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none\n}\n\n.apexcharts-yaxistooltip:after {\n  border-color: transparent;\n  border-width: 6px;\n  margin-top: -6px\n}\n\n.apexcharts-yaxistooltip:before {\n  border-color: transparent;\n  border-width: 7px;\n  margin-top: -7px\n}\n\n.apexcharts-yaxistooltip-left:after,.apexcharts-yaxistooltip-left:before {\n  left: 100%\n}\n\n.apexcharts-yaxistooltip-right:after,.apexcharts-yaxistooltip-right:before {\n  right: 100%\n}\n\n.apexcharts-yaxistooltip-left:after {\n  border-left-color: #eceff1\n}\n\n.apexcharts-yaxistooltip-left:before {\n  border-left-color: #90a4ae\n}\n\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:after,.apexcharts-yaxistooltip-left.apexcharts-theme-dark:before {\n  border-left-color: rgba(0,0,0,.5)\n}\n\n.apexcharts-yaxistooltip-right:after {\n  border-right-color: #eceff1\n}\n\n.apexcharts-yaxistooltip-right:before {\n  border-right-color: #90a4ae\n}\n\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:after,.apexcharts-yaxistooltip-right.apexcharts-theme-dark:before {\n  border-right-color: rgba(0,0,0,.5)\n}\n\n.apexcharts-yaxistooltip.apexcharts-active {\n  opacity: 1\n}\n\n.apexcharts-yaxistooltip-hidden {\n  display: none\n}\n\n.apexcharts-xcrosshairs,.apexcharts-ycrosshairs {\n  pointer-events: none;\n  opacity: 0;\n  transition: .15s ease all\n}\n\n.apexcharts-xcrosshairs.apexcharts-active,.apexcharts-ycrosshairs.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-ycrosshairs-hidden {\n  opacity: 0\n}\n\n.apexcharts-selection-rect {\n  cursor: move\n}\n\n.svg_select_boundingRect,.svg_select_points_rot {\n  pointer-events: none;\n  opacity: 0;\n  visibility: hidden\n}\n\n.apexcharts-selection-rect+g .svg_select_boundingRect,.apexcharts-selection-rect+g .svg_select_points_rot {\n  opacity: 0;\n  visibility: hidden\n}\n\n.apexcharts-selection-rect+g .svg_select_points_l,.apexcharts-selection-rect+g .svg_select_points_r {\n  cursor: ew-resize;\n  opacity: 1;\n  visibility: visible\n}\n\n.svg_select_points {\n  fill: #efefef;\n  stroke: #333;\n  rx: 2\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-zoom {\n  cursor: crosshair\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-pan {\n  cursor: move\n}\n\n.apexcharts-menu-icon,.apexcharts-pan-icon,.apexcharts-reset-icon,.apexcharts-selection-icon,.apexcharts-toolbar-custom-icon,.apexcharts-zoom-icon,.apexcharts-zoomin-icon,.apexcharts-zoomout-icon {\n  cursor: pointer;\n  width: 20px;\n  height: 20px;\n  line-height: 24px;\n  color: #6e8192;\n  text-align: center\n}\n\n.apexcharts-menu-icon svg,.apexcharts-reset-icon svg,.apexcharts-zoom-icon svg,.apexcharts-zoomin-icon svg,.apexcharts-zoomout-icon svg {\n  fill: #6e8192\n}\n\n.apexcharts-selection-icon svg {\n  fill: #444;\n  transform: scale(.76)\n}\n\n.apexcharts-theme-dark .apexcharts-menu-icon svg,.apexcharts-theme-dark .apexcharts-pan-icon svg,.apexcharts-theme-dark .apexcharts-reset-icon svg,.apexcharts-theme-dark .apexcharts-selection-icon svg,.apexcharts-theme-dark .apexcharts-toolbar-custom-icon svg,.apexcharts-theme-dark .apexcharts-zoom-icon svg,.apexcharts-theme-dark .apexcharts-zoomin-icon svg,.apexcharts-theme-dark .apexcharts-zoomout-icon svg {\n  fill: #f3f4f5\n}\n\n.apexcharts-canvas .apexcharts-reset-zoom-icon.apexcharts-selected svg,.apexcharts-canvas .apexcharts-selection-icon.apexcharts-selected svg,.apexcharts-canvas .apexcharts-zoom-icon.apexcharts-selected svg {\n  fill: #008ffb\n}\n\n.apexcharts-theme-light .apexcharts-menu-icon:hover svg,.apexcharts-theme-light .apexcharts-reset-icon:hover svg,.apexcharts-theme-light .apexcharts-selection-icon:not(.apexcharts-selected):hover svg,.apexcharts-theme-light .apexcharts-zoom-icon:not(.apexcharts-selected):hover svg,.apexcharts-theme-light .apexcharts-zoomin-icon:hover svg,.apexcharts-theme-light .apexcharts-zoomout-icon:hover svg {\n  fill: #333\n}\n\n.apexcharts-menu-icon,.apexcharts-selection-icon {\n  position: relative\n}\n\n.apexcharts-reset-icon {\n  margin-left: 5px\n}\n\n.apexcharts-menu-icon,.apexcharts-reset-icon,.apexcharts-zoom-icon {\n  transform: scale(.85)\n}\n\n.apexcharts-zoomin-icon,.apexcharts-zoomout-icon {\n  transform: scale(.7)\n}\n\n.apexcharts-zoomout-icon {\n  margin-right: 3px\n}\n\n.apexcharts-pan-icon {\n  transform: scale(.62);\n  position: relative;\n  left: 1px;\n  top: 0\n}\n\n.apexcharts-pan-icon svg {\n  fill: #fff;\n  stroke: #6e8192;\n  stroke-width: 2\n}\n\n.apexcharts-pan-icon.apexcharts-selected svg {\n  stroke: #008ffb\n}\n\n.apexcharts-pan-icon:not(.apexcharts-selected):hover svg {\n  stroke: #333\n}\n\n.apexcharts-toolbar {\n  position: absolute;\n  z-index: 11;\n  max-width: 176px;\n  text-align: right;\n  border-radius: 3px;\n  padding: 0 6px 2px;\n  display: flex;\n  justify-content: space-between;\n  align-items: center\n}\n\n.apexcharts-menu {\n  background: #fff;\n  position: absolute;\n  top: 100%;\n  border: 1px solid #ddd;\n  border-radius: 3px;\n  padding: 3px;\n  right: 10px;\n  opacity: 0;\n  min-width: 110px;\n  transition: .15s ease all;\n  pointer-events: none\n}\n\n.apexcharts-menu.apexcharts-menu-open {\n  opacity: 1;\n  pointer-events: all;\n  transition: .15s ease all\n}\n\n.apexcharts-menu-item {\n  padding: 6px 7px;\n  font-size: 12px;\n  cursor: pointer\n}\n\n.apexcharts-theme-light .apexcharts-menu-item:hover {\n  background: #eee\n}\n\n.apexcharts-theme-dark .apexcharts-menu {\n  background: rgba(0,0,0,.7);\n  color: #fff\n}\n\n@media screen and (min-width:768px) {\n  .apexcharts-canvas:hover .apexcharts-toolbar {\n      opacity: 1\n  }\n}\n\n.apexcharts-canvas .apexcharts-element-hidden,.apexcharts-datalabel.apexcharts-element-hidden,.apexcharts-hide .apexcharts-series-points {\n  opacity: 0\n}\n\n.apexcharts-hidden-element-shown {\n  opacity: 1;\n  transition: 0.25s ease all;\n}\n.apexcharts-datalabel,.apexcharts-datalabel-label,.apexcharts-datalabel-value,.apexcharts-datalabels,.apexcharts-pie-label {\n  cursor: default;\n  pointer-events: none\n}\n\n.apexcharts-pie-label-delay {\n  opacity: 0;\n  animation-name: opaque;\n  animation-duration: .3s;\n  animation-fill-mode: forwards;\n  animation-timing-function: ease\n}\n\n.apexcharts-annotation-rect,.apexcharts-area-series .apexcharts-area,.apexcharts-area-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,.apexcharts-gridline,.apexcharts-line,.apexcharts-line-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,.apexcharts-point-annotation-label,.apexcharts-radar-series path,.apexcharts-radar-series polygon,.apexcharts-toolbar svg,.apexcharts-tooltip .apexcharts-marker,.apexcharts-xaxis-annotation-label,.apexcharts-yaxis-annotation-label,.apexcharts-zoom-rect {\n  pointer-events: none\n}\n\n.apexcharts-marker {\n  transition: .15s ease all\n}\n\n.resize-triggers {\n  animation: 1ms resizeanim;\n  visibility: hidden;\n  opacity: 0;\n  height: 100%;\n  width: 100%;\n  overflow: hidden\n}\n\n.contract-trigger:before,.resize-triggers,.resize-triggers>div {\n  content: " ";\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0\n}\n\n.resize-triggers>div {\n  height: 100%;\n  width: 100%;\n  background: #eee;\n  overflow: auto\n}\n\n.contract-trigger:before {\n  overflow: hidden;\n  width: 200%;\n  height: 200%\n}\n\n.apexcharts-bar-goals-markers{\n  pointer-events: none\n}\n\n.apexcharts-bar-shadows{\n  pointer-events: none\n}\n\n.apexcharts-rangebar-goals-markers{\n  pointer-events: none\n}', r2 ? s2.prepend(t3.css) : o2.head.appendChild(t3.css));
            }
            var l2 = t3.create(t3.w.config.series, {});
            if (!l2)
              return e2(t3);
            t3.mount(l2).then(function() {
              "function" == typeof t3.w.config.chart.events.mounted && t3.w.config.chart.events.mounted(t3, t3.w), t3.events.fireEvent("mounted", [t3, t3.w]), e2(l2);
            }).catch(function(t4) {
              i2(t4);
            });
          } else
            i2(new Error("Element not found"));
        });
      } }, { key: "create", value: function(t3, e2) {
        var i2 = this.w;
        new Gt(this).initModules();
        var a2 = this.w.globals;
        (a2.noData = false, a2.animationEnded = false, this.responsive.checkResponsiveConfig(e2), i2.config.xaxis.convertedCatToNumeric) && new X(i2.config).convertCatToNumericXaxis(i2.config, this.ctx);
        if (null === this.el)
          return a2.animationEnded = true, null;
        if (this.core.setupElements(), "treemap" === i2.config.chart.type && (i2.config.grid.show = false, i2.config.yaxis[0].show = false), 0 === a2.svgWidth)
          return a2.animationEnded = true, null;
        var s2 = y.checkComboSeries(t3);
        a2.comboCharts = s2.comboCharts, a2.comboBarCount = s2.comboBarCount;
        var r2 = t3.every(function(t4) {
          return t4.data && 0 === t4.data.length;
        });
        (0 === t3.length || r2) && this.series.handleNoData(), this.events.setupEventHandlers(), this.data.parseData(t3), this.theme.init(), new H(this).setGlobalMarkerSize(), this.formatters.setLabelFormatters(), this.titleSubtitle.draw(), a2.noData && a2.collapsedSeries.length !== a2.series.length && !i2.config.legend.showForSingleSeries || this.legend.init(), this.series.hasAllSeriesEqualX(), a2.axisCharts && (this.core.coreCalculations(), "category" !== i2.config.xaxis.type && this.formatters.setLabelFormatters(), this.ctx.toolbar.minX = i2.globals.minX, this.ctx.toolbar.maxX = i2.globals.maxX), this.formatters.heatmapLabelFormatters(), new y(this).getLargestMarkerSize(), this.dimensions.plotCoords();
        var o2 = this.core.xySettings();
        this.grid.createGridMask();
        var n2 = this.core.plotChartType(t3, o2), l2 = new O(this);
        return l2.bringForward(), i2.config.dataLabels.background.enabled && l2.dataLabelsBackground(), this.core.shiftGraphPosition(), { elGraph: n2, xyRatios: o2, dimensions: { plot: { left: i2.globals.translateX, top: i2.globals.translateY, width: i2.globals.gridWidth, height: i2.globals.gridHeight } } };
      } }, { key: "mount", value: function() {
        var t3 = this, e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, i2 = this, a2 = i2.w;
        return new Promise(function(s2, r2) {
          if (null === i2.el)
            return r2(new Error("Not enough data to display or target element not found"));
          (null === e2 || a2.globals.allSeriesCollapsed) && i2.series.handleNoData(), i2.grid = new j(i2);
          var o2, n2, l2 = i2.grid.drawGrid();
          (i2.annotations = new P(i2), i2.annotations.drawImageAnnos(), i2.annotations.drawTextAnnos(), "back" === a2.config.grid.position) && (l2 && a2.globals.dom.elGraphical.add(l2.el), null != l2 && null !== (o2 = l2.elGridBorders) && void 0 !== o2 && o2.node && a2.globals.dom.elGraphical.add(l2.elGridBorders));
          if (Array.isArray(e2.elGraph))
            for (var h2 = 0; h2 < e2.elGraph.length; h2++)
              a2.globals.dom.elGraphical.add(e2.elGraph[h2]);
          else
            a2.globals.dom.elGraphical.add(e2.elGraph);
          "front" === a2.config.grid.position && (l2 && a2.globals.dom.elGraphical.add(l2.el), null != l2 && null !== (n2 = l2.elGridBorders) && void 0 !== n2 && n2.node && a2.globals.dom.elGraphical.add(l2.elGridBorders));
          "front" === a2.config.xaxis.crosshairs.position && i2.crosshairs.drawXCrosshairs(), "front" === a2.config.yaxis[0].crosshairs.position && i2.crosshairs.drawYCrosshairs(), "treemap" !== a2.config.chart.type && i2.axes.drawAxis(a2.config.chart.type, l2);
          var c2 = new V(t3.ctx, l2), d2 = new q(t3.ctx, l2);
          if (null !== l2 && (c2.xAxisLabelCorrections(l2.xAxisTickWidth), d2.setYAxisTextAlignments(), a2.config.yaxis.map(function(t4, e3) {
            -1 === a2.globals.ignoreYAxisIndexes.indexOf(e3) && d2.yAxisTitleRotate(e3, t4.opposite);
          })), i2.annotations.drawAxesAnnotations(), !a2.globals.noData) {
            if (a2.config.tooltip.enabled && !a2.globals.noData && i2.w.globals.tooltip.drawTooltip(e2.xyRatios), a2.globals.axisCharts && (a2.globals.isXNumeric || a2.config.xaxis.convertedCatToNumeric || a2.globals.isRangeBar))
              (a2.config.chart.zoom.enabled || a2.config.chart.selection && a2.config.chart.selection.enabled || a2.config.chart.pan && a2.config.chart.pan.enabled) && i2.zoomPanSelection.init({ xyRatios: e2.xyRatios });
            else {
              var g2 = a2.config.chart.toolbar.tools;
              ["zoom", "zoomin", "zoomout", "selection", "pan", "reset"].forEach(function(t4) {
                g2[t4] = false;
              });
            }
            a2.config.chart.toolbar.show && !a2.globals.allSeriesCollapsed && i2.toolbar.createToolbar();
          }
          a2.globals.memory.methodsToExec.length > 0 && a2.globals.memory.methodsToExec.forEach(function(t4) {
            t4.method(t4.params, false, t4.context);
          }), a2.globals.axisCharts || a2.globals.noData || i2.core.resizeNonAxisCharts(), s2(i2);
        });
      } }, { key: "destroy", value: function() {
        var t3, e2;
        window.removeEventListener("resize", this.windowResizeHandler), this.el.parentNode, t3 = this.parentResizeHandler, (e2 = jt.get(t3)) && (e2.disconnect(), jt.delete(t3));
        var i2 = this.w.config.chart.id;
        i2 && Apex._chartInstances.forEach(function(t4, e3) {
          t4.id === x.escapeString(i2) && Apex._chartInstances.splice(e3, 1);
        }), new Vt(this.ctx).clear({ isUpdating: false });
      } }, { key: "updateOptions", value: function(t3) {
        var e2 = this, i2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], a2 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], s2 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3], r2 = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4], o2 = this.w;
        return o2.globals.selection = void 0, t3.series && (this.series.resetSeries(false, true, false), t3.series.length && t3.series[0].data && (t3.series = t3.series.map(function(t4, i3) {
          return e2.updateHelpers._extendSeries(t4, i3);
        })), this.updateHelpers.revertDefaultAxisMinMax()), t3.xaxis && (t3 = this.updateHelpers.forceXAxisUpdate(t3)), t3.yaxis && (t3 = this.updateHelpers.forceYAxisUpdate(t3)), o2.globals.collapsedSeriesIndices.length > 0 && this.series.clearPreviousPaths(), t3.theme && (t3 = this.theme.updateThemeOptions(t3)), this.updateHelpers._updateOptions(t3, i2, a2, s2, r2);
      } }, { key: "updateSeries", value: function() {
        var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
        return this.series.resetSeries(false), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(t3, e2, i2);
      } }, { key: "appendSeries", value: function(t3) {
        var e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], a2 = this.w.config.series.slice();
        return a2.push(t3), this.series.resetSeries(false), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(a2, e2, i2);
      } }, { key: "appendData", value: function(t3) {
        var e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = this;
        i2.w.globals.dataChanged = true, i2.series.getPreviousPaths();
        for (var a2 = i2.w.config.series.slice(), s2 = 0; s2 < a2.length; s2++)
          if (null !== t3[s2] && void 0 !== t3[s2])
            for (var r2 = 0; r2 < t3[s2].data.length; r2++)
              a2[s2].data.push(t3[s2].data[r2]);
        return i2.w.config.series = a2, e2 && (i2.w.globals.initialSeries = x.clone(i2.w.config.series)), this.update();
      } }, { key: "update", value: function(t3) {
        var e2 = this;
        return new Promise(function(i2, a2) {
          new Vt(e2.ctx).clear({ isUpdating: true });
          var s2 = e2.create(e2.w.config.series, t3);
          if (!s2)
            return i2(e2);
          e2.mount(s2).then(function() {
            "function" == typeof e2.w.config.chart.events.updated && e2.w.config.chart.events.updated(e2, e2.w), e2.events.fireEvent("updated", [e2, e2.w]), e2.w.globals.isDirty = true, i2(e2);
          }).catch(function(t4) {
            a2(t4);
          });
        });
      } }, { key: "getSyncedCharts", value: function() {
        var t3 = this.getGroupedCharts(), e2 = [this];
        return t3.length && (e2 = [], t3.forEach(function(t4) {
          e2.push(t4);
        })), e2;
      } }, { key: "getGroupedCharts", value: function() {
        var t3 = this;
        return Apex._chartInstances.filter(function(t4) {
          if (t4.group)
            return true;
        }).map(function(e2) {
          return t3.w.config.chart.group === e2.group ? e2.chart : t3;
        });
      } }, { key: "toggleSeries", value: function(t3) {
        return this.series.toggleSeries(t3);
      } }, { key: "highlightSeriesOnLegendHover", value: function(t3, e2) {
        return this.series.toggleSeriesOnHover(t3, e2);
      } }, { key: "showSeries", value: function(t3) {
        this.series.showSeries(t3);
      } }, { key: "hideSeries", value: function(t3) {
        this.series.hideSeries(t3);
      } }, { key: "isSeriesHidden", value: function(t3) {
        this.series.isSeriesHidden(t3);
      } }, { key: "resetSeries", value: function() {
        var t3 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
        this.series.resetSeries(t3, e2);
      } }, { key: "addEventListener", value: function(t3, e2) {
        this.events.addEventListener(t3, e2);
      } }, { key: "removeEventListener", value: function(t3, e2) {
        this.events.removeEventListener(t3, e2);
      } }, { key: "addXaxisAnnotation", value: function(t3) {
        var e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0, a2 = this;
        i2 && (a2 = i2), a2.annotations.addXaxisAnnotationExternal(t3, e2, a2);
      } }, { key: "addYaxisAnnotation", value: function(t3) {
        var e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0, a2 = this;
        i2 && (a2 = i2), a2.annotations.addYaxisAnnotationExternal(t3, e2, a2);
      } }, { key: "addPointAnnotation", value: function(t3) {
        var e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0, a2 = this;
        i2 && (a2 = i2), a2.annotations.addPointAnnotationExternal(t3, e2, a2);
      } }, { key: "clearAnnotations", value: function() {
        var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0, e2 = this;
        t3 && (e2 = t3), e2.annotations.clearAnnotations(e2);
      } }, { key: "removeAnnotation", value: function(t3) {
        var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0, i2 = this;
        e2 && (i2 = e2), i2.annotations.removeAnnotation(i2, t3);
      } }, { key: "getChartArea", value: function() {
        return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner");
      } }, { key: "getSeriesTotalXRange", value: function(t3, e2) {
        return this.coreUtils.getSeriesTotalsXRange(t3, e2);
      } }, { key: "getHighestValueInSeries", value: function() {
        var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
        return new U(this.ctx).getMinYMaxY(t3).highestY;
      } }, { key: "getLowestValueInSeries", value: function() {
        var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
        return new U(this.ctx).getMinYMaxY(t3).lowestY;
      } }, { key: "getSeriesTotal", value: function() {
        return this.w.globals.seriesTotals;
      } }, { key: "toggleDataPointSelection", value: function(t3, e2) {
        return this.updateHelpers.toggleDataPointSelection(t3, e2);
      } }, { key: "zoomX", value: function(t3, e2) {
        this.ctx.toolbar.zoomUpdateOptions(t3, e2);
      } }, { key: "setLocale", value: function(t3) {
        this.localization.setCurrentLocaleValues(t3);
      } }, { key: "dataURI", value: function(t3) {
        return new G(this.ctx).dataURI(t3);
      } }, { key: "exportToCSV", value: function() {
        var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        return new G(this.ctx).exportToCSV(t3);
      } }, { key: "paper", value: function() {
        return this.w.globals.dom.Paper;
      } }, { key: "_parentResizeCallback", value: function() {
        this.w.globals.animationEnded && this.w.config.chart.redrawOnParentResize && this._windowResize();
      } }, { key: "_windowResize", value: function() {
        var t3 = this;
        clearTimeout(this.w.globals.resizeTimer), this.w.globals.resizeTimer = window.setTimeout(function() {
          t3.w.globals.resized = true, t3.w.globals.dataChanged = false, t3.ctx.update();
        }, 150);
      } }, { key: "_windowResizeHandler", value: function() {
        var t3 = this.w.config.chart.redrawOnWindowResize;
        "function" == typeof t3 && (t3 = t3()), t3 && this._windowResize();
      } }], [{ key: "getChartByID", value: function(t3) {
        var e2 = x.escapeString(t3);
        if (Apex._chartInstances) {
          var i2 = Apex._chartInstances.filter(function(t4) {
            return t4.id === e2;
          })[0];
          return i2 && i2.chart;
        }
      } }, { key: "initOnLoad", value: function() {
        for (var e2 = document.querySelectorAll("[data-apexcharts]"), i2 = 0; i2 < e2.length; i2++) {
          new t2(e2[i2], JSON.parse(e2[i2].getAttribute("data-options"))).render();
        }
      } }, { key: "exec", value: function(t3, e2) {
        var i2 = this.getChartByID(t3);
        if (i2) {
          i2.w.globals.isExecCalled = true;
          var a2 = null;
          if (-1 !== i2.publicMethods.indexOf(e2)) {
            for (var s2 = arguments.length, r2 = new Array(s2 > 2 ? s2 - 2 : 0), o2 = 2; o2 < s2; o2++)
              r2[o2 - 2] = arguments[o2];
            a2 = i2[e2].apply(i2, r2);
          }
          return a2;
        }
      } }, { key: "merge", value: function(t3, e2) {
        return x.extend(t3, e2);
      } }]), t2;
    }();
    module.exports = _t;
  }
});

// node_modules/vue3-apexcharts/dist/vue3-apexcharts.common.js
var require_vue3_apexcharts_common = __commonJS({
  "node_modules/vue3-apexcharts/dist/vue3-apexcharts.common.js"(exports, module) {
    module.exports = function(modules) {
      var installedModules = {};
      function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) {
          return installedModules[moduleId].exports;
        }
        var module2 = installedModules[moduleId] = {
          i: moduleId,
          l: false,
          exports: {}
        };
        modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
        module2.l = true;
        return module2.exports;
      }
      __webpack_require__.m = modules;
      __webpack_require__.c = installedModules;
      __webpack_require__.d = function(exports2, name, getter) {
        if (!__webpack_require__.o(exports2, name)) {
          Object.defineProperty(exports2, name, { enumerable: true, get: getter });
        }
      };
      __webpack_require__.r = function(exports2) {
        if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
          Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
        }
        Object.defineProperty(exports2, "__esModule", { value: true });
      };
      __webpack_require__.t = function(value, mode) {
        if (mode & 1)
          value = __webpack_require__(value);
        if (mode & 8)
          return value;
        if (mode & 4 && typeof value === "object" && value && value.__esModule)
          return value;
        var ns = /* @__PURE__ */ Object.create(null);
        __webpack_require__.r(ns);
        Object.defineProperty(ns, "default", { enumerable: true, value });
        if (mode & 2 && typeof value != "string")
          for (var key in value)
            __webpack_require__.d(ns, key, function(key2) {
              return value[key2];
            }.bind(null, key));
        return ns;
      };
      __webpack_require__.n = function(module2) {
        var getter = module2 && module2.__esModule ? function getDefault() {
          return module2["default"];
        } : function getModuleExports() {
          return module2;
        };
        __webpack_require__.d(getter, "a", getter);
        return getter;
      };
      __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      __webpack_require__.p = "";
      return __webpack_require__(__webpack_require__.s = "fb15");
    }({
      "8bbf": function(module2, exports2) {
        module2.exports = require_vue();
      },
      "95e6": function(module2, exports2) {
        module2.exports = require_apexcharts_common();
      },
      "fb15": function(module2, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        if (typeof window !== "undefined") {
          var currentScript = window.document.currentScript;
          if (false) {
            var getCurrentScript;
          }
          var src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/);
          if (src) {
            __webpack_require__.p = src[1];
          }
        }
        var setPublicPath = null;
        var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__("8bbf");
        var external_root_ApexCharts_commonjs_apexcharts_commonjs2_apexcharts_ = __webpack_require__("95e6");
        var external_root_ApexCharts_commonjs_apexcharts_commonjs2_apexcharts_default = __webpack_require__.n(external_root_ApexCharts_commonjs_apexcharts_commonjs2_apexcharts_);
        const events = [
          "animationEnd",
          "beforeMount",
          "mounted",
          "updated",
          "click",
          "mouseMove",
          "mouseLeave",
          "legendClick",
          "markerClick",
          "selection",
          "dataPointSelection",
          "dataPointMouseEnter",
          "dataPointMouseLeave",
          "beforeZoom",
          "beforeResetZoom",
          "zoomed",
          "scrolled",
          "brushScrolled"
        ];
        const vueApexcharts = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
          name: "apexchart",
          props: {
            options: {
              type: Object
            },
            type: {
              type: String
            },
            series: {
              type: Array,
              required: true
            },
            width: {
              default: "100%"
            },
            height: {
              default: "auto"
            }
          },
          emits: events,
          setup(props, { emit }) {
            const __el = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
            const chart = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
            const isObject = (item) => {
              return item && typeof item === "object" && !Array.isArray(item) && item != null;
            };
            const extend = (target, source) => {
              if (typeof Object.assign !== "function") {
                (function() {
                  Object.assign = function(target2) {
                    if (target2 === void 0 || target2 === null) {
                      throw new TypeError("Cannot convert undefined or null to object");
                    }
                    let output2 = Object(target2);
                    for (let index = 1; index < arguments.length; index++) {
                      let source2 = arguments[index];
                      if (source2 !== void 0 && source2 !== null) {
                        for (let nextKey in source2) {
                          if (source2.hasOwnProperty(nextKey)) {
                            output2[nextKey] = source2[nextKey];
                          }
                        }
                      }
                    }
                    return output2;
                  };
                })();
              }
              let output = Object.assign({}, target);
              if (isObject(target) && isObject(source)) {
                Object.keys(source).forEach((key) => {
                  if (isObject(source[key])) {
                    if (!(key in target)) {
                      Object.assign(output, {
                        [key]: source[key]
                      });
                    } else {
                      output[key] = extend(target[key], source[key]);
                    }
                  } else {
                    Object.assign(output, {
                      [key]: source[key]
                    });
                  }
                });
              }
              return output;
            };
            const init = async () => {
              await Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])();
              if (chart.value) {
                return;
              }
              const newOptions = {
                chart: {
                  type: props.type || props.options.chart.type || "line",
                  height: props.height,
                  width: props.width,
                  events: {}
                },
                series: props.series
              };
              events.forEach((event) => {
                let callback = (...args) => emit(event, ...args);
                newOptions.chart.events[event] = callback;
              });
              const config = extend(props.options, newOptions);
              chart.value = new external_root_ApexCharts_commonjs_apexcharts_commonjs2_apexcharts_default.a(__el.value, config);
              return chart.value.render();
            };
            const refresh = () => {
              destroy();
              return init();
            };
            const destroy = () => {
              chart.value.destroy();
            };
            const updateSeries = (newSeries, animate) => {
              return chart.value.updateSeries(newSeries, animate);
            };
            const updateOptions = (newOptions, redrawPaths, animate, updateSyncedCharts) => {
              return chart.value.updateOptions(newOptions, redrawPaths, animate, updateSyncedCharts);
            };
            const toggleSeries = (seriesName) => {
              return chart.value.toggleSeries(seriesName);
            };
            const showSeries = (seriesName) => {
              chart.value.showSeries(seriesName);
            };
            const hideSeries = (seriesName) => {
              chart.value.hideSeries(seriesName);
            };
            const appendSeries = (newSeries, animate) => {
              return chart.value.appendSeries(newSeries, animate);
            };
            const resetSeries = () => {
              chart.value.resetSeries();
            };
            const toggleDataPointSelection = (seriesIndex, dataPointIndex) => {
              chart.value.toggleDataPointSelection(seriesIndex, dataPointIndex);
            };
            const appendData = (newData) => {
              return chart.value.appendData(newData);
            };
            const zoomX = (start, end) => {
              return chart.value.zoomX(start, end);
            };
            const dataURI = (options) => {
              return chart.value.dataURI(options);
            };
            const setLocale = (localeName) => {
              return chart.value.setLocale(localeName);
            };
            const addXaxisAnnotation = (options, pushToMemory) => {
              chart.value.addXaxisAnnotation(options, pushToMemory);
            };
            const addYaxisAnnotation = (options, pushToMemory) => {
              chart.value.addYaxisAnnotation(options, pushToMemory);
            };
            const addPointAnnotation = (options, pushToMemory) => {
              chart.value.addPointAnnotation(options, pushToMemory);
            };
            const removeAnnotation = (id, options) => {
              chart.value.removeAnnotation(id, options);
            };
            const clearAnnotations = () => {
              chart.value.clearAnnotations();
            };
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeMount"])(() => {
              window.ApexCharts = external_root_ApexCharts_commonjs_apexcharts_commonjs2_apexcharts_default.a;
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(() => {
              __el.value = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])().proxy.$el;
              init();
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeUnmount"])(() => {
              if (!chart.value) {
                return;
              }
              destroy();
            });
            const reactiveProps = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["toRefs"])(props);
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(reactiveProps.options, () => {
              if (!chart.value && props.options) {
                init();
              } else {
                chart.value.updateOptions(props.options);
              }
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(
              reactiveProps.series,
              () => {
                if (!chart.value && props.series) {
                  init();
                } else {
                  chart.value.updateSeries(props.series);
                }
              },
              { deep: true }
            );
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(reactiveProps.type, () => {
              refresh();
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(reactiveProps.width, () => {
              refresh();
            });
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(reactiveProps.height, () => {
              refresh();
            });
            return {
              chart,
              init,
              refresh,
              destroy,
              updateOptions,
              updateSeries,
              toggleSeries,
              showSeries,
              hideSeries,
              resetSeries,
              zoomX,
              toggleDataPointSelection,
              appendData,
              appendSeries,
              addXaxisAnnotation,
              addYaxisAnnotation,
              addPointAnnotation,
              removeAnnotation,
              clearAnnotations,
              setLocale,
              dataURI
            };
          },
          render() {
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
              class: "vue-apexcharts"
            });
          }
        });
        var vue3_apexcharts = vueApexcharts;
        const install = (app) => {
          app.component(vue3_apexcharts.name, vue3_apexcharts);
        };
        vue3_apexcharts.install = install;
        var src_0 = vue3_apexcharts;
        var entry_lib = __webpack_exports__["default"] = src_0;
      }
    });
  }
});

// dep:vue3-apexcharts
var vue3_apexcharts_default = require_vue3_apexcharts_common();
export {
  vue3_apexcharts_default as default
};
/*!
 * ApexCharts v3.43.0
 * (c) 2018-2023 ApexCharts
 * Released under the MIT License.
 */
/*! #__NO_SIDE_EFFECTS__ */
/**
* @vue/compiler-core v3.4.29
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/**
* @vue/compiler-dom v3.4.29
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/**
* @vue/reactivity v3.4.29
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/**
* @vue/runtime-core v3.4.29
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/**
* @vue/runtime-dom v3.4.29
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/**
* @vue/shared v3.4.29
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/**
* vue v3.4.29
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
//# sourceMappingURL=vue3-apexcharts.js.map
