const t=t=>t&&"object"==typeof t&&"function"==typeof t.then;class s extends Promise{constructor(s){let e,i;super(((t,s)=>{e=t,i=s})),this._s="pending",this.resolve=s=>{this.isPending&&(t(s)?this.task=s:(this._s="fulfilled",e(s)))},this.reject=t=>{this.isPending&&(this._s="rejected",i(t))},this.task=s}get status(){return this._s}get isPending(){return"pending"===this._s}get isFulfilled(){return"fulfilled"===this._s}get isRejected(){return"rejected"===this._s}get task(){return this._task}set task(s){let e;this._task=s,t(s)?e=s:"function"==typeof s&&(e=new Promise(s)),e&&(async()=>{try{const t=await e;s===this._task&&this.resolve(t)}catch(t){s===this._task&&this.reject(t)}})()}get isEmpty(){return null==this._task}}export{s as default};
//# sourceMappingURL=index.min.mjs.map
