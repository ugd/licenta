const isPromiseLike = (value) => (value && "object" === typeof value && "function" === typeof value.then);
class MutablePromise extends Promise {
    constructor(executor) {
        let rs;
        let rj;
        const fn = (_rs, _rj) => { rs = _rs; rj = _rj; };
        super(fn);
        // walkaround babel which can not extend builtin class
        // let _this = this;
        // let then = new Promise(fn).then;
        // this.then = function(){ then.apply(_this, arguments) } as any;
        this._s = "pending";
        this.resolve = (value) => {
            if (this.isPending) {
                if (isPromiseLike(value)) {
                    this.task = value;
                }
                else {
                    this._s = "fulfilled";
                    rs(value);
                }
            }
        };
        this.reject = (reason) => {
            if (this.isPending) {
                this._s = "rejected";
                rj(reason);
            }
        };
        this.task = executor;
    }
    get status() { return this._s; }
    get isPending() { return "pending" === this._s; }
    get isFulfilled() { return "fulfilled" === this._s; }
    get isRejected() { return "rejected" === this._s; }
    get task() { return this._task; }
    set task(value) {
        //if(!this.isPending){ return; }
        this._task = value;
        let p;
        if (isPromiseLike(value)) {
            p = value;
        }
        else if ("function" === typeof value) {
            p = new Promise(value);
        }
        if (p) {
            (async () => {
                try {
                    const ret = await p;
                    // make sure task not change
                    if (value === this._task) {
                        this.resolve(ret);
                    }
                }
                catch (reason) {
                    // make sure task not change
                    if (value === this._task) {
                        this.reject(reason);
                    }
                }
            })();
        }
    }
    get isEmpty() { return null == this._task; }
}

export { MutablePromise as default };
//# sourceMappingURL=index.mjs.map
