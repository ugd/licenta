declare type ResolveValue<T> = T | PromiseLike<T>;
declare type Resolve<T> = (value: ResolveValue<T>) => void;
declare type Reject = (reason?: any) => void;
declare type Executor<T> = (resolve: Resolve<T>, reject: Reject) => void;
declare class MutablePromise<T> extends Promise<T> {
    private _s;
    get status(): string;
    get isPending(): boolean;
    get isFulfilled(): boolean;
    get isRejected(): boolean;
    private _task;
    get task(): PromiseLike<T> | Executor<T> | null;
    set task(value: PromiseLike<T> | Executor<T> | null);
    get isEmpty(): boolean;
    resolve: Resolve<T>;
    reject: Reject;
    then: (onfulfilled?: (value: T) => any, onrejected?: (reason: any) => any) => Promise<any>;
    constructor(executor?: PromiseLike<T> | Executor<T> | null);
}
export default MutablePromise;
export { Resolve, Reject, ResolveValue, Executor };
//# sourceMappingURL=index.d.ts.map