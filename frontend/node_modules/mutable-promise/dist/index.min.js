!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).MutablePromise=e()}(this,(function(){"use strict";const t=t=>t&&"object"==typeof t&&"function"==typeof t.then;return class extends Promise{constructor(e){let s,i;super(((t,e)=>{s=t,i=e})),this._s="pending",this.resolve=e=>{this.isPending&&(t(e)?this.task=e:(this._s="fulfilled",s(e)))},this.reject=t=>{this.isPending&&(this._s="rejected",i(t))},this.task=e}get status(){return this._s}get isPending(){return"pending"===this._s}get isFulfilled(){return"fulfilled"===this._s}get isRejected(){return"rejected"===this._s}get task(){return this._task}set task(e){let s;this._task=e,t(e)?s=e:"function"==typeof e&&(s=new Promise(e)),s&&(async()=>{try{const t=await s;e===this._task&&this.resolve(t)}catch(t){e===this._task&&this.reject(t)}})()}get isEmpty(){return null==this._task}}}));
//# sourceMappingURL=index.min.js.map
